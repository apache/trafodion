////
/**
* @@@ START COPYRIGHT @@@
*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*
* @@@ END COPYRIGHT @@@
*/
////

[[query-plans]]
= Query Plans

This section describes CQDs that are used to influence query plans.

[[default-degree-of-parallelism]]
== DEFAULT_DEGREE_OF_PARALLELISM

[cols="25%h,75%"]
|===
| *Description*               | Defines the minimum size of the adaptive segment; that is, the number of processors 
available for query operator parallelism. The optimizer may choose an adaptive-segment size that is equal to, or the multiple of, 
the value of this CQD depending on the maximum estimated resource consumed by any single operator in the query. 
The optimizer may also decide to run the query with no parallelism if the resource consumption estimate is very low.
| *Values*                    |
Unsigned Integer. +
 +
The default value is *'16'*.
| *Usage*                     | For systems running at higher levels of concurrency with workloads that include a large 
number of small queries, reducing the default degree of parallelism may help achieve higher throughput. +
 +
With the default of 16, for 32-node systems, adaptive segmentation can use two 16-node virtual segments to execute queries that 
do not require a degree of parallelism of 32.  This default setting can, for example, be changed to 8 for a 16-node system, 
to allow adaptive segmentation to leverage a lower degree of parallelism.

| *Production Usage*          | Not applicable.
| *Impact*                    | Lowering the value of this CQD can increase the throughput of 
high-concurrency small-query workloads, but has the potential disadvantage of increasing the 
elapsed time for some of the longer running queries that leverage adaptive segmentation.
| *Level*                     | System. There may be scenarios where you want to influence the degree of adaptive segmentation 
parallelism only for a certain set of queries and use it at the service level.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[hash-joins]]
== HASH_JOINS

[cols="25%h,75%"]
|===
| *Description*               | Determines whether the {project-name} Optimizer considers Hash Join when generating an execution plan.
| *Values*                    |
*'ON'* Hash Join is considered. +
*'OFF'* Hash Join is not considered. +
 +
The default value is *'ON'*.
| *Usage*                     | Use this CQD when you want to force the optimizer to generate a query plan that does not use any Hash Joins.
| *Production Usage*          | Hash Join is an important join implementation strategy for most complex queries.
It is highly recommended that you do not turn HASH_JOINS OFF; that is, this CQD should be used to force a query plan for a particular query on an exception basis only.
| *Impact*                    | Turning HASH_JOINS OFF may result in very inefficient query plans that use expensive nested joins or sorts for merge joins.
| *Level*                     | Query.
| *Conflicts/Synergies*       | If you turn all three join implementations OFF (Hash Joins, Nested Joins, and Merge Joins), then the compiler may fail to generate query plans.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[hbase-coprocessors]]
== HBASE_COPROCESSORS

[cols="25%h,75%"]
|===
| *Description*               | Allow HBase coprocessors to be used when computing aggregates.
| *Values*                    |
*'ON'*: Use HBase coprocessors. +
*'OFF'*: Do not use HBase coprocessors. +
 +
The default value is *'ON'*.
| *Usage*                     | Enables {project-name} to use HBase coprocessors to do early aggregation and filtering
at the HBase Region Server level. This CQD does not affect Transaction coprocessors used by {project-name}. +
 +
As of Release 2.0 only COUNT(*) queries will be affected by this attribute.
| *Production Usage*          | Yes.
| *Impact*                    | Network traffic between Region Server and {project-name} processes is reduced but
the Region Server can become very busy when aggregating over large tables.
| *Level*                     | Query.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[hive-num-esps-per-datanode]]
== HIVE_NUM_ESPS_PER_DATANODE

[cols="25%h,75%"]
|===
| *Description*               | Determines number of ESP processes used to scan a Hive table, per HDFS DataNode. 
| *Values*                    |
Positive integer. +
 +
The default value is *'2'*.
| *Usage*                     | Use this CQD to increase or decrease the number of scanners that process a single Hive table.
If a Hive scan is found to be the bottleneck for a particular query, then increasing this attribute to; for example, 4 or higher will help.
On the other hand decreasing the attribute to 1 could help with concurrency.
| *Production Usage*          | Yes.
| *Impact*                    | Controls number of ESPs and, therefore, affects query execution time and system workload.
| *Level*                     | Query.
| *Conflicts/Synergies*       | The CQD <<hive-min-bytes-per-esp-partition,HIVE_MIN_BYTES_PER_ESP_PARTITION>> (default = 67108864) may need to be adjusted downward
when this attribute is used to increase the parallelism of scanning smaller Hive tables.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[join-order-by-user]]
== JOIN_ORDER_BY_USER

[cols="25%h,75%"]
|===
| *Description*               | Enables or disables the join order in which the optimizer joins the tables to be the sequence of the
tables in the FROM clause of the query.
| *Values*                    |
*'ON'* Join order is forced. +
*'OFF'* Join order is decided by the optimizer. +
 +
The default value is *'OFF'*.
| *Usage*                     | When set to ON, the optimizer considers only execution plans that have the join order matching
the sequence of the tables in the FROM clause.
| *Production Usage*          | This setting is to be used for forcing a desired join order that was not generated by default by
the optimizer only. It can be used as a workaround for query plans with inefficient join order.
| *Impact*                    | Because you are in effect forcing the optimizer to use a plan that joins the table in the order
specified in the FROM clause, the plan generated may not be the optimal one.
| *Level*                     | Query.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[mc-skew-sensitivity-threshold]]
== MC_SKEW_SENSITIVITY_THRESHOLD

[cols="25%h,75%"]
|===
| *Description*               | Define the multi-column skew sensitivity threshold T used by multi-column skew-insensitive hash join (Skew Buster). +
 +
Let `f` be the occurrence frequency of a skew value `v`, `DoP` be the degree of parallelism of a hash join operator, and `RC` be the row count of
the source data (for example, fact table) where the skew originates. +
 +
The hash join will run in the anti-skew mode for `v` if `f >= T * DoP / RC`.
| *Values*                    |
*< 0*: Disable the multi-column skew buster. +
*&#62;= 0*: Define the threshold T. + 
 +
Default value: *0.1*.  
| *Usage*                     | Use of a *negative value* to disable multi-column anti-skew hash joins. This may slow down query performance when
multi-column skew values are present in the fact table. +
 +
A value of *0* treats every multi-column value as skew values. This may increase network traffic since skewed values are broadcasted from the inner
side child of the hash join to all join processes. +
 +
A value *greater than 0* selects those multi-column values as skewed values if their occurrence frequencies are high enough. 
| *Production Usage*          | Please contact {project-support}.
| *Impact*                    | This CQD impacts runtime performance.
| *Level*                     | Session.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[mdam-no-stats-positions-threshold]]
== MDAM_NO_STATS_POSITIONS_THRESHOLD

[cols="25%h,75%"]
|===
| *Description*               | This CQD effects the behavior of the query optimizer when there are no statistics available for a query
having range predicates on key columns. The {project-name} Optimizer calculates the worst case number of seeks that the MDAM access method
would do if chosen for the query. +
 +
If this number is greater than the value of MDAM_NO_STATS_POSITIONS_THRESHOLD, then MDAM is not considered for the query execution plan. 
| *Values*                    |
Any integer greater than equal to zero. +
 +
Default value: *10*.  
| *Usage*                     | In certain situations, queries on tables lacking statistics may not be optimal because MDAM was not chosen.
Increasing the value for this CQD allows MDAM to be chosen in more cases. On the other hand, if the value is made too high and the worst case
scenario actually occurs, an MDAM plan may perform poorly.
| *Production Usage*          | Please contact {project-support}.
| *Impact*                    | Table scans on tables lacking statistics may improve by varying the value of this CQD.
Results vary depending on the actual data in the table and the semantics of the query.
| *Level*                     | Query.
| *Conflicts/Synergies*       | If <<mdam-scan-method,MDAM_SCAN_METHOD>> is set to *'OFF'*, then this CQD has no effect.
| *Real Problem Addressed*    | Perform UPDATE STATISTICS on the table (at the very least on key columns) to obtain statistics.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===


<<<
[[mdam-scan-method]]
== MDAM_SCAN_METHOD

[cols="25%h,75%"]
|===
| *Description*               | Enables or disables the Multi-Dimensional Access Method (MDAM).
| *Values*                    |
*'ON'* MDAM is considered. +
*'OFF'* MDAM is disabled. +
 +
The default value is *'ON'*.
| *Usage*                     | In certain situations, the {project-name} Optimizer might choose MDAM inappropriately, causing poor performance.
In such situations you may want to turn MDAM OFF for the query it is effecting.
| *Production Usage*          | Yes.
| *Impact*                    | Table scans with predicates on non-leading clustering key column(s) could benefit from MDAM access
method if the leading column(s) has a small number of distinct values. Turning MDAM off results in a longer scan time for such queries.
| *Level*                     | Set this CQD at the query level when MDAM is not working efficiently for a specific query. However,
there may be cases (usually a defect) where a larger set of queries is being negatively impacted by MDAM. In those cases you may want
to set it at the service or system level.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[merge-joins]]
== MERGE_JOINS

[cols="25%h,75%"]
|===
| *Description*               | Determines if Merge Join is considered by the optimizer to generate an execution plan.
| *Values*                    |
*'ON'*: Merge Join is considered. +
*'OFF'*: Merge Join is disabled. +
 +
The default value is *'ON'*.
| *Usage*                     | Use this CQD when you want to force a query plan not to use Merge Joins. This is useful as a workaround
for query plans with very expensive sorts for Merge Joins. Turning MERGE_JOINS OFF also has the advantage of reducing the query compile time. 
| *Production Usage*          | Merge Join is an efficient join implementation strategy if the physical schema was designed to take advantage
of it. For example, large tables are physically ordered based on the most frequently joined column(s).
| *Impact*                    | Turning MERGE_JOINS OFF may result in the optimizer not considering potentially efficient query plans,
for queries with large joins on tables that are physically ordered by the join column(s). +
 +
Turning MERGE_JOINS ON causes an increase in compile
time because the optimizer now has to consider many more join options.
| *Level*                     | Set this CQD at the query level when a Merge Join is not working efficiently for a specific query. However,
there may be cases (usually a defect) where a larger set of queries is being negatively impacted by Merge Joins. In those cases you may want to
set it at the service or system level.
| *Conflicts/Synergies*       | Avoid turning all the three join implementations OFF (Hash Joins, Nested Joins, and Merge Joins).
This may result in the {project-name} Compiler failing to generate query plans.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[nested-joins]]
== NESTED_JOINS

[cols="25%h,75%"]
|===
| *Description*               | Determines if Nested Join is considered by the optimizer to generate an execution plan.
| *Values*                    |
*'ON'*: Nested Join is considered. +
*'OFF'*: Nested Join is disabled. +
 +
The default value is *'ON'*.
| *Usage*                     | Use this CQD when you want to force a query plan not to use Nested Joins. This is useful
as a workaround for query plans with very expensive Nested Joins, which may occur if the optimizer fails to estimate the
cost of a Nested Join correctly.
| *Production Usage*          | Nested Join is an important join implementation strategy for many complex queries. It is
recommended not to turn NESTED_JOINS OFF. It should only be used to force a query plan for a particular query on an exception basis.
| *Impact*                    | Turning NESTED_JOINS OFF may result in inefficient query plans for certain type of queries,
such as light workloads and star join queries.
| *Level*                     | Query.
| *Conflicts/Synergies*       | Avoid turning all the three join implementations OFF (Hash Joins, Nested Joins, and Merge Joins).
This may result in the compiler failing to generate query plans.
| *Real Problem Addressed*    | The problem of inefficient Nested Joins can be better handled using a higher degree of query plan
robustness as set by the <<robust-query-optimization,ROBUST_QUERY_OPTIMIZATION>> CQD.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[optimization-level]]
== OPTIMIZATION_LEVEL

[cols="25%h,75%"]
|===
| *Description*               | Controls the optimizer resources and time spent for optimizing a query plan, with level 0 indicating
the least amount of optimization effort and level 5 indicating the most. Lower optimization levels produce lower plan quality with
minimal compile time, while higher optimization levels cause the compiler to spend more compilation time to produce better plan quality.
| *Values*                    |
'0', '2', '3', '5' +
 +
The default value is *'3'*.
| *Usage*                     | Reduce the optimization level when compile time is longer than desired and queries have relatively small
execution cost and are simple in structure.
| *Production Usage*          | Use this CQD only as a workaround for queries with unacceptable compile time or plan quality.
| *Impact*                    | Lowering the optimization level below the system default may result in inefficient query execution plans.
Increasing the optimization level over the system default may result in very high compile time for complex queries.
| *Level*                     | Query.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[parallel-num-esps]]
== PARALLEL_NUM_ESPS

[cols="25%h,75%"]
|===
| *Description*               | Controls the maximum number of parallel ESPs that work on a particular operation; for example, a join.
| *Values*                    | Unsigned Integer: The maximum number of ESPs that should be used for a particular operation.
The value must be less than the number of nodes in the cluster. +
 +
*'SYSTEM'*: The compiler calculates the number of ESPs to be used. +
 +
The default value is *'SYSTEM'*.
| *Usage*                     | Used to control the maximum degree of parallelism for a query. This could be useful to limit the
number of resources (node and memory) any single query can use. 
| *Production Usage*          | Not applicable.
| *Impact*                    | Lowering the value of this CQD can increase the throughput of high concurrency small and medium
query workloads, but has the potential disadvantage of increasing the elapsed time of some of the long-running queries.
| *Level*                     | Service.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[risk-premium-nj]]
== RISK_PREMIUM_NJ

[cols="25%h,75%"]
|===
| *Description*               | Influences the optimizer to choose other types of joins over nested joins, by making a nested join plan relatively more expensive.
| *Values*                    |
Any positive fractional value. +
 +
The default value is *'1.2'*.
| *Usage*                     | Review <<robust-query-optimization,ROBUST_QUERY_OPTIMIZATION>> before considering the use of this CQD. +
 +
The default setting indicates that a nested join plan must be 20% cheaper before it is allowed to win over competing safer (hash) join plans.
A setting of 1.0 means no handicap for nested joins. A setting of 5.0 means a nested join must be 400% cheaper before it is allowed to win over
competing hash join plans. +
 +
If it is determined that the optimizer is using nested joins often enough where these plans are resulting in poor performance, then this CQD
may be used to influence the optimizer to consider another join instead, such as a hash join, in some of those cases. +
 +
NESTED_JOINS OFF could turn nested joins off completely. However, there are many cases where nested joins do provide better performance than hash
joins, and turning them off completely may negatively impact the performance of queries that can do a lot better with nested joins.
| *Production Usage*          | Please contact {project-support}.
| *Impact*                    | Specifying a risk premium insures against nested joins being chosen when they should not have been. However,
this can also result in nested joins not being chosen where the cardinality estimation was in fact accurate and a nested join could have
performed better. Therefore, this setting should be used with care in order to get robustness with a net gain in performance.
| *Level*                     | Any. There may be cases where there are different applications or workloads that might benefit from this CQD more
than other workloads. In such cases this could be used at the Service level.
| *Conflicts/Synergies*       | <<robust-query-optimization,ROBUST_QUERY_OPTIMIZATION>> is a CQD that provides a robust query setting across the board,
influencing the nested join risk premium as well. It is advisable that you use that setting instead to influence plans, unless they are specifically
addressing nested join issues and need to use this setting independent of that CQD.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[risk-premium-serial]]
== RISK_PREMIUM_SERIAL

[cols="25%h,75%"]
|===
| *Description*               | Influences the optimizer to choose a parallel plan over a serial plan, by making a serial plan relatively more expensive.
| *Values*                    |
Any positive fractional value. +
 +
The default value is *'1.2'*.
| *Usage*                     | Review <<robust-query-optimization,ROBUST_QUERY_OPTIMIZATION>> before considering the use of this CQD. +
 +
The default setting means that a serial plan must be 20% cheaper before it is allowed to win over competing parallel plans.
A setting of 1.0 means no handicap for serial plans. A setting of 2.0 means a serial plan must be 100% cheaper before it is
allowed to win over competing parallel plans. +
 +
If it is determined that the optimizer is using serial plans often enough where these plans are resulting in poor performance, then this CQD
may be used to influence the optimizer to consider parallel plans instead in some of those cases. +
| *Production Usage*          | Please contact {project-support}.
| *Impact*                    | Specifying a risk premium insures against serial plans being chosen when they should not have been.
However, this can also result in serial plans not being chosen where the cardinality estimation was in fact accurate and a serial plan
could have performed better. Therefore, this setting should be used with care in order to get robustness with a net gain in performance.
| *Level*                     | Any. There may be cases where there are different applications or workloads that might benefit from this
CQD more than other workloads. In such cases this could be used at the Service level.
| *Conflicts/Synergies*       | <<robust-query-optimization,ROBUST_QUERY_OPTIMIZATION>> is a CQD that provides a robust query setting across the board,
influencing the serial plan risk premium as well. It is advised that you use that setting instead to influence plans, unless they are specifically
addressing serial plan issues and need to use this setting independent of that CQD.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[risk-premium-serial-scaleback-maxcard-threshold]]
== RISK_PREMIUM_SERIAL_SCALEBACK_MAXCARD_THRESHOLD

[cols="25%h,75%"]
|===
| *Description*               | Defines the minimal estimated max cardinality or row count of any relational operators in a query above
which the risk premium for serial plan is applied. +
 +
A serial query plan is favored by the {project-name} Compiler when it estimates the query reads and processes small amount of data.
The estimation error could become large when some operator is calculated to produce many rows yielding a non-optimal serial plan.
This CQD helps prevent utilizing serial plan in such cases.
| *Values*                    | An unsigned integer value. 
| *Usage*                     | Adjust this CQD when necessary only.  +
 +
Use of a value smaller than the default (10,000) to penalize more serial plans or favor more parallel plans for operators produce less number of rows. 
Otherwise, use of a larger value.
| *Production Usage*          | Please contact {project-support}.
| *Impact*                    | This CQD impacts plan quality.
| *Level*                     | Session.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[robust-query-optimization]]
== ROBUST_QUERY_OPTIMIZATION

[cols="25%h,75%a"]
|===
| *Description*               | Provides a simpler way to influence the optimizer's choice of query plans. The optimizer chooses query plans
based on cardinality estimates (the number of result rows estimated at each step of a query execution plan). Actual cardinalities encountered
at query execution often differ from estimates. The optimizer considers risky choices and exacts risk premiums before it chooses a plan that
is inherently sensitive to cardinality estimation errors. Risky choices include: +
 +
*Nested joins*: Can be excellent data reducers but they can also result in extremely long-running queries when their outer table
cardinality is grossly underestimated. +
 +
*Serial plans*: Are an excellent choice because they use the least resources when processing low data volumes. But they can also result
in very long-running queries when actual cardinalities greatly exceed estimates. +
 +
*Complete sharing of ESP partitioning schemes*: Correct parallel processing requires partitioning the data across ESP instances using a
partitioning scheme usually based on the largest table's partitioning keys, join columns, and group by columns. Complete sharing of ESP
partitioning schemes minimizes the overhead of runtime repartitioning. But, it can also result in very long-running queries if the
"least common denominator" partitioning scheme results in a few active ESPs doing most of the work. This can happen when repartitioning
is being done on a very low unique entry count attribute. For example, gender. +
 +
ROBUST_QUERY_OPTIMIZATION can be used to influence the premiums associated with these risky plans and thereby overall plan quality and
performance for your specific workloads.
| *Values*                    |
*'MIN'*: No risk premium. +
*'HIGH'* and *'MAXIMUM'*: Higher risk premium. +
*'SYSTEM'*: Safe risk premium. +
 +
The default value is *'SYSTEM'*.
| *Usage*                     | 
MAXIMUM tells the optimizer to make the safest choice of query plans. This means: +
 +
&#8226; RISK_PREMIUM_NJ is set to 5.0: nested join must be 400% cheaper before it can win over competing (hash) join plans. +
&#8226; RISK_PREMIUM_SERIAL is set to 2.0: serial plan must be 100% cheaper before it can win over competing parallel plans. +
&#8226; PARTITIONING_SCHEME_SHARING is set to 2: no partition scheme sharing between adjacent ESP fragments. +
 +
HIGH tells the optimizer to make a safer choice of query plans. This means: +
 +
&#8226; RISK_PREMIUM_NJ is set to 2.5: nested join must be 150% cheaper before it can win over competing (hash) join plans. +
&#8226; RISK_PREMIUM_SERIAL is set to 1.5: serial plan must be 50% cheaper before it can win over completing parallel plans. +
&#8226; PARTITIONING_SCHEME_SHARING is set to 1: subset sharing of partition schemes between adjacent ESP fragments. +
 +
SYSTEM tells the optimizer to make a safe choice of query plans. This means: +
 +
&#8226; RISK_PREMIUM_NJ is set to 1.2: nested join must be 20% cheaper before it can win over competing (hash) join plans. +
&#8226; RISK_PREMIUM_SERIAL is set to 1.2: serial plan must be 20% cheaper before it can win over completing parallel plans. +
&#8226; PARTITIONING_SCHEME_SHARING is set to 1: subset sharing of partition schemes between adjacent ESP fragments. +
 +
MIN tells the optimizer to believe its cardinality estimates are always correct when choosing query plans. For example, don't apply any risk premium for risky operations. This means: +
 +
&#8226; RISK_PREMIUM_NJ is set to 1.0: nested join can win over competing (hash) join plans purely based on cost & cardinality estimates. +
&#8226; RISK_PREMIUM_SERIAL is set to 1.0: serial plan can win over completing parallel plans purely based on cost & cardinality estimates. +
&#8226; PARTITIONING_SCHEME_SHARING is set to 0: complete sharing of partition schemes between adjacent ESP fragments. +
 +
If histograms are accurate and the queries are relatively simple, then you could choose a lower robustness setting.
In complex query environments where queries could end up processing large amounts of data, you should consider higher settings. +
 +
If you notice that when queries are not performing well it is due to either nested join plans, serial plans, or reduced parallelism,
then you could consider increasing risk premiums to see if you can get overall better performance.
| *Production Usage*          | It is best to try out different options to achieve best overall performance in a test environment before
implementing the changed settings in a production environment.
| *Impact*                    | Specifying a risk premium insures against nested joins or serial plans being chosen when they should not
have been. However, this can also result in such plans not being chosen where the cardinality estimation was in fact accurate and such
plans could have performed better. So this setting should be used with care in order to get robustness with a net gain in performance.
| *Level*                     | Any. There may be cases where there are different applications or workloads that might benefit from this
CQD more than other workloads. In such cases this could be used at the Service level.
| *Conflicts/Synergies*       | This conflicts with the <<risk-premium-nj,RISK_PREMIUM_NJ>>, <<risk-premium-serial,RISK_PREMIUM_SERIAL>>,
and <<partitioning-scheme-sharing,PARTITIONING_SCHEME_SHARING>> settings. Use this CQD when possible. Use the risk premium settings rarely,
when specific premiums need to be set differently to address specific issues. +
 +
If overall this CQD is working well but you have outliers, such as poor nested join plans or inappropriate serial plans, then you could
use the individual CQDs at a finer granularity, such as at a query level, to get better plans.
| *Real Problem Addressed*    | Sometimes the cardinality underestimation, compared to the actual row counts, resulting in a nested join
or serial plan being chosen when it shouldn't have been, may be due to not enough, or inaccurate, histogram statistics information available
to the optimizer. So, first and foremost, histogram statistics should be kept up to date along with the multi-column statistics that the
optimizer may warn about. However, cardinality underestimations may still happen at higher levels of an execution plan.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[skew-explain]]
== SKEW_EXPLAIN

[cols="25%h,75%"]
|===
| *Description*               | Turns on the reporting of anti-skew join plan details in EXPLAIN or EXPLAIN OPTIONS 'f'.
| *Values*                    |
*'OFF'*: Disables the use of SKEW_EXPLAIN. +
*'ON'*: Enables skew information in EXPLAIN. +
 +
The default value is *'OFF'*.
| *Usage*                     | Not applicable. 
| *Production Usage*          | Not applicable.
| *Impact*                    | Query plans are not changed by this CQD. 
| *Level*                     | Any.
| *Conflicts/Synergies*       | Allows additional information to be displayed in explain plans. It has no impact on query plans.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[skew-rowcount-threshold]]
== SKEW_ROWCOUNT_THRESHOLD

[cols="25%h,75%"]
|===
| *Description*               | The optimizer looks for skewed values and address that skew if the number of rows in the table exceeds this threshold.
| *Values*                    |
*'n'*: where n is the number of rows +
 +
Default: *'1000000'*
| *Usage*                     | Skew can occur either in a nested join or a hash join. Currently, such skew is typically handled for the outer
table of a join. The outer table is identified by the Explain plan. +
 +
The first indication is that there is a performance problem caused by skew that is not addressed by the compiler. A skew can be detected by
observing the imbalanced use of node cycles during query execution or by observed table skew. +
 +
The default setting has been chosen to handle most skew values that are worth worrying about. That is, in other cases there may be skew but
the impact on total query execution may be minimal. However, there could be cases where this is not true. +
 +
If you detect or suspect that a performance issue is caused by skew issues, then you need to look at the cardinality of the table with skew
(typically, the outer table in a join) to determine whether the table has fewer rows than defined by this CQD (default: 1 million rows.)
If the table has fewer rows than the CQD setting, then set this CQD to a value smaller than the number of rows in that table. +
 +
If changing the setting addresses the performance problem, then the skew has been addressed. You can also examine whether the optimizer
has addressed the skew issue by turning on SKEW_EXPLAIN EXPLAIN of the plan and then run the EXPLAIN statement. +
 +
If you find that you need to change the setting of this CQD to a value other than the default value, then please file a case providing
information about the table skew, the query, and the value that worked. Filing a case for this situation helps us tune the default value further.
| *Production Usage*          | See usage discussion above. Use this CQD with care.
| *Impact*                    | A lower setting allows more skews to be detected and addressed. However, compile time is increased.
| *Level*                     | Any.
| *Conflicts/Synergies*       | SKEW_EXPLAIN can be used as described in above. Also, <<skew-sensitivity-threshold,SKEW_SENSITIVITY_THRESHOLD>>
is relevant if this threshold allows a skew to be detected only.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[skew-sensitivity-threshold]]
== SKEW_SENSITIVITY_THRESHOLD

[cols="25%h,75%"]
|===
| *Description*               | Used to specify a threshold that determines whether a value in the join column is considered skewed.
| *Values*                    |
*'-1'*: Disables the use of skew buster. +
*'n'*: 'n' is a floating-point value greater than or equal to 0. +
 +
The default value is *'-1'*.
| *Usage*                     | A value is considered skewed if its occurrence frequency is greater than the threshold value multiplied
by the average number of rows per processing node (CPU). That is, if the average row count equals the row count divided by the number
of processing nodes, then the frequency of the value is greater than the threshold multiplied by the average row count. +
 +
A setting of _n_, where _n_ &#62;&#61; 0, indicates that the value should be considered as skewed if its occurrence frequency is greater
than _n_ times the average number of rows per processing node. +
 +
If some small skew is suspected for hash joins during query execution (detected by observing spiked CPU busy usage), then try to lower
this setting. A default setting of 0.1 should eliminate most skews. Setting the CQD to a very large value, such as 10, is not recommended,
as it effectively turns off skew buster. 
| *Production Usage*          | Not applicable.
| *Impact*                    | Not applicable.
| *Level*                     | Any.
| *Conflicts/Synergies*       | This CQD is only relevant if the <<skew-rowcount-threshold,SKEW_ROWCOUNT_THRESHOLD>> has been met.
The <<skew-rowcount-threshold,SKEW_ROWCOUNT_THRESHOLD CQD>> controls the row count of the table at which the optimizer looks for a skew. 
| *Real Problem Addressed*    | Skew is quite common in a real big-data application, and is effectively addressed by skew buster.
However, there may be design opportunities that could help address the problem as well.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[subquery_unnesting]]
== SUBQUERY_UNNESTING

[cols="25%h,75%"]
|===
| *Description*               | Allows correlated subqueries in a SQL statement to be unnested, so that they can be executed efficiently.
| *Values*                    |
*'ON'*: Unnesting enabled. +
*'OFF'*: Unnesting disabled. +
 +
The default value is *'ON'*.
| *Usage*                     | Turn this CQD OFF when (in rare cases) unnesting a correlated subquery causes performance to degrade.
If this attribute has to be turned OFF, then that could indicate a bug in the {project-name} Optimizer. Please contact {project-support}.
| *Production Usage*          | Yes.
| *Impact*                    | Turn OFF with caution at a system level, as other queries which rely on un-nesting could be adversely impacted.
| *Level*                     | Query.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[traf-allow-esp-colocation]]
== TRAF_ALLOW_ESP_COLOCATION

[cols="25%h,75%"]
|===
| *Description*               | Enables or disables whether ESP are colocated with HBase Region Servers, which minimizes the inter-node
network traffic between the ESP processes and the HBase Region Servers.
| *Values*                    |
*'ON'*: Colocation enabled. +
*'OFF'*: Colocation disabled. +
 +
The default value is *'OFF'*.
| *Usage*                     | Enable the feature when each region server serves approximately equal amount of data, and/or reducing network traffic is important.  
| *Production Usage*          | Please contact {project-support}.
| *Impact*                    | Plan quality.
| *Level*                     | Session.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[traf-upsert-with-insert-default-semantics]]
== TRAF_UPSERT_WITH_INSERT_DEFAULT_SEMANTICS

[cols="25%h,75%"]
|===
| *Description*               | Enables population of omitted columns in an UPSERT statement with default values when the table is created in aligned-row format mode.
| *Values*                    |
*'ON'*: Default population enabled. +
*'OFF'*: Default population disabled. +
 +
The default value is *'ON'*.
| *Usage*                     | When a column with default value is omitted in an UPSERT statement of a table in aligned row format mode,
then the statement is transformed to merge. +
 +
If the row already exists, then the omitted columns are populated with values from the existing row. +
 +
If the row doesn't exist, then the omitted columns are populated with default values. This default behavior can be changed by setting this CQD to 'ON',
which improves the performance of the UPSERT statements with omitted default value columns.
| *Production Usage*          | Yes.
| *Impact*                    | Improved upsert performance of aligned row format tables.
| *Level*                     | Query.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===

<<<
[[upd-ordered]]
== UPD_ORDERED

[cols="25%h,75%"]
|===
| *Description*               | Controls whether rows should be inserted, updated, or deleted in clustering key order.
| *Values*                    |
*'ON'*: The optimizer generates and considers plans where the rows are inserted, updated, or deleted in clustering key order. +
*'OFF'*: The optimizer does not generate plans where the rows must be inserted, updated, or deleted in clustering key order. +
 +
The default value is *'ON'*.
| *Usage*                     | Inserting, updating or deleting rows in the clustering key order is most efficient and highly recommended.
Turning this CQD OFF may result in saving the data sorting cost but at the expense of having less efficient random I/O Insert/Update/Delete operations.
If you know that he data is already sorted in clustering key order, or is mostly in clustering key order, so that it would not result in random I/O,
you could set this CQD to OFF. 
| *Production Usage*          | Not applicable.
| *Impact*                    | If turned OFF, the system may perform large number of inefficient Random I/Os when performing Insert/Update/Delete operations.
| *Level*                     | Query.
| *Conflicts/Synergies*       | Not applicable.
| *Real Problem Addressed*    | Not applicable.
| *Introduced In Release*     | {project-name} 1.3.0.
| *Deprecated In Release*     | Not applicable.
|===
