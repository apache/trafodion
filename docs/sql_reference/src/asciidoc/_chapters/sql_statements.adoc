////
/**
* @@@ START COPYRIGHT @@@
*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*
* @@@ END COPYRIGHT @@@
  */
////

[[sql_statements]]
= SQL Statements

This section describes the syntax and semantics of Trafodion SQL statements.

Trafodion SQL statements are entered interactively or from script files using a client-based tool, such as the
Trafodion Command Interface (TrafCI). To install and configure a client application that enables you to connect
to and use a Trafodion database, see the
http://trafodion.incubator.apache.org/client_install/index.html[_Trafodion Client Installation_ _Guide_].

[[sql_statements_categories]]
== Categories

The statements are categorized according to their functionality:

* <<Data_Definition_Language_Statements,Data Definition Language (DDL) Statements>>
* <<Data_Manipulation_Language_Statements,Data Manipulation Language (DML) Statements>>
* <<Transaction_Control_Statements,Transaction Control Statements>>
* <<Data_Control_and_Security_Statements,Data Control and Security Statements>>
* <<Stored_Procedure_and_User_Defined_Function_Statements,Stored Procedure and User-Defined Function Statements>>
* <<Prepared_Statements,Prepared Statements>>
* <<Control_Statements,Control Statements>>
* <<Object_Naming_Statements,Object Naming Statements>>
* <<SHOW_GET_and_EXPLAIN_Statements,"SHOW, GET, and EXPLAIN Statements">>

<<<
[[Data_Definition_Language_Statements]]
=== Data Definition Language (DDL) Statements

Use these DDL statements to create, drop, or alter the definition of a Trafodion SQL schema or object.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run DDL statements inside a user-defined
transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run these statements, AUTOCOMMIT must be turned ON
(the default) for the session.

[cols="2*", options="header"]
|===
| Statement                                                  | What It Does
| <<ALTER_LIBRARY_Statement,ALTER LIBRARY Statement>>        | Updates the physical filename for a library object in a Trafodion database.
| <<ALTER_TABLE_Statement,ALTER TABLE Statement>>            | Changes attributes for a table.
| <<ALTER_USER_Statement,ALTER USER Statement>>              | Changes attributes for a user.
| <<CREATE_FUNCTION_Statement,CREATE FUNCTION Statement>>    | Registers a user-defined function (UDF) written in C as a functionwithin a Trafodion database.
| <<CREATE_INDEX_Statement,CREATE INDEX Statement>>          | Creates an index on a table.
| <<CREATE_LIBRARY_Statement,CREATE LIBRARY Statement>>      | Registers a library object in a Trafodion database.
| <<CREATE_PROCEDURE_Statement,CREATE PROCEDURE Statement>>  | Registers a Java method as a stored procedure in Java (SPJ) within a Trafodion database.
| <<CREATE_ROLE_Statement,CREATE ROLE Statement>>            | Creates a role.
| <<CREATE_SCHEMA_Statement,CREATE SCHEMA Statement>>        | Creates a schema in the database.
| <<CREATE_TABLE_Statement,CREATE TABLE Statement>>          | Creates a table.
| <<CREATE_VIEW_Statement,CREATE VIEW Statement>>            | Creates a view.
| <<DROP_FUNCTION_Statement,DROP FUNCTION Statement>>        | Removes a user-defined function (UDF) from the Trafodion database.
| <<DROP_INDEX_Statement,DROP INDEX Statement>>              | Drops an index.
| <<DROP_LIBRARY_Statement,DROP LIBRARY Statement>>          | Removes a library object from the Trafodion database and also removes the library file
referenced by the library object.
| <<DROP_PROCEDURE_Statement,DROP PROCEDURE Statement>>      | Removes a stored procedure in Java (SPJ) from the Trafodion database.
| <<DROP_ROLE_Statement,DROP ROLE Statement>>                | Drops a role.
| <<DROP_SCHEMA_Statement,DROP SCHEMA Statement>>            | Drops a schema from the database.
| <<DROP_TABLE_Statement,DROP TABLE Statement>>              | Drops a table.
| <<DROP_VIEW_Statement,DROP VIEW Statement>>                | Drops a view.
| <<REGISTER_USER_Statement,REGISTER USER Statement>>        | Registers a user in the SQL database, associating the user's login name
with a database username.
| <<UNREGISTER_USER_Statement, UNREGISTER USER Statement>>   | Removes a database username from the SQL database.
|===


<<<
[[Data_Manipulation_Language_Statements]]
=== Data Manipulation Language (DML) Statements

Use these DML statements to delete, insert, select, or update rows in one or more tables:

[cols="2*", options="header"]
|===
| Statement                               | What It Does
| <<DELETE_Statement,DELETE Statement>> | Deletes rows from a table or view.
| <<INSERT_Statement,INSERT Statement>> | Inserts data into tables and views.
| <<MERGE_Statement,MERGE Statement>>   | Either performs an upsert operation (that is, updates a table if the row
exists or inserts into a table if the row does not exist) or updates (merges) matching rows from one table to another.
| <<SELECT_Statement,SELECT Statement>> | Retrieves data from tables and views.
| <<TABLE_Statement,TABLE Statement>>   | Equivalent to the query specification SELECT * FROM _table_
| <<UPDATE_Statement,UPDATE Statement>> | Updates values in columns of a table or view.
| <<UPSERT_Statement,UPSERT Statement>> | Updates a table if the row exists or inserts into a table if the row does not exist.
| <<VALUES_Statement,VALUES Statement>> | Displays the results of the evaluation of the expressions and the results of row subqueries
within the row value constructors.
|===

[[Transaction_Control_Statements]]
=== Transaction Control Statements

Use these statements to specify user-defined transactions and to set attributes for the next transaction:

[cols="2*",options="header"]
|===
| Statement                                                 | What It Does
| <<BEGIN_WORK_Statement,BEGIN WORK Statement>>           | Starts a transaction.
| <<COMMIT_WORK_Statement,COMMIT WORK Statement>>         | Commits changes made during a transaction and ends the transaction.
| <<ROLLBACK_WORK_Statement,ROLLBACK WORK Statement>>     | Undoes changes made during a transaction and ends the transaction.
| <<SET_TRANSACTION_Statement,SET TRANSACTION Statement>> | Sets attributes for the next SQL transaction — whether to automatically
commit database changes.
|===

<<<
[[Data_Control_and_Security_Statements]]
=== Data Control and Security Statements

Use these statements to register users, create roles, and grant and revoke privileges:

[cols="2*",options="header"]
|===
| Statement                                                                     | What It Does
| <<ALTER_USER_Statement,ALTER USER Statement>>                                 | Changes attributes associated with a user who is registered in the database.
| <<CREATE_ROLE_Statement,CREATE ROLE Statement>>                               | Creates an SQL role.
| <<DROP_ROLE_Statement,DROP ROLE Statement>>                                   | Deletes an SQL role.
| <<GRANT_Statement,GRANT Statement>>                                           | Grants access privileges on an SQL object to specified users or roles.
| <<GRANT_COMPONENT_PRIVILEGE_Statement,GRANT COMPONENT PRIVILEGE Statement>>   | Grants one or more component privileges to a user or role.
| <<GRANT_ROLE_Statement,GRANT ROLE Statement>>                                 | Grants one or more roles to a user.
| <<REGISTER_USER_Statement,REGISTER USER Statement>>                           | Registers a user in the SQL database, associating the user's login name with a database username.
| <<REVOKE_Statement,REVOKE Statement>>                                         | Revokes access privileges on an SQL object from specified users or roles.
| <<REVOKE_COMPONENT_PRIVILEGE_Statement,REVOKE COMPONENT PRIVILEGE Statement>> | Removes one or more component privileges from a user or role.
| <<REVOKE_ROLE_Statement,REVOKE ROLE Statement>>                               | Removes one or more roles from a user.
| <<UNREGISTER_USER_Statement,UNREGISTER USER Statement>>                       | Removes a database username from the SQL database.
|===

<<<
[[Stored_Procedure_and_User_Defined_Function_Statements]]
=== Stored Procedure and User-Defined Function Statements

Use these statements to create and execute stored procedures in Java (SPJs) or create user-defined functions (UDFs) and to modify
authorization to access libraries or to execute SPJs or UDFs:

[cols="2*",options="header"]
|===
| Statement                                                 | What It Does
| <<ALTER_LIBRARY_Statement,ALTER LIBRARY Statement>>       | Updates the physical filename for a library object in a Trafodion database.
| <<CALL_Statement,CALL Statement>>                         | Initiates the execution of a stored procedure in Java (SPJ) in a Trafodion database.
| <<CREATE_FUNCTION_Statement,CREATE FUNCTION Statement>>   | Registers a user-defined function (UDF) written in C as a function within a Trafodion database.
| <<CREATE_LIBRARY_Statement,CREATE LIBRARY Statement>>     | Registers a library object in a Trafodion database.
| <<CREATE_PROCEDURE_Statement,CREATE PROCEDURE Statement>> | Registers a Java method as a stored procedure in Java (SPJ) within a Trafodion database.
| <<DROP_FUNCTION_Statement,DROP FUNCTION Statement>>       | Removes a user-defined function (UDF) from the Trafodion database.
| <<DROP_LIBRARY_Statement,DROP LIBRARY Statement>>         | Removes a library object from the Trafodion database and also removes the library file
referenced by the library object.
| <<DROP_PROCEDURE_Statement,DROP PROCEDURE Statement>>     | Removes a stored procedure in Java (SPJ) from the Trafodion database.
| <<GRANT_Statement,GRANT Statement>>                       | Grants privileges for accessing a library object or executing an SPJ or UDF to specified users.
| <<REVOKE_Statement,REVOKE Statement>>                     | Revokes privileges for accessing a library object or executing an SPJ or UDF from specified users.
UDF from specified users.
|===

[[Prepared_Statements]]
=== Prepared Statements

Use these statements to prepare and execute an SQL statement:

[cols="2*",options="header"]
|===
| Statement                                                 | What It Does
| <<EXECUTE_Statement,EXECUTE Statement>>                   | Executes an SQL statement previously compiled by a PREPARE statement.
| <<PREPARE_Statement,PREPARE Statement>>                   | Compiles an SQL statement for later use with the EXECUTE statement in the same session.
|===


<<<
[[Control_Statements]]
=== Control Statements

Use these statements to control the execution, default options, plans, and performance of DML statements:

[cols="2*",options="header"]
|===
| Statement                                                                     | What It Does
| <<CONTROL_QUERY_CANCEL_Statement,CONTROL QUERY CANCEL Statement>>             | Cancels an executing query that you identify with a query ID.
| <<CONTROL_QUERY_DEFAULT_Statement,CONTROL QUERY DEFAULT Statement>>           | Changes a default attribute to influence a query plan.
|===

[[Object_Naming_Statements]]
=== Object Naming Statements

Use this statements to specify default ANSI names for the schema:

[cols="2*",options="header"]
|===
| Statement                                        | What It Does
| <<SET_SCHEMA_Statement,SET SCHEMA Statement>>    | Sets the default ANSI schema for unqualified object names for the current session.
|===

<<<
[[SHOW_GET_and_EXPLAIN_Statements]]
=== SHOW, GET, and EXPLAIN Statements

Use these statements to display information about database objects or query execution plans:

[cols="2*",options="header"]
|===
| Statement                                                               | What It Does
| <<EXPLAIN_Statement,EXPLAIN Statement>>                                 | Displays information contained in the query execution plan.
| <<GET_Statement,GET Statement>>                                         | Displays the names of database objects, components, component
privileges, roles, or users that exist in the Trafodion instance.
| <<GET_HBASE_OBJECTS_Statement,GET HBASE OBJECTS Statement>>             | Displays a list of HBase objects through an SQL interface
| <<GET_VERSION_OF_METADATA_Statement,GET VERSION OF METADATA Statement>> | Displays the version of the metadata in the Trafodion instance and
indicates if the metadata is current.
| <<GET_VERSION_OF_SOFTWARE_Statement,GET VERSION OF SOFTWARE Statement>> | Displays the version of the Trafodion software that is installed on the
system and indicates if it is current.
| <<INVOKE_Statement,INVOKE Statement>>                                   | Generates a record description that corresponds to a row in the
specified table or view.
| <<SHOWCONTROL_Statement,SHOWCONTROL Statement>>                         | Displays the CONTROL QUERY DEFAULT attributes in effect.
| <<SHOWDDL_Statement,SHOWDDL Statement>>                                 | Describes the DDL syntax used to create an object as it exists in the
metadata, or it returns a description of a user, role, or component in the form of a GRANT statement.
| <<SHOWDDL_SCHEMA_Statement,SHOWDDL SCHEMA Statement>>                   | Displays the DDL syntax used to create a schema as it exists in the
metadata and shows the authorization ID that owns the schema.
| <<SHOWSTATS_Statement,SHOWSTATS Statement>>                             | Displays the histogram statistics for one or more groups of columns
within a table. These statistics are used to devise optimized access plans.

|===

<<<
[[ALTER_LIBRARY_Statement]]
== ALTER LIBRARY Statement

* <<alter_library_syntax,Syntax Description of ALTER LIBRARY>>
* <<alter_library_considerations,Considerations for ALTER LIBRARY>>
* <<alter_library_examples,Examples of ALTER LIBRARY>>

The ALTER LIBRARY statement updates the physical filename for a library object in a Trafodion database.
A library object can be an SPJ's JAR file or a UDF's library file.

ALTER LIBRARY is a Trafodion SQL extension.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run this statement inside 
user-defined transaction (`BEGIN WORK&#8230;COMMIT WORK`) or when AUTOCOMMIT is OFF. To run this statement, AUTOCOMMIT must be
turned ON (the default) for the session.

```
ALTER LIBRARY [[catalog-name.]schema-name.]library-name
   FILE library-filename
   [HOST NAME host-name]
   [LOCAL FILE host-filename]
```

<<<
[[alter_library_syntax]]
=== Syntax Description of ALTER LIBRARY

* `[[_catalog-name_.]_schema-name_.]_library-name_`
+
specifies the ANSI logical name of the library object, where each part of the name is a valid SQL identifier with a maximum of 128 characters.
Specify the name of a library object that has already been registered in the schema. If you do not fully qualify the library name, Trafodion SQL
qualifies it according to the schema of the current session. For more information, see <<Identifiers,Identifiers>> and
<<_Database_Object_Names,Database Object Names>>.

* `FILE _library-filename_`
+
specifies the full path of the redeployed library file, which either an SPJ's JAR file or a UDF's library file.

* `HOST NAME _host-name_`
+
specifies the name of the client host machine where the deployed file resides.

* `LOCAL FILE _host-filename_`
+
specifies the path on the client host machine where the deployed file is stored.

[[alter_library_considerations]]
=== Considerations for ALTER LIBRARY

* HOST NAME and LOCAL FILE are position dependent.

==== Required Privileges

To issue an ALTER LIBRARY statement, one of the following must be true:

* You are DB ROOT.
* You are the owner of the library.
* You have the ALTER or ALTER_LIBRARY component privilege for the SQL_OPERATIONS component.

<<<
[[alter_library_examples]]
=== Examples of ALTER LIBRARY

* This ALTER LIBRARY statement updates the JAR file (SPJs) for a library named SALESLIB in the SALES schema:
+
```
ALTER LIBRARY sales.saleslib FILE Sales2.jar;`
```

* This ALTER LIBRARY statement updates the library file (UDFs) for a library named MYUDFS in the default schema:
+
```
ALTER LIBRARY myudfs FILE $TMUDFLIB;
```


<<<
[[ALTER_TABLE_Statement]]
== ALTER TABLE Statement

* <<alter_table_syntax,Syntax Description of ALTER TABLE>>
* <<alter_table_considerations,Considerations for ALTER TABLE>>
* <<alter_table_examples,Examples of ALTER TABLE>>

The ALTER TABLE statement changes a Trafodion SQL table. See <<Tables,Tables>>.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run this
statement inside a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF.
To run this statement, AUTOCOMMIT must be turned ON (the default) for the session.

```
ALTER TABLE name alter-action

alter-action is:

     ADD [COLUMN] column-definition
   | ADD IF NOT EXISTS column-definition
   | ADD [CONSTRAINT constraint-name] table-constraint
   | DROP CONSTRAINT constraint-name [RESTRICT]
   | RENAME TO new-name [CASCADE]
   | DROP COLUMN [IF EXISTS] column-name

column-definition is:

   column-name data-type
      ([DEFAULT default]
         [[CONSTRAINT constraint-name] column-constraint])

data-type is:

     CHAR[ACTER] [(length)[CHARACTERS]]
         [CHARACTER SET char-set-name]
         [UPSHIFT] [[NOT] CASESPECIFIC]
   | CHAR[ACTER] VARYING (length)
         [CHARACTER SET char-set-name]
         [UPSHIFT] [[NOT] CASESPECIFIC]
   | VARCHAR (length) [CHARACTER SET char-set-name]
         [UPSHIFT] [[NOT] CASESPECIFIC]
   | NUMERIC [(precision [,scale])] [SIGNED|UNSIGNED]
   | NCHAR [(length) [CHARACTER SET char-set-name]
         [UPSHIFT] [[NOT] CASESPECIFIC]
   | NCHAR VARYING(length) [CHARACTER SET char-set-name]
         [UPSHIFT] [[NOT] CASESPECIFIC]
   | SMALLINT [SIGNED|UNSIGNED]
   | INT[EGER] [SIGNED|UNSIGNED]
   | LARGEINT
   | DEC[IMAL] [(precision [,scale])] [SIGNED|UNSIGNED]
   | FLOAT [(precision)]
   | REAL
   | DOUBLE PRECISION
   | DATE
   | TIME [(time-precision)]
   | TIMESTAMP [(timestamp-precision)]
   | INTERVAL { start-field TO end-field | single-field }

default is:

     literal
   | NULL
   | CURRENTDATE
   | CURRENTTIME
   | CURRENTTIMESTAMP }

column-constraint is:

     NOT NULL
   | UNIQUE
   | CHECK (condition)
   | REFERENCES ref-spec

table-constraint is:

     UNIQUE (column-list)
   | CHECK (condition)
   | FOREIGN KEY (column-list) REFERENCES ref-spec

ref-spec is:

   referenced-table [(column-list)]

column-list is:

   column-name[, column-name]...
```

<<<
[[alter_table_syntax]]
=== Syntax Description of ALTER TABLE

* `_name_`
+
specifies the current name of the object. See <<Database_Object_Names,Database Object Names>>.

* `ADD [COLUMN] _column-definition_`
+
adds a column to _table_.
+
The clauses for the _column-definition_ are:

** `_column-name_`
+
specifies the name for the new column in the table. _column-name_ is an SQL identifier. _column-name_ must be
unique among column names in the table. If the column name is a Trafodion SQL reserved word, you must
delimit it by enclosing it in double quotes. For example: `"sql".myview`. See <<Identifiers,Identifiers>>.

** `_data-type_`
+
specifies the data type of the values that can be stored in _column-name_. See <<Data_Types,Data Types>>
If a default is not specified, NULL is used.

** `DEFAULT _default_`
+
specifies a default value for the column or specifies that the column does not have a default value. You can declare the default value
explicitly by using the DEFAULT clause, or you can enable null to be used as the default by omitting both the DEFAULT and NOT NULL clauses.
If you omit the DEFAULT clause and specify NOT NULL, Trafodion SQL returns an error. For existing rows of the table, the added column takes
on its default value.
+
If you set the default to the datetime value CURRENT_DATE, CURRENT_TIME, or CURRENT_TIMESTAMP, Trafodion SQL uses January 1, 1 A.D.
12:00:00.000000 as the default date and time for the existing rows.
+
For any row that you add after the column is added, if no value is specified for the column as part of the add row operation, the column
receives a default value based on the current timestamp at the time the row is added.

<<<
** `[[CONSTRAINT _constraint-name_] _column-constraint_]`
+
specifies a name for the column or table constraint. _constraint-name_ must have the same schema as _table_ and must be
unique among constraint names in its schema. If you omit the schema portions of the name you specify in _constraint-name_,
Trafodion SQL expands the constraint name by using the schema for _table_. See <<Database_Object_Names,Database Object Names>>.
+
If you do not specify a constraint name, Trafodion SQL constructs an SQL identifier as the name for the constraint in the schema
for _table._ The identifier consists of the fully qualified table name concatenated with a system-generated unique identifier.
For example, a constraint on table A.B.C might be assigned a name such as A.B.C_123&#8230;_01&#8230;.

*** `_column-constraint_` options:

**** `NOT NULL` 
+
is a column constraint that specifies that the column cannot contain nulls. If you omit NOT NULL, nulls are allowed in the column.
If you specify both NOT NULL and NO DEFAULT, then each row inserted in the table must include a value for the column. See <<Null,Null>>.

**** `UNIQUE`
+
is a column constraint that specifies that the column cannot contain more than one occurrence of the same value. If you omit UNIQUE,
duplicate values are allowed unless the column is part of the PRIMARY KEY. Columns that you define as unique must be specified as NOT NULL.

**** `CHECK (_condition_)`
+
is a constraint that specifies a condition that must be satisfied for each row in the table. See <<Search_Condition,Search Condition>>.
You cannot refer to the CURRENT_DATE, CURRENT_TIME, or CURRENT_TIMESTAMP function in a CHECK constraint, and you cannot use
subqueries in a CHECK constraint.

<<<
**** `REFERENCES _ref-spec_`
+
specifies a REFERENCES column constraint. The maximum combined length of the columns for a REFERENCES constraint is 2048 bytes. +

***** `_ref-spec_` is:
+
`_referenced-table_ [(_column-list_)]`
+
`_referenced-table_` is the table referenced by the foreign key in a referential constraint. _referenced-table_ cannot be a view.
_referenced-table_ cannot be the same as _table_. _referenced-table_ corresponds to the foreign key in the _table_.
 +
`_column-list_` specifies the column or set of columns in the _referenced-table_ that corresponds to the foreign key in _table_. The
columns in the column list associated with REFERENCES must be in the same order as the columns in the column list associated with FOREIGN
KEY. If _column-list_ is omitted, the referenced table's PRIMARY KEY columns are the referenced columns.
+
A table can have an unlimited number of referential constraints, and you can specify the same foreign key in more than one referential
constraint, but you must define each referential constraint separately. You cannot create self-referencing foreign key constraints.

* `ADD [CONSTRAINT _constraint-name_] _table-constraint_`
+
adds a constraint to the table and optionally specifies _constraint-name_ as the name for the constraint. The new constraint
must be consistent with any data already present in the table. 

<<<
** `CONSTRAINT _constraint-name_`
+
specifies a name for the column or table constraint. _constraint-name_ must have the same schema as _table_ and must be unique among constraint
names in its schema. If you omit the schema portions of the name you specify in _constraint-name_, Trafodion SQL expands the constraint
name by using the schema for table. See <<Database_Object_Names,Database Object Names>>. 
+
If you do not specify a constraint name, Trafodion SQL constructs an SQL identifier as the name for the constraint in the schema for table. The
identifier consists of the fully qualified table name concatenated with a system-generated unique identifier. For example, a constraint on table
A.B.C might be assigned a name such as A.B.C_123&#8230;_01&#8230;.
+
** `_table-constraint_` options:

*** `UNIQUE (_column-list_)`
+
is a table constraint that specifies that the column or set of columns cannot contain more 
than one occurrence of the same value or set of values.
+
`_column-list_` cannot include more than one occurrence of the same column. In addition, the set of columns that you specify on a UNIQUE
constraint cannot match the set of columns on any other UNIQUE constraint for the table or on the PRIMARY KEY constraint for the table.
All columns defined as unique must be specified as NOT NULL.
+
A UNIQUE constraint is enforced with a unique index. If there is already a unique index on _column-list_, Trafodion SQL uses that index. If a
unique index does not exist, the system creates a unique index.

*** `CHECK (_condition_)`
+
is a constraint that specifies a condition that must be satisfied for each row in the table.
See <<Search_Condition,Search Condition>>. You cannot refer to the CURRENT_DATE, CURRENT_TIME, or CURRENT_TIMESTAMP function in a CHECK
constraint, and you cannot use subqueries in a CHECK constraint.

<<<
*** `FOREIGN KEY (_column-list_) REFERENCES _ref-spec_ NOT ENFORCED`
+
is a table constraint that specifies a referential constraint for the table, declaring that a column or set of columns (called a foreign key)
in _table_ can contain only values that match those in a column or set of columns in the table specified in the REFERENCES
clause. However, because NOT ENFORCED is specified, this relationship is not checked.
+
The two columns or sets of columns must have the same characteristics (data type, length, scale, precision). Without the FOREIGN KEY clause,
the foreign key in _table_ is the column being defined; with the FOREIGN KEY clause, the foreign key is the column or set of columns specified in
the FOREIGN KEY clause. For information about _ref-spec_, see REFERENCES _ref-spec_ NOT ENFORCED.

* `DROP CONSTRAINT _constraint-name_ [RESTRICT]`
+
drops a constraint from the table. +
+
If you drop a constraint, Trafodion SQL drops its dependent index if Trafodion SQL originally created the same index. If the constraint uses
an existing index, the index is not dropped. +

** `CONSTRAINT _constraint-name_`
+
specifies a name for the column or table constraint. _constraint-name_ must have the same schema as _table_ and must be unique among constraint
names in its schema. If you omit the schema portions of the name you specify in _constraint-name_, Trafodion SQL expands the constraint
name by using the schema for table. See <<Database_Object_Names,Database Object Names>>.
+
If you do not specify a constraint name, Trafodion SQL constructs an SQL identifier as the name for the constraint in the schema for table. The
identifier consists of the fully qualified table name concatenated with a system-generated unique identifier. For example, a constraint on table
A.B.C might be assigned a name such as A.B.C_123&#8230;_01&#8230;.

* `RENAME TO _new-name_ [CASCADE]`
+
changes the logical name of the object within the same schema.

** `_new-name_`
+
specifies the new name of the object after the RENAME TO operation occurs.

<<<
** `CASCADE`
+
specifies that indexes and constraints on the renamed object will be renamed.

* `ADD IF NOT EXISTS _column-definition_`
+
adds a column to _table_ if it does not already exist in the table.
+
The clauses for the _column-definition_ are the same as described in ADD [COLUMN] _column-definition_.

* `DROP COLUMN [IF EXISTS] _column-name_`
+
drops the specified column from _table_, including the column’s data. You cannot drop a primary key column.

<<<
[[alter_table_considerations]]
=== Considerations for ALTER TABLE

[[effect_of_adding_a_column_on_view_definitions]]
==== Effect of Adding a Column on View Definitions

The addition of a column to a table has no effect on existing view definitions. Implicit column references specified by SELECT * in view
definitions are replaced by explicit column references when the definition clauses are originally evaluated.

[[authorization_and_availability_requirements]]
==== Authorization and Availability Requirements

ALTER TABLE works only on user-created tables.

===== Required Privileges

To issue an ALTER TABLE statement, one of the following must be true:

* You are DB ROOT.
* You are the owner of the table.
* You have the ALTER or ALTER_TABLE component privilege for the SQL_OPERATIONS component.

===== Privileges Needed to Create a Referential Integrity Constraint

To create a referential integrity constraint (that is, a constraint on the table that refers to a column in another table), one of the
following must be true:

* You are DB ROOT.
* You are the owner of the referencing and referenced tables.
* You have these privileges on the referencing and referenced table:
** For the referencing table, you have the ALTER or ALTER_TABLE component privilege for the SQL_OPERATIONS component.
** For the referenced table, you have the REFERENCES (or ALL) privilege on the referenced table through your username or through a granted role.

If the constraint refers to the other table in a query expression, you must also have SELECT privileges on the other table.

[[alter_table_examples]]
===  Example of ALTER TABLE

This example adds a column:

[source,sql]
----
ALTER TABLE persnl.project
   ADD COLUMN projlead
      NUMERIC (4) UNSIGNED
----

<<<
[[alter_user_statement]]
== ALTER USER Statement

* <<alter_user_syntax,Syntax Description of ALTER USER>>
* <<alter_user_considerations,Considerations for ALTER USER>>
* <<alter_user_examples,Examples of ALTER USER>>

The ALTER USER statement changes attributes associated with a user who is registered in the database.

ALTER USER is a Trafodion SQL extension.

[source,text,subs="quotes"]
----
ALTER USER database-username alter-action[, alter-action]

alter-action is:
     SET EXTERNAL NAME directory-service-username
   | SET { ONLINE | OFFLINE }
----

<<<
[[alter_user_syntax]]
=== Syntax Description of ALTER USER

* `_database-username_`
+
is the name of a currently registered database user.

* `SET EXTERNAL NAME`
+
changes the name that identifies the user in the directory service. This is also the name the user specifies when
connecting to the database.

** `_directory-service-username_`
+
specifies the new name of the user in the directory service.

* _directory-service-username_ is a regular or delimited case-insensitive
identifier. See <<Case_Insensitive_Delimited_Identifiers,Case-Insensitive Delimited Identifiers>>.

* SET { ONLINE | OFFLINE }
+
changes the attribute that controls whether the user is allowed to connect to the database. +

** `ONLINE`
+
specifies that the user is allowed to connect to the database.

** `OFFLINE`
+
specifies that the user is not allowed to connect to the database.

<<<
[[alter_user_considerations]]
=== Considerations for ALTER USER

Only a user with user administrative privileges (that is, a user who has been granted the MANAGE_USERS component privilege)
can do the following:

* Set the EXTERNAL NAME for any user
* Set the ONLINE | OFFLINE attribute for any user

Initially, DB_ROOT is the only database user who has been granted the MANAGE_USERS component privilege.

[[alter_user_examples]]
=== Examples of ALTER USER

* To change a user's external name:
+
[source,sql]
----
ALTER USER ajones SET EXTERNAL NAME "Americas\ArturoJones";
----

* To change a user's attribute to allow the user to connect to the database:
+
[source,sql]
----
ALTER USER ajones SET ONLINE;
----

<<<
[[begin_work_statement]]
== BEGIN WORK Statement

* <<begin_work_considerations,Considerations for BEGIN WORK>>
* <<begin_work_examples,Example of BEGIN WORK>>

The BEGIN WORK statement enables you to start a transaction explicitly—where the transaction consists of the set of operations
defined by the sequence of SQL statements that begins immediately after BEGIN WORK and ends with the next COMMIT or ROLLBACK
statement. See <<Transaction_Management,Transaction Management>>. BEGIN WORK will raise an error if a transaction is currently active.

BEGIN WORK is a Trafodion SQL extension.

```
BEGIN WORK
```

[[begin_work_considerations]]
=== Considerations for BEGIN WORK

BEGIN WORK starts a transaction. COMMIT WORK or ROLLBACK WORK ends a transaction.

<<<
[[begin_work_examples]]
=== Example of BEGIN WORK

Group three separate statements—two INSERT statements and an UPDATE statement—that update the database within a single transaction:

[source,sql]
----
--- This statement initiates a transaction.
BEGIN WORK;

--- SQL operation complete.

INSERT INTO sales.orders VALUES (125, DATE '2008-03-23', DAT '2008-03-30', 75, 7654);

--- 1 row(s) inserted.

INSERT INTO sales.odetail VALUES (125, 4102, 25000, 2);

--- 1 row(s) inserted.

UPDATE invent.partloc SET qty_on_hand = qty_on_hand - 2 WHERE partnum = 4102 AND loc_code = 'G45';

--- 1 row(s) updated.

--- This statement ends a transaction.
COMMIT WORK;

--- SQL operation complete.
----

<<<
[[call_statement]]
== CALL Statement

* <<call_syntax,Syntax Description of CALL>>
* <<call_considerations,Considerations for CALL>>
* <<call_examples,Examples of CALL>>

The CALL statement invokes a stored procedure in Java (SPJ) in a Trafodion SQL database.

```
CALL procedure-ref ([argument-list])

procedure-ref is:
   [[catalog-name.]schema-name.]procedure-name

argument-list is:
   SQL-expression[, SQL-expression]...
```

[[call_syntax]]
=== Syntax Description of CALL

* `_procedure-ref_`
+
specifies an ANSI logical name of the form:
+
`[[_catalog-name_.]_schema-name_.]_procedure-name_`
+
where each part of the name is a valid SQL identifier with a maximum of 128 characters. For more information, see
<<Identifiers,Identifiers>> and <<Database_Object_Names,Database Object Names>>.
+
If you do not fully qualify the procedure name, Trafodion SQL qualifies it according to the schema of the current session.

* `_argument-list_`
+
accepts arguments for IN, INOUT, or OUT parameters. The arguments consist of SQL expressions, including dynamic parameters,
separated by commas:
+
`_SQL-expression_[\{, _SQL-expression_}&#8230;]`
+
<<<
+
Each expression must evaluate to a value of one of these data types:
+
** Character value
** Date-time value
** Numeric value
+
Interval value expressions are disallowed in SPJs. For more information, see
<<call_input_parameter_arguments,Input Parameter Arguments>> and
<<call_output_parameter_arguments,Output Parameter Arguments>>.
+
Do not specify result sets in the argument list.

[[call_considerations]]
=== Considerations for CALL

[[call_usage_restrictions]]
==== Usage Restrictions

You can use a CALL statement as a stand-alone SQL statement in applications or command-line interfaces,
such as TrafCI. You cannot use a CALL statement inside a compound statement or with rowsets.

[[call_required_privileges]]
==== Required Privileges

To issue a CALL statement, one of the following must be true:

* You are DB ROOT.
* You are the owner of the stored procedure.
* You have the EXECUTE (or ALL) privileges, either directly through your username or through a granted role.
For more information, see the <<GRANT_Statement,GRANT Statement>>.

When the stored procedure executes, it executes as the Trafodion ID.

<<<
[[call_input_parameter_argument]]
==== Input Parameter Arguments

You pass data to an SPJ by using IN or INOUT parameters. For an IN
parameter argument, use one of these SQL expressions:

* Literal
* SQL function (including CASE and CAST expressions)
* Arithmetic or concatenation operation
* Scalar subquery
* Dynamic parameter (for example, ?) in an application
* Named (for example, ?param) or unnamed (for example, ?) parameter in TrafCI

For an INOUT parameter argument, you can use only a dynamic, named, or unnamed parameter. For more information, see
<<Expressions,Expressions>>.

[[call_output_parameter_arguments]]
==== Output Parameter Arguments

An SPJ returns values in OUT and INOUT parameters. Output parameter arguments must be dynamic parameters in an
application (for example, ?) or named or unnamed parameters in HPDCI (for example, ?param or ?). Each
calling application defines the semantics of the OUT and INOUT parameters in its environment.

[[call_data_conversion_parameter_arguments]]
==== Data Conversion of Parameter Arguments

Trafodion SQL performs an implicit data conversion when the data type of a parameter argument is compatible with
but does not match the formal data type of the stored procedure. For stored procedure input values,
the conversion is from the actual argument value to the formal parameter type. For stored procedure output values,
the conversion is from the actual output value, which has the data type of the formal parameter, to the declared
type of the dynamic parameter.

[[call_null_input_and_output]]
==== Null Input and Output

You can pass a null value as input to or output from an SPJ, provided that the corresponding Java data type of the
parameter supports nulls. If a null is input or output for a parameter that does not support nulls, Trafodion SQL
returns an error.

[[call_transaction_semantics]]
==== Transaction Semantics

The CALL statement automatically initiates a transaction if no active transaction exists. However, the failure of
a CALL statement does not always automatically abort the transaction.

[[call_examples]]
=== Examples of CALL

* In TrafCI, execute an SPJ named MONTHLYORDERS, which has one IN parameter represented by a literal and one OUT
parameter represented by an unnamed parameter, ?:
+
[source,sql]
----
CALL sales.monthlyorders(3,?);
----

<<<
* This CALL statement executes a stored procedure, which accepts one IN parameter (a date literal), returns one OUT
parameter (a row from the column, NUM_ORDERS), and returns two result sets:
+
[source,sql]
----
CALL sales.ordersummary('01/01/2001', ?);

NUM_ORDERS
--------------------
                  13

ORDERNUM   NUM_PARTS      AMOUNT          ORDER_DATE LAST_NAME
---------- -------------- --------------- ---------- ------------------
    100210              4        19020.00 2006-04-10 HUGHES
    100250              4        22625.00 2006-01-23 HUGHES
    101220              4        45525.00 2006-07-21 SCHNABL
    200300              3        52000.00 2006-02-06 SCHAEFFER
    200320              4         9195.00 2006-02-17 KARAJAN
    200490              2         1065.00 2006-03-19 WEIGL
.
.
.

--- 13 row(s) selected.

ORDERNUM   PARTNUM  UNIT_PRICE   QTY_ORDERED PARTDESC
---------- -------- ------------ ----------- ------------------
    100210     2001      1100.00           3 GRAPHIC PRINTER,M1
    100210     2403       620.00           6 DAISY PRINTER,T2
    100210      244      3500.00           3 PC GOLD, 30 MB
    100210     5100       150.00          10 MONITOR BW, TYPE 1
    100250     6500        95.00          10 DISK CONTROLLER
    100250     6301       245.00          15 GRAPHIC CARD, HR
.
.
.

--- 70 row(s) selected.

--- SQL operation complete.
----

<<<
[[commit_work_statement]]
== COMMIT WORK Statement

* <<commit_work_considerations,Considerations for COMMIT WORK>>
* <<commit_work_examples,Example of COMMIT WORK>>

The COMMIT WORK statement commits any changes to objects made during the current transaction and ends
the transaction. See <<Transaction_Management,Transaction Management>>.

WORK is an optional keyword that has no effect.

COMMIT WORK issued outside of an active transaction generates error 8605.

```
COMMIT [WORK]
```

[[commit_work_considerations]]
=== Considerations for COMMIT WORK

BEGIN WORK starts a transaction. COMMIT WORK or ROLLBACK WORK ends a transaction.

<<<
[[commit_work_examples]]
=== Example of COMMIT WORK

Suppose that your application adds information to the inventory. You have received 24 terminals from
a new supplier and want to add the supplier and update the quantity on hand. The part number for the
terminals is 5100, and the supplier is assigned supplier number 17. The cost of each terminal is $800.

The transaction must add the order for terminals to PARTSUPP, add the supplier to the SUPPLIER table,
and update QTY_ON_HAND in PARTLOC. After the INSERT and UPDATE statements execute successfully,
you commit the transaction, as shown:

[source,sql]
----
-- This statement initiates a transaction.
BEGIN WORK;

--- SQL operation complete.

-- This statement inserts a new entry into PARTSUPP.
INSERT INTO invent.partsupp
VALUES (5100, 17, 800.00, 24);

--- 1 row(s) inserted.

-- This statement inserts a new entry into SUPPLIER.
INSERT INTO invent.supplier
VALUES (17, 'Super Peripherals','751 Sanborn Way',
 'Santa Rosa', 'California', '95405');

--- 1 row(s) inserted.

-- This statement updates the quantity in PARTLOC.
UPDATE invent.partloc
SET qty_on_hand = qty_on_hand + 24
WHERE partnum = 5100 AND loc_code = 'G43';

--- 1 row(s) updated.

-- This statement ends a transaction.
COMMIT WORK;

--- SQL operation complete.
----

<<<
[[control_query_cancel_statement]]
== CONTROL QUERY CANCEL Statement

The CONTROL QUERY CANCEL statement cancels an executing query that you identify with a query ID.
You can execute the CONTROL QUERY CANCEL statement in a client-based tool like TrafCI or through any ODBC or JDBC
application.

CONTROL QUERY CANCEL is a Trafodion SQL extension.

```
CONTROL QUERY CANCEL QID query-id [COMMENT 'comment-text']
```

[[control_query_cancel_syntax]]
=== Syntax Description of CONTROL QUERY CANCEL

* `_query-id_`
+
specifies the query ID of an executing query, which is a unique identifier generated by the SQL compiler.

* `'_comment-text_'`
+
specifies an optional comment to be displayed in the canceled query’s error message.

[[control_query_cancel_considerations]]
=== Considerations for CONTROL QUERY CANCEL

[[control_query_cancel_benefitsl]]
==== Benefits of CONTROL QUERY CANCEL

For many queries, the CONTROL QUERY CANCEL statement allows the termination of the query without stopping the
master executor process (MXOSRVR). This type of cancellation has these benefits over standard ODBC/JDBC cancel
methods:

* An ANSI-defined error message is returned to the client session, and SQLSTATE is set to HY008.
* Important cached objects persist after the query is canceled, including the master executor process and its
compiler, the compiled statements cached in the master, and the compiler’s query cache and its cached metadata
and histograms.
* The client does not need to reestablish its connection, and its prepared statements are preserved.
* When clients share connections using a middle-tier application server, the effects of canceling one client’s
executing query no longer affect other clients sharing the same connection.

[[control_query_cancel_restrictions]]
==== Restrictions on CONTROL QUERY CANCEL

Some executing queries may not respond to a CONTROL QUERY CANCEL statement within a 60-second interval. For those
queries, Trafodion SQL stops their ESP processes if there are any. If this action allows the query to be canceled,
you will see all the benefits listed above.

If the executing query does not terminate within 120 seconds after the CONTROL QUERY CANCEL statement is issued,
Trafodion SQL stops the master executor process, terminating the query and generating a lost connection error.
In this case, you will not see any of the benefits listed above. Instead, you will lose your connection and will
need to reconnect and re-prepare the query. This situation often occurs with the CALL, DDL, and utility statements
and rarely with other statements.

The CONTROL QUERY CANCEL statement does not work with these statements:

* Unique queries, which operate on a single row and a single partition
* Queries that are not executing, such as a query that is being compiled
* CONTROL QUERY DEFAULT, BEGIN WORK, COMMIT WORK, ROLLBACK WORK, and EXPLAIN statements
* Statically compiled metadata queries
* Queries executed in anomalous conditions, such as queries without runtime statistics or without a query ID

[[control_query_cancel_required_privileges]]
==== Required Privileges

To issue a CONTROL QUERY CANCEL statement, one of the following must be true:

* You are DB ROOT.
* You own (that is, issued) the query.
* You have the QUERY_CANCEL component privilege for the SQL_OPERATIONS component.

<<<
[[control_query_cancel_examples]]
=== Example of CONTROL QUERY CANCEL

This CONTROL QUERY CANCEL statement cancels a specified query and provides a comment concerning the cancel
operation:

[source,sql]
----
control query cancel qid
MXID11000010941212288634364991407000000003806U3333300_156016_S1 comment
'Query is consuming too many resources.';
----

In a separate session, the client that issued the query will see this
error message indicating that the query has been canceled:

[source,sql]
----
>>execute s1;

*** ERROR[8007] The operation has been canceled. Query is consuming too many resources.
----

<<<
[[control_query_default_statement]]
== CONTROL QUERY DEFAULT Statement

The CONTROL QUERY DEFAULT statement changes the default settings for the current process. You can execute
the CONTROL QUERY DEFAULT statement in a client-based tool like TrafCI or through any ODBC or JDBC application.

CONTROL QUERY DEFAULT is a Trafodion SQL extension.

```
{ CONTROL QUERY DEFAULT | CQD } control-default-option

control-default-option is:
  attribute {'attr-value' | RESET}
```

[[control_query_default_syntax]]
=== Syntax Description of CONTROL QUERY DEFAULT

* `_attribute_`
+
is a character string that represents an attribute name. For descriptions of these attributes,
see <<Control_Query_Default_Attributes,Control Query Default (CQD) Attributes>>.

* `_attr-value_`
+
is a character string that specifies an attribute value. You must specify _attr-value_ as a quoted string—even
if the value is a number.

* `RESET`

specifies that the attribute that you set by using a CONTROL QUERY DEFAULT statement in the current session is
to be reset to the value or values in effect at the start of the current session.

<<<
[[control_query_default_considerations]]
=== Considerations for CONTROL QUERY DEFAULT

[[control_query_default_scope]]
==== Scope of CONTROL QUERY DEFAULT

The result of the execution of a CONTROL QUERY DEFAULT statement stays in effect until the current process
terminates or until the execution of another statement for the same attribute overrides it.

CQDs are applied at compile time, so CQDs do not affect any statements that are already prepared. For example:

[source,sql]
----
PREPARE x FROM SELECT * FROM t;
CONTROL QUERY DEFAULT SCHEMA 'myschema';
EXECUTE x;                              -- uses the default schema SEABASE
SELECT * FROM t2;                       -- uses MYSCHEMA;
PREPARE y FROM SELECT * FROM t3;
CONTROL QUERY DEFAULT SCHEMA 'seabase';
EXECUTE y;                              -- uses MYSCHEMA;
----

[[control_query_default_examples]]
=== Examples of CONTROL QUERY DEFAULT

* Change the maximum supported length of the column names to 200 for the current process:
+
[source,sql]
----
CONTROL QUERY DEFAULT HBASE_MAX_COLUMN_NAME_LENGTH '200';
----

* Reset the HBASE_MAX_COLUMN_NAME_LENGTH attribute to its initial value in the current process:
+
[source,sql]
----
CONTROL QUERY DEFAULT HBASE_MAX_COLUMN_NAME_LENGTH RESET;
----

<<<
[[create_function_statement]]
== CREATE FUNCTION Statement

* <<create_function_syntax,Syntax Description of CREATE FUNCTION>>
* <<create_function_considerations,Considerations for CREATE FUNCTION>>
* <<create_function_examples,Examples of CREATE FUNCTION>>

The CREATE FUNCTION statement registers a user-defined function (UDF) written in C as a function within
a Trafodion database. Currently, Trafodion supports the creation of _scalar UDFs_, which return a single
value or row when invoked. Scalar UDFs are invoked as SQL expressions in the SELECT list or WHERE clause
of a SELECT statement.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run this
statement inside a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run
this statement, AUTOCOMMIT must be turned ON (the default) for the session.

```
CREATE FUNCTION function-ref ([parameter-declaration[, parameter-declaration]...])
    {RETURN | RETURNS}
       (return-parameter-declaration[, return-parameter-declaration]...)
    EXTERNAL NAME 'character-string-literal'
    LIBRARY [[catalog-name.]schema-name.]library-name
    [LANGUAGE C]
    [PARAMETER STYLE SQL]
    [NO SQL]
    [NOT DETERMINISTIC | DETERMINISTIC]
    [FINAL CALL | NO FINAL CALL]
    [NO STATE AREA | STATE AREA size]
    [NO PARALLELISM | ALLOW ANY PARALLELISM]

function-ref is:
   [[catalog-name.]schema-name.]function-name

parameter-declaration is:
   [IN] [sql-parameter-name] sql-datatype

return-parameter-declaration is:
   [OUT] [sql-parameter-name] sql-datatype
```

<<<
[[create_function_syntax]]
=== Syntax Description of CREATE FUNCTION

* `_function-ref_ ( [_parameter-declaration_[,_parameter-declaration_]&#8230;] )`
+
specifies the name of the function and any SQL parameters that correspond to the signature of the external function.

** `_function-ref_`
+
specifies an ANSI logical name of the form:
+
`[[_catalog-name_.]_schema-name_.]_function-name_`
+
where each part of the name is a valid SQL identifier with a maximum of 128 characters. For more information, see
<<Identifiers,Identifiers>> and <<Database_Object_Names,Database Object Names>>.
+
Specify a name that is unique and does not exist for any procedure or function in the same schema.
+
If you do not fully qualify the function name, Trafodion SQL qualifies it according to the schema of the current session.

** `_parameter-declaration_`
+
specifies an SQL parameter that corresponds to the signature of the external function:
+
`[IN] [_sql-parameter-name_] _sql-datatype_`

*** `IN`
+
specifies that the parameter passes data to the function.

*** `_sql-parameter-name_`
+
specifies an SQL identifier for the parameter. For more information, see <<Identifiers,Identifiers>>.

<<<
*** `_sql-datatype_`
+
specifies an SQL data type that corresponds to the data type of the parameter in the signature of the
external function. _sql-datatype_ is one of the supported SQL data types in Trafodion. See
<<Data_Types,Data Types>>.

* `{RETURN | RETURNS} (_return-parameter-declaration_[,_return-parameter-declaration_]&#8230;)`
+
specifies the type of output of the function.

** `_return-parameter-declaration_`
+
specifies an SQL parameter for an output value:
+
`[OUT] [_sql-parameter-name_] _sql-datatype_`

*** `OUT`
+
specifies that the parameter accepts data from the function.

*** `_sql-parameter-name_`
+
specifies an SQL identifier for the return parameter. For more information, see <<Identifiers,Identifiers>>.
+
*** `_sql-datatype_`
+
specifies an SQL data type for the return parameter. _sql-datatype_ is one of the supported SQL data types in
Trafodion. See <<Data_Types,Data Types>>.

* `EXTERNAL NAME '_method-name_'`
+
specifies the case-sensitive name of the external function’s method.

* `LIBRARY [[_catalog-name_.]_schema-name_.]_library-name_`
+
specifies the ANSI logical name of a library containing the external function. If you do not fully qualify the
library name, Trafodion SQL qualifies it according to the schema of the current session.

* `LANGUAGE C`
+
specifies that the external function is written in the C language. This clause is optional.

* `PARAMETER STYLE SQL`
+
specifies that the run-time conventions for arguments passed to the external function are those of the SQL
language. This clause is optional.

* `NO SQL`
+
specifies that the function does not perform SQL operations. This clause is optional.

* `DETERMINISTIC | NOT DETERMINISTIC`
+
specifies whether the function always returns the same values for OUT parameters for a given set of argument
values (DETERMINISTIC, the default behavior) or does not return the same values (NOT ETERMINISTIC). If the
function is deterministic, Trafodion SQL is not required to execute the function each time to produce results;
instead, Trafodion SQL caches the results and reuses them during subsequent executions, thus optimizing the execution.

* `FINAL CALL | NO FINAL CALL`
+
specifies whether or not a final call is made to the function. A final call enables the function to free up
system resources. The default is FINAL CALL.

* `NO STATE AREA | STATE AREA _size_`
+
specifies whether or not a state area is allocated to the function. _size_ is an integer denoting memory in
bytes. Acceptable values range from 0 to 16000. The default is NO STATE AREA.

* `NO PARALLELISM | ALLOW ANY PARALLELISM`
+
specifies whether or not parallelism is applied when the function is invoked. The default is ALLOW ANY PARALLELISM.

<<<
[[create_function_considerations]]
=== Considerations for CREATE FUNCTION

[[create_function_required_privileges]]
==== Required Privileges

To issue a CREATE FUNCTION statement, one of the following must be true:

* You are DB ROOT.
* You are creating the function in a shared schema, and you have the USAGE (or ALL) privilege on the library that
will be used in the creation of the function. The USAGE privilege provides you with read access to the library’s
underlying library file.
* You are the private schema owner and have the USAGE (or ALL) privilege on the library that will be used in the
creation of the function. The USAGE privilege provides you with read access to the library’s underlying library file.
* You have the CREATE or CREATE_ROUTINE component level privilege for the SQL_OPERATIONS component and have the
USAGE (or ALL) privilege on the library that will be used in the creation of the function. The USAGE
privilege provides you with read access to the library’s underlying library file.
+
NOTE: In this case, if you create a function in a private schema, it will be owned by the schema owner.

<<<
[[create_function_examples]]
=== Examples of CREATE FUNCTION

* This CREATE FUNCTION statement creates a function that adds two integers:
+
[source,sql]
----
create function add2 (int, int)
       returns (total_value int)
       external name 'add2'
       library myudflib;
----

* This CREATE FUNCTION statement creates a function that returns the minimum, maximum, and average values of
five input integers:
+
[source,sql]
----
create function mma5 (int, int, int, int, int)
       returns (min_value int, max_value int, avg_value int)
       external name 'mma5'
       library myudflib;
----

* This CREATE FUNCTION statement creates a function that reverses an input string of at most 32 characters:
+
[source,sql]
----
create function reverse (varchar(32))
       returns (reversed_string varchar(32))
       external name 'reverse'
       library myudflib;
----

<<<
[[create_index_statement]]
== CREATE INDEX Statement

* <<create_index_syntax,Syntax Description of CREATE INDEX>>
* <<create_index_considerations,Considerations for CREATE INDEX>>
* <<create_index_examples ,Examples of CREATE INDEX>>

The CREATE INDEX statement creates an SQL index based on one or more columns of a table or table-like object.
The CREATE VOLATILE INDEX statement creates an SQL index with a lifespan that is limited to the SQL session that
the index is created. Volatile indexes are dropped automatically when the session ends. See <<Indexes,Indexes>>.

CREATE INDEX is a Trafodion SQL extension.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run this statement
inside a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run this statement,
AUTOCOMMIT must be turned ON (the default) for the session.

```
CREATE [VOLATILE] INDEX index ON table
   (column-name [ASC[ENDING] | DESC[ENDING]]
   [,column-name [ASC[ENDING] | DESC[ENDING]]]...)
   [HBASE_OPTIONS (hbase-options-list)]
   [SALT LIKE TABLE]

hbase-options-list is:
   hbase-option = 'value'[, hbase-option = 'value']...
```

[[create_index_syntax]]
=== Syntax Description of CREATE INDEX

* `_index_`
+
is an SQL identifier that specifies the simple name for the new index. You cannot qualify _index_ with its schema
name. Indexes have their own namespace within a schema, so an index name might be the same as a table or constraint
name. However, no two indexes in a schema can have the same name.

* `_table_`
+
is the name of the table for which to create the index. See <<Database_Object_Names,Database Object Names>>.

* `_column-name_ [ASC[ENDING] | DESC[ENDING]] [,_column-name_ [ASC[ENDING] | DESC[ENDING]]]&#8230;`
+
specifies the columns in _table_ to include in the index. The order of the columns in the index need not correspond
to the order of the columns in the table.
+
ASCENDING or DESCENDING specifies the storage and retrieval order for rows in the index. The default is ASCENDING.
+
Rows are ordered by values in the first column specified for the index. If multiple index rows share the same value
for the first column, the values in the second column are used to order the rows, and so forth. If duplicate index
rows occur in a nonunique index, their order is based on the sequence specified for the columns of the key of the
underlying table. For ordering (but not for other purposes), nulls are greater than other values.

* `HBASE_OPTIONS (_hbase-option_ = '_value_'[, _hbase-option_ = '_value_']&#8230;)`
+
a list of HBase options to set for the index. These options are applied independently of any HBase options set for
the index’s table.

// TODO: The Word document did not list all default values. 
** `_hbase-option_ = '_value_'`
+
is one of the these HBase options and its assigned value:
+
[cols="35%,65%",options="header"]
|===
| HBase Option           | Accepted Values^1^
| BLOCKCACHE             | 'true' \| 'false'
| BLOCKSIZE              | *'65536'( \| '_positive-integer_'
| BLOOMFILTER            | 'NONE' \| 'ROW' \| 'ROWCOL'
| CACHE_BLOOMS_ON_WRITE  | 'true' \| 'false'
| CACHE_DATA_ON_WRITE    | 'true' \| 'false'
| CACHE_INDEXES_ON_WRITE | 'true' \| 'false'
| COMPACT                | 'true' \| 'false'
| COMPACT_COMPRESSION    | 'GZ' \| 'LZ4' \| 'LZO' \| 'NONE' \| 'SNAPPY'
| COMPRESSION            | 'GZ' \| 'LZ4' \| 'LZO' \| 'NONE' \| 'SNAPPY'
| DATA_BLOCK_ENCODING    | 'DIFF' \| 'FAST_DIFF' \| 'NONE' \| 'PREFIX'
| DURABILITY             | 'USE_DEFAULT' \| 'SKIP_WAL' \| 'ASYNC_WAL' \| 'SYNC_WAL' \| 'FSYNC_WAL'
| EVICT_BLOCKS_ON_CLOSE  | *'true'* \| 'false'
| IN_MEMORY              | *'true'* \| 'false'
| KEEP_DELETED_CELLS     | *'true'* \| 'false'
| MAX_FILESIZE           | '_positive-integer_'
| MAX_VERSIONS           | '1' \| '_positive-integer_'
| MEMSTORE_FLUSH_SIZE    | '_positive-integer_'
| MIN_VERSIONS           | '0' \| '_positive-integer_'
| PREFIX_LENGTH_KEY      | '_positive-integer_', which should be less than maximum length of the key for the table.
It applies only if the SPLIT_POLICY is `KeyPrefixRegionSplitPolicy`.
| REPLICATION_SCOPE      | '0' \| *'1'*
| SPLIT_POLICY           | 'org.apache.hadoop.hbase.regionserver. +
ConstantSizeRegionSplitPolicy' \| +
'org.apache.hadoop.hbase.regionserver. +
IncreasingToUpperBoundRegionSplitPolicy' \| +
'org.apache.hadoop.hbase.regionserver. +
KeyPrefixRegionSplitPolicy'
| TTL                    | '-1' (forever) \| '_positive-integer_'
|===
+
^1^ Values in boldface are default values.

* `SALT LIKE TABLE`
+
causes the index to use the same salting scheme (that is,
`SALT USING _num_ PARTITIONS [ON (_column_[, _column_]&#8230;)])` as its base table.

<<<
[[create_index_considerations]]
=== Considerations for CREATE INDEX

Indexes are created under a single transaction. When an index is created, the following steps occur:

* Transaction begins (either a user-started transaction or a system-started transaction).
* Rows are written to the metadata.
* Physical labels are created to hold the index (as non audited).
* The base table is locked for read shared access which prevents inserts, updates, and deletes on the base table from occurring.
* The index is loaded by reading the base table for read uncommitted access using side tree inserts.
+
NOTE: A side tree insert is a fast way of loading data that can perform specialized optimizations because the
partitions are not audited and empty.

* After load is complete, the index audit attribute is turned on and it is attached to the base table (to bring the index online).
* The transaction is committed, either by the system or later by the requestor.

If the operation fails after basic semantic checks are performed, the index no longer exists and the entire transaction
is rolled back even if it is a user-started transaction.

[[create_index_authorization_and_availability_requirements]]
==== Authorization and Availability Requirements

An index always has the same security as the table it indexes.

CREATE INDEX locks out INSERT, DELETE, and UPDATE operations on the table being indexed. If other processes have rows in the table locked
when the operation begins, CREATE INDEX waits until its lock request is granted or timeout occurs.

You cannot access an index directly.

<<<
[[create_index_required_priviges]]
==== Required Privileges

To issue a CREATE INDEX statement, one of the following must be true:

* You are DB ROOT.
* You are creating the table in a shared schema.
* You are the private schema owner.
* You are the owner of the table.
* You have the ALTER, ALTER_TABLE, CREATE, or CREATE_INDEX component privilege for the SQL_OPERATIONS component.
+
NOTE: In this case, if you create an index in a private schema, it will be owned by the schema owner.

[[create_index_limits]]
==== Limits on Indexes

For nonunique indexes, the sum of the lengths of the columns in the index plus the sum of the length of
the clustering key of the underlying table cannot exceed 2048 bytes.

No restriction exists on the number of indexes per table.

[[create_index_examples]]
=== Examples of CREATE INDEX

* This example creates an index on two columns of a table:
+
[source,sql]
----
CREATE INDEX xempname
ON persnl.employee (last_name, first_name);
----

<<<
[[create_library_statement]]
== CREATE LIBRARY Statement

* <<create_library_syntax,Syntax Description of CREATE LIBRARY>>
* <<create_library_considerations,Considerations for CREATE LIBRARY>>
* <<create_library_examples,Examples of CREATE LIBRARY>>

The CREATE LIBRARY statement registers a library object in a Trafodion database. A library object
can be an SPJ's JAR file or a UDF's library file.

CREATE LIBRARY is a Trafodion SQL extension.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run
this statement inside a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT
is OFF. To run this statement, AUTOCOMMIT must be turned ON (the default) for the session.

```
CREATE LIBRARY [[catalog-name.]schema-name.]library-name
   FILE 'library-filename'
   [HOST NAME 'host-name']
   [LOCAL FILE 'host-filename']
```

[[create_library_syntax]]
=== Syntax Description of CREATE LIBRARY

* `[[_catalog-name_.]_schema-name_.]_library-name_`
+
specifies the ANSI logical name of the library object, where each part of the name is a valid SQL
identifier with a maximum of 128 characters. Specify a name that is unique and does not exist for
libraries in the same schema. If you do not fully qualify the library name, Trafodion SQ qualifies
it according to the schema of the current session. For more information, see <<Identifiers,Identifiers>>
and <<Database_Object_Names,Database Object Names>>.

<<<
* `FILE '_library-filename_'`
+
specifies the full path of a deployed library file, which either an SPJ's JAR file or a UDF's library file.
+
NOTE: Make sure to upload the library file to the Trafodion cluster and then copy the library file to the
same directory on all the nodes in the cluster before running the CREATE LIBRARY statement. Otherwise, you
will see an error message indicating that the JAR or DLL file was not found.

* `HOST NAME '_host-name_'`
+
specifies the name of the client host machine where the deployed file resides.

* `LOCAL FILE '_host-filename_'`
+
specifies the path on the client host machine where the deployed file is stored.

[[create_library_considerations]]
=== Considerations for CREATE LIBRARY

* A library object cannot refer to a library file referenced by another library object. If the _library-filename_
is in use by another library object, the CREATE LIBRARY command will fail.
* The _library-filename_ must specify an existing file. Otherwise, the CREATE LIBRARY command will fail.
* The CREATE LIBRARY command does not verify that the specified _library-filename_ is a valid executable file.
* HOST NAME and LOCAL FILE are position dependent.

<<<
[[create_library_required_privileges]]
==== Required Privileges

To issue a CREATE LIBRARY statement, one of the following must be true:

* You are DB ROOT.
* You are creating the library in a shared schema and have the MANAGE_LIBRARY privilege.
* You are the private schema owner and have the MANAGE_LIBRARY privilege.
* You have the CREATE or CREATE_LIBRARY component privilege for the SQL_OPERATIONS component and have
the MANAGE_LIBRARY privilege.
+
NOTE: In this case, if you create a library in a private schema, it will be owned by the schema owner.

[[create_library_examples]]
=== Examples of CREATE LIBRARY

* This CREATE LIBRARY statement registers a library named SALESLIB in the SALES schema for a JAR file (SPJs):
+
[source,sql]
----
CREATE LIBRARY sales.saleslib FILE '/opt/home/trafodion/spjjars/Sales.jar';
----

* This CREATE LIBRARY statement registers a library named MYUDFS in the default schema for a library file (UDFs):
+
[source,sql]
----
CREATE LIBRARY myudfs FILE $UDFLIB;
----

<<<
[[create_procedure_statement]]
== CREATE PROCEDURE Statement

* <<create_procedure_syntax,Syntax Description of CREATE PROCEDURE>>
* <<create_procedure_considerations,Considerations for CREATE PROCEDURE>>
* <<create_procedure_examples,Examples of CREATE PROCEDURE>>

The CREATE PROCEDURE statement registers a Java method as a stored procedure in Java (SPJ) within a Trafodion database.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run this statement
inside a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run this statement,
AUTOCOMMIT must be turned ON (the default) for the session.

```
CREATE PROCEDURE procedure-ref([sql-parameter-list])
   EXTERNAL NAME 'java-method-name [java-signature]'
   LIBRARY [[catalog-name.]schema-name.]library-name
   [EXTERNAL SECURITY external-security-type]
   LANGUAGE JAVA
   PARAMETER STYLE JAVA
   [NO SQL | CONTAINS SQL | MODIFIES SQL DATA | READS SQL DATA]
   [DYNAMIC RESULT SETS integer]
   [TRANSACTION REQUIRED | NO TRANSACTION REQUIRED]
   [DETERMINISTIC | NOT DETERMINISTIC]
   [NO ISOLATE | ISOLATE]

procedure-ref is:
   [[catalog-name.]schema-name.]procedure-name

sql-parameter-list is:
   sql-parameter[, sql-parameter]...

sql-parameter is:
   [parameter-mode] [sql-identifier] sql-datatype

parameter-mode is:
   IN
 | OUT
 | INOUT

java-method-name is:
   [package-name.]class-name.method-name

java-signature is:
   ([java-parameter-list])

java-parameter-list is:
   java-datatype[, java-datatype]...

external-security-type is:
   DEFINER
 | INVOKER
```

NOTE: Delimited variables in this syntax diagram are case-sensitive. Case-sensitive variables include _java-method-name_,
_java-signature_, and _class-file-path_, and any delimited part of the _procedure-ref_.
The remaining syntax is not case-sensitive.

<<<
[[create_procedure_syntax]]
=== Syntax Description of CREATE PROCEDURE

* `_procedure-ref_([_sql-parameter_[, _sql-parameter_]&#8230;])`
+
specifies the name of the stored procedure in Java (SPJ) and any SQL parameters that correspond to the signature of
the SPJ methaod.

** `_procedure-ref_`
+
specifies an ANSI logical name of the form:
+
`[[_catalog-name_.]_schema-name_.]_procedure-name_`
+
where each part of the name is a valid SQL identifier with a maximum of 128 characters. For more information,
see <<Identifiers,Identifiers>> and <<Database_Object_Names,Database Object Names>>.
+
Specify a name that is unique and does not exist for any procedure or function in the same schema. Trafodion SQL
does not support the overloading of procedure names. That is, you cannot register the same procedure name more than
once with different underlying SPJ methods.
+
If you do not fully qualify the procedure name, Trafodion SQL qualifies it according to the schema of the current session.

** _sql-parameter_
+
specifies an SQL parameter that corresponds to the signature of the SPJ method:
+
`[_parameter-mode_] [_sql-identifier_] _sql-datatype_`

*** `_parameter-mode_`
+
specifies the mode IN, OUT, or INOUT of a parameter. The default is IN.

**** `IN`
+
specifies a parameter that passes data to an SPJ.

**** `OUT`
+
specifies a parameter that accepts data from an SPJ. The parameter must be an array.

**** `INOUT`
+
specifies a parameter that passes data to and accepts data from an SPJ. The parameter must be an array.

*** `_sql-identifier_`
+
specifies an SQL identifier for the parameter. For more information, see <<Identifiers,Identifiers>>.

*** `_sql-datatype_`
+
specifies an SQL data type that corresponds to the Java parameter of the SPJ method.
+
_sql-datatype_ can be:
+
[cols="60%,40%",options="header"]
|===
| SQL Data Type | Maps to Java Data Type&#8230;
| CHAR[ACTER] +
CHAR[ACTER] VARYING +
VARCHAR +
PIC[TURE] X^1^ +
NCHAR +
NCHAR VARYING +
NATIONAL CHAR[ACTER] +
NATIONAL CHAR[ACTER] VARYING | java.lang.String
| DATE | java.sql.Date
| TIME | java.sql.Time
| TIMESTAMP | java.sql.Timestamp
| DEC[IMAL]^2^ +
PIC[TURE] S9^3^ +
NUMERIC (including NUMERIC with a precision greater than eighteen)^2^ | java.math.BigDecimal
| SMALLINT^2^ | short
| INT[EGER]^2^ | int or java.lang.Integer^4^
| LARGEINT^2^ | long or java.lang.Long^4^
| FLOAT | double or java.lang.Double^4^
| REAL | float or java.lang.Float^4^
| DOUBLE PRECISION | double or java.lang.Double^4^
|===
+
1. The Trafodion database stores PIC X as a CHAR data type.
2. Numeric data types of SQL parameters must be SIGNED, which is the default in the Trafodion database.
3. The Trafodion database stores PIC S9 as a DECIMAL or NUMERIC data type.
4. By default, the SQL data type maps to a Java primitive type. The SQL data type maps to a Java wrapper class
only if you specify the wrapper class in the Java signature of the EXTERNAL NAME clause.
+
For more information, see <<Data_Types,Data Types>>.

* `EXTERNAL NAME '_java-method-name_ [_java-signature_]'`

** `_java-method-name_`
+
specifies the case-sensitive name of the SPJ method of the form:
+
`[_package-name_.]_class-name_._method-name_`
+
The Java method must exist in a Java class file, _class-name_.class, within a library registered in the database.
The Java method must be defined as public and static and have a return type of void.
+
If the class file that contains the SPJ method is part of a package, you must also specify the package name.
If you do not specify the package name, the CREATE PROCEDURE statement fails to register the SPJ.

** `_java-signature_`
+
specifies the signature of the SPJ method and consists of:
+
`([_java-datatype_[, _java-datatype_]&#8230;])`
+
The Java signature is necessary only if you want to specify a Java wrapper class (for example, java.lang.Integer) instead of a Java
primitive data type (for example, int). An SQL data type maps to a Java primitive data type by default.
+
The Java signature is case-sensitive and must be placed within parentheses, such as (java.lang.Integer, java.lang.Integer).
The signature must specify each of the parameter data types in the order they appear in the Java method definition within
the class file. Each Java data type that corresponds to an OUT or INOUT parameter must befollowed by empty square
brackets ([ ]), such as java.lang.Integer[].

<<<
*** `_java-datatype_`
+
specifies a mappable Java data type. For the mapping of the Java data types to SQL data types, see _sql-datatype_.

* `LIBRARY [[_catalog-name_.]_schema-name_.]_library-name_`
+
specifies the ANSI logical name of a library containing the SPJ method. If you do not fully qualify the library name,
Trafodion SQL qualifies it according to the schema of the current session.

* `EXTERNAL SECURITY _external-security-type_`
+
determines the privileges, or rights, that users have when executing (or calling) the SPJ. An SPJ can have one of these
types of external security:

** INVOKER determines that users can execute, or invoke, the stored procedure using the privileges of the user who invokes
the stored procedure. This behavior is referred to as _invoker rights_ and is the default behavior if EXTERNAL SECURITY is
not specified. Invoker rights allow a user who has the execute privilege on the SPJ to call the SPJ using his or her existing
privileges. In this case, the user must be granted privileges to access the underlying database objects on which the SPJ operates.
+
NOTE: Granting a user privileges to the underlying database objects gives the user direct access to those database objects,
which could pose a risk to more sensitive or critical data to which users should not have access. For example, an SPJ
might operate on a subset of the data in an underlying database object, but that database object might contain other
more sensitive or critical data to which users should not have access.

** DEFINER determines that users can execute, or invoke, the stored procedure using the privileges of the user who created
the stored procedure. This behavior is referred to as _definer rights_. The advantage of definer rights is that users are
allowed to manipulate data by invoking the stored procedure without having to be granted privileges to the underlying
database objects. That way, users are restricted from directly accessing or manipulating more sensitive or critical data in
the database. However, be careful about the users to whom you grant execute privilege on an SPJ with definer external security
because those users will be able to execute the SPJ without requiring privileges to the underlying database objects.

<<<
* `LANGUAGE JAVA`
+
specifies that the external user-defined routine is written in the Java language.

* `PARAMETER STYLE JAVA`
+
specifies that the run-time conventions for arguments passed to the external user-defined routine are those of the Java language.

* `NO SQL`
+
specifies that the SPJ cannot perform SQL operations.

* `CONTAINS SQL | MODIFIES SQL DATA | READS SQL DATA`
+
specifies that the SPJ can perform SQL operations. All these options behave the same as CONTAINS SQL, meaning that the SPJ
can read and modify SQL data. Use one of these options to register a method that contains SQL statements. If you do not specify
an SQL access mode, the default is CONTAINS SQL.

* `DYNAMIC RESULT SETS _integer_`
+
specifies the maximum number of result sets that the SPJ can return. This option is applicable only if the method signature
contains a java.sql.ResultSet[] object. If the method contains a result set object, the valid range is 1 to 255 inclusive.
The actual number of result sets returned by the SPJ method can be less than or equal to this number. If you do not specify
this option, the default value is 0 (zero), meaning that the SPJ does not return result sets.

* `TRANSACTION REQUIRED | NO TRANSACTION REQUIRED`
+
determines whether the SPJ must run in a transaction inherited from the calling application (TRANSACTION REQUIRED, the default
option) or whether the SPJ runs without inheriting the calling application’s transaction (NO TRANSACTION REQUIRED). Typically,
you will want the stored procedure to inherit the transaction from the calling application. However, if the SPJ method does
not access the database or if you want the stored procedure to manage its own transactions, you should set the stored
procedure’s transaction attribute to NO TRANSACTION REQUIRED. For more information, see
<<Effects_of_the_Transaction_Attribute_on_SPJs,Effects of the Transaction Attribute on SPJs>>.

<<<
* `DETERMINISTIC | NOT DETERMINISTIC`
+
specifies whether the SPJ always returns the same values for OUT and INOUT parameters for a given set of argument values
(DETERMINISTIC) or does not return the same values (NOT DETERMINISTIC, the default option). If you specify DETERMINISTIC,
Trafodion SQL is not required to call the SPJ each time to produce results; instead, Trafodion SQL caches the results and
reuses them during subsequent calls, thus optimizing the CALL statement.

* `NO ISOLATE | ISOLATE`
+
specifies that the SPJ executes either in the environment of the database server (NO ISOLATE) or in an isolated environment
(ISOLATE, the default option). Trafodion SQL allows both options but always executes the SPJ in the UDR server process (ISOLATE).

[[create_procedure_considerations]]
=== Considerations for CREATE PROCEDURE

[[create_procedure_required_privileges]]
==== Required Privileges

To issue a CREATE PROCEDURE statement, one of the following must be true:

* You are DB ROOT.
* You are creating the procedure in a shared schema, and you have the USAGE (or ALL) privilege on the library that will be
used in the creation of the stored procedure. The USAGE privilege provides you with read access to the library’s underlying
JAR file, which contains the SPJ Java method.
* You are the private schema owner and have the USAGE (or ALL) privilege on the library that will be used in the creation of
the stored procedure. The USAGE privilege provides you with read access to the library’s underlying JAR file, which contains
the SPJ Java method.
* You have the CREATE or CREATE_ROUTINE component level privilege for the SQL_OPERATIONS component and have the USAGE (or ALL)
privilege on the library that will be used in the creation of the stored procedure. The USAGE privilege provides you with read
access to the library’s underlying JAR file, which contains the SPJ Java method.
+
NOTE: In this case, if you create a stored procedure in a private schema, it will be owned by the schema owner.

<<<
[[effects_of_the_transaction_attribute_on_spjs]]
==== Effects of the Transaction Attribute on SPJs

===== Transaction Required

_Using Transaction Control Statements or Methods_

If you specify TRANSACTION REQUIRED (the default option), a CALL statement automatically initiates a transaction if there is
no active transaction. In this case, you should not use transaction control statements (or equivalent JDBC transaction methods)
in the SPJ method. Transaction control statements include COMMIT WORK and ROLLBACK WORK, and the equivalent JDBC transaction
methods are Connection.commit() and Connection.rollback(). If you try to use transaction control statements or methods in an
SPJ method when the stored procedure’s transaction attribute is set to TRANSACTION REQUIRED, the transaction control statements
or methods in the SPJ method are ignored, and the Java virtual machine (JVM) does not report any errors or warnings. When the
stored procedure’s transaction attribute is set to TRANSACTION REQUIRED, you should rely on the transaction control statements
or methods in the application that calls the stored procedure and allow the calling application to manage the transactions.

_Committing or Rolling Back a Transaction_

If you do not use transaction control statements in the calling application, the transaction initiated by the CALL statement
might not automatically commit or roll back changes to the database. When AUTOCOMMIT is ON (the default setting), the database
engine automatically commits or rolls back any changes made to the database at the end of the CALL statement execution. However,
when AUTOCOMMIT is OFF, the current transaction remains active until the end of the client session or until you explicitly commit
or roll back the transaction. To ensure an atomic unit of work when calling an SPJ, use the COMMIT WORK statement in the calling
application to commit the transaction when the CALL statement succeeds, and use the ROLLBACK WORK statement to roll back the
transaction when the CALL statement fails.

<<<
===== No Transaction Required

In some cases, you might not want the SPJ method to inherit the transaction from the calling application. Instead, you might want
the stored procedure to manage its own transactions or to run without a transaction. Not inheriting the calling application’s
transaction is useful in these cases:

* The stored procedure performs several long-running operations, such as multiple DDL or table maintenance operations, on the
database. In this case, you might want to commit those operations periodically from within the SPJ method to avoid locking tables
for a long time.
* The stored procedure performs certain SQL operations that must run without an active transaction. For example, INSERT, UPDATE,
and DELETE statements with the WITH NO ROLLBACK option are rejected when a transaction is already active, as is the case when a
stored procedure inherits a transaction from the calling application. The PURGEDATA utility is also rejected when a transaction
is already active.
* The stored procedure does not access the database. In this case, the stored procedure does not need to inherit the transaction
from the calling application. By setting the stored procedure’s transaction attribute to NO TRANSACTION REQUIRED, you can avoid
the overhead of the calling application’s transaction being propagated to the stored procedure.

In these cases, you should set the stored procedure’s transaction attribute to NO TRANSACTION REQUIRED when creating the stored
procedure.

If you specify NO TRANSACTION REQUIRED and if the SPJ method creates a JDBC default connection, that connection will have autocommit
enabled by default. You can either use the autocommit transactions or disable autocommit (conn.setAutoCommit(false);) and use the
JDBC transaction methods, Connection.commit() and Connection.rollback(), to commit or roll back work where needed.

<<<
[[create_procedure_examples]]
=== Examples of CREATE PROCEDURE

* This CREATE PROCEDURE statement registers an SPJ named LOWERPRICE, which does not accept any arguments:
+
[source,sql]
----
SET SCHEMA SALES;

CREATE PROCEDURE lowerprice()
   EXTERNAL NAME 'Sales.lowerPrice'
   LIBRARY saleslib
   LANGUAGE JAVA
   PARAMETER STYLE JAVA
   MODIFIES SQL DATA;
----
+
Because the procedure name is not qualified by a catalog and schema, Trafodion SQL qualifies it according to the current
session settings, where the catalog is TRAFODION (by default) and the schema is set to SALES. Since the procedure needs
to be able to read and modify SQL data, MODIFIES SQL DATA is specified in the CREATE PROCEDURE statement.
+
To call this SPJ, use this CALL statement:
+
[source,sql]
----
CALL lowerprice();
----
+
The LOWERPRICE procedure lowers the price of items with 50 or fewer orders by 10 percent in the database.

* This CREATE PROCEDURE statement registers an SPJ named TOTALPRICE, which accepts three input parameters and returns a numeric value, the
total price to an INOUT parameter:
+
[source,sql]
----
CREATE PROCEDURE trafodion.sales.totalprice(IN qty NUMERIC (18),
                                            IN rate VARCHAR (10),
                                            INOUT price NUMERIC (18,2))
   EXTERNAL NAME 'Sales.totalPrice'
   LIBRARY sales.saleslib
   LANGUAGE JAVA
   PARAMETER STYLE JAVA
   NO SQL;
----
+
<<<
+
To call this SPJ in TrafCI, use these statements:
+
[source,sql]
----
SET PARAM ?p 10.00;
CALL sales.totalprice(23, 'standard', ?p);

p
--------------------
              253.97

--- SQL operation complete.
----
+
Since the procedure does not read and modify any SQL data, NO SQL is specified in the CREATE PROCEDURE statement.

* This CREATE PROCEDURE statement registers an SPJ named MONTHLYORDERS, which accepts an integer value for the month
and returns the number of orders:
+
[source,sql]
----
CREATE PROCEDURE sales.monthlyorders(IN INT, OUT number INT)
   EXTERNAL NAME 'Sales.numMonthlyOrders (int, java.lang.Integer[])'
   LIBRARY sales.saleslib
   LANGUAGE JAVA
   PARAMETER STYLE JAVA
   READS SQL DATA;
----
+
Because the OUT parameter is supposed to map to the Java wrapper class, java.lang.Integer, you must specify the Java
signature in the EXTERNAL NAME clause. To invoke this SPJ, use this CALL statement:
+
[source,sql]
----
CALL sales.monthlyorders(3, ?);

ORDERNUM
-----------
          4

--- SQL operation complete.
----

<<<
* This CREATE PROCEDURE statement registers an SPJ named ORDERSUMMARY, which accepts a date (formatted as a string) and
returns information about the orders on or after that date.
+
[source,sql]
----
CREATE PROCEDURE sales.ordersummary(IN on_or_after_date VARCHAR (20),
                                    OUT num_orders LARGEINT)
   EXTERNAL NAME 'Sales.orderSummary (int, long[])'
   LIBRARY sales.saleslib
   EXTERNAL SECURITY invoker
   LANGUAGE JAVA
   PARAMETER STYLE JAVA
   READS SQL DATA
   DYNAMIC RESULT SETS 2;
----
+
To invoke this SPJ, use this CALL statement:
+
[source,sql]
----
CALL neo.sales.ordersummary('01-01-2014', ?);
----
+
The ORDERSUMMARY procedure returns this information about the orders on or after the specified date, 01-01-2014:
+
[source,sql]
----
NUM_ORDERS
--------------------
                  13

ORDERNUM NUM_PARTS            AMOUNT               ORDER_DATE LAST_NAME
-------- -------------------- -------------------- ---------- --------------------
  100210                    4             19020.00 2014-04-10 HUGHES
  100250                    4             22625.00 2014-01-23 HUGHES
  101220                    4             45525.00 2014-07-21 SCHNABL
  ... ... ... ... ...

--- 13 row(s) selected.

ORDERNUM PARTNUM UNIT_PRICE QTY_ORDERED PARTDESC
-------- ------- ---------- ----------- ------------------
  100210     244    3500.00           3 PC GOLD, 30 MB
  100210    2001    1100.00           3 GRAPHIC PRINTER,M1
  100210    2403     620.00           6 DAISY PRINTER,T2
  ... ... ... ... ...

--- 70 row(s) selected.

--- SQL operation complete.
----

<<<
[[create_role_statement]]
== CREATE ROLE Statement

* <<create_role_syntax,Syntax Description of CREATE ROLE>>
* <<create_role_considerations,Considerations for CREATE ROLE>>
* <<create_role_examples,Examples of CREATE ROLE>>

The CREATE ROLE statement creates an SQL role. See <<Roles,Roles>>.

```
CREATE ROLE role-name [ WITH ADMIN grantor ]

grantor is:
   database-username
```

[[create_role_syntax]]
=== Syntax Description of CREATE ROLE

* `_role-name_`
+
is an SQL identifier that specifies the new role. _role-name_ is a regular or delimited
case-insensitive identifier.
See <<Case_Insensitive_Delimited_Identifiers,Case-Insensitive Delimited Identifiers>>.
_role-name_ cannot be an existing role name, and it cannot be a registered database username. However,
_role-name_ can be a configured directory-service username.

* `WITH ADMIN _grantor_`
+
specifies a role owner other than the current user. This is an optional clause.

* `_grantor_`

specifies a registered database username to whom you assign the role owner.

[[create_role_considerations]]
=== Considerations for CREATE ROLE

* To create a role, you must either be DB ROOT or have been granted the MANAGE_ROLES component privilege for SQL_OPERATIONS.
* PUBLIC, _SYSTEM, NONE, and database usernames beginning with DB are reserved. You cannot specify a _role-name_ with any such name.

[[create_role_ownership]]
==== Role Ownership

You can give role ownership to a user by specifying the user in the WITH ADMIN _grantor_ clause with the _grantor_ as the user.

The role owner can perform these operations:

* Grant and revoke the role to users.
* Drop the role.

Role ownership is permanent. After you create the role, the ownership of the role cannot be changed or assigned to another user.

[[create_role_examples]]
=== Examples of CREATE ROLE

* To create a role and assign the current user as the role owner:
+
[source,sql]
----
CREATE ROLE clerks;
----

* To create a role and assign another user as the role owner:
+
[source,sql]
----
CREATE ROLE sales WITH ADMIN cmiller;
----

<<<
[[create_schema_statement]]
== CREATE SCHEMA Statement

* <<create_schema_syntax,Syntax Description of CREATE SCHEMA>>
* <<create_schema_considerations,Considerations for CREATE SCHEMA>>
* <<create_schema_examples,Examples of CREATE SCHEMA>>

The CREATE SCHEMA statement creates a schema in the database. See <<Schemas,Schemas>>.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run DDL statements
inside a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run these statements,
AUTOCOMMIT must be turned ON (the default) for the session.

```
CREATE [schema-class] SCHEMA schema-clause

schema-class is:
   [ PRIVATE | SHARED ]

schema-clause is:
   { schema-name [AUTHORIZATION authid] | AUTHORIZATION authid }

```

[[create_schema_syntax]]
=== Syntax Description of CREATE SCHEMA

* `_schema-class_`
+
indicates whether access to the schema is restricted to the authorization ID by default (PRIVATE) or whether
any database user may add objects to the schema (SHARED). The default class is PRIVATE.
+
NOTE: Schemas created in Trafodion Release 0.9 or earlier are SHARED schemas.

* `_schema-name_`
+
is a name for the new schema and is an SQL identifier that specifies a unique name that is not currently a schema name.
This parameter is optional. However, if you do not specify a schema name, you must specify the authorization clause. If
a schema name is not provided, the authorization ID is used for the schema name. If the authorization ID name matches an
existing schema, the CREATE SCHEMA command fails.

* `_authid_`
+
is the name of the database user or role will own and administer the schema. If this clause is not present, the current
user becomes the schema owner.

[[create_schema_considerations]]
=== Considerations for CREATE SCHEMA

[[create_schema_reserved_schema_names]]
==== Reserved Schema Names

Schema names that begin with a leading underscore (_) are reserved for future use.

[[create_schema_authorization_clause]]
==== AUTHORIZATION Clause

The AUTHORIZATION clause is optional. If you omit this clause, the current user becomes the schema owner.

NOTE: An authorization ID is assigned to a schema name even if authorization is not enabled for the Trafodion database.
However, no enforcement occurs unless authorization is enabled.

The schema owner can perform operations on the schema and on objects within the schema. For example:

* Alter DDL of objects
* Drop the schema
* Drop objects
* Manage objects with utility commands such as UPDATE STATISTICS and PURGEDATA

[[create_schema_who_can_create_a_schema]]
==== Who Can Create a Schema

The privilege to create a schema is controlled by the component privilege CREATE_SCHEMA for the SQL_OPERATIONS component.
By default, this privilege is granted to PUBLIC, but it can be revoked by DB ROOT.

<<<
When authorization is initialized, these authorization IDs are granted the CREATE_SCHEMA privilege:

* PUBLIC
* DB ROOT
* DB ROOTROLE

DB ROOT or anyone granted the DB_ROOTROLE role can grant the CREATE_SCHEMA privilege.

[[create_schema_examples]]
=== Examples of CREATE SCHEMA

* This example creates a private schema schema named MYSCHEMA, which will be owned by the current user:
+
[source,sql]
----
CREATE SCHEMA myschema;
----

* This example creates a shared schema and designates CliffG as the schema owner:
+
[source,sql]
----
CREATE SHARED SCHEMA hockey_league AUTHORIZATION "CliffG";
----

* This example creates a private schema and designates the role DBA as the schema owner:
+
[source,sql]
----
CREATE PRIVATE SCHEMA contracts AUTHORIZATION DBA;
----
+
Users with the role DBA granted to them can grant access to objects in the CONTRACTS schema to other users and roles.

* This example creates a schema named JSMITH:
+
[source,sql]
----
CREATE PRIVATE SCHEMA AUTHORIZATION JSmith;
----

<<<
[[create_table_statement]]
== CREATE TABLE Statement

* <<create_table_syntax,Syntax Description of CREATE TABLE>>
* <<create_table_considerations,Considerations for CREATE TABLE>>
* <<create_table_examples,Examples of CREATE TABLE>>

The CREATE TABLE statement creates a Trafodion SQL table, which is a mapping of a relational SQL table to an HBase table.
The CREATE VOLATILE TABLE statement creates a temporary Trafodion SQL table that exists only during an SQL session. The
CREATE TABLE AS statement creates a table based on the data attributes of a SELECT query and populates the table using the
data returned by the SELECT query. See <<Tables,Tables>>.

NOTE: DDL statements are not currently supported in transactions. That
means that you cannot run this statement inside a user-defined
transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run
this statement, AUTOCOMMIT must be turned ON (the default) for the
session.

```
CREATE [VOLATILE] TABLE IF NOT EXISTS table
    { table-spec | like-spec }
    [SALT USING num PARTITIONS [ON (column[, column]...)]]
    [STORE BY {PRIMARY KEY | (key-column-list)}]
    [HBASEOPTIONS (hbase-options-list)]
    [LOAD IF EXISTS | NO LOAD]
    [AS select-query]

table-spec is:
    (table-element [,table-element]...)

table-element is:
    column-definition
  | [CONSTRAINT constraint-name] table-constraint

column-definition is:
    column data-type
    [DEFAULT default | NO DEFAULT]
    [[CONSTRAINT constraint-name] column-constraint]...
```
<<<
```
data-type is:
    CHAR[ACTER] [(length [CHARACTERS])]
          [CHARACTER SET char-set-name]
	  [UPSHIFT] [[NOT]CASESPECIFIC]
  | CHAR[ACTER] VARYING (length [CHARACTERS])
          [CHARACTER SET char-set-name]
          [UPSHIFT] [[NOT]CASESPECIFIC]
  | VARCHAR (length) [CHARACTER SET char-set-name]
          [UPSHIFT] [[NOT]CASESPECIFIC]
  | NCHAR (length) [CHARACTERS] [UPSHIFT] [[NOT]CASESPECIFIC]
  | NCHAR VARYING(length [CHARACTERS]) [UPSHIFT] [[NOT] CASESPECIFIC]
  | NUMERIC [(precision [,scale])] [SIGNED|UNSIGNED]
  | SMALLINT [SIGNED|UNSIGNED]
  | INT[EGER] [SIGNED|UNSIGNED]
  | LARGEINT
  | DEC[IMAL] [(precision [,scale])] [SIGNED|UNSIGNED]
  | FLOAT [(precision)]
  | REAL
  | DOUBLE PRECISION
  | DATE
  | TIME [(time-precision)]
  | TIMESTAMP [(timestamp-precision)]
  | INTERVAL { start-field TO end-field | single-field }

default is:
    literal
  | NULL
  | CURRENTDATE
  | CURRENTTIME
  | CURRENTTIMESTAMP

column-constraint is:
    NOT NULL
  | UNIQUE
  | PRIMARY KEY [ASC[ENDING] | DESC[ENDING]]
  | CHECK (condition)
  | REFERENCES ref-spec

table-constraint is:
    UNIQUE (column-list)
  | PRIMARY KEY (key-column-list)
  | CHECK (condition)
  | FOREIGN KEY (column-list) REFERENCES ref-spec

ref-spec is:
    referenced-table [(column-list)]
```
<<<
```
column-list is:
    column-name [,column-name]...

key-column-list is:
    column-name [ASC[ENDING] | DESC[ENDING]]
    [,column-name [ASC[ENDING] | DESC[ENDING]]]...

like-spec is:
    LIKE source-table [include-option]

hbase-options-list is:
    hbase-option = 'value'[, hbase-option = 'value']...
```

[[create_table_syntax]]
=== Syntax Description of CREATE TABLE

* `VOLATILE`
+
specifies a volatile table, which is a table limited to the session that creates the table. After the session ends, the
table is automatically dropped. See <<create_volatile_table_considerations,Considerations for CREATE VOLATILE TABLE>>.

* `IF NOT EXISTS`
+
creates an HBase table if it does not already exist when the table is created. This option does not apply to volatile tables.

* `_table_`
+
specifies the ANSI logical name of the table. See <<Database_Object_Names,Database Object Names>>. This name must be
unique among names of tables and views within its schema.

* `SALT USING _num_ PARTITIONS [ON (_column_[, _column_]&#8230;)]`
+
pre-splits the table into multiple regions when the table is created. Salting adds a hash value of the row key as a key
prefix, thus avoiding hot spots for sequential keys. The number of partitions that you specify can be a function of the
number of region servers present in the HBase cluster. You can specify a number from 2 to 1024. If you do not specify
columns, the default is to use all primary key columns.

<<<
* `STORE BY { PRIMARY KEY | (_key-column-list_)}`
+
specifies a set of columns on which to base the clustering key. The clustering key determines the order of rows within
the physical file that holds the table. The storage order has an effect on how you can partition the object.

** `PRIMARY KEY`
+
bases the clustering key on the primary key columns.

** `_key-column-list_`
+
bases the clustering key on the columns in the _key-column-list_. The key columns in _key-column-list_ must be specified
as NOT NULL and must be the same as the primary key columns that are defined on the table. If STORE BY is not specified,
then the clustering key is the PRIMARY KEY.

* `HBASE_OPTIONS (_hbase-option_ = '_value_'[, _hbase-option_ = '_value_']&#8230;)`
+
a list of HBase options to set for the table.

** `_hbase-option_ = '_value_'`
+
is one of the these HBase options and its assigned value:
+
[cols="35%,65%",options="header"]
|===
| HBase Option                                | Accepted Values^1^
| BLOCKCACHE                                  | 'true' \| 'false'
| BLOCKSIZE                                   | '65536' \| '_positive-integer_'
| BLOOMFILTER                                 | 'NONE' \| 'ROW' \| 'ROWCOL'
| CACHE_BLOOMS_ON_WRITE                       | 'true' \| 'false'
| CACHE_DATA_ON_WRITE                         | 'true' \| 'false'
| CACHE_INDEXES_ON_WRITE                      | 'true' \| 'false'
| COMPACT                                     | 'true' \| 'false'
| COMPACT_COMPRESSION                         | 'GZ' \| 'LZ4' \| 'LZO' \| 'NONE' \| 'SNAPPY'
| COMPRESSION                                 | 'GZ' \| 'LZ4' \| 'LZO' \| 'NONE' \| 'SNAPPY'
| DATA_BLOCK_ENCODING                         | 'DIFF' \| 'FAST_DIFF' \| 'NONE' \| 'PREFIX'
| DURABILITY                                  | 'USE_DEFAULT' \| 'SKIP_WAL' \| 'ASYNC_WAL' \| 'SYNC_WAL' \| 'FSYNC_WAL'
| EVICT_BLOCKS_ON_CLOSE                       | *'true'* \| 'false'
| IN_MEMORY                                   | *'true'* \| 'false'
| KEEP_DELETED_CELLS                          | *'true'* \| 'false'
| MAX_FILESIZE                                | '_positive-integer_'
| MAX_VERSIONS                                | '1' \| '_positive-integer_'
| MEMSTORE_FLUSH_SIZE                         | '_positive-integer_'
| MIN_VERSIONS                                | '0' \| '_positive-integer_'
| PREFIX_LENGTH_KEY                           | '_positive-integer_', which should be less than maximum length of the
key for the table. It applies only if the SPLIT_POLICY is `KeyPrefixRegionSplitPolicy`.
| REPLICATION_SCOPE                           | '0' \| '1'
| SPLIT_POLICY                                | 'org.apache.hadoop.hbase.regionserver.ConstantSizeRegionSplitPolicy' \|
'org.apache.hadoop.hbase.regionserver.IncreasingToUpperBoundRegionSplitPolicy' \|
'org.apache.hadoop.hbase.regionserver.KeyPrefixRegionSplitPolicy'
| TTL                                         | '-1' (forever) \| '_positive-integer_'
|===

1. Values in boldface are default values.

* `LOAD IF EXISTS`
+
loads data into an existing table. Must be used with AS _select-query_.
See <<create_table_considerations_for_load_if_exists_and_no_load_options_of_create_table_as,
Considerations For LOAD IF EXISTS and NO LOAD options of CREATE TABLE AS>>.

* `NO LOAD`
+
creates a table with the CREATE TABLE AS statement, but does not load data into the table. 
See <<create_table_considerations_for_load_if_exists_and_no_load_options_of_create_table_as,
Considerations for LOAD IF EXISTS and NO LOAD options of CREATE TABLE AS>>.

* `AS _select-query_`
+
specifies a select query which is used to populate the created table. A select query can be any SQL select statement.

<<<
* `_column data-type_`
+
specifies the name and data type for a column in the table. At least one column definition is required in a
CREATE TABLE statement.

** _column_ is an SQL identifier. _column_ must be unique among column names in the table. If the name is a Trafodion
SQL reserved word, you must delimit it by enclosing it in double quotes. Such delimited parts are case-sensitive.
For example: "join".

** _data-type_ is the data type of the values that can be stored in _column_. A default value must be of the same type as
the column, including the character set for a character column. See "Data Types" Data type also includes case specific
information, such as UPSHIFT.

* `[NOT] CASESPECIFIC`
+
specifies that the column contains strings that are not case specific. The default is CASESPECIFIC. Comparison between two
values is done in a case insensitive way only if both are case insensitive. This applies to comparison in a binary predicate,
LIKE predicate, and POSITION/REPLACE string function searches.
See <<create_table_examples,Examples of CREATE TABLE>>.

* `DEFAULT _default_ | NO DEFAULT`
+
specifies a default value for the column or specifies that the column does not have a default value.
See <<DEFAULT_Clause,DEFAULT Clause>>.

* `CONSTRAINT _constraint-name_`
+
specifies a name for the column or table constraint. _constraint-name_ must have the same schema as _table_ and must be
unique among constraint names in its schema. If you omit the schema portions of the name you specify in _constraint-name_,
Trafodion SQL expands the constraint name by using the schema for _table_. See <<Constraint_Names,Constraint Names>> and
<<Database_Object_Names,Database Object Names>>.

* `NOT NULL`
+
is a column constraint that specifies that the column cannot contain nulls. If you omit NOT NULL, nulls are allowed in
the column. If you specify both NOT NULL and NO DEFAULT, each row inserted in the table must include a value for the column.
See <<Null,Null>>.

<<<
* `UNIQUE, or, UNIQUE (_column-list_)`
+
is a column or table constraint, respectively, that specifies that the column or set of columns cannot contain more than
one occurrence of the same value or set of values. If you omit UNIQUE, duplicate values are allowed unless the column is
part of the PRIMARY KEY.

** _column-list_ cannot include more than one occurrence of the same column. In addition, the set of columns that you
specify on a UNIQUE constraint cannot match the set of columns on any other UNIQUE constraint for the table or on the
PRIMARY KEY constraint for the table. All columns defined as unique must be specified as NOT NULL.
+
A UNIQUE constraint is enforced with a unique index. If there is already a unique index on _column-list_, Trafodion SQL
uses that index. If a unique index does not exist, the system creates a unique index.

* `PRIMARY KEY [ASC[ENDING] | DESC[ENDING]], or, PRIMARY KEY (_key-column-list_)`
+
is a column or table constraint, respectively, that specifies a column or set of columns as the primary key for the table.
_key-column-list_ cannot include more than one occurrence of the same column.
+
ASCENDING and DESCENDING specify the direction for entries in one column within the key. The default is ASCENDING.
+
The PRIMARY KEY value in each row of the table must be unique within the table. A PRIMARY KEY defined for a set of columns
implies that the column values are unique and not null. You can specify PRIMARY KEY only once on any CREATE TABLE statement.
+
Trafodion SQL uses the primary key as the clustering key of the table to avoid creating a separate, unique index to implement
the primary key constraint.
+
A PRIMARY KEY constraint is required in Trafodion SQL.

<<<
* `CHECK (_condition_)`
+
is a constraint that specifies a condition that must be satisfied for each row in the table.
See <<Search_Condition,Search Condition>>.
+
You cannot refer to the CURRENT_DATE, CURRENT_TIME, or CURRENT_TIMESTAMP function in a CHECK constraint, and you cannot use
subqueries in a CHECK constraint.

* `REFERENCES _ref-spec_`
+
specifies a REFERENCES column constraint. The maximum combined length of the columns for a REFERENCES constraint is 2048 bytes.
+
_ref-spec_ is:
+
`_referenced-table_ [(_column-list_)]`

** _referenced-table_ is the table referenced by the foreign key in a referential constraint. _referenced-table_ cannot be a view.
_referenced-table_ cannot be the same as _table_. _referenced-table_ corresponds to the foreign key in the _table_.

** _column-list_ specifies the column or set of columns in the _referenced-table_ that corresponds to the foreign key in _table_.
The columns in the column list associated with REFERENCES must be in the same order as the columns in the column list associated
with FOREIGN KEY. If _column-list_ is omitted, the referenced table's PRIMARY KEY columns are the referenced columns.
+
A table can have an unlimited number of referential constraints, and you can specify the same foreign key in more than one
referential constraint, but you must define each referential constraint separately. You cannot create self-referencing foreign
key constraints.

* `FOREIGN KEY (_column-list_) REFERENCES _ref-spec_`
+
is a table constraint that specifies a referential constraint for the table, declaring that a column or set of columns (called
a foreign key) in _table_ can contain only values that match those in a column or set of columns in the table specified in the
REFERENCES clause.
+
The two columns or sets of columns must have the same characteristics (data type, length, scale, precision). Without the FOREIGN
KEY clause, the foreign key in _table_ is the column being defined; with the FOREIGN KEY clause, the foreign key is the column or
set of columns specified in the FOREIGN KEY clause. For information about _ref-spec_, see REFERENCES _ref-spec_.

<<<
* `LIKE _source-table_ [_include-option_]&#8230;`
+
directs Trafodion SQL to create a table like the existing table, _source-table_, omitting constraints (with the exception of the NOT
NULL and PRIMARY KEY constraints) and partitions unless the _include-option_ clauses are specified.

** `_source-table_`
+
is the ANSI logical name for the existing table and must be unique among names of tables and views within its schema.

** `_include-option_`

*** `WITH CONSTRAINTS`
+
directs Trafodion SQL to use constraints from _source-table_. Constraint names for _table_ are randomly generated unique names.
+
When you perform a CREATE TABLE LIKE, whether or not you include the WITH CONSTRAINTS clause, the target table will have all
the NOT NULL column constraints that exist for the source table with different constraint names.

*** `WITH PARTITIONS`
+
directs Trafodion SQL to use partition definitions from _source-table_. Each new table partition resides on the same volume
as its original _source-table_ counterpart. The new table partitions do not inherit partition names from the original table.
Instead, Trafodion SQL generates new names based on the physical file location.
+
If you specify the LIKE clause and the SALT USING _num_ PARITIONS clause, you cannot specify WITH PARTITIONS.

<<<
[[create_table_considerations]]
=== Considerations for CREATE TABLE

The following subsections provide considerations for various CREATE TABLE options:

* <<create_table_authorization_and_availability_requirements,Authorization and Availability Requirements>>
* <<create_volatile_table_considerations,Considerations for CREATE VOLATILE TABLE>>
* <<create_table_considerations_for_create_table_like,Considerations for CREATE TABLE &#8230; LIKE>>
* <<create_table_considerations_for_load_if_exists_and_no_load_options_of_create_table_as,
Considerations for LOAD IF EXISTS and NO LOAD options of CREATE TABLE AS>>
* <<create_table_considerations_for_create_table_as,Considerations for CREATE TABLE AS>>

[[create_table_authorization_and_availability_requirements]]
==== Authorization and Availability Requirements

[[create_table_required_privileges]]
===== Required Privileges

To issue a CREATE TABLE statement, one of the following must be true:

* You are DB ROOT.
* You are creating the table in a shared schema.
* You are the private schema owner.
* You have the CREATE or CREATE_TABLE component privilege for the SQL_OPERATIONS component.

NOTE: In this case, if you create a table in a private schema, it will be owned by the schema owner.

<<<
[[create_table_privileges_needed_to_create_a_referential_integrity_constraint]]
===== Privileges Needed to Create a Referential Integrity Constraint

To create a referential integrity constraint (that is, a constraint on he table that refers to a column in another table),
one of the following must be true:

* You are DB ROOT.
* You are the owner of the referencing and referenced tables.
* You have these privileges on the referencing and referenced table:
** For the referencing table, you have the CREATE or CREATE_TABLE component privilege for the SQL_OPERATIONS component.
** For the referenced table, you have the REFERENCES (or ALL) privilege on the referenced table through your username
or through a granted role.

If the constraint refers to the other table in a query expression, you must also have SELECT privileges on the other table.


[[create_volatile_table_considerations]]
==== Considerations for CREATE VOLATILE TABLE

* Volatile temporary tables are closely linked to the session. Their namespace is unique across multiple concurrent
sessions, and therefore allow multiple sessions to use the same volatile temporary table names simultaneously without
any conflicts.
* Volatile tables support creation of indexes.
* Volatile tables are partitioned by the system. The number of partitions is limited to four partitions by default.
The partitions will be distributed across the cluster. The default value is four partitions regardless of the system
configuration.
* Statistics are not automatically updated for volatile tables. If you need statistics, you must explicitly run
UPDATE STATISTICS.
* Volatile tables can be created and accessed using one-part, two-part, or three-part names. However, you must use the
same name (one part, two part, or three part) for any further DDL or DML statements on the created volatile table.
See <<create_table_examples,Examples of CREATE TABLE>>.
* Trafodion SQL allows users to explicitly specify primary key and STORE BY clauses on columns that contain null values.

<<<
* Trafodion SQL does not require that the first column in a volatile table contain not null values and be the primary key.
Instead, Trafodion SQL attempts to partition the table, if possible, using an appropriate suitable key column as the
primary and partitioning key. For more information,
see <<create_table_how_trafodion_sql_selects_suitable_keys_for_volatile_tables,
How Trafodion SQL Selects Suitable Keys for Volatile Tables>>.

[[create_table_restrictions_for_create_volatile_table]]
===== Restrictions for CREATE VOLATILE TABLE

These items are not supported for volatile tables:

* ALTER statement
* User constraints
* Creating views
* Creating non-volatile indexes on a volatile table or a volatile index on a non-volatile table
* CREATE TABLE LIKE operations

[[create_table_how_trafodion_sql_supports_nullable_keys_for_volatile_tables]]
===== How Trafodion SQL Supports Nullable Keys for Volatile Tables

* Allows nullable keys in primary key, STORE BY, and unique constraints.
* A null value is treated as the highest value for that column.
* A null value as equal to other null values and only one value is allowed for that column.

[[create_table_how_trafodion_sql_selects_suitable_keys_for_volatile_tables]]
===== How Trafodion SQL Selects Suitable Keys for Volatile Tables

Trafodion SQL searches for the first suitable column in the list of columns of the table being created. Once the column
is located, the table is partitioned on it. The searched columns in the table might be explicitly specified (as in a
CREATE TABLE statement) or implicitly created (as in a CREATE TABLE AS SELECT statement).

The suitable key column is selected only if no primary key or STORE BY clause has been specified in the statement. If any
of these clauses have been specified, they are used to select the key columns.

<<<
Trafodion SQL follows these guidelines to search for and select suitable keys:

* A suitable column can be a nullable column.
* Certain data types in Trafodion SQL cannot be used as a partitioning key. Currently, this includes any floating point
columns (REAL, DOUBLE PRECISION, and FLOAT).
* Trafodion SQL searches for a suitable column according to this predefined order:
** Numeric columns are chosen first, followed by fixed CHAR, DATETIME, INTERVAL, and VARCHAR data types.
** Within numeric data types, the order is binary NUMERIC (LARGEINT, INTEGER, SMALLINT), and DECIMAL.
** An unsigned column is given preference over a signed column.
** A non-nullable column is given preference over a nullable column.
** If all data types are the same, the first column is selected.
* If a suitable column is not located, the volatile table becomes a non-partitioned table with a system-defined SYSKEY as its primary key.
* If a suitable column is located, it becomes the partitioning key where the primary key is _suitable_column_, SYSKEY.
This causes the table to be partitioned while preventing the duplicate key and null-to-non-null errors.

The list below shows the order of precedence, from low to high, of data types when Trafodion SQL searches for a suitable
key. A data type appearing later has precedence over previously-appearing data types. Data types that do not appear in
the list below cannot be chosen as a key column.

<<<
Precedence of Data Types (From Low to High): 

* VARCHAR
* INTERVAL
* DATETIME
* CHAR(ACTER)
* DECIMAL (signed, unsigned)
* SMALLINT (signed, unsigned)
* INTEGER (signed,unsigned)
* LARGEINT (signed only)

[[create_table_creating_nullable_constraints_in_a_volatile_table]]
===== Creating Nullable Constraints in a Volatile Table

These examples show the creation of nullable constraints (primary key, STORE BY, and unique) in a volatile table:

[source,sql]
----
create volatile table t (a int, primary key(a));
create volatile table t (a int, store by primary key);
create volatile table t (a int unique);
----

[[create_table_creating_a_volatile_table_with_a_nullable_primary_key]]
===== Creating a Volatile Table With a Nullable Primary Key

This example creates a volatile table with a nullable primary key:

[source,sql]
----
>>create volatile table t (a int, primary key(a));

--- SQL operation complete.
----

<<<
Only one unique null value is allowed:
[source,sql]
----
>>insert into t values (null);

--- 1 row(s) inserted.

>>insert into t values (null);

*** ERROR[8102] The operation is prevented by a unique constraint.

--- 0 row(s) inserted.
----

[[create_table_examples_for_selecting_suitable_keys_for_volatile_tables]]
===== Examples for Selecting Suitable Keys for Volatile Tables

These examples show the order by which Trafodion SQL selects a suitable key based on the precedence rules described in
<<create_table_how_trafodion_sql_selects_suitable_keys_for_volatile_tables,
How Trafodion SQL Selects Suitable Keys for Volatile Tables>>:

* Selects column a as the primary and partitioning key:
+
[source,sql]
----
create volatile table t (a int);
----

* Selects column b because int has a higher precedence than char:
+
[source,sql]
----
create volatile table t (a char(10), b int);
----

* Selects column b because not null has precedence over nullable columns:
+
[source,sql]
----
create volatile table t (a int, b int not null);
----

* Selects column b because int has precedence over decimal:
+
[source,sql]
----
create volatile table t (a decimal(10), b int);
----

* Selects the first column, a, because both columns have the same data type:
+
[source,sql]
----
create volatile table t (a int not null, b int not null);
----

<<<
* Selects column b because char has precedence over date:
+
[source,sql]
----
create volatile table t (a date, b char(10));
----

* Selects column b because the real data type is not part of the columns to be examined:
+
[source,sql]
----
create volatile table t (a real, b date);
----

* Does not select any column as the primary/partitioning key. SYSKEY is used automatically.
+
[source,sql]
----
create volatile table t (a real, b double precision not null);
----
Similar examples would be used for CREATE TABLE AS SELECT queries.

[[create_table_considerations_for_create_table_like]]
==== Considerations for CREATE TABLE &#8230; LIKE

The CREATE TABLE LIKE statement does not create views, owner information, or privileges for the new table based on the
source table. Privileges associated with a new table created by using the LIKE specification are defined as if the new
table is created explicitly by the current user.

[[create_table_like_and_file_attributes]]
===== CREATE TABLE &#8230; LIKE and File Attributes

CREATE TABLE &#8230; LIKE creates a table like another table, with the exception of file attributes. File attributes
include COMPRESSION, and so on. If you do not include the attribute value as part of the CREATE TABLE &#8230; LIKE
command, SQL creates the table with the default value for the attributes and not the value from the source object.
For example, to create a table like another table that specifies compression, you must specify the compression attribute
value as part of the CREATE TABLE&#8230; LIKE statement. In the following example, the original CREATE TABLE statement
creates a table without compression. However, in the CREATE TABLE &#8230; LIKE statement, compression is specified.

[source,sql]
----
-- Original Table create table NPTEST

(FIRST_NAME CHAR(12) CHARACTER SET ISO88591 COLLATE DEFAULT NO DEFAULT NOT NULL
, LAST_NAME CHAR(24) CHARACTER SET ISO88591 COLLATE DEFAULT NO DEFAULT NOT NULL
, ADDRESS CHAR(128) CHARACTER SET ISO88591 COLLATE DEFAULT DEFAULT NULL
, ZIP INT DEFAULT 0
, PHONE CHAR(10) CHARACTER SET ISO88591 COLLATE DEFAULT DEFAULT NULL
, SSN LARGEINT NO DEFAULT NOT NULL
, INFO1 CHAR(128) CHARACTER SET ISO88591 COLLATE DEFAULT DEFAULT NULL
, INFO2 CHAR(128) CHARACTER SET ISO88591 COLLATE DEFAULT DEFAULT NULL
, primary key (SSN,first_name,last_name)
)

max table size 512

-- CREATE TABLE LIKE

create table LSCE002 like NPTEST ATTRIBUTE compression type hardware;
----

[[create_table_considerations_for_create_table_as]]
==== Considerations for CREATE TABLE AS

These considerations apply to CREATE TABLE AS:

* Access to the table built by CREATE TABLE AS will be a full table scan because a primary and clustering key cannot
be easily defined.
* Compile time estimates and runtime information is not generated for CREATE TABLE AS tables.
* You cannot manage CREATE TABLE AS tables using WMS compile time or runtime rules.
* You cannot specify a primary key for a CREATE TABLE AS table without explicitly defining all the columns in the
CREATE TABLE statement.
* You cannot generate an explain plan for a CREATE TABLE AS &#8230;INSERT/SELECT statement. You can, however, use the
EXPLAIN plan for a CREATE TABLE AS &#8230; INSERT/SELECT statement if you use the NO LOAD option.
* You cannot use the ORDER BY clause in a CREATE TABLE AS statement. The compiler transparently orders the selected
rows to improve the efficiency of the insert.

<<<
[[create_table_considerations_for_load_if_exists_and_no_load_options_of_create_table_as]]
===== Considerations for LOAD IF EXISTS and NO LOAD options of CREATE TABLE AS

The LOAD IF EXISTS option in a CREATE TABLE AS statement causes data to be loaded into an existing table. If you do not
specify the LOAD IF EXISTS option and try to load data into an existing table, the CREATE TABLE AS statement fails to
execute. Use the LOAD IF EXISTS option with the AS clause in these scenarios:

* Running CREATE TABLE AS without re-creating the table. The table must be empty. Otherwise, the CREATE TABLE AS statement
returns an error. Delete the data in the table by using a DELETE statement before issuing the CREATE TABLE AS statement.
* Using CREATE TABLE AS to incrementally add data to an existing table. You must start a user-defined transaction before
issuing the CREATE TABLE AS statement. If you try to execute the CREATE TABLE AS statement without starting a user-defined
transaction, an error is returned, stating that data already exists in the table. With a user-defined transaction, newly
added rows are rolled back if an error occurs.

The NO LOAD option in a CREATE TABLE AS statement creates a table with the CREATE TABLE AS statement, but does not load data
into the table. The option is useful if you must create a table to review its structure and to analyze the SELECT part of the
CREATE TABLE AS statement with the EXPLAIN statement. You can also use EXPLAIN to analyze the implicated INSERT/SELECT part of
the CREATE TABLE AS &#8230; NO LOAD statement. For example:

[source,sql]
----
CREATE TABLE ttgt NO LOAD AS (SELECT ...);
----

[[create_table_trafodion_sql_extensions_to_create_table]]
=== Trafodion SQL Extensions to CREATE TABLE

This statement is supported for compliance with ANSI SQL:1999 Entry Level. Trafodion SQL extensions to the CREATE TABLE
statement are ASCENDING, DESCENDING, and PARTITION clauses. CREATE TABLE LIKE is also an extension.

<<<
[[create_table_examples]]
=== Examples of CREATE TABLE

* This example creates a table. The clustering key is the primary key.
+
[source,sql]
----
CREATE TABLE SALES.ODETAIL
( ordernum NUMERIC (6) UNSIGNED NO DEFAULT NOT NULL, partnum NUMERIC (4)
UNSIGNED NO DEFAULT NOT NULL, unit_price NUMERIC (8,2) NO DEFAULT NOT
NULL, qty_ordered NUMERIC (5) UNSIGNED NO DEFAULT NOT NULL,
PRIMARY KEY (ordernum, partnum) );
----

* This example creates a table like the JOB table with the same constraints:
+
[source,sql]
----
CREATE TABLE PERSNL.JOB_CORPORATE LIKE PERSNL.JOB WITH CONSTRAINTS;
----

* This is an example of NOT CASESPECIFIC usage:
+
[source,sql]
----
CREATE TABLE T (a char(10) NOT CASESPECIFIC, b char(10));
INSERT INTO T values ('a', 'A');
----

* A row is not returned in this example. Constant ‘A’ is case sensitive, whereas column ‘a’ is insensitive.
+
[source,sql]
----
SELECT * FROM T WHERE a = 'A';
----

* The row is returned in this example. Both sides are case sensitive.
+
[source,sql]
----
SELECT * FROM T WHERE a = 'A' (not casespecific);
----

* The row is returned in this example. A case sensitive comparison is done because column ‘b’ is case sensitive.
+
[source,sql]
----
SELECT * FROM T WHERE b = 'A';
----

* The row is returned in this example. A case sensitive comparison is done because column ‘b’ is case sensitive.
+
[source,sql]
----
SELECT * FROM T WHERE b = 'A' (not casespecific);
----

[[create_table_examples_create_table_as]]
==== Examples of CREATE TABLE AS

This section shows the column attribute rules used to generate and specify the column names and data types of the table
being created.

* If _column-attributes_ are not specified, the select list items of the select-query are used to generate the column
names and data attributes of the created table. If the select list item is a column, then it is used as the name of the
created column. For example:
+
[source,sql]
----
create table t as select a,b from t1
----
+
Table t has 2 columns named (a,b) and the same data attributes as columns from table t1.

* If the select list item is an expression, it must be renamed with an AS clause. An error is returned if expressions are
not named. For example:
+
[source,sql]
----
create table t as select a+1 as c from t1
----
+
Table t has 1 column named (c) and data attribute of (a+1)
+
[source,sql]
----
create table t as select a+1 from t1
----
+
An error is returned, expression must be renamed.

* If _column-attributes_ are specified and contains _datatype-info_, then they override the attributes of the select items
in the select query. These data attributes must be compatible with the corresponding data attributes of the select list items
in the select-query.
+
[source,sql]
----
create table t(a int) as select b from t1
----
+
Table t has one column named "a" with data type "int".
+
[source,sql]
----
create table t(a char(10)) as select a+1 b from t1;
----
+
An error is returned because the data attribute of column "a", a char, does not match the data attribute of the select list
item "b" a numeric.

* If _column-attributes_ are specified and they only contain _column-name_, then the specified column-name override any name
that was derived from the select query.
+
[source,sql]
----
create table t(c,d) as select a,b from t1
----
+
Table t has 2 columns, c and d, which has the data attributes of columns a and b from table t1.

* If _column-attributes_ are specified, then they must contain attributes corresponding to all select list items in the
_select-query_. An error is returned, if a mismatch exists.
+
[source,sql]
----
create table t(a int) as select b,c from t1
----
+
An error is returned. Two items need to be specified as part of the table-attributes.

* The _column-attributes_ must specify either the _column-name datatype-info_ pair or just the _column-name_ for all
columns. Youcannot specify some columns with just the name and others with name and data type.
+
[source,sql]
----
create table t(a int, b) as select c,d from t1
----
+
An error is returned.

In the following example, table t1 is created. Table t2 is created using the CREATE TABLE AS syntax without table attributes:


[source,sql]
----
CREATE TABLE t1 (c1 int not null primary key, c2 char(50));

CREATE TABLE t2 (c1 int, c2 char (50) UPSHIFT NOT NULL) AS SELECT * FROM t1;
----

<<<
[[create_view_statement]]
== CREATE VIEW Statement

* <<create_view_syntax,Syntax Description of CREATE VIEW>>
* <<create_view_considerations,Considerations for CREATE VIEW>>
* <<create_view_examples,Examples of CREATE VIEW>>

The CREATE VIEW statement creates a Trafodion SQL view. See <<Views,Views>>.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run this statement inside
a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run this statement, AUTOCOMMIT
must be turned ON (the default) for the session.

```
CREATE [OR REPLACE] VIEW view
    [(column-name ] [,column-name ...)]
        AS query-expr [order-by-clause]
    [WITH CHECK OPTION]
```

[[create_view_syntax]]
=== Syntax Description of CREATE VIEW

* `OR REPLACE`
+
creates a view if one does not exist or replaces a view if a view of the same name exists. The view being replaced might
have the same view definition or a different view definition.

* `_view_`
+
specifies the ANSI logical name of the view. See <<Database_Object_Names,Database Object Names>>. This name must be unique
among names of tables and views within its schema.

* `(_column-name_ [,_column-name_ ]&#8230;)`
+
specifies names for the columns of the view. Column names in the list must match one-for-one with columns in the table
specified by _query-expr_.
+
<<<
+
If you omit this clause, columns in the view have the same names as the corresponding columns in _query-expr_. You must
specify this clause if any two columns in the table specified by _query-expr_ have the same name or if any column of that
table does not have a name. For example, this query expression SELECT MAX(salary), AVG(salary) AS average_salary FROM
employee the first column does not have a name.
+
No two columns of the view can have the same name; if a view refers to more than one table and the select list refers to
columns from different tables with the same name, you must specify new names for columns that would otherwise have duplicate
names.

* `AS _query-expr_`
+
specifies the columns for the view and sets the selection criteria that determines the rows that make up the view. For
information about character string literals, see <<Character_String_Literals,Character String Literals>>.
For the syntax and syntax description of _query-expr_, see <<SELECT_Statement,SELECT Statement>>. The CREATE VIEW statement
provides this restriction with regard to the _query-expr_ syntax: [ANY_N_], [FIRST _N_] select list items are not allowed
in a view.

* `_order-by-clause_`
+
specifies the order in which to sort the rows of the final result table. For the syntax and syntax description of the
_order-by-clause_, see <<SELECT_Statement,SELECT Statement>>. The CREATE VIEW statement restricts the _order-by-clause_
with regard to the _access-clause_ and _mode-clause_. The _access-mode_ and _mode-clause_ cannot follow the
_order-by-clause_.

* `WITH CHECK OPTION`
+
specifies that no row can be inserted or updated in the database through the view unless the row satisfies the view
definition—that is, the search condition in the WHERE clause of the query expression must evaluate to true for any
row that is inserted or updated. This option is only allowed for updatable views.
+
If you omit this option, a newly inserted row or an updated row need not satisfy the view definition, which means that
such a row can be inserted or updated in the table but does not appear in the view. This check is performed each time a
row is inserted or updated.
+
WITH CHECK OPTION does not affect the query expression; rows must always satisfy the view definition.

<<<
[[create_view_considerations]]
=== Considerations for CREATE VIEW

* If you specify CREATE OR REPLACE VIEW:
** A new view is created if a view of the same name does not exist.
** If a view of same name exists, the old view definition is dropped, and a view with a new definition is created. No check
will be done to see if the new view is identical to the view it is replacing. The CREATE OR REPLACE VIEW command will
unilaterally drop the old view definition and replace it with the new view definition.
** The privileges granted on the old view will be re-granted on the new view. If the re-grant of privileges fails, the
CREATE OR REPLACE VIEW operation fails.
** When CREATE OR REPLACE VIEW replaces an existing view, any dependent views will be dropped.
* You can specify GROUP BY using ordinals to refer to the relative position within the SELECT list.
For example, GROUP BY 3, 2, 1.
* Dynamic parameters are not allowed.

[[create_view_effect_of_adding_a_column_on_view_definitions]]
==== Effect of Adding a Column on View Definitions

The addition of a column to a table has no effect on any existing view definitions or conditions included in constraint
definitions. Any implicit column references specified by SELECT * in view or constraint definitions are replaced by
explicit column references when the definition clauses are originally evaluated.

[[create_view_authorization_and_availability_requirements]]
==== Authorization and Availability Requirements

To issue a CREATE VIEW statement, you must have SELECT privileges on the objects underlying the view or be the owner of
the objects underlying the view, and one of the following must be true:

* You are DB ROOT.
* You are creating the view in a shared schema.
* You are the private schema owner.
* You have the CREATE or CREATE_VIEW component privilege for the SQL_OPERATIONS component.
+
NOTE: In this case, if you create a view in a private schema, it will be owned by the schema owner.

When you create a view on a single table, the owner of the view is automatically given all privileges WITH GRANT OPTION
on the view. However, when you create a view that spans multiple tables, the owner ofthe view is given only SELECT
privileges WITH GRANT OPTION. If you try to grant privileges to another user on the view other than SELECT, you will
receive a warning that you lack the grant option for that privilege.

[[create_view_updatable_and_non_updatable_views]]
==== Updatable and Non-Updatable Views

Single table views can be updatable. Multi-table views cannot be updatable.

To define an updatable view, a query expression must also meet these requirements:

* It cannot contain a JOIN, UNION, or EXCEPT clause.
* It cannot contain a GROUP BY or HAVING clause.
* It cannot directly contain the keyword DISTINCT.
* The FROM clause must refer to exactly one table or one updatable view.
* It cannot contain a WHERE clause that contains a subquery.
* The select list cannot include expressions or functions or duplicate column names.

[[create_view_order_by_clause_guidelines]]
==== ORDER BY Clause Guidelines

The ORDER BY clause can be specified in the SELECT portion of a CREATE VIEW definition. Any SELECT syntax that is valid
when the SELECT portion is specified on its own is also valid during the view definition. An ORDER BY clause can contain
either the column name from the SELECT list or from _select-list-index_.

When a DML statement is issued against the view, the rules documented in the following sections are used to apply the
ORDER BY clause.

<<<
===== When to Use ORDER BY

An ORDER BY clause is used in a view definition only when the clause is under the root of the Select query that uses that
view. If the ORDER BY clause appears in other intermediate locations or in a subquery, it is ignored.

Consider this CREATE VIEW statement:

[source,sql]
----
create view v as select a from t order by a; select * from v x, v y;
----

Or this INSERT statement:

[source,sql]
----
insert into t1 select * from v;
----

In these two examples, the ORDER BY clause is ignored during DML processing because the first appears as part of a
derived table and the second as a subquery selects, both created after the view expansion.

If the same query is issued using explicit derived tables instead of a view, a syntax error is returned:

[source,sql]
----
select * from (select a from t order by a) x, (select a from t order by a) y;
----

This example returns a syntax error because an ORDER BY clause is not supported in a subquery.

The ORDER BY clause is ignored if it is part of a view and used in places where it is not supported. This is different
than returning an error when the same query was written with explicit ORDER BY clause, as is shown in the preceding examples.

===== ORDER BY in a View Definition With No Override

If the SELECT query reads from the view with no explicit ORDER BY override, the ORDER BY semantics of the view definition
are used.

In this example, the ordering column is the one specified in the CREATE VIEW statement:

[source,sql]
----
create view v as select * from t order by a Select * from v
----

<<<
The SELECT query becomes equivalent to:

[source,sql]
----
select * from t order by a;
----

===== ORDER BY in a View Definition With User Override

If a SELECT query contains an explicit ORDER BY clause, it overrides the ORDER BY clause specified in the view definition.

For example:

[source,sql]
----
create view v as select a,b from t order by a; select * from v order by b;
----

In this example, order by b overrides the order by a specified in the view definition. The SELECT query becomes equivalent to:

[source,sql]
----
select a,b from t order by b;
----

==== Nested View Definitions

In case of nested view definitions, the ORDER BY clause in the topmost view definition overrides the ORDER BY clause of any
nested view definitions.

For example:

[source,sql]
----
create view v1 as select a,b from t1 order by a;
create view v2 as select a,b from v1 order by b;
select * from v2;
----

In this example, the ORDER BY specified in the definition of view v2 overrides the ORDER BY specified in the definition of view v1.

The SELECT query becomes equivalent to:

[source,sql]
----
select a,b from (select a, b from t) x order by b;
----

<<<
[[create_view_examples]]
=== Examples of CREATE VIEW

* This example creates a view on a single table without a view column list:
+
[source,sql]
----
CREATE VIEW SALES.MYVIEW1 AS
   SELECT ordernum, qty_ordered FROM SALES.ODETAIL;
----

* This example replaces the view, MYVIEW1, with a different view definition:
+
[source,sql]
----
CREATE OR REPLACE VIEW SALES.MYVIEW1 AS
   SELECT ordernum, qty_ordered
   FROM SALES.ODETAIL WHERE unit_price > 100;
----

* This example creates a view with a column list:
+
[source,sql]
----
CREATE VIEW SALES.MYVIEW2
   (v_ordernum, t_partnum) AS SELECT v.ordernum, t.partnum
FROM SALES.MYVIEW1 v, SALES.ODETAIL t;
----

* This example creates a view from two tables by using an INNER JOIN:
+
[source,sql]
----
CREATE VIEW MYVIEW4 (v_ordernum, v_partnum) AS
   SELECT od.ordernum, p.partnum
   FROM SALES.ODETAIL OD INNER JOIN SALES.PARTS P
   ON od.partnum = p.partnum;
----

<<<
[[create_view_vertical_partition_example]]
==== Vertical Partition Example

This example creates three logical vertical partitions for a table, vp0, vp1, and vp2 and then creates a view vp to access them.

A view can be used to obtain a composite representation of a set of closely related tables. In the following example
tables vp0, vp1 and vp2 all have a key column a. This key column is known to contain identical rows for all three tables.
The three tables vp0, vp1 and vp2 also contain columns b, c and d respectively. We can create a view vp that combines
these three tables and provides the interface of columns a, b, c and d belonging to a single object.

Trafodion SQL has the ability to eliminate redundant joins in a query. Redundant joins occur when:

* Output of join contains expressions from only one of its two children
* Every row from this child will match one and only one row from the other child

Suppose tables A and B denote generic tables. To check if the rule "every row from this child will match one and only one row
from the other child" is true, Trafodion SQL uses the fact that the join of Table A with table or subquery B preserves all the
rows of A if the join predicate contains an equi-join predicate that references a key of B, and one of the following is true:
The join is a left outer join where B is the inner table. In this example, for the join between vp0 and vp1,vp0 fills the role
of table A and vp1 fills the role of table B. For the join between vp1 and vp2, vp1 fills the role of table A and vp2 fills
the role of table B.

The view vp shown in this example uses left outer joins to combine thethree underlying tables. Therefore, if the select list
in a query that accesses vp does not contain column d from vp2 then the join to tablevp2 in the view vp will not be performed.

[source,sql]
----
create table vp0(a integer not null, b integer, primary key(a));
create table vp1(a integer not null, c integer, primary key(a));
create table vp2(a integer not null, d integer, primary key(a));

create view vp(a,b,c,d) as
   select vp0.a, b, c, d
   from vp0
   left outer join vp1 on vp0.a=vp1.a
   left outer join vp2 on vp0.a=vp2.a;

select a, b from vp; -- reads only vp0
select a, c from vp; -- reads vp0 and vp1
select d from vp; -- reads vp0 and vp2
----

<<<
[[delete_statement]]
== DELETE Statement

* <<delete_syntax,Syntax Description of DELETE>>
* <<delete_considerations,Considerations for DELETE>>
* <<delete_examples,Examples of DELETE>>

The DELETE statement is a DML statement that deletes a row or rows from a table or an updatable view. Deleting rows from
a view deletes the rows from the table on which the view is based. DELETE does not remove a table or view, even if you
delete the last row in the table or view.

Trafodion SQL provides searched DELETE—deletes rows whose selection depends on a search condition.

For the searched DELETE form, if no WHERE clause exists, all rows are deleted from the table or view.

```
Searched DELETE is:

DELETE FROM table

    [WHERE search-condition ]
       [[FOR] access-option ACCESS]

access-option is:
    READ COMMITTED
```

[[delete_syntax]]
=== Syntax Description of DELETE

* `_table_`
+
names the user table or view from which to delete rows. _table_ must be a base table or an updatable view. To refer to a
table or view, use the ANSI logical name. See <<Database_Object_Names,Database Object Names>>.

* `WHERE _search-condition_`
+
specifies a search condition that selects rows to delete. Within the search condition, any columns being compared are
columns in the table or view being deleted from. See <<Search_Condition,Search Condition>>
+
If you do not specify a search condition, all rows in the table or view are deleted.

* `[FOR] _access-option_ ACCESS`
+
specifies the access option required for data used to evaluate the search condition.
See <<Data_Consistency_and_Access_Options,Data Consistency and Access Options>>.

** `READ `COMMITTED
+
specifies that any data used to evaluate the search condition must come from committed  rows.
+
The default access option is the isolation level of the containing transaction.

[[delete_considerations]]
=== Considerations for DELETE

[[delete_authorization_requirements]]
==== Authorization Requirements

DELETE requires authority to read and write to the table or view being deleted from and authority to read tables or views
specified in subqueries used in the search condition.

[[delete_transaction-initiation-and-termination]]
==== Transaction Initiation and Termination

The DELETE statement automatically initiates a transaction if no transaction is active. Otherwise, you can explicitly
initiate a transaction with the BEGIN WORK statement. When a transaction is started, the SQL statements execute within
that transaction until a COMMIT or ROLLBACK is encountered or an error occurs.

[[delete_isolation-levels-of-transactions-and-access-options-of-statements]]
==== Isolation Levels of Transactions and Access Options of Statements

The isolation level of an SQL transaction defines the degree to which the operations on data within that transaction
are affected by operations of concurrent transactions. When you specify access options for the DML statements within
a transaction, you override the isolation level of the containing transaction. Each statement then executes with
its individual access option.

[[delete_examples]]
=== Examples of DELETE

* Remove all rows from the JOB table:
+
[source,sql]
----
DELETE FROM persnl.job;

--- 10 row(s) deleted.
----

* Remove from the table ORDERS any orders placed with sales representative 220 by any customer except customer number 1234:
+
[source,sql]
----
DELETE FROM sales.orders
WHERE salesrep = 220 AND custnum <> 1234;

--- 2 row(s) deleted.
----

* Remove all suppliers not in Texas from the table PARTSUPP:
+
[source,sql]
----
DELETE FROM invent.partsupp WHERE suppnum IN
   (SELECT suppnum FROM samdbcat.invent.supplier WHERE state <> 'TEXAS');

--- 41 row(s) deleted.
----
+
This statement achieves the same result:
+
[source,sql]
---- 
DELETE FROM invent.partsupp WHERE suppnum NOT IN
   SELECT suppnum FROM samdbcat.invent.supplier WHERE state = 'TEXAS');

--- 41 row(s) deleted.
----

* This is an example of a self-referencing DELETE statement, where the table from which rows are deleted is scanned in a subquery:
+
[source,sql]
----
delete from table1 where a in (select a from table1 where b > 200)
----

<<<
[[drop_function_statement]]
== DROP FUNCTION Statement

* <<drop_function_syntax,Syntax Description of DROP FUNCTION>>
* <<drop_function_considerations,Considerations for DROP FUNCTION>>
* <<drop_function_examples,Examples of DROP FUNCTION>>

The DROP FUNCTION statement removes a user-defined function (UDF) from the Trafodion database.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run this statement inside
a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run this statement, AUTOCOMMIT
must be turned ON (the default) for the session.

```
DROP FUNCTION [[catalog-name.]schema-name.]function-name
```

[[drop_function_syntax]]
=== Syntax Description of DROP FUNCTION

* `[[_catalog-name_.]_schema-name_.]_function-name_`
+
specifies the ANSI logical name of the function, where each part of the name is a valid SQL identifier with a maximum of
128 characters. Specify the name of a function that has already been registered in the schema. If you do not fully qualify
the function name, Trafodion SQL qualifies it according to the schema of the current session. For more information,
see <<Identifiers,Identifiers>> and <<Database_Object_Names,Database Object Names>>.

<<<
[[drop_function_considerations]]
=== Considerations for DROP FUNCTION

[[drop_function_required_privileges]]
==== Required Privileges

To issue a DROP FUNCTION statement, one of the following must be true:

* You are DB ROOT.
* You are the owner of the function.
* You have the DROP or DROP_ROUTINE component privilege for SQL_OPERATIONS component.

[[drop_function_examples]]
=== Examples of DROP FUNCTION

* This DROP FUNCTION statement removes the function named ADD2 from the default schema:
+
[source,sql]
----
DROP FUNCTION add2;
----

* This DROP FUNCTION statement removes the function named MMA5 from the default schema:
+
[source,sql]
----
DROP PROCEDURE mma5;
----

* This DROP FUNCTION statement removes the function named REVERSE from the default schema:
+
[source,sql]
----
DROP PROCEDURE reverse;
----

<<<
[[drop_index_statement]]
== DROP INDEX Statement

* <<drop_index_syntax,Syntax Description of DROP INDEX>>
* <<drop_index_considerations,Considerations for DROP INDEX>>
* <<drop_index_examples,Examples of DROP INDEX>>

The DROP INDEX statement drops a Trafodion SQL index. See <<Indexes,Indexes>>.
DROP INDEX is a Trafodion SQL extension.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run this statement inside
a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run this statement, AUTOCOMMIT
must be turned ON (the default) for the session.

```
DROP [VOLATILE] INDEX index
```

[[drop_index_syntax]]
=== Syntax Description of DROP INDEX

* `_index_`
+
is the index to drop.
+
For information, see <<Database_Object_Names,Database Object Names>>.

[[drop_index_considerations]]
=== Considerations for DROP INDEX

[[drop_index_required_privileges]]
==== Required Privileges

To issue a DROP INDEX statement, one of the following must be true:

* You are DB ROOT.
* You are the owner of the index or the table associated with the index.
* You have the DROP or DROP_INDEX component privilege for the SQL_OPERATIONS component.

[[drop_index_examples]]
=== Examples of DROP INDEX

* This example drops an index:
+
[source,sql]
----
DROP INDEX myindex;
----

* This example drops a volatile index:
+
[source,sql]
----
DROP VOLATILE INDEX vindex;
----

<<<
[[drop_library_statement]]
== DROP LIBRARY Statement

* <<drop_library_syntax,Syntax Description of DROP LIBRARY>>
* <<drop_library_considerations,Considerations for DROP LIBRARY>>
* <<drop_library_examples,Examples of DROP LIBRARY>>

The DROP LIBRARY statement removes a library object from the Trafodion database and also removes the library file
referenced by the library object.

DROP LIBRARY is a Trafodion SQL extension.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run this statement
inside a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run this statement,
AUTOCOMMIT must be turned ON (the default) for the session.

```
DROP LIBRARY [[catalog-name.]schema-name.]library-name [RESTRICT | CASCADE]
```

[[drop_library_syntax]]
=== Syntax Description of DROP LIBRARY

* `[[_catalog-name_.]_schema-name_.]_library-name_`
+
specifies the ANSI logical name of the library object, where each part of the name is a valid SQL identifier with a
maximum of 128 characters. Specify the name of a library object that has already been registered in the schema. If
you do not fully qualify the library name, Trafodion SQL qualifies it according to the schema of the current session.
For more information, see <<Identifiers,Identifiers>> and <<Database_Object_Names,Database Object Names>>.

* `[RESTRICT | CASCADE]`
+
If you specify RESTRICT, the DROP LIBRARY operation fails if any stored procedures in Java (SPJs) or user-defined
functions (UDFs) were created based on the specified library.
+
If you specify CASCADE, any such dependent procedures or functions are removed as part of the DROP LIBRARY operation.
+
The default value is RESTRICT.

[[drop_library_considerations]]
=== Considerations for DROP LIBRARY

* RESTRICT requires that all procedures and functions that refer to the library object be dropped before you drop the
library object. CASCADE automatically drops any procedures or functions that are using the library.
* If the library filename referenced by the library object does not exist, Trafodion SQL issues a warning.

[[drop_library_required_privileges]]
==== Required Privileges

To issue a DROP LIBRARY statement, one of the following must be true:

* You are DB ROOT.
* You are the owner of the library.
* You have the DROP or DROP_LIBRARY component privilege for the SQL_OPERATIONS component.

[[drop_library_examples]]
=== Examples of DROP LIBRARY

* This DROP LIBRARY statement removes the library named SALESLIB from the SALES schema, removes the Sales2.jar file
referenced by the library, and drops any stored procedures in Java (SPJs) that were created based on this library:
+
[source,sql]
----
DROP LIBRARY sales.saleslib CASCADE;
----

* This DROP LIBRARY statement removes the library named MYUDFS from the default schema and removes the $TMUDFS library
file referenced by the library:
+
[source,sql]
----
DROP LIBRARY myudfs RESTRICT;
----

RESTRICT prevents the DROP LIBRARY operation from dropping any user-defined functions (UDFs) that were created based on
this library. If any UDFs were created based on this library, the DROP LIBRARY operation fails.

<<<
[[drop_procedure_statement]]
== DROP PROCEDURE Statement

* <<drop_procedure_syntax,Syntax Description of DROP PROCEDURE>>
* <<drop_procedure_considerations,Considerations for DROP PROCEDURE>>
* <<drop_procedure_examples,Examples of DROP PROCEDURE>>

The DROP PROCEDURE statement removes a stored procedure in Java (SPJ) from the Trafodion database.

NOTE: DDL statements are not currently supported in transactions. That means that you cannot run this statement inside
a user-defined transaction (BEGIN WORK&#8230;COMMIT WORK) or when AUTOCOMMIT is OFF. To run this statement, AUTOCOMMIT
must be turned ON (the default) for the session.

```
DROP PROCEDURE [[catalog-name.]schema-name.]procedure-name
```

[[drop_procedure_syntax]]
=== Syntax Description of DROP PROCEDURE

* `[[_catalog-name_.]_schema-name_.]_procedure-name_`
+
specifies the ANSI logical name of the stored procedure in Java (SPJ), where each part of the name is a valid SQL
identifier with a maximum of 128 characters. Specify the name of a procedure that has already been registered in the
schema. If you do not fully qualify the procedure name, Trafodion SQL qualifies it according to the schema of the
current session.
+
For more information, see <<Identifiers,Identifiers>> and <<Database_Object_Names,Database Object Names>>.

[[drop_procedure_considerations]]
=== Considerations for DROP PROCEDURE

[[drop_procedure_required_privileges]]
==== Required Privileges

To issue a DROP PROCEDURE statement, one of the following must be true:

* You are DB ROOT.
* You are the owner of the procedure.
* You have the DROP or DROP_ROUTINE component privilege for SQL_OPERATIONS component.

[[drop_procedure_examples]]
=== Examples of DROP PROCEDURE

* This DROP PROCEDURE statement removes the procedure named LOWERPRICE from the SALES schema:
+
[source,sql]
----
DROP PROCEDURE sales.lowerprice;
----

* This DROP PROCEDURE statement removes the procedure TOTALPRICE from the default schema for the session, which is the SALES schema:
+
[source,sql]
----
SET SCHEMA sales;
DROP PROCEDURE totalprice;
----

<<<

