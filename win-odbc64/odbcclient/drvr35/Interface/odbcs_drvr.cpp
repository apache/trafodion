/**********************************************************************
// @@@ START COPYRIGHT @@@
//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// @@@ END COPYRIGHT @@@
********************************************************************/
/*
 * Translation unit: ODBC
 * Generated by CNPGEN(TANTAU CNPGEN TANTAU_AG_PC8 20001120.103031) on Mon Nov 11 13:33:05 2002
 * Code file for use with the CEE
 * Client functionality included
 */
#include <windows.h>
#include <stdarg.h>
#include <cee.h>
#if CEE_H_VERSION != 19991123
#error Version mismatch CEE_H_VERSION != 19991123
#endif
#include <idltype.h>
#if IDL_TYPE_H_VERSION != 19971225
#error Version mismatch IDL_TYPE_H_VERSION != 19971225
#endif
#include "odbccommon.h"
#include "odbcsrvrcommon.h"
#include "odbc_cl.h"
#include "Transport.h"
#include "TCPIPSystemDrvr.h"
#include "marshalingdrvr_drvr.h"
#include "odbcs_drvr.h"
#include "sqlcli.h"

#include "..\CStmt.h"

/*****************
 * Module 'odbc' *
 *****************/

/***************************
 * Interface 'odbc_SQLSvc' *
 ***************************/

CEE_status 
FormatSQLDescSeq(
		  SQLItemDescList_def *ODBCDesc
		, IDL_char *SQLDesc
		, IDL_long SQLDescLength
		, BYTE *&SQLDataPtr
		, char swap
)
{
	IDL_long msg_total_len = 0;
	SQLItemDesc_def *SQLItemDesc;
	IDL_long data_total_len = 0;

	IDL_long VarAlign;
	IDL_long IndAlign;
	IDL_long Version;
	IDL_long DataType;
	IDL_long DateTimeCode;
	IDL_long Length;
	IDL_long Precision;
	IDL_long Scale;
	IDL_long Nullable;
	IDL_long SignType;
	IDL_long ODBCDataType;
	IDL_long ODBCPrecision;
	IDL_long SQLCharset;
	IDL_long ODBCCharset;
	IDL_long ColHeadingNmlen;
	IDL_long TableNamelen;
	IDL_long CatalogNamelen;
	IDL_long SchemaNamlen;
	IDL_long Headinglen;
	IDL_long IntLeadPrec;
	IDL_long paramMode;

	IDL_long dataBufferLength = 0;
	IDL_long numEntries = 0;

	IDL_char *curptr;
	int i;

	curptr = SQLDesc;

	dataBufferLength = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(dataBufferLength);
	LONG_swap(&dataBufferLength,swap);

	numEntries = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(numEntries);
	LONG_swap(&numEntries,swap);

	if ((SQLDataPtr = new BYTE[sizeof(data_total_len)+sizeof(dataBufferLength)+(numEntries * (sizeof(VarAlign) + sizeof(IndAlign)))]) == NULL)
		return CEE_ALLOCFAIL;
	else
	{
		*(IDL_long *)(SQLDataPtr+data_total_len) = data_total_len;
		data_total_len += sizeof(data_total_len);

		*(IDL_long *)(SQLDataPtr+data_total_len) = dataBufferLength;
		data_total_len += sizeof(dataBufferLength);
	}

	if (numEntries == 0)
	{
		ODBCDesc->_length = 0;
		ODBCDesc->_buffer = 0;
	}
	else
	{
		ODBCDesc->_buffer = new SQLItemDesc_def[numEntries];
		if (ODBCDesc->_buffer == NULL)
			return CEE_ALLOCFAIL;
		ODBCDesc->_length = 0;
	}

	for (i = 0; i < numEntries; i++)
	{
		SQLItemDesc = (SQLItemDesc_def *)ODBCDesc->_buffer + ODBCDesc->_length;

		// copy VarAlign location
		VarAlign = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&VarAlign,swap);
		*(IDL_long *)(SQLDataPtr+data_total_len) = VarAlign;
		msg_total_len += sizeof(VarAlign);
		data_total_len += sizeof(VarAlign);
		
		// copy IndAlign location
		IndAlign = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&IndAlign,swap);
		*(IDL_long *)(SQLDataPtr+data_total_len) = IndAlign;
		msg_total_len += sizeof(IndAlign);
		data_total_len += sizeof(IndAlign);
		
		Version = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&Version,swap);
		SQLItemDesc->version = Version;
		msg_total_len += sizeof(Version);

		DataType = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&DataType,swap);
		SQLItemDesc->dataType = DataType;
		msg_total_len += sizeof(DataType);
		
		DateTimeCode = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&DateTimeCode,swap);
		SQLItemDesc->datetimeCode = DateTimeCode;
		msg_total_len += sizeof(DateTimeCode);
		
		Length = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&Length,swap);
		SQLItemDesc->maxLen = Length;
		msg_total_len += sizeof(Length);
		
		Precision = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&Precision,swap);
		SQLItemDesc->precision = (short)Precision;
		msg_total_len += sizeof(Precision);
		
		Scale = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&Scale,swap);
		SQLItemDesc->scale = (short)Scale;
		msg_total_len += sizeof(Scale);
		
		Nullable = *(IDL_long*)(curptr+msg_total_len);
		if (Nullable)
			SQLItemDesc->nullInfo = true;
		else
			SQLItemDesc->nullInfo = false;
		msg_total_len += sizeof(Nullable);
		
		SignType = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&SignType,swap);
		if (SignType)
			SQLItemDesc->signType = true;
		else
			SQLItemDesc->signType = false;
		msg_total_len += sizeof(SignType);
		
		ODBCDataType = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&ODBCDataType,swap);
		SQLItemDesc->ODBCDataType = ODBCDataType;
		msg_total_len += sizeof(ODBCDataType);
		
		ODBCPrecision = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&ODBCPrecision,swap);
		SQLItemDesc->ODBCPrecision = (IDL_short)ODBCPrecision;
		msg_total_len += sizeof(ODBCPrecision);

		SQLCharset = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&SQLCharset,swap);
		SQLItemDesc->SQLCharset = SQLCharset;
		msg_total_len += sizeof(SQLCharset);

		ODBCCharset = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&ODBCCharset,swap);
		SQLItemDesc->ODBCCharset = ODBCCharset;
		msg_total_len += sizeof(ODBCCharset);

		ColHeadingNmlen	= *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(ColHeadingNmlen);
		LONG_swap(&ColHeadingNmlen,swap);
		if (ColHeadingNmlen > 0)
		{
			memcpy(SQLItemDesc->colHeadingNm, curptr+msg_total_len, ColHeadingNmlen);
			msg_total_len += ColHeadingNmlen;
		}
		else
			SQLItemDesc->colHeadingNm[0] = '\0';

		TableNamelen = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(TableNamelen);
		LONG_swap(&TableNamelen,swap);
		if (TableNamelen > 0)
		{
			memcpy(SQLItemDesc->TableName, curptr+msg_total_len, TableNamelen);
			msg_total_len += TableNamelen;
		}
		else
			SQLItemDesc->TableName[0] = '\0';

		CatalogNamelen	= *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(CatalogNamelen);
		LONG_swap(&CatalogNamelen,swap);
		if (CatalogNamelen > 0)
		{
			memcpy(SQLItemDesc->CatalogName, curptr+msg_total_len, CatalogNamelen);
			msg_total_len += CatalogNamelen;
		}
		else
			SQLItemDesc->CatalogName[0] = '\0';

		SchemaNamlen	= *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(SchemaNamlen);
		LONG_swap(&SchemaNamlen,swap);
		if (SchemaNamlen > 0)
		{
			memcpy(SQLItemDesc->SchemaName, curptr+msg_total_len, SchemaNamlen);
			msg_total_len += SchemaNamlen;
		}
		else
			SQLItemDesc->SchemaName[0] = '\0';

		Headinglen	= *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(Headinglen);
		LONG_swap(&Headinglen,swap);
		if (Headinglen > 0)
		{
			memcpy(SQLItemDesc->Heading, curptr+msg_total_len, Headinglen);
			msg_total_len += Headinglen;
		}
		else
			SQLItemDesc->Heading[0] = '\0';

		IntLeadPrec = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&IntLeadPrec,swap);
		SQLItemDesc->intLeadPrec = IntLeadPrec;
		msg_total_len += sizeof(IntLeadPrec);

		paramMode = *(IDL_long*)(curptr+msg_total_len);
		LONG_swap(&paramMode,swap);
		SQLItemDesc->paramMode = paramMode;
		msg_total_len += sizeof(paramMode);

		ODBCDesc->_length++;
	}

	if (msg_total_len > SQLDescLength)
	{
		return CEE_INTERNALFAIL;
	}

	*(IDL_long *)(SQLDataPtr) = data_total_len;

	return CEE_SUCCESS;

}

//
// unmarshall a SQLItemDescList_def structure
//
extern "C"  CEE_status
copy_SQLItemDescList(SQLItemDescList_def* pname, IDL_char*& curptr, IDL_long& msg_total_len,char swap)
{

//
//  SQLItemDescList_def
//

	IDL_long ColHeadingNmlen = 0;
	IDL_long TableNamelen = 0;
    IDL_long CatalogNamelen = 0;
    IDL_long SchemaNamelen = 0;
    IDL_long Headinglen = 0;

//
//  SQLItemDescList_def -> _length
//

	pname->_length = *(IDL_unsigned_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(pname->_length);
	ULONG_swap(&pname->_length,swap);

	if(pname->_length > 0)
	{
		pname->_buffer = new SQLItemDesc_def[pname->_length];

		if(pname->_buffer == NULL)
			return CEE_ALLOCFAIL;

		SQLItemDesc_def *pSQLItemDesc = pname->_buffer;

		for(IDL_unsigned_long i = 0; i < pname->_length; i++)
		{
//
//  SQLItemDescList_def -> _buffer -> version
//
			pSQLItemDesc->version = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->version);
			LONG_swap(&pSQLItemDesc->version,swap);
//
//  SQLItemDescList_def -> _buffer -> dataType
//
			pSQLItemDesc->dataType = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->dataType);
			LONG_swap(&pSQLItemDesc->dataType,swap);
//
//  SQLItemDescList_def -> _buffer -> datetimeCode
//
			pSQLItemDesc->datetimeCode = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->datetimeCode);
			LONG_swap(&pSQLItemDesc->datetimeCode,swap);
//
//  SQLItemDescList_def -> _buffer -> maxLen
//
			pSQLItemDesc->maxLen = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->maxLen);
			LONG_swap(&pSQLItemDesc->maxLen,swap);
//
//  SQLItemDescList_def -> _buffer -> precision
//
			pSQLItemDesc->precision = *(IDL_short*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->precision);
			SHORT_swap(&pSQLItemDesc->precision,swap);
//
//  SQLItemDescList_def -> _buffer -> scale
//
			pSQLItemDesc->scale = *(IDL_short*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->scale);
			SHORT_swap(&pSQLItemDesc->scale,swap);
//
//  SQLItemDescList_def -> _buffer -> nullInfo
//
			pSQLItemDesc->nullInfo = *(BYTE*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->nullInfo);

//
//  SQLItemDescList_def -> _buffer -> colHeadingNm
//
		    ColHeadingNmlen	= *(IDL_long*)(curptr+msg_total_len);
		    msg_total_len += sizeof(ColHeadingNmlen);
		    LONG_swap(&ColHeadingNmlen,swap);
		    if (ColHeadingNmlen > 0)
			{
			   memcpy(pSQLItemDesc->colHeadingNm, curptr+msg_total_len, ColHeadingNmlen);
			   msg_total_len += ColHeadingNmlen;
			}
		    else
			   pSQLItemDesc->colHeadingNm[0] = '\0';

//
//  SQLItemDescList_def -> _buffer -> signType
//
			pSQLItemDesc->signType = *(BYTE*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->signType);

//
//  SQLItemDescList_def -> _buffer -> ODBCDataType
//
			pSQLItemDesc->ODBCDataType = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->ODBCDataType);
			LONG_swap(&pSQLItemDesc->ODBCDataType,swap);

//
//  SQLItemDescList_def -> _buffer -> ODBCPrecision
//
			pSQLItemDesc->ODBCPrecision = *(IDL_short*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->ODBCPrecision);
			SHORT_swap(&pSQLItemDesc->ODBCPrecision,swap);

//
//  SQLItemDescList_def -> _buffer -> SQLCharset
//
			pSQLItemDesc->SQLCharset = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->SQLCharset);
			LONG_swap(&pSQLItemDesc->SQLCharset,swap);

//
//  SQLItemDescList_def -> _buffer -> ODBCCharset
//
			pSQLItemDesc->ODBCCharset = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->ODBCCharset);
			LONG_swap(&pSQLItemDesc->ODBCCharset,swap);

//
//  SQLItemDescList_def -> _buffer -> TableName
//
 		   TableNamelen = *(IDL_long*)(curptr+msg_total_len);
		   msg_total_len += sizeof(TableNamelen);
		   LONG_swap(&TableNamelen,swap);
		   if (TableNamelen > 0)
		   {
			   memcpy(pSQLItemDesc->TableName, curptr+msg_total_len, TableNamelen);
			   msg_total_len += TableNamelen;
		   }
		   else
			   pSQLItemDesc->TableName[0] = '\0';

//
//  SQLItemDescList_def -> _buffer -> CatalogName
//
 		   CatalogNamelen = *(IDL_long*)(curptr+msg_total_len);
		   msg_total_len += sizeof(CatalogNamelen);
		   LONG_swap(&CatalogNamelen,swap);
		   if (CatalogNamelen > 0)
		   {
			   memcpy(pSQLItemDesc->CatalogName, curptr+msg_total_len, CatalogNamelen);
			   msg_total_len += CatalogNamelen;
		   }
		   else
			   pSQLItemDesc->CatalogName[0] = '\0';

//
//  SQLItemDescList_def -> _buffer -> SchemaName
//
 		   SchemaNamelen = *(IDL_long*)(curptr+msg_total_len);
		   msg_total_len += sizeof(SchemaNamelen);
		   LONG_swap(&SchemaNamelen,swap);
		   if (SchemaNamelen > 0)
		   {
			   memcpy(pSQLItemDesc->SchemaName, curptr+msg_total_len, SchemaNamelen);
			   msg_total_len += SchemaNamelen;
		   }
		   else
			   pSQLItemDesc->SchemaName[0] = '\0';

//
//  SQLItemDescList_def -> _buffer -> HeadingName
//
 		   Headinglen = *(IDL_long*)(curptr+msg_total_len);
		   msg_total_len += sizeof(Headinglen);
		   LONG_swap(&Headinglen,swap);
		   if (Headinglen > 0)
		   {
			   memcpy(pSQLItemDesc->Heading, curptr+msg_total_len, Headinglen);
			   msg_total_len += Headinglen;
		   }
		   else
			   pSQLItemDesc->Heading[0] = '\0';

//
//  SQLItemDescList_def -> _buffer -> intLeadPrec
//
			pSQLItemDesc->intLeadPrec = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->intLeadPrec);
			LONG_swap(&pSQLItemDesc->intLeadPrec,swap);


//
//  SQLItemDescList_def -> _buffer -> paramMode
//
			pSQLItemDesc->paramMode = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(pSQLItemDesc->paramMode);
			LONG_swap(&pSQLItemDesc->paramMode,swap);


			pSQLItemDesc++; // next item

		} // for pname->_length

	} // if pname->_length > 0


	return CEE_SUCCESS;

} // copy_SQLItemDescList()

//
// unmarshall a ERROR_DESC_LIST_def structure
//
extern "C"  CEE_status
copy_ERROR_DESC_LIST(ERROR_DESC_LIST_def* pname, IDL_char*& curptr, IDL_long& msg_total_len, char swap)
{

	IDL_unsigned_long i = 0;
	IDL_long tmpLength;


//
//   ERROR_DESC_LIST_def -> _length
//
	pname->_length = *(IDL_unsigned_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(pname->_length);
	ULONG_swap(&pname->_length,swap);

	if(pname->_length > 0)
	{
		ERROR_DESC_def *ptr = new ERROR_DESC_def[pname->_length];

        if(ptr == NULL)
	       return CEE_ALLOCFAIL;
		else
		   pname->_buffer = ptr;


		for(i = 0; i < pname->_length; i++)
		{
	        ptr->rowId = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(ptr->rowId);
	        LONG_swap(&ptr->rowId,swap);

	        ptr->errorDiagnosticId = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(ptr->errorDiagnosticId);
	        LONG_swap(&ptr->errorDiagnosticId,swap);

	        ptr->sqlcode = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(ptr->sqlcode);
	        LONG_swap(&ptr->sqlcode,swap);

            memcpy(ptr->sqlstate,curptr+msg_total_len,sizeof(ptr->sqlstate));			
	        msg_total_len += sizeof(ptr->sqlstate);

//
//          errorText
//			
	        tmpLength = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(tmpLength);
	        LONG_swap(&tmpLength,swap);

			if(tmpLength > 0)
				ptr->errorText = (IDL_char*)(curptr+msg_total_len);
			else
			    ptr->errorText = NULL;


            msg_total_len += tmpLength;

//
//          operationAbortId
//			
	        ptr->operationAbortId = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(ptr->operationAbortId);
	        LONG_swap(&ptr->operationAbortId,swap);

//
//          errorCodeType
//			
	        ptr->errorCodeType = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(ptr->errorCodeType);
	        LONG_swap(&ptr->errorCodeType,swap);

//
//          Param1
//			
	        tmpLength = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(tmpLength);
	        LONG_swap(&tmpLength,swap);

			if(tmpLength > 0)
				ptr->Param1 = (IDL_char*)(curptr+msg_total_len);
			else
			    ptr->Param1 = NULL;

            msg_total_len += tmpLength;

//
//          Param2
//			
	        tmpLength = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(tmpLength);
	        LONG_swap(&tmpLength,swap);

			if(tmpLength > 0)
				ptr->Param2 = (IDL_char*)(curptr+msg_total_len);
			else
			    ptr->Param2 = NULL;

            msg_total_len += tmpLength;

//
//          Param3
//			
	        tmpLength = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(tmpLength);
	        LONG_swap(&tmpLength,swap);

			if(tmpLength > 0)
				ptr->Param3 = (IDL_char*)(curptr+msg_total_len);
			else
			    ptr->Param3 = NULL;
			

            msg_total_len += tmpLength;
//
//          Param4
//			
	        tmpLength = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(tmpLength);
	        LONG_swap(&tmpLength,swap);

			if(tmpLength > 0)
				ptr->Param4 = (IDL_char*)(curptr+msg_total_len);
			else
			    ptr->Param4 = NULL;

            msg_total_len += tmpLength;

//
//          Param5
//			
	        tmpLength = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(tmpLength);
	        LONG_swap(&tmpLength,swap);

			if(tmpLength > 0)
				ptr->Param5 = (IDL_char*)(curptr+msg_total_len);
			else
			    ptr->Param5 = NULL;

            msg_total_len += tmpLength;

//
//          Param6
//			
	        tmpLength = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(tmpLength);
	        LONG_swap(&tmpLength,swap);

			if(tmpLength > 0)
				ptr->Param6 = (IDL_char*)(curptr+msg_total_len);
			else
			    ptr->Param6 = NULL;


            msg_total_len += tmpLength;

//
//          Param7
//			
	        tmpLength = *(IDL_long*)(curptr+msg_total_len);
	        msg_total_len += sizeof(tmpLength);
	        LONG_swap(&tmpLength,swap);

			if(tmpLength > 0)
				ptr->Param7 = (IDL_char*)(curptr+msg_total_len);
			else
			    ptr->Param7 = NULL;


            msg_total_len += tmpLength;
			
			ptr++; // next item

		} // for pname->_length

	} // if pname->_length > 0 

    return CEE_SUCCESS;

} /* copy_ERROR_DESC_LIST() */


/**********************************************
 * Operation 'odbc_SQLSvc_InitializeDialogue' *
 **********************************************/

extern "C"  CEE_status
odbc_SQLSvc_InitializeDialogue_(
    /* In    */ const CEE_handle_def *ph_
  , /* In    */ CEE_tag_def tag_
  , /* In    */ const USER_DESC_def *userDesc
  , /* In    */ const CONNECTION_CONTEXT_def *inContext
  , /* In    */ DIALOGUE_ID_def dialogueId
  , /* Out   */ odbc_SQLSvc_InitializeDialogue_exc_ *exception_
  , /* Out   */ OUT_CONNECTION_CONTEXT_def *outContext
  )
{
	DWORD dwTimeout;
	bool sts;
	CEE_status retcode;
	IDL_long  wlength, rlength;
	IDL_char *wbuffer, *rbuffer;
	IDL_char *curptr;

	VERSION_def version[4];
	VERSION_def* versionPtr = &version[0];

	IDL_long msg_total_length = 0;
	IDL_long exceptionLength = 0;
	IDL_long computerNameLength = 0;
	IDL_long catalogLength = 0;
	IDL_long schemaLength = 0;

	SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
	CConnect *pConnection = (CConnect *)srvrCallContext->sqlHandle;

	pConnection->m_srvrTCPIPSystem->odbcAPI = SRVR_API_SQLCONNECT;
	pConnection->m_srvrTCPIPSystem->dialogueId = srvrCallContext->dialogueId;
	dwTimeout = srvrCallContext->u.connectParams.loginTimeout;
	pConnection->m_srvrTCPIPSystem->dwTimeout = dwTimeout;

	retcode = odbc_SQLSvc_InitializeDialogue_param_pst_(
		  pConnection->m_srvrTCPIPSystem
		, wbuffer
		, wlength
		, userDesc
		, inContext
		, dialogueId
	);

	if (retcode != CEE_SUCCESS)
		return retcode;

	sts = OpenIO (pConnection->m_srvrTCPIPSystem,srvrCallContext->SQLSvc_ObjRef);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

	sts = DoIO (pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength,pConnection);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

	// process output parameters

	char swap = pConnection->m_srvrTCPIPSystem->swap();
	curptr = rbuffer;

	//
	// copy odbc_SQLSvc_InitializeDialogue_exc_ *exception_
	//

	exception_->exception_nr = *(IDL_long *)(curptr + msg_total_length);
	msg_total_length += sizeof(exception_->exception_nr);
	LONG_swap(&exception_->exception_nr,swap);

	exception_->exception_detail = *(IDL_long *)(curptr + msg_total_length);
	msg_total_length += sizeof(exception_->exception_detail);
	LONG_swap(&exception_->exception_detail,swap);

	switch(exception_->exception_nr)
	{
		case odbc_SQLSvc_InitializeDialogue_ParamError_exn_:
	  	   exceptionLength = *(IDL_long *)(curptr + msg_total_length);
	       msg_total_length += sizeof(exceptionLength);
	       LONG_swap(&exceptionLength,swap);

		   if(exceptionLength > 0)
			   exception_->u.ParamError.ParamDesc = (IDL_char*)(curptr+msg_total_length);
		   msg_total_length += exceptionLength;
		   break;

		case odbc_SQLSvc_InitializeDialogue_InvalidConnection_exn_:
		   break;

		case odbc_SQLSvc_InitializeDialogue_SQLError_exn_:
	      retcode = copy_ERROR_DESC_LIST(&exception_->u.SQLError.errorList, curptr, msg_total_length,swap);
		  if(retcode != CEE_SUCCESS)
			  return retcode;;
		  break;

		case odbc_SQLSvc_InitializeDialogue_SQLInvalidHandle_exn_:
		   break;

		case odbc_SQLSvc_InitializeDialogue_SQLNeedData_exn_:
		   break;

		case odbc_SQLSvc_InitializeDialogue_InvalidUser_exn_:
	      retcode = copy_ERROR_DESC_LIST(&exception_->u.InvalidUser.errorList, curptr, msg_total_length,swap);
		  if(retcode != CEE_SUCCESS)
			  return retcode;;
		  break;

		default:
		   break;
	}
	
	// copy OUT_CONNECTION_CONTEXT_def

	// copy VERSION_LIST_def *versionList
	outContext->versionList._length = *(IDL_unsigned_long *)(curptr + msg_total_length);
	msg_total_length += sizeof(outContext->versionList._length);
	ULONG_swap(&outContext->versionList._length,swap);

	// Get the versionPtr
	outContext->versionList._buffer = (VERSION_def *)new char[outContext->versionList._length*sizeof(VERSION_def)];
	versionPtr = outContext->versionList._buffer; 
	
	for (int i = 0; i < outContext->versionList._length; i++)
	{
		// copy componentId
		versionPtr->componentId = *(IDL_short *)(curptr + msg_total_length);
		msg_total_length += sizeof(versionPtr->componentId);
		SHORT_swap(&versionPtr->componentId,swap);

		// copy majorVersion
		versionPtr->majorVersion = *(IDL_short *)(curptr + msg_total_length);
		msg_total_length += sizeof(versionPtr->majorVersion);
		SHORT_swap(&versionPtr->majorVersion,swap);

		// copy minorVersion
		versionPtr->minorVersion = *(IDL_short *)(curptr + msg_total_length);
		msg_total_length += sizeof(versionPtr->minorVersion);
		SHORT_swap(&versionPtr->minorVersion,swap);

		// copy buildId
		versionPtr->buildId = *(IDL_unsigned_long *)(curptr + msg_total_length);
		msg_total_length += sizeof(versionPtr->buildId);
		ULONG_swap(&versionPtr->buildId,swap);
		
		// Get the next versionlist values
		versionPtr++;
	}

	// copy nodeId
	outContext->nodeId = *(IDL_short *)(curptr + msg_total_length);
	msg_total_length += sizeof(outContext->nodeId);
	SHORT_swap(&outContext->nodeId,swap);

	//copy processId
	outContext->processId = *(IDL_unsigned_long *)(curptr + msg_total_length);
	msg_total_length += sizeof(outContext->processId);
	ULONG_swap(&outContext->processId,swap);
	  
	computerNameLength = *(IDL_long *)(curptr+msg_total_length);
	msg_total_length += sizeof(computerNameLength);
	LONG_swap(&computerNameLength,swap);

	if (computerNameLength != 0)
	{
		memcpy(outContext->computerName, curptr + msg_total_length, computerNameLength);
		msg_total_length += computerNameLength;
	}

	catalogLength = *(IDL_long *)(curptr + msg_total_length);
	msg_total_length += sizeof(catalogLength);
	LONG_swap(&catalogLength,swap);
  
	if (catalogLength != 0)
	{
		memcpy(outContext->catalog, curptr + msg_total_length, catalogLength);
		msg_total_length += catalogLength;
	}

	schemaLength = *(IDL_long *)(curptr + msg_total_length);
	msg_total_length += sizeof(schemaLength);
	LONG_swap(&schemaLength,swap);
  
	if (schemaLength != 0)
	{
		memcpy(outContext->schema, curptr + msg_total_length, schemaLength);
		msg_total_length += schemaLength;
	}

	outContext->outContextOptions1 = *(IDL_unsigned_long *)(curptr + msg_total_length);
	msg_total_length += sizeof(outContext->outContextOptions1);
	ULONG_swap(&outContext->outContextOptions1,swap);
	outContext->outContextOptions2 = *(IDL_unsigned_long *)(curptr + msg_total_length);
	msg_total_length += sizeof(outContext->outContextOptions2);
	ULONG_swap(&outContext->outContextOptions2,swap);

	if (outContext->outContextOptions1 & OUTCONTEXT_OPT1_ROLENAME || outContext->outContextOptions1 & OUTCONTEXT_OPT1_DOWNLOAD_CERTIFICATE)
	{
		outContext->outContextOptionStringLen = *(IDL_unsigned_long *)(curptr + msg_total_length);
		msg_total_length += sizeof(outContext->outContextOptionStringLen);
		ULONG_swap(&outContext->outContextOptionStringLen,swap);

		if (outContext->outContextOptionStringLen != 0)
		{
			outContext->outContextOptionString = new char[outContext->outContextOptionStringLen+1];
			memcpy(outContext->outContextOptionString, curptr+msg_total_length, outContext->outContextOptionStringLen);
			outContext->outContextOptionString[outContext->outContextOptionStringLen] = '\0';
			msg_total_length += outContext->outContextOptionStringLen;
		}
	}
	return CEE_SUCCESS;

} // odbc_SQLSvc_InitializeDialogue_()


/*********************************************
 * Operation 'odbc_SQLSvc_TerminateDialogue' *
 *********************************************/

extern "C"  CEE_status
odbc_SQLSvc_TerminateDialogue_(
    /* In    */ const CEE_handle_def *ph_
  , /* In    */ CEE_tag_def tag_
  , /* In    */ DIALOGUE_ID_def dialogueId
  , /* Out   */ odbc_SQLSvc_TerminateDialogue_exc_ *exception_
  )
{
	IDL_long timerTimeout;
	bool sts;
	CEE_status retcode;
	IDL_long wlength,rlength;
	IDL_char* wbuffer, *rbuffer;
	IDL_char *curptr;

	IDL_long msg_total_length = 0;
	IDL_long exceptionLength = 0;

	SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
	CConnect *pConnection = (CConnect *)srvrCallContext->sqlHandle;

	pConnection->m_srvrTCPIPSystem->odbcAPI = SRVR_API_SQLDISCONNECT;
	pConnection->m_srvrTCPIPSystem->dialogueId = srvrCallContext->dialogueId;
	timerTimeout = srvrCallContext->connectionTimeout;
	pConnection->m_srvrTCPIPSystem->dwTimeout = timerTimeout > 10 ? timerTimeout : 10;

	retcode = odbc_SQLSvc_TerminateDialogue_param_pst_(
		  pConnection->m_srvrTCPIPSystem
		, wbuffer
		, wlength
		, dialogueId
	);
	if (retcode != CEE_SUCCESS)
		return retcode;

	sts = OpenIO (pConnection->m_srvrTCPIPSystem,srvrCallContext->SQLSvc_ObjRef);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

	sts = DoIO (pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength,pConnection);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

	// process output parameters
	char swap = pConnection->m_srvrTCPIPSystem->swap();
	curptr = rbuffer;

	//
	// copy odbc_SQLSvc_TerminateDialogue_exc_ *exception_
	//

	exception_->exception_nr = *(IDL_long *)(curptr + msg_total_length);
	msg_total_length += sizeof(exception_->exception_nr);
	LONG_swap(&exception_->exception_nr,swap);

	exception_->exception_detail = *(IDL_long *)(curptr + msg_total_length);
	msg_total_length += sizeof(exception_->exception_detail);
	LONG_swap(&exception_->exception_detail,swap);

	switch(exception_->exception_nr)
	{
		case odbc_SQLSvc_TerminateDialogue_ParamError_exn_:
	  	   exceptionLength = *(IDL_long *)(curptr + msg_total_length);
	       msg_total_length += sizeof(exceptionLength);
	       LONG_swap(&exceptionLength,swap);

		   if(exceptionLength > 0)
			   exception_->u.ParamError.ParamDesc = (IDL_char*)(curptr+msg_total_length);
		   msg_total_length += exceptionLength;
		   break;

		case odbc_SQLSvc_TerminateDialogue_InvalidConnection_exn_:
		   break;

		case odbc_SQLSvc_TerminateDialogue_SQLError_exn_:
	      retcode = copy_ERROR_DESC_LIST(&exception_->u.SQLError.errorList, curptr, msg_total_length,swap);
		  if(retcode != CEE_SUCCESS)
			  return retcode;;
		  break;

		default:
		   break;
	}


	return CEE_SUCCESS;

} // odbc_SQLSvc_TerminateDialogue_()


/*
 * operation 'odbc_SQLDrvr_SetConnectionOption'
 */
extern "C"  CEE_status
odbc_SQLDrvr_SetConnectionOption_pst_(
    /* In    */ CEE_tag_def tag_
  , /* In    */ DIALOGUE_ID_def dialogueId
  , /* In    */ IDL_short connectionOption
  , /* In    */ IDL_long optionValueNum
  , /* In    */ IDL_string optionValueStr
  , /* Out   */ struct odbc_SQLSvc_SetConnectionOption_exc_ *exception_
  , /* Out   */ ERROR_DESC_LIST_def *sqlWarning
  )
{
	bool sts;
	CEE_status retcode;
	IDL_long   wlength,rlength;
	IDL_char   *wbuffer, *rbuffer;
	IDL_char   *curptr;
	IDL_long   msg_total_len = 0;

	SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
	CConnect *pConnection = (CConnect *)srvrCallContext->sqlHandle;

	pConnection->m_srvrTCPIPSystem->odbcAPI = SRVR_API_SQLSETCONNECTATTR;
	pConnection->m_srvrTCPIPSystem->dialogueId = srvrCallContext->dialogueId;
	pConnection->m_srvrTCPIPSystem->dwTimeout = 0;

	retcode = odbc_SQLDrvr_SetConnectionOption_param_pst_(
		  pConnection->m_srvrTCPIPSystem
		, wbuffer
		, wlength
		, dialogueId
		, connectionOption
		, optionValueNum
		, optionValueStr
	);
	if (retcode != CEE_SUCCESS)
		return retcode;

	sts = OpenIO (pConnection->m_srvrTCPIPSystem,srvrCallContext->SQLSvc_ObjRef);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

	sts = DoIO (pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength,pConnection);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

//
// process output parameters
//
	char swap = pConnection->m_srvrTCPIPSystem->swap();
	msg_total_len = 0;
	curptr = rbuffer;

//
//   exception_
//

	IDL_long ExceptionLength;

//
//   exception_ ->exception_nr
//
	exception_->exception_nr = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(exception_->exception_nr);
	LONG_swap(&exception_->exception_nr,swap);

//
//   exception_ ->exception_detail
//
	exception_->exception_detail = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(exception_->exception_detail);
	LONG_swap(&exception_->exception_detail,swap);

	switch(exception_->exception_nr)
	{
	   case odbc_SQLSvc_SetConnectionOption_ParamError_exn_:

	      ExceptionLength = *(IDL_long*)(curptr+msg_total_len);
	      msg_total_len += sizeof(ExceptionLength);
	      LONG_swap(&ExceptionLength,swap);

		  if(ExceptionLength > 0)
		  {
		     exception_->u.ParamError.ParamDesc = (IDL_char*)(curptr+msg_total_len);
		     msg_total_len += ExceptionLength;
		  }
		  
		  break;

	   case odbc_SQLSvc_SetConnectionOption_SQLError_exn_:
	      retcode = copy_ERROR_DESC_LIST(&exception_->u.SQLError.errorList, curptr, msg_total_len,swap);
		  if(retcode != CEE_SUCCESS)
			  return retcode;
		  break;

  	   case odbc_SQLSvc_SetConnectionOption_InvalidConnection_exn_:
	   case odbc_SQLSvc_SetConnectionOption_SQLInvalidHandle_exn_:
		  break;

	   default:
		  break;
	}

//
//	ERROR_DESC_LIST_def sqlWarning;
//
    ExceptionLength = *(IDL_long*)(curptr+msg_total_len);
	if(ExceptionLength > 0)
	{
	   retcode = copy_ERROR_DESC_LIST(sqlWarning, curptr, msg_total_len,swap);
 	   if(retcode != CEE_SUCCESS)
	      return retcode;
	}	

	return CEE_SUCCESS;

} // odbc_SQLDrvr_SetConnectionOption_pst_()


/*
 * operation 'odbc_SQLDrvr_EndTransaction'
 */
extern "C"  CEE_status
odbc_SQLDrvr_EndTransaction_pst_(
    /* In    */ CEE_tag_def tag_
  , /* In    */ DIALOGUE_ID_def dialogueId
  , /* In    */ IDL_unsigned_short transactionOpt
  , /* Out   */ struct odbc_SQLSvc_EndTransaction_exc_ *exception_
  , /* Out   */ ERROR_DESC_LIST_def *sqlWarning
  )
{
	bool sts;
	CEE_status retcode;
	IDL_long  wlength,  rlength;
	IDL_char *wbuffer, *rbuffer;
	IDL_long msg_total_len;
	IDL_char *curptr;

	SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
	CConnect *pConnection = (CConnect *)srvrCallContext->sqlHandle;

	pConnection->m_srvrTCPIPSystem->odbcAPI = SRVR_API_SQLENDTRAN;
	pConnection->m_srvrTCPIPSystem->dialogueId = srvrCallContext->dialogueId;
	pConnection->m_srvrTCPIPSystem->dwTimeout = 0;

	retcode = odbc_SQLDrvr_EndTransaction_param_pst_(
		  pConnection->m_srvrTCPIPSystem
		, wbuffer
		, wlength
		, dialogueId
		, transactionOpt
	);

	if (retcode != CEE_SUCCESS)
		return retcode;

	sts = OpenIO (pConnection->m_srvrTCPIPSystem,srvrCallContext->SQLSvc_ObjRef);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

	sts = DoIO (pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength,pConnection);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

// process output parameters

	char swap = pConnection->m_srvrTCPIPSystem->swap();
	msg_total_len = 0;
	curptr = rbuffer;

//
//   exception_
//

	IDL_long ExceptionLength;

//
//   exception_ ->exception_nr
//
	exception_->exception_nr = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(exception_->exception_nr);
	LONG_swap(&exception_->exception_nr,swap);

//
//   exception_ ->exception_detail
//
	exception_->exception_detail = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(exception_->exception_detail);
	LONG_swap(&exception_->exception_detail,swap);

	switch(exception_->exception_nr)
	{
	   case odbc_SQLSvc_EndTransaction_ParamError_exn_:

	      ExceptionLength = *(IDL_long*)(curptr+msg_total_len);
	      msg_total_len += sizeof(ExceptionLength);
	      LONG_swap(&ExceptionLength,swap);

		  if(ExceptionLength > 0)
		  {
		     exception_->u.ParamError.ParamDesc = (IDL_char*)(curptr+msg_total_len);
		     msg_total_len += ExceptionLength;
		  }
		  
		  break;

	   case odbc_SQLSvc_EndTransaction_SQLError_exn_:
	      retcode = copy_ERROR_DESC_LIST(&exception_->u.SQLError.errorList, curptr, msg_total_len,swap);
		  if(retcode != CEE_SUCCESS)
			  return retcode;
		  break;

	   case odbc_SQLSvc_EndTransaction_InvalidConnection_exn_:
	   case odbc_SQLSvc_EndTransaction_TransactionError_exn_:
		  break;

	   default:
		  break;
	}

//
//	ERROR_DESC_LIST_def sqlWarning;
//
    ExceptionLength = *(IDL_long*)(curptr+msg_total_len);
	if(ExceptionLength > 0)
	{
	   retcode = copy_ERROR_DESC_LIST(sqlWarning, curptr, msg_total_len,swap);
 	   if(retcode != CEE_SUCCESS)
	      return retcode;
	}	


	return CEE_SUCCESS;

} // odbc_SQLDrvr_EndTransaction_pst_()



/*********************************
 * Operation 'odbc_SQLDrvr_Close' *
 *********************************/

extern "C"  CEE_status
odbc_SQLDrvr_Close_pst_(
    /* In    */ CEE_tag_def tag_
  , /* Out   */ IDL_long *returnCode
  , /* Out   */ IDL_long *rowsAffected
  , /* Out   */ BYTE *&sqlWarningOrError
  )
{
	bool sts;
	CEE_status retcode;
	IDL_long wlength,rlength;
	IDL_char* wbuffer, *rbuffer;
	IDL_char *curptr;
	IDL_long msg_total_len = 0;
	IDL_long sqlWarningOrErrorLength = 0;

	SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
	CStmt *pStatement = (CStmt *)srvrCallContext->sqlHandle;
	CConnect *pConnection = pStatement->getConnectHandle();

	pConnection->m_srvrTCPIPSystem->odbcAPI = SRVR_API_SQLFREESTMT;
	pConnection->m_srvrTCPIPSystem->dialogueId = srvrCallContext->dialogueId;
	pConnection->m_srvrTCPIPSystem->dwTimeout = srvrCallContext->statementTimeout;

	retcode = odbc_SQLDrvr_Close_param_pst_(
		  pConnection->m_srvrTCPIPSystem
		, wbuffer
		, wlength
		, srvrCallContext->dialogueId
		, srvrCallContext->u.closeParams.stmtLabel
		, srvrCallContext->u.closeParams.option
	);

	if (retcode != CEE_SUCCESS)
		return retcode;

	sts = OpenIO (pConnection->m_srvrTCPIPSystem,srvrCallContext->SQLSvc_ObjRef);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

	sts = DoIO (pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength, pConnection,pStatement);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

// process output parameters

	char swap = pConnection->m_srvrTCPIPSystem->swap();
	curptr = rbuffer;

	msg_total_len = 0;
	curptr = rbuffer;
	*returnCode = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(*returnCode);
	LONG_swap(returnCode,swap);

	if (*returnCode != SQL_SUCCESS && *returnCode != SQL_NO_DATA_FOUND)
	{
		sqlWarningOrErrorLength = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(sqlWarningOrErrorLength);
		LONG_swap(&sqlWarningOrErrorLength,swap);
		if (sqlWarningOrErrorLength > 0)
		{

			if ((sqlWarningOrError = new BYTE[sqlWarningOrErrorLength]) == NULL)
				return CEE_ALLOCFAIL;
			else
			{
				memcpy(sqlWarningOrError,curptr+msg_total_len,sqlWarningOrErrorLength); 
				SQL_WARNING_OR_ERROR_swap(sqlWarningOrError,sqlWarningOrErrorLength,swap);
				msg_total_len += sqlWarningOrErrorLength;
			}
		}
	}

	if (*returnCode == SQL_SUCCESS || *returnCode == SQL_SUCCESS_WITH_INFO)
	{
		*rowsAffected = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(*rowsAffected);
		LONG_swap(rowsAffected,swap);
	}

	return CEE_SUCCESS;

} // odbc_SQLDrvr_Close_pst_()


/******************************************
 * Operation 'odbc_SQLSvc_GetSQLCatalogs' *
 ******************************************/

extern "C"  CEE_status
odbc_SQLDrvr_GetSQLCatalogs_pst_(
    /* In    */ CEE_tag_def tag_
  , /* Out   */ IDL_string *catStmtLabel
  , /* Out   */ SQLItemDescList_def *outputItemDescList
  , /* Out   */ struct odbc_SQLSvc_GetSQLCatalogs_exc_ *exception_
  , /* Out   */ ERROR_DESC_LIST_def *sqlWarning
  )
{
	bool sts;

	CEE_status retcode;
	IDL_long  wlength,  rlength;
	IDL_char *wbuffer, *rbuffer;

	IDL_char   *curptr;
	IDL_long   msg_total_len = 0;
	IDL_long catStmtLabelLength = 0;
	IDL_long proxySyntaxStringLen = 0;


	SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
	CStmt *pStatement = (CStmt *)srvrCallContext->sqlHandle;
	CConnect *pConnection = pStatement->getConnectHandle();

	pConnection->m_srvrTCPIPSystem->odbcAPI = SRVR_API_GETCATALOGS;
	pConnection->m_srvrTCPIPSystem->dialogueId = srvrCallContext->dialogueId;
	pConnection->m_srvrTCPIPSystem->dwTimeout = srvrCallContext->statementTimeout;  // queryTimeOut

	retcode = odbc_SQLDrvr_GetSQLCatalogs_param_pst_(
		  pConnection->m_srvrTCPIPSystem
		, wbuffer
		, wlength
		, srvrCallContext->dialogueId
		, srvrCallContext->u.getSQLCatalogsParams.stmtLabel
		, (IDL_long)srvrCallContext->odbcAPI //APIType
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.catalogNm
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.schemaNm
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.tableNm
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.tableTypeList
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.columnNm
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.columnType
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.rowIdScope
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.nullable
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.uniqueness
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.accuracy
		, (IDL_long)srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.sqlType
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.metadataId
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.fkcatalogNm
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.fkschemaNm
		, srvrCallContext->u.getSQLCatalogsParams.catalogAPIParams.fktableNm
	);

	if (retcode != CEE_SUCCESS)
		return retcode;

	sts = OpenIO (pConnection->m_srvrTCPIPSystem,srvrCallContext->SQLSvc_ObjRef);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

	sts = DoIO (pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength, pConnection, pStatement);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

// process output parameters

	char swap = pConnection->m_srvrTCPIPSystem->swap();
	msg_total_len = 0;
	curptr = rbuffer;

//
//   exception_
//

	IDL_long ExceptionLength;

//
//   exception_ ->exception_nr
//
	exception_->exception_nr = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(exception_->exception_nr);
	LONG_swap(&exception_->exception_nr,swap);

//
//   exception_ ->exception_detail
//
	exception_->exception_detail = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(exception_->exception_detail);
	LONG_swap(&exception_->exception_detail,swap);

	switch(exception_->exception_nr)
	{
	   case odbc_SQLSvc_GetSQLCatalogs_ParamError_exn_:

	      ExceptionLength = *(IDL_long*)(curptr+msg_total_len);
	      msg_total_len += sizeof(ExceptionLength);
	      LONG_swap(&ExceptionLength,swap);

		  if(ExceptionLength > 0)
		  {
		     exception_->u.ParamError.ParamDesc = (IDL_char*)(curptr+msg_total_len);
		     msg_total_len += ExceptionLength;
		  }
		  
		  break;

	   case odbc_SQLSvc_GetSQLCatalogs_SQLError_exn_:
	      retcode = copy_ERROR_DESC_LIST(&exception_->u.SQLError.errorList, curptr, msg_total_len,swap);
		  if(retcode != CEE_SUCCESS)
			  return retcode;
		  break;

  	   case odbc_SQLSvc_GetSQLCatalogs_InvalidConnection_exn_:
	   case odbc_SQLSvc_GetSQLCatalogs_SQLInvalidHandle_exn_:
		  break;

	   default:
		  break;
	}

//
//  IDL_char *catStmtLabel
//
	catStmtLabelLength  = *(IDL_long*)(curptr+msg_total_len);
    msg_total_len += sizeof(catStmtLabelLength);
	LONG_swap(&catStmtLabelLength,swap);

	if(catStmtLabelLength > 0)
	{
       *catStmtLabel = (IDL_char*)(curptr+msg_total_len);
	   msg_total_len += catStmtLabelLength;
	}

//
//  SQLItemDescList_def
//	
    retcode = copy_SQLItemDescList(outputItemDescList,curptr,msg_total_len,swap);
    if(retcode != CEE_SUCCESS)
       return retcode;


//
//	ERROR_DESC_LIST_def sqlWarning;
//
    ExceptionLength = *(IDL_long*)(curptr+msg_total_len);
	if(ExceptionLength > 0)
	{
	   retcode = copy_ERROR_DESC_LIST(sqlWarning, curptr, msg_total_len,swap);
 	   if(retcode != CEE_SUCCESS)
	      return retcode;
	}	

	// 
	// SPJ related stuff we can ignore
	// 
	proxySyntaxStringLen = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(proxySyntaxStringLen);
	LONG_swap(&proxySyntaxStringLen,swap);
	msg_total_len += proxySyntaxStringLen;


	return CEE_SUCCESS;

} // odbc_SQLDrvr_GetSQLCatalogs_pst_()


/*
 * entry for the double buffering fetch thread
 */
extern "C"
UINT __stdcall odbc_SQLDrvr_PreFetch_pst_(LPVOID pParam)
{
	CEE_status	sts = 0;
	SQL_DataValue_def outputDataValue;
	outputDataValue._length = 0;
	outputDataValue._buffer = NULL;

	CStmt *pStatement = (CStmt *)pParam;
	CConnect *pConnection = pStatement->getConnectHandle();

	EnterCriticalSection(&pConnection->m_CSTransmision);

	if(pStatement->m_preFetchThread.m_State == PREFETCH_STATE_WRK_CANCELLED)
	{
		LeaveCriticalSection(&pConnection->m_CSTransmision);
		return sts;
	}
	else
		pStatement->m_preFetchThread.m_State = PREFETCH_STATE_WRK_STARTED;

    sts = odbc_SQLDrvr_Fetch_pst_(
		    &pStatement->m_preFetchThread.m_SrvrCallContext,
			 NULL, // setStmtOptions
			&pStatement->m_preFetchThread.returnCode,
			 pStatement->m_preFetchThread.sqlWarningOrError,
			&pStatement->m_preFetchThread.rowsReturned,
			&pStatement->m_preFetchThread.outValuesFormat,
			&outputDataValue);

	pStatement->m_preFetchThread.copyOutBuffer(outputDataValue);
	pStatement->m_preFetchThread.m_State = PREFETCH_STATE_WRK_DONE;

	LeaveCriticalSection(&pConnection->m_CSTransmision);

	return sts;
}


/*
 * operation 'odbc_SQLDrvr_Fetch_'
 */

extern "C"  CEE_status
odbc_SQLDrvr_Fetch_pst_(
    /* In    */ CEE_tag_def tag_
  , /* In    */ IDL_string setStmtOptions
  , /* Out   */ IDL_long *returnCode
  , /* Out   */ BYTE *&sqlWarningOrError
  , /* Out   */ IDL_long *rowsReturned
  , /* Out   */ IDL_long *outValuesFormat
  , /* Out   */ SQL_DataValue_def *outputDataValue
  )
{
	bool sts;
	CEE_status retcode;
	IDL_long wlength,rlength;
	IDL_char *wbuffer = NULL;
	IDL_char *rbuffer = NULL;

	IDL_long    loopRetcode = 0;
	IDL_long    loopRowsAffected = 0;
	IDL_short   loopMoreThanOnce = 0;

	IDL_long    cursorCharset = 1; //SQLCHARSETCODE_ISO88591 - change this when supporting character sets
	IDL_long    stmtCharset   = 1; //SQLCHARSETCODE_ISO88591 - change this when supporting character sets

	IDL_long    sqlWarningOrErrorLength = 0;
	IDL_char   *curptr = NULL;
	IDL_long    msg_total_len = 0;
	IDL_long    outValuesLength = 0;
	IDL_long    AllocLength = 0;
	BYTE       *outValues = NULL;
	BYTE	   *VarPtr = NULL;
	BYTE	   *memPtr = NULL;
	BYTE	   *IndPtr = NULL;

	SQLINTEGER	SQLCharset=0;         
	SQLSMALLINT	SQLDataType=0;
	SQLSMALLINT	SQLDatetimeCode=0;
	SQLINTEGER	SQLMaxLength=0;
	SQLSMALLINT	SQLPrecision=0;
	SQLSMALLINT	SQLUnsigned=0;
	SQLSMALLINT	SQLNullable=0;

	IDL_long		ccount = 0;
	IDL_long		rcount = 0;

	IDL_long		memOffSet = 0;
	IDL_long 		IndOffSet = 0;
	IDL_long 		VarOffSet = 0;
	IDL_long		VarBufferLength=0;
	IDL_long		ColumnLength = 0;
	IDL_unsigned_short  SQLVarCharWithLen=0; 


	SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
	CStmt *pStatement = (CStmt *)srvrCallContext->sqlHandle;
	CConnect *pConnection = pStatement->getConnectHandle();

    pConnection->m_srvrTCPIPSystem->odbcAPI = SRVR_API_SQLFETCH;
	pConnection->m_srvrTCPIPSystem->dialogueId = srvrCallContext->dialogueId;
	pConnection->m_srvrTCPIPSystem->dwTimeout = srvrCallContext->u.fetchParams.queryTimeout;

	retcode = odbc_SQLDrvr_Fetch_param_pst_(
			  pConnection->m_srvrTCPIPSystem
			, wbuffer
			, wlength
			, srvrCallContext->dialogueId
			, srvrCallContext->u.fetchParams.maxRowCount
			, srvrCallContext->u.fetchParams.maxRowLen
			, srvrCallContext->u.fetchParams.asyncEnable
			, srvrCallContext->u.fetchParams.queryTimeout
			, pStatement->getStmtHandle()
			, srvrCallContext->u.fetchParams.stmtLabel
			, stmtCharset
			, NULL // cursor name, unused for now
			, cursorCharset
			, setStmtOptions
		);

	if (retcode != CEE_SUCCESS)
		return retcode;

	sts = OpenIO (pConnection->m_srvrTCPIPSystem,srvrCallContext->SQLSvc_ObjRef);

	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

	sts = DoIO (pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength, pConnection, pStatement);

	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

// Process FETCH output parameters

// The Fetch response has the following format:

// IDL_long returnCode
// IDL_long	sqlWarningOrErrorLength
//    if sqlWarningOrErrorLength > 0
//       sqlWarningOrError for sqlWarningOrErrorLength bytes
// IDL_long RowsReturned
// IDL_long outValuesFormat   (ROWWISE_ROWSETS = 1, COLUMNWISE_ROWSETS = 2)
// IDL_long outValuesLength
//    if outValuesLength > 0
//	     outValues for outValuesLength bytes

	char swap = pConnection->m_srvrTCPIPSystem->swap();
	msg_total_len = 0;
	curptr = rbuffer;
	*returnCode = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(*returnCode);

	LONG_swap(returnCode,swap);

	if (*returnCode != SQL_SUCCESS && *returnCode != SQL_NO_DATA_FOUND)
	{
		sqlWarningOrErrorLength = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(sqlWarningOrErrorLength);
		LONG_swap(&sqlWarningOrErrorLength,swap);
		if (sqlWarningOrErrorLength > 0)
		{
			if ((sqlWarningOrError = new BYTE[sqlWarningOrErrorLength]) == NULL)
				return CEE_ALLOCFAIL;
			else
			{
				memcpy(sqlWarningOrError,curptr+msg_total_len,sqlWarningOrErrorLength); 
				SQL_WARNING_OR_ERROR_swap(sqlWarningOrError,sqlWarningOrErrorLength,swap);
				msg_total_len += sqlWarningOrErrorLength;
			}
		}
	}

	if (*returnCode == SQL_SUCCESS || *returnCode == SQL_SUCCESS_WITH_INFO)
	{
		*rowsReturned = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(*rowsReturned);
		LONG_swap(rowsReturned,swap);


		*outValuesFormat = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(*outValuesFormat);
		LONG_swap(outValuesFormat,swap);
		
		outValuesLength = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(outValuesLength);
		LONG_swap(&outValuesLength,swap);

		outputDataValue->_length = 0;
		outputDataValue->_buffer = 0;

		if (outValuesLength <= 0)
			return CEE_SUCCESS;


		outputDataValue->_length = outValuesLength;
		outputDataValue->_buffer = (IDL_octet*) (curptr+msg_total_len);

	}

	return CEE_SUCCESS;

}/* odbc_SQLDrvr_Fetch_pst_() */

/***********************************
 * Operation 'odbc_SQLDrvr_Prepare' *
 ***********************************/

extern "C"  CEE_status
odbc_SQLDrvr_Prepare_pst_(
    /* In    */ CEE_tag_def tag_
  , /* In    */ IDL_string setStmtOptions
  , /* Out   */ IDL_long *returnCode
  , /* Out   */ BYTE *&sqlWarningOrError
  , /* Out   */ IDL_long *sqlQueryType
  , /* Out   */ IDL_long *stmtHandle
  , /* Out   */ IDL_long *estimatedCost
  , /* Out   */ BYTE *&inputParams
  , /* Out   */ SQLItemDescList_def *inputDesc
  , /* Out   */ BYTE *&outputColumns
  , /* Out   */ SQLItemDescList_def *outputDesc
)
{
	IDL_boolean sts;
	CEE_status  retcode;
	IDL_long   wlength,rlength;
	IDL_char   *wbuffer, *rbuffer;

	IDL_char   *curptr;
	IDL_long    sqlWarningOrErrorLength = 0;
	IDL_long	inputDescLength = 0;
	IDL_long	outputDescLength = 0;
	IDL_long	msg_total_len = 0;

	IDL_long	stmtCharset = 1;      // SQLCHARSETCODE_ISO88591 - change this when supporting character sets
	IDL_long	cursorCharset = 1;    // SQLCHARSETCODE_ISO88591 - change this when supporting character sets
	IDL_long	moduleCharset = 1;    // SQLCHARSETCODE_ISO88591 - change this when supporting character sets
	IDL_long	sqlStringCharset = 1; // SQLCHARSETCODE_ISO88591 - change this when supporting character sets

	IDL_long_long moduleTimestamp = 0;

	

	SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
	CStmt *pStatement = (CStmt *)srvrCallContext->sqlHandle;
	CConnect *pConnection = pStatement->getConnectHandle();


	pConnection->m_srvrTCPIPSystem->odbcAPI = SRVR_API_SQLPREPARE;
	pConnection->m_srvrTCPIPSystem->dialogueId = srvrCallContext->dialogueId;
	pConnection->m_srvrTCPIPSystem->dwTimeout = srvrCallContext->u.sendSQLcommandParams.queryTimeout;


	retcode = odbc_SQLDrvr_Prepare_param_pst_(
		  pConnection->m_srvrTCPIPSystem
		, wbuffer
		, wlength
		, srvrCallContext->dialogueId
		, srvrCallContext->u.sendSQLcommandParams.asyncEnable
		, srvrCallContext->u.sendSQLcommandParams.queryTimeout
		, srvrCallContext->u.sendSQLcommandParams.sqlStmtType
		, srvrCallContext->u.sendSQLcommandParams.stmtLabel
		, stmtCharset
		, srvrCallContext->u.sendSQLcommandParams.cursorName
		, cursorCharset
		, srvrCallContext->u.sendSQLcommandParams.moduleName
		, moduleCharset
		, moduleTimestamp
		, (IDL_char *)srvrCallContext->u.sendSQLcommandParams.sqlString
		, sqlStringCharset
		, setStmtOptions
		, srvrCallContext->u.sendSQLcommandParams.stmtName // explain label
		, EXTERNAL_STMT
		, srvrCallContext->maxRowsetSize
		, srvrCallContext->u.sendSQLcommandParams.holdableCursor		
	);

	if (retcode != CEE_SUCCESS)
		return retcode;

	sts = OpenIO (pConnection->m_srvrTCPIPSystem,srvrCallContext->SQLSvc_ObjRef);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);


	sts = DoIO (pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength, pConnection, pStatement);
	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

// process output parameters

	char swap = pConnection->m_srvrTCPIPSystem->swap();
	curptr = rbuffer;
	
	*returnCode = *(IDL_long*)(curptr);

	msg_total_len += sizeof(*returnCode);

	LONG_swap(returnCode,swap);

	if (*returnCode != SQL_SUCCESS)
	{
		sqlWarningOrErrorLength = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(sqlWarningOrErrorLength);
		LONG_swap(&sqlWarningOrErrorLength,swap);
		if (sqlWarningOrErrorLength > 0)
		{

			if ((sqlWarningOrError = new BYTE[sqlWarningOrErrorLength]) == NULL)
				return CEE_ALLOCFAIL;
			else
			{
				memcpy(sqlWarningOrError,curptr+msg_total_len,sqlWarningOrErrorLength); 
				SQL_WARNING_OR_ERROR_swap(sqlWarningOrError,sqlWarningOrErrorLength,swap);
				msg_total_len += sqlWarningOrErrorLength;
			}
		}
	}

	if (*returnCode == SQL_SUCCESS || *returnCode == SQL_SUCCESS_WITH_INFO)
	{
		*sqlQueryType = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(*sqlQueryType);
		LONG_swap(sqlQueryType,swap);

		*stmtHandle = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(*stmtHandle);
		LONG_swap(stmtHandle,swap);

		*estimatedCost = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(*estimatedCost);
		LONG_swap(estimatedCost,swap);

		inputDescLength = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(inputDescLength);
		LONG_swap(&inputDescLength,swap);
		if (inputDescLength > 0)
		{
			retcode = FormatSQLDescSeq(inputDesc, curptr+msg_total_len, inputDescLength, inputParams,swap);
			if (retcode != CEE_SUCCESS)
				return retcode;
			else
				msg_total_len += inputDescLength;
		}
		else
		{
			inputDesc->_length = 0;
			inputDesc->_buffer = 0;
		}

		outputDescLength = *(IDL_long*)(curptr+msg_total_len);
		msg_total_len += sizeof(outputDescLength);
		LONG_swap(&outputDescLength,swap);
		if (outputDescLength > 0)
		{
			retcode = FormatSQLDescSeq(outputDesc, curptr+msg_total_len, outputDescLength, outputColumns,swap);
			if (retcode != CEE_SUCCESS)
				return retcode;
			else
	 			msg_total_len += outputDescLength;
		}
		else
		{
			outputDesc->_length = 0;
			outputDesc->_buffer = 0;
		}
	}

	return CEE_SUCCESS;

} // odbc_SQLDrvr_Prepare_pst_()


/*
 * operation 'odbc_SQLDrvr_Execute'
 */
extern "C"  CEE_status
odbc_SQLDrvr_Execute_pst_(
    /* In    */ CEE_tag_def tag_
  , /* In    */ DIALOGUE_ID_def dialogueId
  , /* In    */ IDL_long sqlAsyncEnable
  , /* In    */ IDL_long holdableCursor  
  , /* In    */ IDL_long queryTimeout
  , /* In    */ IDL_long inputRowCnt
  , /* In    */ IDL_long maxRowsetSize
  , /* In    */ IDL_long sqlStmtType
  , /* In    */ IDL_long stmtHandle
  , /* In    */ IDL_long stmtType
  , /* In    */ IDL_string sqlString
  , /* In    */ IDL_string cursorName
  , /* In    */ IDL_string stmtLabel
  , /* In    */ IDL_string stmtExplainLabel
  , /* In    */ const SQLValueList_def *inputValueList
  , /* Out   */ IDL_long *returnCode
  , /* Out   */ BYTE *&sqlWarningOrError
  , /* Out   */ IDL_long_long *rowsAffected
  , /* Out   */ IDL_long *sqlQueryType
  , /* Out   */ IDL_long *estimatedCost
  , /* Out   */ SQL_DataValue_def *outputDataValue
  , /* Out   */ SQLItemDescList_def *outputItemDescList
  , /* Out   */ BYTE *&outputColumns // output from Prepare
  )
{
	bool sts;
	CEE_status retcode;
	IDL_long wlength,rlength;
	IDL_char* wbuffer, *rbuffer;

	SQLValue_def*	SQLValue;

	IDL_long			memOffSet = 0;
	BYTE			*VarBuffer = NULL;
	BYTE			*memPtr;

	IDL_long	stmtLabelCharset = 1;  // SQLCHARSETCODE_ISO88591 - change this when supporting character sets
	IDL_long	cursorCharset    = 1; // SQLCHARSETCODE_ISO88591 - change this when supporting character sets
	IDL_long	sqlStringCharset = 1; // SQLCHARSETCODE_ISO88591 - change this when supporting character sets



	IDL_long			VarBufferLength=0;
	IDL_long			TotalVarBufferLength=0;
	IDL_long	i=0;
	SQLINTEGER		SQLCharset=0;
	SQLSMALLINT		SQLDataType=0; 
	SQLSMALLINT		SQLDatetimeCode=0;
	SQLINTEGER		SQLMaxLength=0; 
	SQLSMALLINT		SQLPrecision=0;
	SQLSMALLINT		SQLUnsigned=0;
	SQLSMALLINT		SQLNullable=0;

	IDL_long			maxRowLen = 0;
	IDL_unsigned_short	SQLVarCharWithLen=0;

	IDL_long			cur_msg_len = 0;
	IDL_long			iCondition = 0;

	odbc_SQLSvc_ExecuteCall_exc_ SQLException = {0,0,0};
	SQLValueList_def *InputValueList;


	IDL_long		sqlWarningOrErrorLength = 0;
	IDL_char		*curptr;
	IDL_long		msg_total_len = 0;
	IDL_long	outValuesLength = 0;

	BYTE		*inputParams = 0;
	//BYTE		*outputColumns = 0;
	IDL_long		iVarLocation = 0;
	IDL_long		iIndLocation = 0;

	IDL_unsigned_long	oVarLocation = 0;
	IDL_unsigned_long	oIndLocation = 0;

	IDL_unsigned_long	paramTotal = 0;
	IDL_unsigned_long	paramNumber = 0;
	IDL_unsigned_long	Items = 0;
	IDL_long			rowNumber = -1;
	IDL_long			start_msg_total_len = 0;

	IDL_long outputDescLength = 0; // response from server

	IDL_long numSPJResultSets = 0; // Number of SPJ result sets
	IDL_long proxySyntaxStringLen = 0; // JDBC proxy syntax string - we don't use it, but its part of the wire protocol

	IDL_long quadSize=0;
	IDL_long tmpRowsAffected = 0; // hack - get rid of this when we're allowed to break the wire protocol



	SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
	CStmt *pStatement = (CStmt *)srvrCallContext->sqlHandle;
	CConnect *pConnection = pStatement->getConnectHandle();

 // pConnection->m_srvrTCPIPSystem->odbcAPI is set in drvrnet.cpp itself
	pConnection->m_srvrTCPIPSystem->dialogueId = srvrCallContext->dialogueId;
	pConnection->m_srvrTCPIPSystem->dwTimeout = srvrCallContext->u.executeParams.queryTimeout;
	
	if(pConnection->m_srvrTCPIPSystem->odbcAPI == SRVR_API_SQLEXECUTE2)
	{
		InputValueList = (struct SQLValueList_def_seq_ *)srvrCallContext->u.executeParams.inputValueList;
		
		if (InputValueList->_length > 0)
		{
			pStatement->getStmtData(inputParams, outputColumns);
			paramTotal = pStatement->getImpParamDescCount();

			TotalVarBufferLength = *(IDL_long*)(inputParams+msg_total_len);
			msg_total_len += sizeof(TotalVarBufferLength);

			VarBufferLength = *(IDL_long*)(inputParams+msg_total_len);
			msg_total_len += sizeof(VarBufferLength);

			start_msg_total_len = msg_total_len;
			VarBufferLength = VarBufferLength * inputRowCnt;
			if ((VarBuffer = new BYTE[VarBufferLength]) == NULL)
				return CEE_ALLOCFAIL;
			memset(VarBuffer,0,VarBufferLength);

			memPtr = VarBuffer ;
			
			for (Items = 0, i = 0; i < InputValueList->_length ;i++)
			{
				SQLValue = (SQLValue_def *)InputValueList->_buffer + i;
				// Varchar fields are two bytes aligned. Make sure that the column values are
				// even byte aligned incase SQLValue->dataValue._length is odd. Note that
				// in the case of rowsets, in the server, when we do a reprepare() 
				// in BuildSQLDesc2withRowsets(), if the length is odd, we set 
				// quadList var_layout to even. So we need to make sure that the same
				// layout happens from the driver too. JoyJ
				switch (SQLValue->dataType)
				{
					case SQLTYPECODE_VARCHAR_WITH_LENGTH:
					case SQLTYPECODE_VARCHAR_LONG:
						quadSize = ((SQLValue->dataValue._length + 2 - 1) >> 1) << 1;  
					break;
					default:
						quadSize = SQLValue->dataValue._length;
				}
				paramNumber = Items % paramTotal + 1;
				if (paramNumber == 1)
				{
					msg_total_len = start_msg_total_len;
					iVarLocation = 0;
					iIndLocation = 0;
					rowNumber++;
				}

				iVarLocation = *(IDL_long*)(inputParams+msg_total_len);
				msg_total_len += sizeof(iVarLocation);

				iIndLocation = *(IDL_long*)(inputParams+msg_total_len);
				msg_total_len += sizeof(iIndLocation);

				if (iIndLocation != -1)
				{ 
					oIndLocation = (iIndLocation * inputRowCnt) + (2 * rowNumber);
					if (SQLValue->dataValue._buffer != NULL && SQLValue->dataInd != -1)
					{
						oVarLocation = (iVarLocation * inputRowCnt) + (quadSize * rowNumber);
						memcpy(memPtr+oVarLocation, (const void *)SQLValue->dataValue._buffer, SQLValue->dataValue._length);
						*(IDL_short *)(memPtr+oIndLocation) = 0;
					}
					else
						*(IDL_short *)(memPtr+oIndLocation) = -1;

				}
				else
				{
					oVarLocation = (iVarLocation * inputRowCnt) + (quadSize * rowNumber);
					memcpy(memPtr+oVarLocation, (const void *)SQLValue->dataValue._buffer, SQLValue->dataValue._length);
				}


				if (msg_total_len > TotalVarBufferLength)
				{
					delete VarBuffer;
					return CEE_ALLOCFAIL;
				}
				Items++;
			}
		}

	} // odbcAPI == SRVR_API_SQLEXECUTE2

	retcode = odbc_SQLDrvr_Execute_param_pst_(
		  pConnection->m_srvrTCPIPSystem
		, wbuffer
		, wlength
		, dialogueId
		, sqlAsyncEnable
		, holdableCursor		
		, queryTimeout
		, inputRowCnt
		, maxRowsetSize
		, sqlStmtType
		, stmtHandle
		, stmtType
		, sqlString
		, sqlStringCharset
		, cursorName
		, cursorCharset
		, stmtLabel
		, stmtLabelCharset
		, stmtExplainLabel
		, VarBufferLength
		, VarBuffer
        , inputValueList
	);


	if (retcode != CEE_SUCCESS)
	{
		delete[] VarBuffer;
		return retcode;
	}

	sts = OpenIO (pConnection->m_srvrTCPIPSystem,srvrCallContext->SQLSvc_ObjRef);
	if (sts == false)
	{
		delete[] VarBuffer;
		return MAP_SRVR_ERRORS(pConnection);
	}

	sts = DoIO (pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength, pConnection, pStatement);

	delete[] VarBuffer;

	if (sts == false)
		return MAP_SRVR_ERRORS(pConnection);

//
// process output parameters
//

	char swap = pConnection->m_srvrTCPIPSystem->swap();
	msg_total_len = 0;
	curptr = rbuffer;

//
//  returnCode	
//
	*returnCode = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(*returnCode);
	LONG_swap(returnCode,swap);

//
//  sqlWarningOrErrorLength
//	sqlWarningOrError (if sqlWarningOrErrorLength > 0)
//	
	sqlWarningOrErrorLength = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(sqlWarningOrErrorLength);
	LONG_swap(&sqlWarningOrErrorLength,swap);

	if (sqlWarningOrErrorLength > 0)
	{
		if ((sqlWarningOrError = new BYTE[sqlWarningOrErrorLength]) == NULL)
			return CEE_ALLOCFAIL;
		else
		{
			memcpy(sqlWarningOrError,curptr+msg_total_len,sqlWarningOrErrorLength); 
			SQL_WARNING_OR_ERROR_swap(sqlWarningOrError,sqlWarningOrErrorLength,swap);
			msg_total_len += sqlWarningOrErrorLength;
		}
	}

//
//	outputDescLength
//	outputDesc
//	The output Descriptors will be sent back in the case of a SQLExecDirect
//
	outputDescLength = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(outputDescLength);
	LONG_swap(&outputDescLength,swap);

	if (outputDescLength > 0)
	{
		retcode = FormatSQLDescSeq(outputItemDescList, curptr+msg_total_len, outputDescLength, outputColumns,swap);
		if (retcode != CEE_SUCCESS)
			return retcode;
		else
 			msg_total_len += outputDescLength;
		pStatement->setDescRec(NULL, outputItemDescList);
	}
	else
	{
		outputItemDescList->_length = 0;
		outputItemDescList->_buffer = 0;
	}


//
//  rowsAffected
//
	///////////////////////////////////////////////////////////////////////
	//            ***** Begin HACK *****                                 //
	///////////////////////////////////////////////////////////////////////

	// hack - get rid of this when we're allowed to break the wire protocol
	// re-enable the next 3 lines and get rid of the next two

	//*rowsAffected = *(IDL_long_long*)(curptr+msg_total_len);
	//msg_total_len += sizeof(*rowsAffected);
	//LONGLONG_swap(rowsAffected);

	tmpRowsAffected = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(tmpRowsAffected);


	///////////////////////////////////////////////////////////////////////
	//            ***** End HACK *****                                   //
	///////////////////////////////////////////////////////////////////////

//
//  queryType
//
	*sqlQueryType = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(*sqlQueryType);
	LONG_swap(sqlQueryType,swap);

//
//  estimatedCost
//
	///////////////////////////////////////////////////////////////////////
	//            ***** Begin HACK *****                                 //
	///////////////////////////////////////////////////////////////////////

	*estimatedCost = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(*estimatedCost);
	//LONG_swap(estimatedCost);

	if(swap == SWAP_YES)
	{
	*rowsAffected = tmpRowsAffected;
	*rowsAffected = *rowsAffected << 32;
	*rowsAffected = *rowsAffected | *estimatedCost;
		LONGLONG_swap(rowsAffected,swap);
	}
	else
	{
		//we're connected to Seaquest
		*rowsAffected = *estimatedCost;
		*rowsAffected = *rowsAffected << 32;
		*rowsAffected = *rowsAffected | tmpRowsAffected;

	}

	// BIGE hosts need to do this
	//*rowsAffected = *estimatedCost;
	//*rowsAffected = *rowsAffected << 32;
	//*rowsAffected = *rowsAffected | tmpRowsAffected;
	
	

	///////////////////////////////////////////////////////////////////////
	//            ***** End HACK *****                                   //
	///////////////////////////////////////////////////////////////////////

//
//  outValuesLength
//  outValues (if outValuesLength > 0)
//
    outValuesLength = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(outValuesLength);
	LONG_swap(&outValuesLength,swap);

	outputDataValue->_length = outValuesLength;

	if(outValuesLength > 0)
		outputDataValue->_buffer = (IDL_octet*) (curptr+msg_total_len);
	else
		outputDataValue->_buffer = NULL;

	msg_total_len += outValuesLength;


//
// SPJ Result Sets
//
    numSPJResultSets = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(numSPJResultSets);
	LONG_swap(&numSPJResultSets,swap);
	
	pStatement->m_spjNumResultSets = 0;
	pStatement->m_spjCurrentResultSetIndex = 0;

	if(numSPJResultSets > 0)
	{
		IDL_long tempRsStmtHandle;
		IDL_long tempRsStmtLabelLength;
		IDL_long tempRsStmtLabelCharset;
		IDL_long tempRsOutputDescLength;
		BYTE	 *tempRsOutputColumns;
		
		pStatement->m_spjNumResultSets = numSPJResultSets;
		pStatement->m_spjResultSets = new SPJ_RS_DATA[numSPJResultSets];
		
		for(i = 0; i < numSPJResultSets; i++)
		{
			//
			// Result Set: Statement Handle
			//
			tempRsStmtHandle = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(tempRsStmtHandle);
			LONG_swap(&tempRsStmtHandle,swap);

			pStatement->m_spjResultSets[i].spjStmtHandle = tempRsStmtHandle;

			//
			// Result Set: Statement Label (Statement label length + statement label + statement label charset)
			//
			tempRsStmtLabelLength = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(tempRsStmtLabelLength);
			LONG_swap(&tempRsStmtLabelLength,swap);

			
			strncpy(pStatement->m_spjResultSets[i].spjStmtLabelName,curptr+msg_total_len,tempRsStmtLabelLength);
			msg_total_len += tempRsStmtLabelLength;

			tempRsStmtLabelCharset = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(tempRsStmtLabelCharset);
			LONG_swap(&tempRsStmtLabelCharset,swap);
			//pStatement->m_spjResultSets[i].spjStmtLabelCharset = tempRsStmtLabelCharset;

			//
			// Result Set: output Descriptor Length + output Descriptor
			//
			tempRsOutputDescLength = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(tempRsOutputDescLength);
			LONG_swap(&tempRsOutputDescLength,swap);

			if(tempRsOutputDescLength > 0)
			{
				retcode = FormatSQLDescSeq(&pStatement->m_spjResultSets[i].spjOutputItemDesc, 
										curptr+msg_total_len, 
										tempRsOutputDescLength, 
										tempRsOutputColumns,
										swap);

				if (retcode != CEE_SUCCESS)
					return retcode;
				else
 					msg_total_len += tempRsOutputDescLength;


				delete[] tempRsOutputColumns;

			} // tempRsOutputDescLength

			//
			//	Proxy Syntax String - Only JDBC needs, so we'll skip this
			//
			proxySyntaxStringLen = *(IDL_long*)(curptr+msg_total_len);
			msg_total_len += sizeof(proxySyntaxStringLen);
			LONG_swap(&proxySyntaxStringLen,swap);
			msg_total_len += proxySyntaxStringLen;

		} // end for numSPJResultSets

	} // if(numSPJResultSets > 0)

	// 
	// SPJ related stuff we can ignore
	// 
	proxySyntaxStringLen = *(IDL_long*)(curptr+msg_total_len);
	msg_total_len += sizeof(proxySyntaxStringLen);
	LONG_swap(&proxySyntaxStringLen,swap);
	msg_total_len += proxySyntaxStringLen;



	return CEE_SUCCESS;

} // odbc_SQLDrvr_Execute_pst_()


extern "C" CEE_status
odbc_SQLDrvr_ExtractLOB_pst_(
    /* In    */ CEE_tag_def tag_
 , /* In    */ IDL_short extractType
 , /* In    */ IDL_string  lobHandle
 , /* In    */ IDL_long    lobHandleLen
 , /* In    */ IDL_long  &extractLen
 , /* Out   */ struct odbc_SQLsvc_ExtractLob_exc_ *exception_
 , /* Out   */ BYTE *& extractData
)
{
    bool sts;

    CEE_status retcode;
    IDL_long   wlength, rlength;
    IDL_char   *wbuffer, *rbuffer;

    IDL_long sqlWarningOrErrorLength = 0;
    IDL_char   *curptr;
    IDL_long   msg_total_len = 0;

    IDL_long   lobHandleCharset = 1;

    SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
    CStmt * pStatement = (CStmt *)srvrCallContext->sqlHandle;
    CConnect *pConnection = pStatement->getConnectHandle();

    retcode = odbc_SQLDrvr_ExtractLob_param_pst_(
        pConnection->m_srvrTCPIPSystem
        , wbuffer
        , wlength
        , extractType
        , lobHandle
        , lobHandleLen
        , lobHandleCharset
        , extractLen
        );

    sts = OpenIO(pConnection->m_srvrTCPIPSystem, srvrCallContext->SQLSvc_ObjRef);
    if (sts == false)
        return MAP_SRVR_ERRORS(pConnection);

    sts = DoIO(pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength, pConnection, pStatement);
    if (sts == false)
        return MAP_SRVR_ERRORS(pConnection);

    // process output parameters

    char swap = pConnection->m_srvrTCPIPSystem->swap();
    msg_total_len = 0;
    curptr = rbuffer;

    //
    //   exception_
    //

    IDL_long ExceptionLength;

    //
    //   exception_ ->exception_nr
    //
    exception_->exception_nr = *(IDL_long*)(curptr + msg_total_len);
    msg_total_len += sizeof(exception_->exception_nr);
    LONG_swap(&exception_->exception_nr, swap);

    //
    //   exception_ ->exception_detail
    //
    exception_->exception_detail = *(IDL_long*)(curptr + msg_total_len);
    msg_total_len += sizeof(exception_->exception_detail);
    LONG_swap(&exception_->exception_detail, swap);

    switch (exception_->exception_nr)
    {
    case odbc_SQLSvc_ExtractLob_ParamError_exn_:
        ExceptionLength = *(IDL_long *)(curptr + msg_total_len);
        msg_total_len += sizeof(ExceptionLength);
        LONG_swap(&ExceptionLength);

        if (ExceptionLength > 0)
        {
            exception_->u.ParamError.ParamDesc = (IDL_char *)(curptr + msg_total_len);
            msg_total_len += ExceptionLength;
        }
        break;

    case odbc_SQLSvc_ExtractLob_SQLError_exn_:
        retcode = copy_ERROR_DESC_LIST(&exception_->u.SQLError.errorList, curptr, msg_total_len, swap);
        if (retcode != CEE_SUCCESS)
            return retcode;
        break;

    case odbc_SQLSvc_ExtractLob_InvalidConnection_exn_:
    case odbc_SQLSvc_ExtractLob_SQLInvalidhandle_exn_:
        break;
    default:
        break;
    }
    extractType = *(IDL_short *)(curptr + msg_total_len);
    msg_total_len += sizeof(IDL_short);
    SHORT_swap(&extractType, swap);

    switch (extractType)
    {
    case 0:
        extractLen = *(IDL_long_long *)(curptr + msg_total_len);
        break;
    case 1:
        extractLen = *(IDL_long_long *)(curptr + msg_total_len);
        msg_total_len += sizeof(IDL_long_long);
        extractData = (BYTE *)(curptr + msg_total_len);
    default:
        break;
    }

    return CEE_SUCCESS;
}


extern "C" CEE_status
odbc_SQLDrvr_UpdateLob_pst_(
    /* In    */ CEE_tag_def tag_
  , /* In    */ IDL_long  updataType
  , /* In    */ IDL_string  lobHandle
  , /* In    */ IDL_long    lobHandleLen
  , /* In    */ IDL_long_long  totalLength
  , /* In    */ IDL_long_long  offset
  , /* In    */ IDL_long_long  pos
  , /* In    */ IDL_long_long  length
  , /* In    */ BYTE *        &data
  , /* Out   */ struct odbc_SQLSvc_UpdateLob_exc_ *exception_
)
{
    bool sts;

    CEE_status retcode;
    IDL_long   wlength, rlength;
    IDL_char   *wbuffer, *rbuffer;

    IDL_long sqlWarningOrErrorLength = 0;
    IDL_char   *curptr;
    IDL_long   msg_total_len = 0;

    IDL_long   lobHandleCharset = 1;

    SRVR_CALL_CONTEXT *srvrCallContext = (SRVR_CALL_CONTEXT *)tag_;
    CStmt * pStatement = (CStmt *)srvrCallContext->sqlHandle;
    CConnect *pConnection = pStatement->getConnectHandle();

    pConnection->m_srvrTCPIPSystem->odbcAPI = SRVR_API_UPDATELOB;
    pConnection->m_srvrTCPIPSystem->dialogueId = srvrCallContext->dialogueId;
    pConnection->m_srvrTCPIPSystem->dwTimeout = srvrCallContext->statementTimeout;

    retcode = odbc_SQLDrvr_UpdateLob_param_pst_(
        pConnection->m_srvrTCPIPSystem
        , wbuffer
        , wlength
        , updataType
        , lobHandle
        , lobHandleLen
        , lobHandleCharset
        , totalLength
        , offset
        , data
        , pos
        , length
        );

    sts = OpenIO(pConnection->m_srvrTCPIPSystem, srvrCallContext->SQLSvc_ObjRef);
    if (sts == false)
        return MAP_SRVR_ERRORS(pConnection);

    sts = DoIO(pConnection->m_srvrTCPIPSystem, wbuffer, wlength, rbuffer, rlength, pConnection, pStatement);
    if (sts == false)
        return MAP_SRVR_ERRORS(pConnection);

    char swap = pConnection->m_srvrTCPIPSystem->swap();
    msg_total_len = 0;
    curptr = rbuffer;

    //
    //   exception_
    //

    IDL_long ExceptionLength;

    //
    //   exception_ ->exception_nr
    //
    exception_->exception_nr = *(IDL_long*)(curptr + msg_total_len);
    msg_total_len += sizeof(exception_->exception_nr);
    LONG_swap(&exception_->exception_nr, swap);

    //
    //   exception_ ->exception_detail
    //
    exception_->exception_detail = *(IDL_long*)(curptr + msg_total_len);
    msg_total_len += sizeof(exception_->exception_detail);
    LONG_swap(&exception_->exception_detail, swap);

    switch (exception_->exception_nr)
    {
    case odbc_SQLSvc_UpdateLob_ParamError_exn_:
        ExceptionLength += *(IDL_long *)(curptr + msg_total_len);
        msg_total_len += sizeof(ExceptionLength);
        LONG_swap(&ExceptionLength);
        if (ExceptionLength > 0)
        {
            exception_->u.ParamError.ParamDesc = (IDL_char *)(curptr + msg_total_len);
            msg_total_len += ExceptionLength;
        }
        break;
    case odbc_SQLSvc_UpdateLob_InvalidConnect_exn_:
        retcode = copy_ERROR_DESC_LIST(&exception_->u.SQLError.errorList, curptr, msg_total_len, swap);
        if (retcode != CEE_SUCCESS)
            return retcode;
    case odbc_SQLSvc_UpdateLob_SQLError_exn_:
    case odbc_SQLSvc_UpdateLob_SQLInvalidhandle_exn_:
        break;

    default:
        break;
    }

    return CEE_SUCCESS;
}

//-----------------------------------------------------------------

CEE_status MAP_SRVR_ERRORS(CConnect *pConnection)
{
	long signature = (long)pConnection->m_srvrTCPIPSystem;

	CEE_status sts = CEE_SUCCESS;
	CError* ierror = GTransport.m_error_list.find_error(signature);
	if (ierror == NULL)
		return UNKNOWN_EXCEPTION;
	sts = ierror->error;
	if (GTransport.bMapErrors){
		switch (ierror->error)
		{
			case WSAEDISCON:
			case WSAECONNABORTED:				//Software caused connection abort
			case WSAENETRESET:					// Network dropped connection because of reset			
			case WSAECONNRESET:					//Connection reset by peer
				sts = COMM_LINK_FAIL_EXCEPTION;
				break;
			case WSAETIMEDOUT:					//Connection timed out
			case TIMEOUT_EXCEPTION:
				sts = TIMEOUT_EXCEPTION;
				break;
			// Errors of interest, for reference
			case DRVR_ERR_WRONG_IP_ADDRESS:		//DRVR_ERR_WRONG_IP_ADDRESS
			case WSAEADDRNOTAVAIL:				// Connot assign requested address
			case WSAECONNREFUSED:				// Connection Refused
			case WSAEFAULT:						// Bad address
			case WSAENETUNREACH:				// Network is unreachable
			case WSAENETDOWN:					// Network is down
			case WSAEINTR:						// Interrupted function call
			case DRVR_ERR_INCORRECT_LENGTH:
			case DRVR_ERR_WRONGSIGNATURE:
			case DRVR_ERR_ERROR_FROM_SERVER:
			case 999:
			default:
				sts = TRANSPORT_ERROR;
				break;
		}
	}
	return sts;
}



