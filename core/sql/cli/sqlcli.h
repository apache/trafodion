/*********************************************************************
// @@@ START COPYRIGHT @@@
//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// @@@ END COPYRIGHT @@@
**********************************************************************/
#ifndef SQLCLI_HDR
#define SQLCLI_HDR

/* -*-C-*-
******************************************************************************
*
* File:         SQLCLI.h
* Description:  Declarations for the NonStop SQL CLI
* Language:     C and C++.  The comment style herein must be C, not C++.
*
******************************************************************************
*/

/* Size specific types used here */
typedef int             Int32;
typedef unsigned int    UInt32;
#if defined(NA_64BIT)
typedef long Int64;
#else
typedef long long int Int64;
#endif

#ifdef __cplusplus
extern "C"
{
#endif

typedef Int32 SQLCTX_HANDLE;

#if !defined(_MSC_VER) && !defined(_int64)
/* _int64 is an MSVC builtin definition, but may be used elsewhere */ 
/* #define _int64 long long */
  typedef long long _int64;
#endif

/* Internal structure definitions version */
#define SQLCLI_CURRENT_VERSION 1
#define SQLCLI_STATEMENT_VERSION_1  1
#define SQLCLI_STATEMENT_VERSION_2  2

/* Functional conformance version */
#define CLI_VERSION 100L

/* structure to identify a module */
struct SQLMODULE_ID_t {
  Int32 version;
  const char * module_name;
  _int64 creation_timestamp;
  const char * charset; /* charset (encoded in ASCII, and null terminated) */
			 /* of the module name. */
  Int32 module_name_len;  /* length of the module name (in bytes) */
};


/* typedef the structure so that C compilers can use it without the 'struct' */
typedef struct SQLMODULE_ID_t SQLMODULE_ID;

/* specifies the way of naming an object in the CLI */
enum SQLOBJ_ID_NAME_MODE {
  stmt_name     =   1,          /* statement name as char string            */
  cursor_name   =   2,          /* cursor name as char string               */
  desc_name     =   3,          /* descriptor name as char string           */
  queryid_str   =   4,          /* Query id as char string                  */
  string_data   =  50,          /* string data passed in without a          */
                                /* descriptor. Used in certain cli calls    */
                                /* improve performance.                     */
  stmt_handle   = 101,          /* statement handle (generated by CLI)      */
  desc_handle   = 102,          /* descriptor handle (generated by CLI)     */
  stmt_via_desc = 201,          /* descriptor for a statement name          */
  curs_via_desc = 202,          /* descriptor for a cursor name             */
  desc_via_desc = 203           /* descriptor for a descriptor name         */
};

/* generic structure to pass names to the SQLCLI */
struct SQLCLI_OBJ_ID {
  Int32 version;                /* set to SQLCLI_CURRENT_VERSION if no tag  */
  Int32 name_mode;              /* see enum SQLOBJ_ID_NAME_MODE below       */
  const SQLMODULE_ID * module;  /* module name (leading part of name)       */
  const char * identifier;      /* actual identifier (one part name)        */
  void * handle;                /* handle, in addition or instead of a name */
  const char * charset;	/* charset (encoded in ASCII, and null terminated) */ 
                        /* of the identifier. */
  Int32 identifier_len;  /* length of the identifier (in bytes) */
  Int32 tag;             /* added in R1.8, used when version==SQLCLI_STATEMENT_VERSION_2 */
                        /* tag must be non-zero for nowaited operation      */
                        /* and zero for waited. */
};


/* structure to pass a statement identifier to the CLI             */
 
typedef struct SQLCLI_OBJ_ID SQLSTMT_ID;
typedef struct SQLCLI_OBJ_ID SQLCLI_STMT_ID;

/* structure to pass a descriptor name or handle to the CLI. */
typedef struct SQLCLI_OBJ_ID SQLDESC_ID;

/* specifies whether a descriptor is an input or output descriptor */
enum SQLWHAT_DESC {
  SQLWHAT_INPUT_DESC    =    1,
  SQLWHAT_OUTPUT_DESC   =    2
};

/* specifies a particular item in a descriptor entry */
enum SQLDESC_ITEM_ID {

  SQLDESC_TYPE          =    1, /* (numeric) data type, ANSI                */
  SQLDESC_DATETIME_CODE =    2, /* (numeric) datetime code a la ANSI        */

  SQLDESC_LENGTH        =    3, /* (numeric) length in chars, bits, ...     */
  SQLDESC_OCTET_LENGTH  =    4, /* (numeric) length in bytes                */
  SQLDESC_PRECISION     =    5, /* (numeric) precision (decimal or binary)  */
  SQLDESC_SCALE         =    7, /* (numeric) scale of the number            */
  SQLDESC_INT_LEAD_PREC =    8, /* (numeric) interval leading field precis. */

  SQLDESC_NULLABLE      =    9, /* (numeric) 0 = NOT NULL, 1 = nullable     */

  SQLDESC_CHAR_SET      =   10, /* (numeric) 1 part charset enum */
  SQLDESC_CHAR_SET_CAT  =   11, /* (string ) catalog part of the char set   */
  SQLDESC_CHAR_SET_SCH  =   12, /* (string ) schema part of the char set    */
  SQLDESC_CHAR_SET_NAM  =   13, /* (string ) 1 part charset name            */
  SQLDESC_COLLATION     =   14, /* (numeric) collation code                 */
  SQLDESC_COLL_CAT      =   15, /* (string ) catalog of the coll name       */
  SQLDESC_COLL_SCH      =   16, /* (string ) schema part of the coll name   */
  SQLDESC_COLL_NAM      =   17, /* (string ) 1 part collation name          */

  SQLDESC_NAME          =   18, /* (string ) column name                    */
  SQLDESC_UNNAMED       =   19, /* (numeric) 0 = named, 1 = unnamed col.    */
  SQLDESC_HEADING       =   20, /* (string ) heading of the column          */

  SQLDESC_IND_TYPE      =   21, /* (numeric) data type of the indicator var */
  SQLDESC_VAR_PTR       =   22, /* (numeric) pointer to the data            */
  SQLDESC_IND_PTR       =   23, /* (numeric) pointer to an indicator var.   */

  SQLDESC_RET_LEN       =   24, /* (numeric) actual char length of the data */
  SQLDESC_RET_OCTET_LEN =   25, /* (numeric) actual byte len of the data    */
  SQLDESC_VAR_DATA      =   26, /* (string ) the actual data                */
  SQLDESC_IND_DATA      =   27, /* (numeric) value of the indicator         */
  SQLDESC_TYPE_FS       =   28, /* (numeric) data type, SQL/MP FS internal  */

  SQLDESC_IND_LENGTH    =   29, /* (numeric) Length in chars of the ind var */
  SQLDESC_ROWSET_VAR_LAYOUT_SIZE   = 30,
  SQLDESC_ROWSET_IND_LAYOUT_SIZE   = 31,
  SQLDESC_ROWSET_SIZE              = 32,
  SQLDESC_ROWSET_HANDLE            = 33,
  SQLDESC_ROWSET_NUM_PROCESSED     = 34,
  SQLDESC_ROWSET_ADD_NUM_PROCESSED = 35,
  SQLDESC_ROWSET_STATUS_PTR        = 36,

  SQLDESC_TABLE_NAME               = 37,
  SQLDESC_SCHEMA_NAME              = 38,
  SQLDESC_CATALOG_NAME             = 39,

  SQLDESC_PARAMETER_MODE	   = 40, /* (numeric) the parameter mode
					     defined in enum PARAMETER_MODE */
  SQLDESC_ORDINAL_POSITION	   = 41, /* (numeric) the formal parameter
					     ordinal position */
  SQLDESC_PARAMETER_INDEX	   = 42, /* (numeric) the actual parameter
					    position */
  SQLDESC_DESCRIPTOR_TYPE          = 43, /* specify either the wide or narrow
					    descriptor type.
					    static descriptors default to wide,
					    dynamic descritpors default to
					    narrow. */
  SQLDESC_ROWSET_TYPE              = 44, /* of type enum ROWSET_TYPE.
					    Defined in SQLCLIdev.h(not 
					    externalized yet)
					    Specifies if this is a row-wise 
					    column-wise rowset */

  SQLDESC_ROWWISE_ROWSET_SIZE      = 45, /* number of rows in this rowset */
  SQLDESC_ROWWISE_ROWSET_ROW_LEN   = 46, /* length of each row */
  SQLDESC_ROWWISE_ROWSET_PTR       = 47, /* ptr to the start of rowset */
  SQLDESC_TEXT_FORMAT		   = 48, /* (string) Datatype in text format */
#ifdef _DEBUG
  SQLDESC_ROWWISE_VAR_OFFSET       = 49, /* testing logic offset of value in Attribute */
  SQLDESC_ROWWISE_IND_OFFSET       = 50, /* testing logic offset of indicator in Attributes */  
#endif
  SQLDESC_CASEINSENSITIVE          = 51, /* (numeric) 0 = casesensitive, 1 = caseinsensitive */
  SQLDESC_DATA_OFFSET              = 52, /* offset to actual data in the row */
  SQLDESC_NULL_IND_OFFSET          = 53, /* offset to null indicator in the row */
  SQLDESC_VC_IND_LENGTH            = 54, /* (numeric) Length of varchar length indicator */
  SQLDESC_ALIGNED_LENGTH           = 55, /* total aligned length: data + null + vclen + filler */
  SQLDESC_ROWWISE_ROWSET_PARTN_NUM = 56  /* partition num where rwrs buffer need to go to */
};

enum DESCRIPTOR_TYPE {
  DESCRIPTOR_TYPE_WIDE = 0,
  DESCRIPTOR_TYPE_NARROW = 1
};
  
enum PARAMETER_MODE { 
  PARAMETER_MODE_UNDEFINED	=    0,
  PARAMETER_MODE_IN		=    1,
  PARAMETER_MODE_INOUT		=    2, 
  PARAMETER_MODE_OUT		=    4
};

/* specifies the character set names corresponding to SQLDESC_CHAR_SET_NAM */
#ifndef SQLCHARSETSTRING_DEFINED
#define SQLCHARSETSTRING_DEFINED   1

#define SQLCHARSETSTRING_ISO88591          "ISO88591"
#define SQLCHARSETSTRING_KANJI             "KANJI"
#define SQLCHARSETSTRING_KSC5601           "KSC5601"
#define SQLCHARSETSTRING_UNICODE           "UCS2"
#define SQLCHARSETSTRING_LATIN             "LATIN"
#define SQLCHARSETSTRING_EUCJP             "EUCJP"
#define SQLCHARSETSTRING_GB2312            "GB2312"
#define SQLCHARSETSTRING_GBK               "GBK"
#define SQLCHARSETSTRING_GB18030           "GB18030"
#define SQLCHARSETSTRING_MB_KSC5601        "MB_KSC5601"
#define SQLCHARSETSTRING_SJIS              "SJIS"
#define SQLCHARSETSTRING_UTF8              "UTF8"
#define SQLCHARSETSTRING_BIG5              "BIG5"
#define SQLCHARSETSTRING_UCS2              SQLCHARSETSTRING_UNICODE
#define SQLCHARSETSTRING_ISO_MAPPING       "ISO_MAPPING"
#define SQLCHARSETSTRING_BINARY            "BINARY"
#endif /* SQLCHARSETSTRING_DEFINED */

/* specifies the supported character sets (for numeric value version of 
SQL_EXEC_GETDESCITEM() and SQL_EXEC_SETDESCITEM() corresponding to SQLDESC_CHAR_SET)
*/
#ifndef SQLCHARSET_CODE_DEFINED
#define SQLCHARSET_CODE_DEFINED

enum SQLCHARSET_CODE {
  SQLCHARSETCODE_UNKNOWN        =  0,
  SQLCHARSETCODE_ISO88591       =  1,
  SQLCHARSETCODE_KANJI          = -1,
  SQLCHARSETCODE_KSC5601        = -2,
  SQLCHARSETCODE_SJIS           = 10,
  SQLCHARSETCODE_UCS2           = 11,
  SQLCHARSETCODE_EUCJP          = 12,
  SQLCHARSETCODE_BIG5           = 13,
  SQLCHARSETCODE_GB18030        = 14,
  SQLCHARSETCODE_UTF8           = 15,
  SQLCHARSETCODE_MB_KSC5601     = 16,
  SQLCHARSETCODE_GB2312         = 17,
  SQLCHARSETCODE_GBK            = 18,
  SQLCHARSETCODE_BINARY         = 19,

  /* specifies that the user input string is in the same charset that is
     set as the value of the ISO_MAPPING default in the defaults table.
     Cli will pass in the input string as is to mxcmp without any translation.
     It will also tell mxcmp to treat any unprefixed literals in the 
     input string as iso88591. */
  SQLCHARSETCODE_ISO_MAPPING    = 9999
};
#endif /* SQLCHARSET_CODE_DEFINED */

/* specifies the supported character set conversions that are allowed */
#ifndef SQLCONVCHARSET_CODE_DEFINED
#define SQLCONVCHARSET_CODE_DEFINED

  enum SQLCONVCHARSET_CODE {
  SQLCONVCHARSETCODE_UNKNOWN    = 0,
  SQLCONVCHARSETCODE_UTF8       = 1,
  SQLCONVCHARSETCODE_UTF16      = 2,
  SQLCONVCHARSETCODE_UTF32      = 3,
  SQLCONVCHARSETCODE_ISO88591   = 4,
  SQLCONVCHARSETCODE_SJIS       = 5,
  SQLCONVCHARSETCODE_EUCJP      = 6,
  SQLCONVCHARSETCODE_KSC        = 7,
  SQLCONVCHARSETCODE_BIG5       = 8,
  SQLCONVCHARSETCODE_2312       = 9,
  SQLCONVCHARSETCODE_GB18030    = 10,
  SQLCONVCHARSETCODE_GBK        = 11
};
#endif /* SQLCONVCHARSET_CODE_DEFINED */

#define SQLCONV_REVERSE_INBYTES    2

/* specifies the collation names corresponding to SQLDESC_COLL_NAM */
#ifndef SQLCOLLATIONSTRING_DEFINED
#define SQLCOLLATIONSTRING_DEFINED 1
  
#define SQLCOLLATIONSTRING_DEFAULT         "DEFAULT"
#define SQLCOLLATIONSTRING_CZECH           "CZECH"
#define SQLCOLLATIONSTRING_CZECH_CI        "CZECH_CI"
#endif /* SQLCOLLATIONSTRING_DEFINED */

/* struct to hold one item of a descriptor entry */
typedef struct {
  Int32 item_id;                 /* which item (see SQLDESC_ITEM_ID)         */
  Int32 value_num_desc_entry;    /* value num's input descriptor entry num   */
  Int32 entry;                   /* number of the entry                      */
  long  num_val_or_len;          /* numeric value or length of string        */
  char * string_val;             /* string value (if not a numeric value)    */
} SQLDESC_ITEM;

/*  ANSI datatype values for item descriptor areas
 *   - see ANSI-92 Spec. Section 17.1 - Table 18
 *   - includes tandem extensions (negative values)
 */
enum SQLTYPE_CODE {
    /* CHAR/CHARACTER */
    SQLTYPECODE_CHAR     = 1,

    /* NUMERIC */
    SQLTYPECODE_NUMERIC  = 2,
    SQLTYPECODE_NUMERIC_UNSIGNED = -201,

    /* DECIMAL */
    SQLTYPECODE_DECIMAL  = 3,

    /* DECIMAL Tandem extensions */
    SQLTYPECODE_DECIMAL_UNSIGNED       = -301,
    SQLTYPECODE_DECIMAL_LARGE          = -302,
    SQLTYPECODE_DECIMAL_LARGE_UNSIGNED = -303,

    /* INTEGER/INT */
    SQLTYPECODE_INTEGER  = 4,

    /* INTEGER/INT Tandem extensions */
    SQLTYPECODE_INTEGER_UNSIGNED       = -401,
    SQLTYPECODE_LARGEINT               = -402,
    SQLTYPECODE_LARGEINT_UNSIGNED      = -405,

    /* TINYINT */
    SQLTYPECODE_TINYINT                = -403,
    SQLTYPECODE_TINYINT_UNSIGNED       = -404,

    /* SMALLINT */
    SQLTYPECODE_SMALLINT = 5,

    /* SMALLINT Tandem extensions */
    SQLTYPECODE_SMALLINT_UNSIGNED      = -502,

    /*  Bit Precision int, Tandem extensions */
    SQLTYPECODE_BPINT_UNSIGNED         = -503,

    /* IEEE FLOAT (precision,scale)
     *    Internally converted to REAL or DOUBLE depending on
     *                 precision
     */
    SQLTYPECODE_IEEE_FLOAT    = 6,

    /* IEEE REAL
     *    Tandem note: precision == 22
     */
    SQLTYPECODE_IEEE_REAL     = 7,

    /* IEEE DOUBLE PRECISION
     *    Tandem note: precision == 54
     */
    SQLTYPECODE_IEEE_DOUBLE   = 8,

    /* Tandem FLOAT (precision,scale)
     *    Internally converted to REAL or DOUBLE depending on
     *                 precision
     */
    SQLTYPECODE_TDM_FLOAT    = -411,
    SQLTYPECODE_FLOAT = SQLTYPECODE_TDM_FLOAT,

    /* Tandem REAL
     *    Tandem note: precision == 22
     */
    SQLTYPECODE_TDM_REAL     = -412,
    SQLTYPECODE_REAL = SQLTYPECODE_TDM_REAL,

    /* Tandem DOUBLE PRECISION
     *    Tandem note: precision == 54
     */
    SQLTYPECODE_TDM_DOUBLE   = -413,
    SQLTYPECODE_DOUBLE = SQLTYPECODE_TDM_DOUBLE,

    /* DATE,TIME,TIMESTAMP */
    SQLTYPECODE_DATETIME = 9,

    /* TIMESTAMP */
    SQLTYPECODE_INTERVAL = 10,

    /* no ANSI value 11 */

    /* VARCHAR/CHARACTER VARYING */
    SQLTYPECODE_VARCHAR  = 12,

    /* SQL/MP stype VARCHAR with length prefix: Tandem Extension */
    SQLTYPECODE_VARCHAR_WITH_LENGTH = -601,

    /* LONG VARCHAR/ODBC CHARACTER VARYING */
    SQLTYPECODE_VARCHAR_LONG  = -1,		/* ## NEGATIVE??? */

    /* BLOB TYPE */
    SQLTYPECODE_BLOB  = -602,
    SQLTYPECODE_CLOB  = -603,

    /* BOOLEAN TYPE */
    SQLTYPECODE_BOOLEAN = -701,

    /* BINARY TYPE */
    SQLTYPECODE_BINARY = 60,

    /* VARBINARY TYPE */
    SQLTYPECODE_VARBINARY = 61,

    /* no ANSI value 13 */

    /* BIT */
    SQLTYPECODE_BIT      = 14,  /* not supported */

    /* BIT VARYING */
    SQLTYPECODE_BITVAR   = 15   /* not supported */
};

/* #ifndef SQLDTCODE_DATE */
/* specifies the type of datetime data type */
enum SQLDATETIME_CODE {
  SQLDTCODE_DATE      = 1,
  SQLDTCODE_TIME      = 2,
  SQLDTCODE_TIMESTAMP = 3,
  SQLDTCODE_MPDATETIME = 4
};
/* #endif */

/* specifies the type of interval data type */
enum SQLINTERVAL_CODE {
  SQLINTCODE_YEAR          =  1,
  SQLINTCODE_MONTH         =  2,
  SQLINTCODE_DAY           =  3,
  SQLINTCODE_HOUR          =  4,
  SQLINTCODE_MINUTE        =  5,
  SQLINTCODE_SECOND        =  6,
  SQLINTCODE_YEAR_MONTH    =  7,
  SQLINTCODE_DAY_HOUR      =  8,
  SQLINTCODE_DAY_MINUTE    =  9,
  SQLINTCODE_DAY_SECOND    = 10,
  SQLINTCODE_HOUR_MINUTE   = 11,
  SQLINTCODE_HOUR_SECOND   = 12,
  SQLINTCODE_MINUTE_SECOND = 13
};

/* type codes from SQL/MP include file sql.h, for TYPE_FS
   descriptor fields (with additional SQL/MX datatypes)             */

#ifndef _SQLDT_ASCII_F

#define _SQLDT_ASCII_F      0   /* CHAR datatype                    */
#define _SQLDT_ASCII_F_UP   1   /* CHAR datatype, UPSHIFTed         */
#define _SQLDT_DOUBLE_F     2   /* DOUBLE CHAR datatype             */
#define _SQLDT_ASCII_V     64   /* VARCHAR datatype                 */
#define _SQLDT_ASCII_V_UP  65   /* VARCHAR datatype, UPSHIFted      */
#define _SQLDT_DOUBLE_V    66   /* DOUBLE VARCHAR datatype          */
#define _SQLDT_16BIT_S    130   /* 16 bit signed binary number      */
                                /* SMALLINT, NUMERIC(1-4, <scale>)  */
#define _SQLDT_16BIT_U    131   /* 16 bit unsigned binary number    */
                                /* unsigned NUMERIC(1-4, <scale>)   */
#define _SQLDT_32BIT_S    132   /* 32 bit signed binary number      */
                                /* INTEGER, NUMERIC(5-9, <scale>)   */
#define _SQLDT_32BIT_U    133   /* 32 bit unsigned binary number    */
                                /* unsigned NUMERIC(5-9, <scale>)   */
#define _SQLDT_64BIT_S    134   /* 64 bit signed binary number      */
                                /* LARGEINT, NUMERIC(10-18,<scale>) */
#define _SQLDT_TDM_REAL   140   /* 32 bit TANDEM FLOAT              */
#define _SQLDT_TDM_DOUBLE 141   /* 64 bit TANDEM FLOAT              */
#define _SQLDT_IEEE_REAL  142   /* 32 bit IEEE FLOAT (SQL/MX only)  */
#define _SQLDT_IEEE_DOUBLE 143  /* 64 bit IEEE FLOAT (SQL/MX only)  */
#define _SQLDT_DEC_U      150   /* DECIMAL datatype: unsigned       */
#define _SQLDT_DEC_LSS    151   /* DECIMAL datatype:                */
                                /* leading sign is separate         */
#define _SQLDT_DEC_LSE    152   /* DECIMAL datatype:                */
                                /* leading sign is embedded         */
#define _SQLDT_DEC_TSS    153   /* DECIMAL datatype:                */
                                /* trailing sign separate           */
#define _SQLDT_DEC_TSE    154   /* DECIMAL datatype:                */
                                /* trailing sign embedded           */
#define _SQLDT_NUM_BIG_U  155   /* BigNum unsigned NUMERIC datatype */
                                /* NUMERIC(N) where N > 9           */
#define _SQLDT_NUM_BIG_S  156   /* BigNum signed NUMERIC datatype   */
                                /* NUMERIC(N) where N > 18          */

#define _SQLDT_BLOB       160   /* BLOB datatype                    */
#define _SQLDT_CLOB       161   /* CLOB datatype                    */

#define _SQLDT_DATETIME   192   /* DATETIME datatype                */

/*
 * INTERVAL datatype:
 */
#define _SQLDT_INT_Y_Y    195     /* YEAR TO YEAR         */
#define _SQLDT_INT_MO_MO  196     /* MONTH TO MONTH       */
#define _SQLDT_INT_Y_MO   197     /* YEAR TO MONTH        */
#define _SQLDT_INT_D_D    198     /* DAY TO DAY           */
#define _SQLDT_INT_H_H    199     /* HOUR TO HOUR         */
#define _SQLDT_INT_D_H    200     /* DAY TO HOUR          */
#define _SQLDT_INT_MI_MI  201     /* MINUTE TO MINUTE     */
#define _SQLDT_INT_H_MI   202     /* HOUR TO MINUTE       */
#define _SQLDT_INT_D_MI   203     /* DAY TO MINUTE        */
#define _SQLDT_INT_S_S    204     /* SECOND TO SECOND     */
#define _SQLDT_INT_MI_S   205     /* MINUTE TO SECOND     */
#define _SQLDT_INT_H_S    206     /* HOUR TO SECOND       */
#define _SQLDT_INT_D_S    207     /* DAY TO SECOND        */
#define _SQLDT_INT_F_F    208     /* FRACTION TO FRACTION */
#define _SQLDT_INT_S_F    209     /* SECOND TO FRACTION   */
#define _SQLDT_INT_MI_F   210     /* MINUTE TO FRACTION   */
#define _SQLDT_INT_H_F    211     /* HOUR TO FRACTION     */
#define _SQLDT_INT_D_F    212     /* DAY TO FRACTION      */

#endif /* ifndef _SQLDT_ASCII_F */


/* constant char strings that can be used to indicate charset sets for
   object and module names (from common/charinfo.cpp)
*/
#define MAX_CHAR_SET_STRING_LENGTH 128


/* specifies a particular statement information item in the diagnostics area */
enum SQLDIAG_STMT_INFO_ITEM_ID {

  /* ANSI */
  SQLDIAG_NUMBER        =    1, /* (numeric) number of conditions stored    */
  SQLDIAG_MORE          =    2, /* (string ) Y = all conditions not stored  */
  SQLDIAG_COMMAND_FUNC  =    3, /* (string ) type of statement executed     */
  SQLDIAG_DYNAMIC_FUNC  =    4, /* (string ) type of prepared stmt executed */
  SQLDIAG_ROW_COUNT     =    5, /* (numeric) number of rows affected        */

  /* SQL/MX */
  SQLDIAG_AVERAGE_STREAM_WAIT  =  101, /* (numeric) avg wait time for stream */
  SQLDIAG_ROWSET_ROW_COUNT     =  102, /* (numeric) array containing number 
				       of rows affected by each rowset row  */

  /* SQL/MP */
  SQLDIAG_COST          =  201, /* (numeric) estimated query cost           */
  SQLDIAG_FIRST_FSCODE  =  202, /* (numeric) first file system error        */
  SQLDIAG_LAST_FSCODE   =  203, /* (numeric) last file system error         */
  SQLDIAG_LAST_SYSKEY   =  204  /* (numeric) SYSKEY of last record inserted */
};

/* specifies a particular condition information item in the diagnostics area */
enum SQLDIAG_COND_INFO_ITEM_ID {

  /* ANSI */
  SQLDIAG_COND_NUMBER   =    1, /* (numeric) condition number               */
  SQLDIAG_RET_SQLSTATE  =    2, /* (string ) returned SQLSTATE              */
  SQLDIAG_CLASS_ORIG    =    3, /* (string ) class origin, e.g. ISO 9075    */
  SQLDIAG_SUBCLASS_ORIG =    4, /* (string ) subclass origin, e.g. ISO 9075 */
  SQLDIAG_SERVER_NAME   =    5, /* (string ) SQL server name                */
  SQLDIAG_CONNECT_NAME  =    6, /* (string ) connection name                */
  SQLDIAG_CONSTR_CAT    =    7, /* (string ) constraint catalog name        */
  SQLDIAG_CONSTR_SCHEMA =    8, /* (string ) constraint schema name         */
  SQLDIAG_CONSTR_NAME   =    9, /* (string ) constraint name                */
  SQLDIAG_CATALOG_NAME  =   10, /* (string ) catalog name                   */
  SQLDIAG_SCHEMA_NAME   =   11, /* (string ) schema name                    */
  SQLDIAG_TABLE_NAME    =   12, /* (string ) table name                     */
  SQLDIAG_COLUMN_NAME   =   13, /* (string ) column name                    */
  SQLDIAG_CURSOR_NAME   =   14, /* (string ) cursor name                    */
  SQLDIAG_MSG_TEXT      =   15, /* (string ) message text                   */
  SQLDIAG_MSG_LEN       =   16, /* (numeric) message length in characters   */
  SQLDIAG_MSG_OCTET_LEN =   17, /* (numeric) message length in bytes        */
  SQLDIAG_TRIGGER_CAT   =   18, /* (string ) trigger catalog name           */
  SQLDIAG_TRIGGER_SCHEMA =  19, /* (string ) trigger schema name            */
  SQLDIAG_TRIGGER_NAME   =  20, /* (string ) trigger name                   */ 

  /* ODBC */
  SQLDIAG_COLUMN_NUMBER =  101, /* (numeric) column number                  */
  SQLDIAG_NATIVE        =  102, /* (numeric) native error code              */
  SQLDIAG_ROW_NUMBER    =  103, /* (numeric) row number                     */

  /* SQL/MP */
  SQLDIAG_SOURCE_FILE   =  201, /* (string ) source file name               */
  SQLDIAG_LINE_NUMBER   =  202, /* (numeric) source code line number        */
  SQLDIAG_SUBSYSTEM_ID  =  203, /* (string ) component that issued error    */
  SQLDIAG_SQLCODE       =  204, /* (numeric) SQLCODE of this condition      */
  SQLDIAG_NSK_CODE      =  205 /* (numeric) NSK code FExxx from NSK/FS/DP2 */
};

/* struct to specify one condition information item of a diagnostics entry */
typedef struct {
  Int32 item_id; /* item id (SQLDIAG_COND_INFO_ITEM_ID) */
  Int32 cond_number_desc_entry;  /* cond. num's input descriptor entry num   */
} SQLDIAG_COND_INFO_ITEM;

/* struct to hold one item value of a diagnostic condition */
typedef struct {
  /* which condition and which item in that condition */ 
  SQLDIAG_COND_INFO_ITEM item_id_and_cond_number;   
  /* numeric value or length of string        */
  Int32 * num_val_or_len;  
  /* string value (if not a numeric value)    */          
  char * string_val;   
} SQLDIAG_COND_INFO_ITEM_VALUE;

/* struct to return query cost information to caller after prepare of a stmt */
typedef struct {
  double cpuTime;
  double ioTime;
  double msgTime;
  double idleTime;
  double numSeqIOs;
  double numRandIOs;
  double totalTime;
  double cardinality;
  double estimatedTotalMem;
  short  resourceUsage;
  short maxCpuUsage;
} SQL_QUERY_COST_INFO;

#define COMPILER_ID_LEN   28
#define COMPILE_INFO_LEN  4096
typedef struct {        
  _int64 compileStartTime;
  _int64 compileEndTime;  
  char compilerId[COMPILER_ID_LEN];
  _int64 cmpCpuTotal;
  _int64 cmpCpuBinder;
  _int64 cmpCpuNormalizer;
  _int64 cmpCpuAnalyzer;
  _int64 cmpCpuOptimizer;
  _int64 cmpCpuGenerator;
  UInt32 metadataCacheHits;
  UInt32 metadataCacheLookups;
  Int32 queryCacheState;
  UInt32 histogramCacheHits;
  UInt32 histogramCacheLookups;
  _int64 stmtHeapSize;
  _int64 cxtHeapSize;
  Int32  optTasks;
  Int32  optContexts;
  short isRecompile;  
  char compileInfo[COMPILE_INFO_LEN];  
  Int32 compileInfoLen;
} SQL_COMPILATION_STATS_DATA;

/* struct to return details about a query after prepare. 
   Will be used by caller(mxcs/wms) to determine how/when/if to run the 
   query */
typedef struct {
  UInt32 affinityNumber;
  Int32 dop; /* degree of parallel execution */
  short xnNeeded;
  short mandatoryCrossProduct;
  short missingStats;
  short numOfJoins;
  short fullScanOnTable;
  short highDp2MxBufferUsage;
  double rowsAccessedForFullScan;
  double dp2RowsAccessed;
  double dp2RowsUsed;
  SQL_COMPILATION_STATS_DATA compilationStats;
  unsigned short statsCollectionType;    /* see SQLSTATS_TYPE */
  unsigned short numOfUdrs;
  unsigned short numOfBmos;
  unsigned short overflowMode;
  double overflowSize;
  short queryType;
  short subqueryType;
  float bmoMemLimitPerNode;
  float estBmoMemPerNode;
  char filler[20];
} SQL_QUERY_COMPILER_STATS_INFO;

/* struct to hold statistics to be returned. */
typedef struct {
  _int64 prepareTime;
  _int64 fixupTime;
  _int64 freeupTime;
  _int64 returnedRowsIOTime;
  _int64 elapsedTime;
  _int64 rowsAffected;
  short compilerCacheHit;
  short executorCacheHit;
} SQL_QUERY_STATISTICS;

/* specifies an SQL transaction command */
enum SQLTRANS_COMMAND {
  /* The only commands currently supported are transaction       */
  /* status and quiesce (prepare for a REPLY call).              */
  /* Use static SQL or a dynamic prepare or execute immediate to */
  /* perform all other SQL transaction statements.               */
  SQLTRANS_BEGIN            =    1, 
  SQLTRANS_COMMIT           =    2, 
  SQLTRANS_ROLLBACK         =    3,
  /* SQLTRANS_ROLLBACK_WAITED  =    4, */
  SQLTRANS_STATUS           =    5,
  /* SQLTRANS_SET              =    6, */
  SQLTRANS_QUIESCE          =    7,
  /* currently, called only by mxci after a BREAK key is hit
     to abort any implicit transactions started by cli */
  SQLTRANS_ROLLBACK_IMPLICIT_XN = 8,

  /* inherit the global transaction and make it the current xn */
  SQLTRANS_INHERIT          = 10,

  SQLTRANS_SUSPEND          = 11,
  SQLTRANS_RESUME           = 12,
};

/* specifies the type/format of an AUTHID */
enum SQLAUTHID_TYPE {
  SQLAUTHID_TYPE_ASCII_USERNAME = 7777,
  SQLAUTHID_TYPE_ASCII_USERROLE = 7799,
  SQLAUTHID_TYPE_ASCII_SID      = 8888,
  SQLAUTHID_TYPE_INVALID        = 9999
};

/* struct to specify an array of pointer pairs without using a va list.*/
struct SQLCLI_PTR_PAIRS {
  void * var_ptr; /* pointer to the data variable */
  void * ind_ptr; /* pointer to indicator variable; -1 is NULL */
};

/* struct to specify an array of quad fields without using a va list. */
struct SQLCLI_QUAD_FIELDS {
  Int32  var_layout; /* data variable layout size */
  void * var_ptr;    /* pointer to the data variable */
  Int32  ind_layout; /* indicator variable layout size */
  void * ind_ptr;    /* pointer to indicator variable; -1 is NULL */
};

/* For the GetStmtAttr and SetStmtAttr interfaces.  */
enum SQLATTRCURSOR_TYPE {
  SQL_READONLY_CURSOR = 0,
  SQL_UPDATABLE_CURSOR = 1
};

enum SQLATTR_TYPE {
  SQL_ATTR_CURSOR_HOLDABLE = -3,
  SQL_ATTR_INPUT_ARRAY_MAXSIZE = -2,
  SQL_ATTR_QUERY_TYPE = -4,
  SQL_ATTR_ROWSET_ATOMICITY = -5,
  SQL_ATTR_NOT_ATOMIC_FAILURE_LIMIT = -6,
  SQL_ATTR_XN_NEEDED = -7,
  SQL_ATTR_UNIQUE_STMT_ID = -8,
  SQL_ATTR_UNIQUE_QUERY_ID = -8,
  SQL_ATTR_MAX_RESULT_SETS = -9,
  SQL_ATTR_UNIQUE_STMT_ID_NO_DIAGS = -10,
  SQL_ATTR_RS_PROXY_SYNTAX = -11,
  SQL_ATTR_CONSUMER_QUERY_TEXT = -12,
  SQL_ATTR_CONSUMER_CPU = -13,
  SQL_ATTR_COPY_STMT_ID_TO_DIAGS = -14,
  SQL_ATTR_PARENT_QID = -15,
  SQL_ATTR_CURSOR_UPDATABLE = -16,
  SQL_ATTR_SUBQUERY_TYPE = -17
};

/* A container for a single statement attribute. For use with
   the SQL_EXEC_GetStmtAttrs function that returns multiple
   attributes in one call. */
typedef struct {
  Int32 attr_type;      /* IN:    which attr, from the         */
                        /*        SQLATTR_TYPE enum            */
  Int32 index;          /* IN:    optional index if attr       */
                        /*        is a collection              */
  Int32 *numeric_value; /* INOUT: if attr is numeric, address  */
                        /*        of target buffer for the     */
                        /*        attr value                   */
  char *string_value;   /* INOUT: if attr is string, address   */
                        /*        of target buffer for the     */
                        /*        attr value                   */
  Int32 max_string_len; /* IN:    if attr is string, max len   */
                        /*        of buffer pointed to by      */
                        /*        string_val                   */
  Int32 *len_of_item;   /* INOUT OPTIONAL: if attr is string,  */
                        /*        address of target buffer to  */
                        /*        hold actual len of item      */
                        /*        returned. If error returned  */
                        /*        because string_value buffer  */
                        /*        too small then len_of_item   */
                        /*        holds the required size      */
} SQLSTMT_ATTR;

enum SQLATTRHOLDABLE_TYPE {
  SQL_NONHOLDABLE = 0,
  SQL_HOLDABLE    = 1
};

enum SESSIONATTR_TYPE {
  SESSION_ATTR_ID = 1,
  SESSION_PARENT_QID = 2,
  SESSION_DATABASE_USER_NAME = 3,
  SESSION_DATABASE_USER_ID = 4,
  SESSION_SESSION_USER_ID = 5,
  SESSION_DATABASE_USER = 6,
  SESSION_EXTERNAL_USER_NAME = 7
};

/* this list and their values must be the same as the
   enum QueryType in comexe/ComTdbRoot.h */
enum SQLATTRQUERY_TYPE {
  SQL_OTHER = -1,
  SQL_UNKNOWN = 0,
  SQL_SELECT_UNIQUE = 1,
  SQL_SELECT_NON_UNIQUE = 2,
  SQL_INSERT_UNIQUE = 3,
  SQL_INSERT_NON_UNIQUE = 4,
  SQL_UPDATE_UNIQUE = 5,
  SQL_UPDATE_NON_UNIQUE = 6,
  SQL_DELETE_UNIQUE = 7,
  SQL_DELETE_NON_UNIQUE = 8,
  SQL_CONTROL = 9,
  SQL_SET_TRANSACTION = 10,
  SQL_SET_CATALOG = 11,
  SQL_SET_SCHEMA = 12,
  SQL_CALL_NO_RESULT_SETS = 13,
  SQL_CALL_WITH_RESULT_SETS = 14,
  SQL_SP_RESULT_SET = 15,
  SQL_INSERT_RWRS = 16,

  /* same value as RWRS insert. identifier rowset_sidetree is obsolete and
     will be removed in future when no callers use this identifier.*/
  SQL_INSERT_ROWSET_SIDETREE = 16,

  /* utilities, like DUP, POPULATE, etc...implemented in catman. See
     sqlcomp/parser.cpp for complete list */
  SQL_CAT_UTIL = 17,

  /* complex util statements implemented in executor by converting them
     to multiple sql queries. See optimizer/RelMisc.h, class ExeUtilExpr */
  SQL_EXE_UTIL = 18,
  /* Used to denote unload statements, a fast and parallel 
     approach to extract data from SQL tables into extrenal files */
  SQL_SELECT_UNLOAD = 19
  
  

};

enum SQLATTR_SUBQUERY_TYPE
{
  SQL_STMT_NA = 0, 
  SQL_STMT_CTAS = 1,
  SQL_STMT_GET_STATISTICS = 3,
  /* describe type of statements like showcontrol, showplan */
  SQL_DESCRIBE_QUERY = 4,
  SQL_DISPLAY_EXPLAIN = 5,
  SQL_STMT_HBASE_LOAD = 6,
  SQL_STMT_HBASE_UNLOAD = 7,
  /* Used to denote lob access */
  SQL_LOB_EXTRACT = 8,
  SQL_LOB_UPDATE_UTIL = 9
};


enum SQLATTRATOMIC_TYPE {
  SQL_NOT_SPECIFIED = 0,
  SQL_ATOMIC = 1,
  SQL_NOT_ATOMIC = 2
};

enum SQLSTMT_STATE_TYPE {
  SQLSTMT_STATE_INITIAL = 0,
  SQLSTMT_STATE_OPEN = 1,
  SQLSTMT_STATE_EOF = 2,
  SQLSTMT_STATE_CLOSE = 3,
  SQLSTMT_STATE_DEALLOCATED = 4,
  SQLSTMT_STATE_FETCH = 5,
  SQLSTMT_STATE_CLOSE_TABLES = 6,
  SQLSTMT_STATE_PREPARE = 7,
  SQLSTMT_STATE_PROCESS_ENDED = 8,
  SQLSTMT_RELEASE_TRANS = 9,
  SQLSTMT_SUSPENDED = 10,
  SQLSTMT_STATE_UNKNOWN
};

enum SQLSTATS_TYPE {
  SQLCLI_SAME_STATS    = 999,
  SQLCLI_NO_STATS      = 0,
  /* SQLCLI_DEFAULT_STATS means the statistics is merged based on the statistics view type */
  SQLCLI_DEFAULT_STATS = 0, 
  SQLCLI_ACCUMULATED_STATS = 2, 
  SQLCLI_PERTABLE_STATS   = 3,  
  SQLCLI_ALL_STATS     = 4,
  SQLCLI_OPERATOR_STATS = 5,
  SQLCLI_CPU_OFFENDER_STATS = 6,
  SQLCLI_QID_DETAIL_STATS = 7,
  SQLCLI_SE_OFFENDER_STATS = 8,
  SQLCLI_DISK_OFFENDER_STATS = SQLCLI_SE_OFFENDER_STATS,
  SQLCLI_RMS_INFO_STATS = 9,
  SQLCLI_PROGRESS_STATS = 10,
  SQLCLI_ET_OFFENDER_STATS = 11,
  SQLCLI_RMS_CHECK_STATS = 12,
  SQLCLI_MEM_OFFENDER_STATS = 13,
  SQLCLI_PROCESS_STATS = 14
};

/* For the GetUniqueQueryIdAttrs interfaces.  */

enum UNIQUEQUERYID_ATTR_TYPE {
  /* segment number                                       */
  UNIQUEQUERYID_SEGMENTNUM   = 0,  

  /* segment name: max 10 bytes                           */
  UNIQUEQUERYID_SEGMENTNAME  = 1,  

  /* cpu number                                           */
  UNIQUEQUERYID_CPU          = 2,  

  /* pin of master exe process                            */
  UNIQUEQUERYID_PIN          = 3,  

  /* starttime of master exe process                      */
  UNIQUEQUERYID_EXESTARTTIME = 4,  

  /* unique session number                                */
  UNIQUEQUERYID_SESSIONNUM   = 5,
  
  /* null terminated user name: max 32 bytes              */
  UNIQUEQUERYID_USERNAME     = 6,  

  /* null terminated session name: max 24 bytes           */
  UNIQUEQUERYID_SESSIONNAME  = 7,  

  /* unique query num within a process                    */
  UNIQUEQUERYID_QUERYNUM     = 8,  

  /* null terminated user statement name: max 110 bytes   */
  UNIQUEQUERYID_STMTNAME     = 9,   

  /* null terminated session id:          max 104 bytes   */
  UNIQUEQUERYID_SESSIONID    = 10
};

typedef struct {
  Int32 attr_type;           /* IN: which attr (UNIQUEQUERYID_ATTR_TYPE)      */
  _int64 num_val_or_len;     /* IN: if string value, max length of string 
				    to return in string_val
                              Note: string_val buffer size should be one more than
                                     num_val_or_len to allow for a null terminator
                                OUT: if numeric value, the value. 
                                     if string value, the actual length of string_val returned */
  char * string_val;         /* OUT: if string value, null terminated string */
} UNIQUEQUERYID_ATTR;
  
#define MAX_TDB_NAME_LEN		35

enum STATS_REQ_TYPE {
  SQLCLI_STATS_REQ_NONE = -1,
  SQLCLI_STATS_REQ_STMT = 0,
  SQLCLI_STATS_REQ_CPU = 1,
  SQLCLI_STATS_REQ_PID = 2,
  SQLCLI_STATS_REQ_QID = 3,
  SQLCLI_STATS_REQ_QID_CURRENT = 4,
  SQLCLI_STATS_REQ_CPU_OFFENDER = 5,
  SQLCLI_STATS_REQ_QID_DETAIL = 6,
  SQLCLI_STATS_REQ_SE_OFFENDER = 7,
  SQLCLI_STATS_REQ_DISK_OFFENDER = SQLCLI_STATS_REQ_SE_OFFENDER,
  SQLCLI_STATS_REQ_RMS_INFO = 8,
  SQLCLI_STATS_REQ_ET_OFFENDER = 9,
  SQLCLI_STATS_REQ_MEM_OFFENDER = 10,
  SQLCLI_STATS_REQ_PROCESS_INFO = 11,
  SQLCLI_STATS_REQ_QID_INTERNAL = 12
};

enum STATS_SUB_REQ_TYPE {
  SQLCLI_STATS_REQ_QUERIES_IN_SQL = 1,
  SQLCLI_STATS_REQ_QUERIES_IN_CLIENT = 2,
  SQLCLI_STATS_REQ_INACTIVE_QUERIES = 3,
  SQLCLI_STATS_REQ_DEAD_QUERIES = 4,
  SQLCLI_STATS_REQ_UNMONITORED_QUERIES = 5, 
  SQLCLI_STATS_REQ_SE_ROOT = 6,
  SQLCLI_STATS_REQ_SE_OPERATOR = 7,
  SQLCLI_STATS_REQ_RMS_CHECK = 11,
  SQLCLI_STATS_REQ_MEM_HIGH_WM = 12,
  SQLCLI_STATS_REQ_MEM_ALLOC = 13,
  SQLCLI_STATS_REQ_PFS_USE = 14,
  SQLCLI_STATS_REQ_ACTIVE_QUERIES = 15,
  SQLCLI_STATS_REQ_QUERIES_IN_COMPILE = 16
};

enum SCRATCH_OVERFLOW_MODE {
  SQLCLI_OFM_DISK_TYPE = 0,
  SQLCLI_OFM_SSD_TYPE = 1,
  SQLCLI_OFM_MMAP_TYPE = 2

};

typedef struct {
  short tdb_id;
  short stats_type;
  char  tdb_name[MAX_TDB_NAME_LEN+1];
} SQLSTATS_DESC;

/* SQLSTATS_DESC stats type returned for various SQLSTATS_TYPE
  SQLSTATS_TYPE             Returned SQLSTATS_DESC_STATS_TYPEs

  SQLCLI_ACCUMULATED_STATS  SQLSTATS_DESC_MASTER_STATS
                            SQLSTATS_DESC_MEAS_STATS

  SQLCLI_PERTABLE_STATS     SQLSTATS_DESC_MASTER_STATS
                            SQLSTATS_DESC_ROOT_OPER_STATS
                            SQLSTATS_DESC_PERTABLE_STATS as many as the no. of tables in the query
                            
  SQLCLI_OPERATOR_STATS     SQLSTATS_DESC_MASTER_STATS
                            SQLSTATS_DESC_ROOT_OPER_STATS for every ESP root or master root
                            SQLSTATS_DESC_PERTABLE_STATS for all DP2 operators
                            SQLSTATS_DESC_PERTABLE_STATS for all PA operators
                            SQLSTATS_DESC_BMO_STATS for sort, hash join and hash group by operators
                            SQLSTATS_DESC_UDR_BASE_STATS for UDR
                            SQLSTATS_DESC_OPER_STATS for the rest
                            
*/
enum SQLSTATS_DESC_STATS_TYPE {
  SQLSTATS_DESC_OPER_STATS = 0,
  SQLSTATS_DESC_ROOT_OPER_STATS = 1,
  SQLSTATS_DESC_PARTITION_ACCESS_STATS = 4,
  SQLSTATS_DESC_GROUP_BY_STATS = 5,
  SQLSTATS_DESC_HASH_JOIN_STATS = 6,
  SQLSTATS_DESC_PROBE_CACHE_STATS = 7,
  SQLSTATS_DESC_ESP_STATS = 8,
  SQLSTATS_DESC_SPLIT_TOP_STATS = 9,
  SQLSTATS_DESC_MEAS_STATS = 10,
  SQLSTATS_DESC_PERTABLE_STATS = 11,
  SQLSTATS_DESC_SORT_STATS = 12,
  SQLSTATS_DESC_UDR_STATS = 13,
  SQLSTATS_DESC_NO_OP = 14,  
  SQLSTATS_DESC_MASTER_STATS = 15 ,
  SQLSTATS_DESC_RMS_STATS = 16,
  SQLSTATS_DESC_BMO_STATS = 17,
  SQLSTATS_DESC_UDR_BASE_STATS = 18,
  SQLSTATS_DESC_REPLICATE_STATS = 19,
  SQLSTATS_DESC_REPLICATOR_STATS = 20,
  SQLSTATS_DESC_FAST_EXTRACT_STATS = 21,
  SQLSTATS_DESC_REORG_STATS = 22,
  SQLSTATS_DESC_SE_STATS = 23,
  SQLSTATS_DESC_HDFSSCAN_STATS = 23,
  SQLSTATS_DESC_HBASE_ACCESS_STATS = 23,
  SQLSTATS_DESC_PROCESS_STATS = 25,
};


enum SQLSTATS_ITEM_ID {
/* SQLSTATS_ITEM_ID for SQLSTATS_DESC_MASTER_STATS */
  SQLSTATS_QUERY_ID = 0,
  SQLSTATS_COMP_START_TIME = 1,
  SQLSTATS_COMP_END_TIME = 2,
  SQLSTATS_COMP_TIME = 3,
  SQLSTATS_EXECUTE_START_TIME  = 4,
  SQLSTATS_FIRST_ROW_RET_TIME = 5,
  SQLSTATS_EXECUTE_END_TIME = 6,
  SQLSTATS_EXECUTE_TIME = 7,
  SQLSTATS_FIXUP_TIME = 8,
  SQLSTATS_STMT_STATE = 9,
  SQLSTATS_ROWS_AFFECTED = 10,
  SQLSTATS_SQL_ERROR_CODE = 11,
  SQLSTATS_STATS_ERROR_CODE = 12,
  SQLSTATS_QUERY_TYPE = 13,
  SQLSTATS_PARENT_QUERY_ID = 14,
  SQLSTATS_NUM_SQLPROCS = 15,
  SQLSTATS_NUM_CPUS = 16,
  SQLSTATS_SOURCE_STR = 17,
  SQLSTATS_MASTER_PRIORITY = 18,
  SQLSTATS_TRANSID = 19,
  SQLSTATS_CHILD_QUERY_ID = 200,
  SQLSTATS_RECLAIM_SPACE_COUNT = 201,
  SQLSTATS_SUBQUERY_TYPE = 202,
  SQLSTATS_PARENT_QUERY_SYSTEM = 203,
  SQLSTATS_EXECUTE_COUNT = 204,
  SQLSTATS_EXECUTE_TIME_MIN = 205,
  SQLSTATS_EXECUTE_TIME_MAX = 206,
  SQLSTATS_EXECUTE_TIME_AVG = 207,
/* The following 3 enums are moved from operator level stats
  to here, however, the enum values are not changed to provide
  backward compatibility */
  SQLSTATS_AQR_LAST_ERROR= 86,
  SQLSTATS_AQR_NUM_RETRIES=87,
  SQLSTATS_AQR_DELAY_BEFORE_RETRY=88,
/* SQLSTATS_ITEM_ID for SQLSTATS_DESC_MASTER_STATS and SQLSTATS_DESC_PERTABLE_STATS */
  SQLSTATS_EST_ROWS_ACCESSED = 20,
  SQLSTATS_EST_ROWS_USED = 21,
  SQLSTATS_SOURCE_STR_LEN = 22,
  SQLSTATS_ROWS_RETURNED = 23,
  SQLSTATS_ROWS_RETURNED_TIME = 24,
/* SQLSTATS_ITEM_ID for SQLSTATS_DESC_MEAS_STATS and SQLSTATS_DESC_PERTABLE_STATS */
  SQLSTATS_ACT_ROWS_ACCESSED = 30,
  SQLSTATS_ACT_ROWS_USED = 31,
  SQLSTATS_SE_IOS = 32,
  SQLSTATS_SE_IO_BYTES = 33,
  SQLSTATS_SE_IO_MAX_TIME = 34,
  SQLSTATS_HBASE_IOS = 40,
  SQLSTATS_HBASE_IO_BYTES = 41,
  SQLSTATS_HBASE_IO_ELAPSED_TIME = 42,
  SQLSTATS_HBASE_IO_MAX_TIME = 43,
  SQLSTATS_HIVE_IOS = 44,
  SQLSTATS_HIVE_IO_BYTES = 45,
  SQLSTATS_HIVE_IO_ELAPSED_TIME = 46,
  SQLSTATS_HIVE_IO_MAX_TIME = 47,

  SQLSTATS_SQL_CPU_BUSY_TIME = 50,
  SQLSTATS_SQL_SPACE_ALLOC = 51,
  SQLSTATS_SQL_SPACE_USED = 52,
  SQLSTATS_SQL_HEAP_ALLOC = 53,
  SQLSTATS_SQL_HEAP_USED = 54,
  SQLSTATS_OPENS = 59,
  SQLSTATS_OPEN_TIME = 60,
  SQLSTATS_PROCESS_CREATED = 61,
  SQLSTATS_PROCESS_CREATE_TIME = 62,
  SQLSTATS_REQ_MSG_CNT = 63,
  SQLSTATS_REQ_MSG_BYTES = 64,
  SQLSTATS_REPLY_MSG_CNT = 65,
  SQLSTATS_REPLY_MSG_BYTES = 66,
  SQLSTATS_PHYS_MEM_IN_USE = 67,
  SQLSTATS_SQL_MAX_WAIT_TIME = 68,
  SQLSTATS_SQL_AVG_WAIT_TIME = 69,
  SQLSTATS_SQL_HEAP_WM = 71,

/* SQLSTATS_ITEM_ID for SQLSTATS_DESC_PERTABLE_STATS */
  SQLSTATS_TABLE_ANSI_NAME = 70,
/* SQLSTATS_ITEM_ID for Operator level Stats */
  SQLSTATS_EXPLAIN_NODE_ID = 80,
  SQLSTATS_NUM_CALLS = 81,
  SQLSTATS_TDB_ID = 82,
  SQLSTATS_TDB_NAME = 83,
  SQLSTATS_LEFT_CHILD = 84,
  SQLSTATS_RIGHT_CHILD = 85,
  /* enum 86, 87 and 88 are moved to master stats */
  SQLSTATS_PARENT_TDB_ID = 89,
  SQLSTATS_FRAG_NUM = 90,
  SQLSTATS_OPER_CPU_TIME =91,
  SQLSTATS_INST_NUM = 92,
  SQLSTATS_INST_ID = 93,
  SQLSTATS_DETAIL = 94,
  SQLSTATS_DOP = 95,
/* SQLSTATS_ITEM_ID for RMS_STATS */
  SQLSTATS_RMS_VER = 100,
  SQLSTATS_NODE_NAME = 101,
  SQLSTATS_CPU = 102,
  SQLSTATS_SSCP_PID = 103,
  SQLSTATS_SSCP_PRIORITY = 104,
  SQLSTATS_SSCP_TIMESTAMP = 105,
  SQLSTATS_SSMP_PID = 106,
  SQLSTATS_SSMP_PRIORITY = 107,
  SQLSTATS_SSMP_TIMESTAMP = 108,
  SQLSTATS_STORE_SRC_LEN = 109,
  SQLSTATS_RMS_ENV_TYPE = 110,
  SQLSTATS_STATS_HEAP_ALLOC = 111,
  SQLSTATS_STATS_HEAP_USED = 112,
  SQLSTATS_STATS_HEAP_HIGH_WM = 113,
  SQLSTATS_PROCESSES_REGD = 114,
  SQLSTATS_QUERIES_REGD = 115,
  SQLSTATS_RMS_SEMAPHORE_PID = 116,
  SQLSTATS_SSCPS_OPENED = 117,
  SQLSTATS_SSCPS_DELETED_OPENS = 118,
  SQLSTATS_LAST_GC_TIME = 119,
  SQLSTATS_QUERIES_GCED_IN_LAST_RUN = 120,
  SQLSTATS_TOTAL_QUERIES_GCED = 121,
  SQLSTATS_SSMP_REQ_MSG_CNT = 122,
  SQLSTATS_SSMP_REQ_MSG_BYTES = 123,
  SQLSTATS_SSMP_REPLY_MSG_CNT = 124,
  SQLSTATS_SSMP_REPLY_MSG_BYTES = 125,
  SQLSTATS_SSCP_REQ_MSG_CNT = 126,
  SQLSTATS_SSCP_REQ_MSG_BYTES = 127,
  SQLSTATS_SSCP_REPLY_MSG_CNT = 128,
  SQLSTATS_SSCP_REPLY_MSG_BYTES = 129,
  SQLSTATS_RMS_STATS_RESET_TIMESTAMP = 130,
  SQLSTATS_RMS_STATS_NUM_SQL_SIK = 131,
  SQLSTATS_PROCESS_STATS_HEAPS = 132,
  SQLSTATS_RMS_CONFIGURED_PID_MAX = 133,
/* SQLSTATS_ITEM_ID for BMO_STATS */
  SQLSTATS_BMO_HEAP_USED = 150,
  SQLSTATS_BMO_HEAP_ALLOC = 151,
  SQLSTATS_BMO_HEAP_WM = 152,
  SQLSTATS_BMO_SPACE_BUFFER_SIZE = 153,
  SQLSTATS_BMO_SPACE_BUFFER_COUNT = 154,
  SQLSTATS_SCRATCH_IO_TIME = 155,
  SQLSTATS_SCRATCH_IO_SIZE = 156,
  SQLSTATS_SCRATCH_FILE_COUNT = 157,
  SQLSTATS_SCRATCH_BUFFER_BLOCK_SIZE = 158,
  SQLSTATS_SCRATCH_BUFFER_BLOCKS_READ = 159,
  SQLSTATS_SCRATCH_BUFFER_BLOCKS_WRITTEN = 160,
  SQLSTATS_SCRATCH_OVERFLOW_MODE = 161,
  SQLSTATS_SCRATCH_READ_COUNT = 162,
  SQLSTATS_SCRATCH_WRITE_COUNT = 163,
  SQLSTATS_SCRATCH_IO_MAX_TIME = 164,
  SQLSTATS_BMO_EST_MEMORY = 165,
  SQLSTATS_BMO_PHASE = 166,
  SQLSTATS_INTERIM_ROW_COUNT = 167,
/* SQLSTATS_ITEM_ID for UDR_BASE_STATS */
  SQLSTATS_UDR_CPU_BUSY_TIME = 170,
  SQLSTATS_RECENT_REQ_TS = 171,
  SQLSTATS_RECENT_REPLY_TS = 172,
  SQLSTATS_UDR_SERVER_ID = 173,
  SQLSTATS_CANCEL_TIME_ID = 174,
  SQLSTATS_QUERY_SUSPENDED = 175,
  SQLSTATS_SUSPEND_TIME_ID = 176,
/* SQLSTATS_ITEM_ID for REPLICATE_STATS */
  SQLSTATS_REPL_ANSI_NAME = 180,
  SQLSTATS_REPL_SOURCE_SYSTEM = 181,
  SQLSTATS_REPL_TARGET_SYSTEM = 182,
  SQLSTATS_REPL_OBJECT_TYPE = 183,
  SQLSTATS_REPL_TYPE = 184,
  SQLSTATS_REPL_NUM_PARTNS = 185,
  SQLSTATS_REPL_PHASE0_START_TIME = 186,
  SQLSTATS_REPL_PHASE0_END_TIME = 187,
  SQLSTATS_REPL_PHASE0_ELAPSED_TIME = 188,
  SQLSTATS_REPL_PHASE1_START_TIME = 189,
  SQLSTATS_REPL_PHASE1_END_TIME = 190,
  SQLSTATS_REPL_PHASE1_ELAPSED_TIME = 191,
  SQLSTATS_REPL_PHASE2_START_TIME = 192,
  SQLSTATS_REPL_PHASE2_END_TIME = 193,
  SQLSTATS_REPL_PHASE2_ELAPSED_TIME = 194,
  SQLSTATS_REPL_PHASE3_START_TIME = 195,
  SQLSTATS_REPL_PHASE3_END_TIME = 196,
  SQLSTATS_REPL_PHASE3_ELAPSED_TIME = 197,
  SQLSTATS_REPL_PHASE4_START_TIME = 198,
  SQLSTATS_REPL_PHASE4_END_TIME = 199,
  SQLSTATS_REPL_PHASE4_ELAPSED_TIME = 220,
  SQLSTATS_REPL_PHASE5_START_TIME = 221,
  SQLSTATS_REPL_PHASE5_END_TIME = 222,
  SQLSTATS_REPL_PHASE5_ELAPSED_TIME = 223,
  SQLSTATS_REPL_PHASE6_START_TIME = 224,
  SQLSTATS_REPL_PHASE6_END_TIME = 225,
  SQLSTATS_REPL_PHASE6_ELAPSED_TIME = 226,
  SQLSTATS_REPL_ROWS_READ = 227,
  SQLSTATS_REPL_TOTAL_BLOCKS = 228,
  SQLSTATS_REPL_BLOCKS_REPLICATED = 229,
  SQLSTATS_REPL_PERCENT_DONE = 230,
  SQLSTATS_REPL_AVG_COMP_RATIO = 231,
  SQLSTATS_REPL_AVG_COMP_TIME = 232,
  SQLSTATS_REPL_AVG_UNCOMP_TIME = 233,
  SQLSTATS_REPL_STATUS = 234,
  SQLSTATS_REPL_SOURCE_FILE_NAME = 235,
  SQLSTATS_REPL_TARGET_FILE_NAME = 236,
  SQLSTATS_REPL_BLOCK_LEN = 237,
  SQLSTATS_REPL_TOTAL_COMPRESS_TIME = 238,
  SQLSTATS_REPL_TOTAL_COMPRESS_BYTES = 239,
  SQLSTATS_REPL_TOTAL_UNCOMPRESS_TIME = 240,
  SQLSTATS_REPL_TOTAL_UNCOMPRESS_BYTES = 241,
  SQLSTATS_REPL_CONCURRENCY = 242,
  SQLSTATS_REPL_COMPLETED_PARTNS = 243,
  SQLSTATS_REPL_BLOCKS_READ = 244,
  SQLSTATS_TOPN = 245
};

typedef struct {
    short  tdb_id;
    short  stats_type;
    short  statsItem_id; /* SQLSTATS_ITEM_ID */
    _int64 int64_value;
    double double_value;
    char   *str_value;
    Int32  str_max_len;
    Int32  str_ret_len;
    Int32  error_code;
} SQLSTATS_ITEM;


/* used in call to SQLCLI_Prepare2 */
enum PREPARE_FLAGS
{
  /* A standalone and not an explicitely PREPAREd query */
  PREPARE_STANDALONE_QUERY   = 0x0001,

  /* prepare being issued as part of an internal AQR */
  PREPARE_AUTO_QUERY_RETRY   = 0x0002,

  /* prepare for old style automatic recomp */
  PREPARE_RECOMP             = 0x0004,

  /* prepare should deallocate and reload cache in mxcmp */
  PREPARE_WITH_DECACHE       = 0x0008,

  /* prepare should not use query text cache */
  PREPARE_NO_TEXT_CACHE      = 0x0010,

  /* set when prepare is redriven for nowaited case */
  PREPARE_NOT_A_NEW_OPERATION = 0x0020,

  /* set when WMS monitoring is needed  */
  PREPARE_MONITOR_THIS_QUERY = 0x0040,

  /* set when embedded compiler needs to be called */
  PREPARE_USE_EMBEDDED_ARKCMP = 0x0080,

  /* set when we don't want the plan to go in the query cache */
  PREPARE_DONT_CACHE          = 0x0100 
};

/* used to put and get DDL redefinition invalidation keys */
typedef Int64 InvalidObjectUID;

/* used to put and get security invalidation keys */
typedef struct {
  UInt32 subject;
  UInt32 object;
} InvalidSecurityKey;

typedef struct {
  char  operation[2];
  char  filler[6];
  union {
    InvalidObjectUID ddlObjectUID;
    InvalidSecurityKey revokeKey;
  };
} SQL_QIKEY;

Int32  SQL_EXEC_AllocDesc (
	        /*INOUT*/ SQLDESC_ID * desc_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor);

Int32  SQL_EXEC_ALLOCDESC (
	        /*INOUT*/ SQLDESC_ID * desc_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor);

Int32  SQL_EXEC_AllocDescBasic (
	        /*INOUT*/ SQLDESC_ID * desc_id,
		/*IN OPTIONAL*/ Int32  max_entries);

Int32  SQL_EXEC_AssocFileNumber (
                /*IN*/ SQLSTMT_ID * statement_id,
	        /*IN*/ short        file_number);

Int32  SQL_EXEC_ASSOCFILENUMBER (
                /*IN*/ SQLSTMT_ID * statement_id,
	        /*IN*/ short        file_number);
Int32  SQL_EXEC_GetDiskMaxSize (
		/*IN*/ char *volname,
		/*OUT*/ Int64 *totalCapacity,
		/*OUT*/ Int64 *totalFreespace);
Int32  SQL_EXEC_GetListOfDisks (
	       	/*IN/OUT*/ char *diskBuf,
		/* OUT */ Int32 *numTSEs,
		/* OUT */ Int32 *maxTSELength,
		/* IN/OUT */ Int32 *diskBufLength
		);


Int32  SQL_EXEC_AllocStmt (
		/*INOUT*/ SQLSTMT_ID * new_statement_id,
		/*IN OPTIONAL*/ SQLSTMT_ID * cloned_statement);

Int32  SQL_EXEC_ALLOCSTMT (
		/*INOUT*/ SQLSTMT_ID * new_statement_id,
		/*IN OPTIONAL*/ SQLSTMT_ID * cloned_statement);

Int32  SQL_EXEC_AllocStmtForRS (
                /*IN*/ SQLSTMT_ID *callStmtId,
                /*IN*/ Int32  resultSetIndex,
                /*INOUT*/ SQLSTMT_ID *resultSetStmtId);

Int32  SQL_EXEC_ALLOCSTMTFORRS (
                /*IN*/ SQLSTMT_ID *callStmtId,
                /*IN*/ Int32  resultSetIndex,
                /*INOUT*/ SQLSTMT_ID *resultSetStmtId);

Int32  SQL_EXEC_ClearDiagnostics (/*IN*/ SQLSTMT_ID *statement_id);

Int32  SQL_EXEC_CLEARDIAGNOSTICS (/*IN*/ SQLSTMT_ID *statement_id);

Int32  SQL_EXEC_CLI_VERSION ();

Int32  SQL_EXEC_CloseStmt (
		/*IN*/ SQLSTMT_ID * statement_id);

Int32  SQL_EXEC_CLOSESTMT (
		/*IN*/ SQLSTMT_ID * statement_id);


Int32  SQL_EXEC_CreateContext(/*OUT*/ SQLCTX_HANDLE * context_handle,
			    /*IN OPTIONAL*/ char* sqlAuthId, 
			    /*IN OPTIONAL*/ Int32  suppressAutoXactStart);
  
Int32  SQL_EXEC_CREATECONTEXT(/*OUT*/ SQLCTX_HANDLE * context_handle,
			    /*IN OPTIONAL*/ char* sqlAuthId, 
			    /*IN OPTIONAL*/ Int32  suppressAutoXactStart);


Int32  SQL_EXEC_CurrentContext(/*OUT*/ SQLCTX_HANDLE * contextHandle);


Int32  SQL_EXEC_CURRENTCONTEXT(/*OUT*/ SQLCTX_HANDLE * contextHandle);


Int32  SQL_EXEC_DeleteContext(/*IN*/ SQLCTX_HANDLE contextHandle);


Int32  SQL_EXEC_DELETECONTEXT(/*IN*/ SQLCTX_HANDLE contextHandle);


Int32  SQL_EXEC_ResetContext(/*IN*/ SQLCTX_HANDLE contextHandle, /*IN*/ void *contextMsg);


Int32  SQL_EXEC_RESETCONTEXT(/*IN*/ SQLCTX_HANDLE contextHandle, /*IN*/ void *contextMsg);

Int32  SQL_EXEC_DeallocDesc (
		/*IN*/ SQLDESC_ID * desc_id );

Int32  SQL_EXEC_DEALLOCDESC (
		/*IN*/ SQLDESC_ID * desc_id );

Int32  SQL_EXEC_DeallocStmt (
		/*IN*/ SQLSTMT_ID * statement_id);

Int32  SQL_EXEC_DEALLOCSTMT (
		/*IN*/ SQLSTMT_ID * statement_id);

Int32  SQL_EXEC_DefineDesc (
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN* (SQLWHAT_DESC) */ Int32 what_descriptor,
		/*IN*/ SQLDESC_ID * sql_descriptor);

Int32 SQL_EXEC_DEFINEDESC (
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN* (SQLWHAT_DESC) */ Int32 what_descriptor,
		/*IN*/ SQLDESC_ID * sql_descriptor);

Int32 SQL_EXEC_DescribeStmt (
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN OPTIONAL*/ SQLDESC_ID * output_descriptor);

Int32 SQL_EXEC_DESCRIBESTMT (
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN OPTIONAL*/ SQLDESC_ID * output_descriptor);

Int32 SQL_EXEC_DisassocFileNumber(/*IN*/ SQLSTMT_ID * statement_id);

Int32 SQL_EXEC_DISASSOCFILENUMBER(/*IN*/ SQLSTMT_ID * statement_id);

Int32 SQL_EXEC_DropContext (
		/*IN*/ SQLCTX_HANDLE context_handle );

Int32 SQL_EXEC_DROPCONTEXT (
		/*IN*/ SQLCTX_HANDLE context_handle );

Int32 SQL_EXEC_Exec (
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
                ...);

Int32 SQL_EXEC_EXEC (
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
		/*IN*/ struct SQLCLI_PTR_PAIRS ptr_pairs[]);

Int32 SQL_EXEC_ExecClose (
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
                ...);

Int32 SQL_EXEC_EXECCLOSE (
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
		/*IN*/ struct SQLCLI_PTR_PAIRS ptr_pairs[]);

Int32 SQL_EXEC_ExecDirect(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN*/ SQLDESC_ID * sql_source,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
                ...);
Int32 SQL_EXEC_ExecDirect2(
               /*IN*/           SQLSTMT_ID * statement_id,
               /*IN*/           SQLDESC_ID * sql_source,
	       /*IN*/           Int32 prepFlags,
               /*IN  OPTIONAL*/ SQLDESC_ID * input_descriptor,
               /*IN*/                 Int32   num_ptr_pairs,
               ...
					  );
Int32 SQL_EXEC_EXECDIRECT (
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN*/ SQLDESC_ID * sql_source,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
		/*IN*/ struct SQLCLI_PTR_PAIRS ptr_pairs[]);

Int32 SQL_EXEC_ExecDirectDealloc(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN*/ SQLDESC_ID * sql_source,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
                ...);

Int32 SQL_EXEC_EXECDIRECTDEALLOC(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN*/ SQLDESC_ID * sql_source,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
		/*IN*/ struct SQLCLI_PTR_PAIRS ptr_pairs[]);

Int32 SQL_EXEC_ExecFetch(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
                ...);

Int32 SQL_EXEC_EXECFETCH(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
		/*IN*/ struct SQLCLI_PTR_PAIRS ptr_pairs[]);

Int32 SQL_EXEC_ClearExecFetchClose(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN OPTIONAL*/ SQLDESC_ID * output_descriptor,
		/*IN*/ Int32 num_input_ptr_pairs,
		/*IN*/ Int32 num_output_ptr_pairs,
		/*IN*/ Int32 num_total_ptr_pairs,
                ...);

Int32 SQL_EXEC_CLEAREXECFETCHCLOSE(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * input_descriptor,
		/*IN OPTIONAL*/ SQLDESC_ID * output_descriptor,
		/*IN*/ Int32 num_input_ptr_pairs,
		/*IN*/ Int32 num_output_ptr_pairs,
		/*IN*/ Int32 num_total_ptr_pairs,
		/*IN*/ struct SQLCLI_PTR_PAIRS input_ptr_pairs[],
		/*IN*/ struct SQLCLI_PTR_PAIRS output_ptr_pairs[]);

Int32 SQL_EXEC_Fetch(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * output_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
                ...);

Int32 SQL_EXEC_FETCH(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * output_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
		/*IN*/ struct SQLCLI_PTR_PAIRS ptr_pairs[]);

Int32 SQL_EXEC_FetchClose(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * output_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
                ...);

Int32 SQL_EXEC_FETCHCLOSE(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN OPTIONAL*/ SQLDESC_ID * output_descriptor,
		/*IN*/ Int32 num_ptr_pairs,
		/*IN*/ struct SQLCLI_PTR_PAIRS ptr_pairs[]);

Int32 SQL_EXEC_FetchMultiple(/*IN*/ SQLSTMT_ID * statement_id,
                            /*IN  OPTIONAL*/ SQLDESC_ID * output_descriptor,
                            /*IN*/                 Int32 rowset_size,
                            /*IN*/                 Int32 * rowset_status_ptr,
                            /*OUT*/                Int32 * rowset_nfetched,
                            /*IN*/                 Int32 num_quadruple_fields,
                                            ...);
Int32 SQL_EXEC_FETCHMULTIPLE(/*IN*/ SQLSTMT_ID * statement_id,
                            /*IN  OPTIONAL*/ SQLDESC_ID * output_descriptor,
                            /*IN*/                 Int32 rowset_size,
                            /*IN*/                 Int32 * rowset_status_ptr,
                            /*OUT*/                Int32 * rowset_nfetched,
                            /*IN*/                 Int32 num_quadruple_fields,
                            /*IN*/   struct SQLCLI_QUAD_FIELDS   quad_fields[]);
Int32 SQL_EXEC_Cancel (
		/*IN OPTIONAL*/ SQLSTMT_ID * statement_id);

Int32 SQL_EXEC_CANCEL (
		/*IN OPTIONAL*/ SQLSTMT_ID * statement_id);

Int32 SQL_EXEC_GetDescEntryCount(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ SQLDESC_ID * output_descriptor);

Int32 SQL_EXEC_GETDESCENTRYCOUNT(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ SQLDESC_ID * output_descriptor);


Int32 SQL_EXEC_GetDescEntryCountBasic(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*OUT*/ Int32 * num_entries);
Int32 SQL_EXEC_GetDescItem(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 entry,
		/*IN* (SQLDESC_ITEM_ID) */ Int32 what_to_get,
		/*OUT OPTIONAL*/ void * numeric_value,
		/*OUT OPTIONAL*/ char * string_value,
		/*IN OPTIONAL*/ Int32 max_string_len,
		/*OUT OPTIONAL*/ Int32 * len_of_item,
		/*IN OPTIONAL*/ Int32 start_from_offset);

Int32 SQL_EXEC_GETDESCITEM(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 entry,
		/*IN* (SQLDESC_ITEM_ID) */ Int32 what_to_get,
		/*OUT OPTIONAL*/ void * numeric_value,
		/*OUT OPTIONAL*/ char * string_value,
		/*IN OPTIONAL*/ Int32 max_string_len,
		/*OUT OPTIONAL*/ Int32 * len_of_item,
		/*IN OPTIONAL*/ Int32 start_from_offset);

Int32 SQL_EXEC_GetDescItems(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ SQLDESC_ITEM desc_items[],
		/*IN*/ SQLDESC_ID * value_num_descriptor,
		/*IN*/ SQLDESC_ID * output_descriptor);

Int32 SQL_EXEC_GETDESCITEMS(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ SQLDESC_ITEM desc_items[],
		/*IN*/ SQLDESC_ID * value_num_descriptor,
		/*IN*/ SQLDESC_ID * output_descriptor);

Int32 SQL_EXEC_GetDescItems2(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 no_of_desc_items,
		/*IN*/ SQLDESC_ITEM desc_items[]);

Int32 SQL_EXEC_GETDESCITEMS2(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 no_of_desc_items,
		/*IN*/ SQLDESC_ITEM desc_items[]);

Int32 SQL_EXEC_GetDiagnosticsStmtInfo(
		/*IN*/ Int32 *stmt_info_items,
		/*IN*/ SQLDESC_ID * output_descriptor);

Int32 SQL_EXEC_GETDIAGNOSTICSSTMTINFO(
		/*IN*/ Int32 *stmt_info_items,
		/*IN*/ SQLDESC_ID * output_descriptor);

Int32 SQL_EXEC_GetDiagnosticsStmtInfo2(
		/*IN OPTIONAL*/ SQLSTMT_ID * statement_id,
		/*IN* (SQLDIAG_STMT_INFO_ITEM_ID) */ Int32 what_to_get,
		/*OUT OPTIONAL*/ void * numeric_value,
		/*OUT OPTIONAL*/ char * string_value,
		/*IN OPTIONAL*/ Int32 max_string_len,
		/*OUT OPTIONAL*/ Int32 * len_of_item);

Int32 SQL_EXEC_GETDIAGNOSTICSSTMTINFO2(
		/*IN OPTIONAL*/ SQLSTMT_ID * statement_id,
		/*IN* (SQLDIAG_STMT_INFO_ITEM_ID) */ Int32 what_to_get,
		/*OUT OPTIONAL*/ void * numeric_value,
		/*OUT OPTIONAL*/ char * string_value,
		/*IN OPTIONAL*/ Int32 max_string_len,
		/*OUT OPTIONAL*/ Int32 * len_of_item);

Int32 SQL_EXEC_GetDiagnosticsCondInfo(
		/*IN*/ SQLDIAG_COND_INFO_ITEM *cond_info_items,
		/*IN*/ SQLDESC_ID * cond_num_descriptor,
		/*IN*/ SQLDESC_ID * output_descriptor);

Int32 SQL_EXEC_GETDIAGNOSTICSCONDINFO(
		/*IN*/ SQLDIAG_COND_INFO_ITEM *cond_info_items,
		/*IN*/ SQLDESC_ID * cond_num_descriptor,
		/*IN*/ SQLDESC_ID * output_descriptor);

Int32 SQL_EXEC_GetDiagnosticsCondInfo2(
		/*IN* (SQLDIAG_COND_INFO_ITEM_ID) */ Int32 what_to_get,
		/*IN*/ Int32 conditionNum,
		/*OUT OPTIONAL*/ Int32 * numeric_value,
		/*OUT OPTIONAL*/ char * string_value,
		/*IN OPTIONAL */ Int32 max_string_len,
		/*OUT OPTIONAL*/ Int32 * len_of_item);

Int32 SQL_EXEC_GETDIAGNOSTICSCONDINFO2(
		/*IN* (SQLDIAG_COND_INFO_ITEM_ID) */ Int32 what_to_get,
		/*IN*/ Int32 conditionNum,
		/*OUT OPTIONAL*/ Int32 * numeric_value,
		/*OUT OPTIONAL*/ char * string_value,
		/*IN OPTIONAL */ Int32 max_string_len,
		/*OUT OPTIONAL*/ Int32 * len_of_item);

Int32 SQL_EXEC_GetDiagnosticsCondInfo3 (
		/*IN*/ Int32 no_of_condition_items,
		/*IN*/ SQLDIAG_COND_INFO_ITEM_VALUE
			  diag_cond_info_item_values[]);

Int32 SQL_EXEC_GETDIAGNOSTICSCONDINFO3 (
		/*IN*/ Int32 no_of_condition_items,
		/*IN*/ SQLDIAG_COND_INFO_ITEM_VALUE
			  diag_cond_info_item_values[]);

/* This function retrieves the SQLSTATE from the statement diagnostics area
   if possible */  
Int32 SQL_EXEC_GetMainSQLSTATE(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN*/  Int32 sqlcode,
		/*OUT*/ char * sqlstate /* assumed to be char[6] */);

Int32 SQL_EXEC_GETMAINSQLSTATE(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN*/  Int32 sqlcode,
		/*OUT*/ char * sqlstate /* assumed to be char[6] */);

Int32 SQL_EXEC_GetCSQLSTATE(
		/*OUT*/ char * sqlstate /* assumed to be char[6] */,
		/*IN*/  Int32 sqlcode);

Int32 SQL_EXEC_GETCSQLSTATE(
		/*OUT*/ char * sqlstate /* assumed to be char[6] */,
		/*IN*/  Int32 sqlcode);

Int32 SQL_EXEC_GetCobolSQLSTATE(
		/*OUT*/ char * sqlstate /* assumed to be char[5] */,
		/*IN*/  Int32 sqlcode);

Int32 SQL_EXEC_GETCOBOLSQLSTATE(
		/*OUT*/ char * sqlstate /* assumed to be char[5] */,
		/*IN*/  Int32 sqlcode);

Int32 SQL_EXEC_GetSQLSTATE(
		/*OUT*/ char * sqlstate /* assumed to be char[6] */);

Int32 SQL_EXEC_GETSQLSTATE(
		/*OUT*/ char * sqlstate /* assumed to be char[6] */);

Int32 SQL_EXEC_GetSessionAttr(
		/*IN* (SESSIONATTR_TYPE) */ Int32 attrName,
		/*OUT OPTIONAL*/        Int32 * numeric_value,
		/*OUT OPTIONAL*/        char * string_value,
		/*IN OPTIONAL*/         Int32 max_string_len,
		/*OUT OPTIONAL*/        Int32 * len_of_item);

Int32 SQL_EXEC_GetUniqueQueryIdAttrs (
                /*IN*/    char * uniqueQueryId,
		/*IN*/    Int32 uniqueQueryIdLen,
		/*IN*/    Int32 no_of_attrs,
		/*INOUT*/ UNIQUEQUERYID_ATTR unique_queryid_attrs[]);

Int32 SQL_EXEC_GetStmtAttr(
                /*IN*/                  SQLSTMT_ID * statement_id,
		/*IN* (SQLATTR_TYPE) */ Int32 attrName,
		/*OUT OPTIONAL*/        Int32 * numeric_value,
		/*OUT OPTIONAL*/        char * string_value,
		/*IN OPTIONAL*/         Int32 max_string_len,
		/*OUT OPTIONAL*/        Int32 * len_of_item);

Int32 SQL_EXEC_GETSTMTATTR(
                /*IN*/                  SQLSTMT_ID * statement_id,
		/*IN* (SQLATTR_TYPE) */ Int32 attrName,
		/*OUT OPTIONAL*/        Int32 * numeric_value,
		/*OUT OPTIONAL*/        char * string_value,
		/*IN OPTIONAL*/         Int32 max_string_len,
		/*OUT OPTIONAL*/        Int32 * len_of_item);

Int32 SQL_EXEC_GetStmtAttrs(
                /*IN*/                  SQLSTMT_ID * statement_id,
                /*IN*/                  Int32 number_of_attrs,
		/*INOUT*/               SQLSTMT_ATTR attrs[],
		/*OUT OPTIONAL*/        Int32 * num_returned);

Int32 SQL_EXEC_GETSTMTATTRS(
                /*IN*/                  SQLSTMT_ID * statement_id,
                /*IN*/                  Int32 number_of_attrs,
		/*INOUT*/               SQLSTMT_ATTR attrs[],
		/*OUT OPTIONAL*/        Int32 * num_returned);

Int32 SQL_EXEC_GetExplainData(
                                              /*IN*/    SQLSTMT_ID * statement_id,
                                              /*INOUT*/ char * explain_ptr,
                                              /*IN*/    Int32 explain_len,
                                              /*INOUT*/ Int32 * ret_explain_len);

Int32 SQL_EXEC_StoreExplainData(
                                                /*IN*/ Int64 * exec_start_utc_ts,
                                                /*IN*/    char * query_id,
                                                /*INOUT*/ char * explain_ptr,
                                                /*IN*/    Int32 explain_len);

Int32 SQL_EXEC_Prepare(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN*/ SQLDESC_ID * sql_source);

Int32 SQL_EXEC_PREPARE(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN*/ SQLDESC_ID * sql_source);

Int32 SQL_EXEC_Prepare2(
     /*IN*/    SQLSTMT_ID * statement_id,
     /*IN*/    SQLDESC_ID * sql_source,
     /*INOUT*/ char * gencode_ptr,
     /*IN*/    Int32 gencode_len,
     /*INOUT*/ Int32 * ret_gencode_len,
     /*INOUT*/ SQL_QUERY_COST_INFO *query_cost_info,
     /*INOUT*/ SQL_QUERY_COMPILER_STATS_INFO *comp_stats_info,
     /*INOUT*/ char * uniqueQueryId,
     /*INOUT*/ Int32 * uniqueQueryIdLen,
     /*IN*/    UInt32 flags);

Int32 SQL_EXEC_ResDescName(
		/*INOUT*/ SQLDESC_ID * statement_id,
		/*IN OPTIONAL*/ SQLSTMT_ID * from_statement,
		/*IN OPTIONAL (SQLWHAT_DESC) */ Int32 what_desc);

Int32 SQL_EXEC_RESDESCNAME(
		/*INOUT*/ SQLDESC_ID * statement_id,
		/*IN OPTIONAL*/ SQLSTMT_ID * from_statement,
		/*IN OPTIONAL (SQLWHAT_DESC) */ Int32 what_desc);

Int32 SQL_EXEC_ResStmtName(
		/*INOUT*/ SQLSTMT_ID * statement_id);

Int32 SQL_EXEC_RESSTMTNAME(
		/*INOUT*/ SQLSTMT_ID * statement_id);

Int32 SQL_EXEC_SetCursorName(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN*/ SQLSTMT_ID * cursor_name);


Int32 SQL_EXEC_SETCURSORNAME(
		/*IN*/ SQLSTMT_ID * statement_id,
		/*IN*/ SQLSTMT_ID * cursor_name);

Int32 SQL_EXEC_SetDescEntryCount(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ SQLDESC_ID * input_descriptor);

Int32 SQL_EXEC_SETDESCENTRYCOUNT(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ SQLDESC_ID * input_descriptor);

Int32 SQL_EXEC_SetDescEntryCountBasic(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 num_entries);

Int32 SQL_EXEC_SetDescItem(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 entry,
		/*IN* (SQLDESC_ITEM_ID) */ Int32 what_to_set, 
		/*IN OPTIONAL*/ long   numeric_value,
		/*IN OPTIONAL*/ char * string_value);

Int32 SQL_EXEC_SETDESCITEM(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 entry,
		/*IN* (SQLDESC_ITEM_ID) */ Int32 what_to_set,
		/*IN OPTIONAL*/ long   numeric_value,
		/*IN OPTIONAL*/ char * string_value);

Int32 SQL_EXEC_SetDescItems(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ SQLDESC_ITEM desc_items[],
		/*IN*/ SQLDESC_ID * value_num_descriptor,
		/*IN*/ SQLDESC_ID * input_descriptor);

Int32 SQL_EXEC_SETDESCITEMS(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ SQLDESC_ITEM desc_items[],
		/*IN*/ SQLDESC_ID * value_num_descriptor,
		/*IN*/ SQLDESC_ID * input_descriptor);

Int32 SQL_EXEC_SetDescItems2(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 no_of_desc_items,
		/*IN*/ SQLDESC_ITEM desc_items[]);

Int32 SQL_EXEC_SETDESCITEMS2(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 no_of_desc_items,
		/*IN*/ SQLDESC_ITEM desc_items[]);

Int32 SQL_EXEC_SetDescPointers(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 starting_entry,
		/*IN*/ Int32 num_ptr_pairs,
                ...);

Int32 SQL_EXEC_SETDESCPOINTERS(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 starting_entry,
		/*IN*/ Int32 num_ptr_pairs,
		/*IN*/ struct SQLCLI_PTR_PAIRS ptr_pairs[]);

Int32 SQL_EXEC_SetRowsetDescPointers(SQLDESC_ID * desc_id,
                                           Int32 rowset_size,
                                           Int32 *rowset_status_ptr,
                                           Int32 starting_entry,
                                           Int32 num_quadruple_fields,
                                           ...);

Int32 SQL_EXEC_SETROWSETDESCPOINTERS(SQLDESC_ID * desc_id,
                                           Int32 rowset_size,
                                           Int32 *rowset_status_ptr,
                                           Int32 starting_entry,
                                           Int32 num_quadruple_fields,
                             struct SQLCLI_QUAD_FIELDS    quad_fields[]);

Int32 SQL_EXEC_SetStmtAttr(
                /*IN*/                  SQLSTMT_ID * statement_id,
		/*IN* (SQLATTR_TYPE) */ Int32 attrName,
		/*IN OPTIONAL*/         Int32 numeric_value,
		/*IN OPTIONAL*/         char * string_value);


Int32 SQL_EXEC_SETSTMTATTR(
                /*IN*/                  SQLSTMT_ID * statement_id,
		/*IN* (SQLATTR_TYPE) */ Int32 attrName,
		/*IN OPTIONAL*/         Int32 numeric_value,
		/*IN OPTIONAL*/         char * string_value);

Int32 SQL_EXEC_SwitchContext(
		/*IN*/ SQLCTX_HANDLE context_handle,
		/*OUT OPTIONAL*/ SQLCTX_HANDLE * prev_context_handle);
               
Int32 SQL_EXEC_SWITCHCONTEXT(
		/*IN*/ SQLCTX_HANDLE context_handle,
		/*OUT OPTIONAL*/ SQLCTX_HANDLE * prev_context_handle);

Int32 SQL_EXEC_Xact(
		/*IN* (SQLTRANS_COMMAND) */ Int32 command,
		/*OUT OPTIONAL*/ SQLDESC_ID * transid_descriptor); 

Int32 SQL_EXEC_XACT(
		/*IN* (SQLTRANS_COMMAND) */ Int32 command,
		/*OUT OPTIONAL*/ SQLDESC_ID * transid_descriptor); 

Int32 SQL_EXEC_SetAuthID(
   const char * externalUsername,  /*IN*/
   const char * databaseUsername,  /*IN*/
   const char * authToken,	   /*IN*/
   Int32        authTokenLen,	   /*IN*/
   Int32        effectiveUserID,   /*IN*/
   Int32        sessionUserID);	   /*IN*/

Int32 SQL_EXEC_SETAUTHID(
		/*IN*/                        char   * authID,
		/*IN SQLAUTHID_TYPE */ Int32 authIDType,
		/* OUT OPTIONAL primaryRole*/ char *primaryRole,
		/* OUT OPTIONAL  role len*/ short *primaryRoleLen,
                /* OUT OPTIONAL userRedefTime*/ Int64 *redefTime);

Int32 SQL_EXEC_GetAuthState(
   /*OUT*/  bool & authenticationEnabled,
   /*OUT*/  bool & authorizationEnabled,
   /*OUT*/  bool & authorizationReady,
   /*OUT*/  bool & auditingEnabled);

Int32 SQL_EXEC_LocaleToUTF8 (
               /*IN*/Int32 conv_charset,
               /*IN*/void     * Input_Buffer_Addr,
               /*IN*/Int32      Input_Buffer_Length,
               /*IN/OUT*/void * Output_Buffer_Addr,
               /*IN*/Int32      Output_Buffer_Length,
               /*OUT*/void   ** First_Untranslated_Char_Addr,
               /*OUT*/Int32   * Output_Data_Length,
               /*IN*/Int32      add_null_at_end_Flag,
               /*OUT*/Int32   * num_translated_char
   );

Int32 SQL_EXEC_UTF8ToLocale(
               /*IN*/Int32 conv_charset,
               /*IN*/void     * Input_Buffer_Addr,
               /*IN*/Int32      Input_Buffer_Length,
               /*IN/OUT*/void * Output_Buffer_Addr,
               /*IN*/Int32      Output_Buffer_Length,
               /*OUT*/void   ** First_Untranslated_Char_Addr,
               /*OUT*/Int32   * Output_Data_Length,
               /*IN*/Int32      add_null_at_end_Flag,
               /*IN*/Int32      allow_invalids,
               /*OUT*/Int32   * num_translated_char,
               /*IN*/void     * substitution_char_addr
   );

Int32 SQL_EXEC_LocaleToUTF16 (
               /*IN*/Int32      conv_charset,
               /*IN*/void     * Input_Buffer_Addr,
               /*IN*/Int32      Input_Buffer_Length,
               /*IN/OUT*/void * Output_Buffer_Addr,
               /*IN*/Int32      Output_Buffer_Length,
               /*OUT*/void   ** First_Untranslated_Char_Addr,
               /*OUT*/Int32   * Output_Data_Length,
               /*IN*/Int32      conv_flags,
               /*IN*/Int32      add_null_at_end_Flag,
               /*OUT*/Int32   * num_translated_char
   );

Int32 SQL_EXEC_UTF16ToLocale(
               /*IN*/Int32 conv_charset,
               /*IN*/void     * Input_Buffer_Addr,
               /*IN*/Int32      Input_Buffer_Length,
               /*IN/OUT*/void * Output_Buffer_Addr,
               /*IN*/Int32      Output_Buffer_Length,
               /*OUT*/void   ** First_Untranslated_Char_Addr,
               /*OUT*/Int32   * Output_Data_Length,
               /*IN*/Int32      conv_flags,
               /*IN*/Int32      add_null_at_end_Flag,
               /*IN*/Int32      allow_invalids,
               /*OUT*/Int32   * num_translated_char,
               /*IN*/void     * substitution_char_addr
   );

Int32 SQL_EXEC_SetSecInvalidKeys(
            /* IN */   Int32 numSiKeys,
           /* IN */    SQL_QIKEY siKeys[]);

Int32 SQL_EXEC_GetSecInvalidKeys(
            /* IN */      Int64 prevTimestamp,
            /* IN/OUT */  SQL_QIKEY siKeys[],
            /* IN */      Int32 maxNumSiKeys,
            /* IN/OUT */  Int32 *returnedNumSiKeys,
            /* IN/OUT */  Int64 *maxTimestamp);


Int32 SQL_EXEC_GetStatistics2(
            /* IN */  	short statsReqType,
	    /* IN */  	char *statsReqStr,
	    /* IN */  	Int32 statsReqStrLen,
	    /* IN */	short activeQueryNum,
	    /* IN */ 	short statsMergeType,
	    /* OUT */ 	short *statsCollectType,
	    /* IN/OUT */ SQLSTATS_DESC sqlstats_desc[],
	    /* IN */ 	Int32 max_stats_desc,
	    /* OUT */	Int32 *no_returned_stats_desc);

Int32 SQL_EXEC_GetStatisticsItems(
            /* IN */  	short statsReqType,
	    /* IN */  	char *queryId,
	    /* IN */  	Int32 queryIdLen,
            /* IN */	Int32 no_of_stats_items,
	    /* IN/OUT */   SQLSTATS_ITEM sqlstats_items[]);

Int32 SQL_EXEC_GetChildQueryInfo(
     /*IN*/    SQLSTMT_ID * statement_id,
     /*INOUT*/ char * uniqueQueryId,
     /*IN */   Int32 uniqueQueryIdMaxLen,
     /*INOUT*/ Int32 * uniqueQueryIdLen,
     /*INOUT*/ SQL_QUERY_COST_INFO *query_cost_info,
     /*INOUT*/ SQL_QUERY_COMPILER_STATS_INFO *comp_stats_info);

#ifdef __cplusplus
}

/* temporary functions -- for use by sqlcat simulator only */

Int32 SQL_EXEC_AllocDesc (
	        /*INOUT*/ SQLDESC_ID * desc_id,
		/*IN OPTIONAL*/ Int32 max_entries);

Int32 SQL_EXEC_GetDescEntryCount(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*OUT*/ Int32 * num_entries);

Int32 SQL_EXEC_SetDescEntryCount(
		/*IN*/ SQLDESC_ID * sql_descriptor,
		/*IN*/ Int32 num_entries);

short sqInit();

#endif /*__cplusplus*/

#endif /*SQLCLI_HDR*/
