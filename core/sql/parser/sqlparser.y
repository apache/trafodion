/* -*-C++-*- */
/**********************************************************************
// @@@ START COPYRIGHT @@@
//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// @@@ END COPYRIGHT @@@
**********************************************************************/
%{

/* -*-C++-*-
******************************************************************************
*
* File:         SqlParser.y
* Description:  SQL Parser
*
* Created:      4/28/94
* Language:     C++
*
*
*	Is there a parser, much bemus'd in beer,
*	A maudlin poetess, a rhyming peer,
*	A clerk, foredoom'd his father's soul to cross,
*	Who pens a stanza, when he should engross?
*		-- with my apologies to Alexander Pope
*
******************************************************************************
*/

// As of 07/26/01, yacc (bison) reports for this file:
// w:\parser\sqlparser.y contains 56 shift/reduce conflicts and 9 reduce/reduce conflicts.
// As of 02/23/07, yacc (bison) reports for this file:
// w:\parser\sqlparser.y contains 71 shift/reduce conflicts and 12 reduce/reduce conflicts.

// shift/reduce case study: DROP GHOST TABLE
// Before the invention of ghost tables, the second production for drop_table_statement was:
//   drop_table_statement : TOK_DROP TOK_TABLE ddl_qualified_name optional_cleanup
//                            optional_drop_invalidate_dependent_behavior optional_validate optional_logfile
// I wanted to insert an optional TOK_GHOST like this:
//   drop_table_statement : TOK_DROP optional_ghost TOK_TABLE ddl_qualified_name optional_cleanup
//                            optional_drop_invalidate_dependent_behavior optional_validate optional_logfile
//   optional_ghost : empty | TOK_GHOST
// Unfortunately that introduced a shift/reduce conflict. After reading TOK_DROP, if the next 
// token is TOK_TABLE, bison wanted to reduce 
//   optional_ghost -> empty
// but it also wanted to shift TOK_TABLE because DROP TABLE was not enough to distinguish the 
// first two productions for drop_table_statement. So in order to avoid introducing a 
// shift/reduce conflict, the productions have been written like this:
//   drop_table_statement : drop_table_start_tokens ddl_qualified_name optional_cleanup
//                            optional_drop_invalidate_dependent_behavior optional_validate optional_logfile
//   drop_table_start_tokens : TOK_DROP TOK_TABLE | TOK_DROP TOK_GHOST TOK_TABLE
// This solves the problem because bison does not have to reduce after reading TOK_DROP. Rather,
// after reading TOK_DROP TOK_TABLE, it can lookahead at the next token to decide what to do.


#include "Platform.h"				// must be the first #include
//debug yacc
#define YY_LOG_FILE "yylog"
#define YYFPRINTF(stderr, format, args...) {FILE* fp=fopen(YY_LOG_FILE, "a+");fprintf(fp, format, ##args);fclose(fp);}

#define   SQLPARSERGLOBALS__INITIALIZE
#define   SQLPARSERGLOBALS_CONTEXT_AND_DIAGS
#define   SQLPARSERGLOBALS_FLAGS
#define   SQLPARSERGLOBALS_HOSTVARS
#define   SQLPARSERGLOBALS_LEX_AND_PARSE
#define   SQLPARSERGLOBALS_NADEFAULTS
#define   SQLPARSERGLOBALS_NAMES_AND_TOKENS
#include "SqlParserGlobals.h"			// must be the second #include

#define CheckModeSpecial1() if (NOT SqlParser_CurrentParser->modeSpecial1()) { YYERROR; } 

// This define is to restrict some commands to the DB_Transporter.
#define CHECK_DBTRANSPORTER \
  if ((!Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE)) && \
      (CmpCommon::getDefault(IS_DB_TRANSPORTER) != DF_ON)) \
  { \
     yyerror(""); \
     YYERROR; \
  }
                               
#define CheckModeSpecial4 \
  if (CmpCommon::getDefault(MODE_SPECIAL_4) != DF_ON) \
  { \
     yyerror(""); \
     YYERROR; \
  }
                               
#define INCLUDE_UNION
#   include <alloca.h>
#include "ComCextdecs.h"
#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <sstream>

using namespace std;

#include "NAAssert.h"	 // required after including a RogueWave file!

#include "CharType.h"
#include "DatetimeType.h"
#include "IntervalType.h"
#include "NumericType.h"
#include "ItemNAType.h"
#include "MiscType.h"
#include "CmpContext.h"

#include "AllElemDDL.h"
#include "AllItemExpr.h"
#include "AllRelExpr.h"
#include "AllStmtDDL.h"
#include "ComAnsiNamePart.h"
#include "ComDiags.h"
#include "ComMPLoc.h"
#include "ComSmallDefs.h"
#include "ComTransInfo.h"
#include "ControlDB.h"
#include "CmpStatement.h"
#include "GroupAttr.h"
#include "HeapLog.h"
#include "HvTypes.h"
#include "ItemExprList.h"
#include "ItemSample.h"
#include "LateBindInfo.h"
#include "NAExit.h"
#include "OperTypeEnum.h"
#include "OptHints.h"
#include "parser.h"
#include "ParserMsg.h"
#include "RelDCL.h"
#include "RelPackedRows.h"
#include "RelSample.h"
#include "RelSequence.h"
#include "SqlciError.h"
#include "sqlcli.h"
#include "SqlParserAux.h"
#include "StmtCompilationMode.h"
#include "StmtDMLSetTransaction.h"

#include "StmtDDLonHiveObjects.h"

// -- triggers
#include "Triggers.h"
#include "ItemNAType.h"

// MV
#include "Refresh.h"
#include "ItemLog.h"
#include "MvLog.h"
#include "StmtDDLCreateMV.h"

#include "StmtNode.h"
#include "wstr.h"
#include "NABoolean.h"
#include "HvRolesAssign.h"

#include "exp_expr.h"
#include "exp_clause_derived.h"
#include "exp_datetime.h"
#include "Analyzer.h"

#include "OptimizerSimulator.h"

#include "ItemFuncUDF.h"

#include "ExpLOBenums.h"

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// The SQL parser auxiliary methods that used to be here had to be moved
// to SqlParserAux.{h,cpp} to work around a c89 (v2.1) internal limit that 
// shows up as 
//    ugen: internal: Assertion failure
//    in source file 'W:\parser\SqlParser.cpp', at source line 22210
//    detected in back end file 'eval.c', at line 4653
// when cross-compiling SQLMX for NSK. So, please add any new SQL parser
// auxiliary methods into SqlParserAux.{h,cpp} instead of here.
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

static const UInt32 DEFAULT_STRING_SIZE = 1;

THREAD_P Int32     externalDataTypeCnt_   = 0 ;
THREAD_P NAString *externalDataTypeNames_ = NULL ;
static void beginCallStmtParsing ()
{
  inCallStmt = TRUE;
  currVarIndex = 1;
}
 
static void beginRSProxyStmtParsing ()
{
  inRSProxyStmt = TRUE;
}


// prepare "nameList" with old/new transition names
static void prepareReferencingNames( TableRefList & nameList,
				     StmtDDLCreateTrigger * triggerObject )
{
  if (triggerObject->getOldName()) 	{
    NAString oldTransName(OLDCorr);
    nameList.insert(*new(PARSERHEAP()) 
		    TableRefName(oldTransName, *triggerObject->getOldName()));
  }
  if (triggerObject->getNewName())	{
    NAString newTransName(NEWCorr);
    nameList.insert(*new(PARSERHEAP()) 
		    TableRefName(newTransName, *triggerObject->getNewName()));
  } 
}


//++ Triggers
//
// This routine determines the legal values of the SQLSTATE quoted string that
// appears in a SIGNAL statement:
// * The string must contain 5 alphanumeric charecters (ANSI)
// * The first character must be 'S'. (This is a Tandem Extension, and not ANSI)
//
static NABoolean isInvalidSignalSqlstateValue(NAString *SqlState)
{
        Int32 wasError = FALSE;

        if (SqlState->length() != 5)     // SQLSTATE must be 5 characters long.
                wasError = TRUE;

        for (Int32 i=0; i<5; i++)  // Each character must be alphanumeric.
                if (!isAlNum8859_1(SqlState->data()[i]))
                        wasError = TRUE;

// Begin soln:10-060123-4013
        // We are not seeing any requrement to have an ['S'|'s'] as a prefix
        // to the user defined SQLSTATE in the SIGNAL SQLSTATE option,hence we are
        // removing this restruction.

        //if (SqlState->data()[0]!='S' && SqlState->data()[0]!='s')
        //        wasError = TRUE;
// End soln:10-060123-4013

        return wasError;
}

/*  These globals are used by triggers */
THREAD_P ParTriggerScopeType RowOrTableClause1 = ParTRIG_SCOPE_NONE ;
THREAD_P ParTriggerScopeType RowOrTableClause2 = ParTRIG_SCOPE_NONE ;
THREAD_P NABoolean InsideTriggerDefinition   = FALSE ;
THREAD_P NABoolean CSInsideTriggerDefinition = FALSE ;

//#define YYDEBUG 1			// Turn on debugging, if needed.
//#define YYERROR_VERBOSE 1		// Can be done automatically with
#if YYDEBUG				// the DBG param to GenBison.bat.
  #define dbgprintf(x)  printf(x)
#else
  #define dbgprintf(x)
#endif

//This global is introduced to disallow Subqueries in the If Condition.
THREAD_P NABoolean InIfCondition = FALSE ;

//This global is introduced to disallow non-ISO88591 character string to appear in certain ddl statements.
THREAD_P NABoolean NonISO88591LiteralEncountered = FALSE ;

//This global is introduced to turn unknown charset to ISO88591 charset in ddls.
THREAD_P NABoolean turnUnknownCharSetToISO88591 = FALSE;

THREAD_P NABoolean turnUnknownCharSetToISO88591CurrentValue;

//This global is introduced to apply ISO88591 charset to quoted string
//without charset prefix regardless of the DEFAULT_CHARSET setting.
THREAD_P NABoolean makeQuotedStringISO88591 = FALSE;

// NABoolean makeQuotedStringISO88591CurrentValue = FALSE;

//This global is introduced to disallow hexadecimal string literals to appear in certain statements (e.g. ddl).
THREAD_P NABoolean HexStringLiteralNotAllowed = FALSE;

//This global is introduced to allow empty character length specifier 
//(e.g. varchar) in VARCHAR for ODBC.
THREAD_P NABoolean empty_charlen_specifier_allowed = FALSE;

THREAD_P Int32 NumOfScalars = 0 ;
THREAD_P Int32 NumOfArrays  = 0 ;

//This global is introduced to allow CAST to remember whether
//or not the user specified a CHARACTER SET clause for the target
//[var]char type.
THREAD_P NABoolean cast_target_cs_specified = FALSE ;

THREAD_P NABoolean in_col_defn = FALSE;

// to be moved to ParNameLocList.h
void ParSetTextStartPosForDisplayExplain(ParNameLocList * pNameLocList);
NABoolean ParGetTextStartEndPosForDisplayExplain(
     ParNameLocList * pNameLocList,
     StringPos &start, StringPos&end);

static void restoreInferCharsetState()
{
  turnUnknownCharSetToISO88591 = turnUnknownCharSetToISO88591CurrentValue;
}

static void disableMakeQuotedStringISO88591Mechanism()
{
  // makeQuotedStringISO88591CurrentValue = makeQuotedStringISO88591;
  makeQuotedStringISO88591 = FALSE;
}

static void enableMakeQuotedStringISO88591Mechanism()
{
  // makeQuotedStringISO88591CurrentValue = makeQuotedStringISO88591;
  makeQuotedStringISO88591 = TRUE;
}

// static void restorePreviousMakeQuotedStringISO88591State()
// {
//   makeQuotedStringISO88591 = makeQuotedStringISO88591CurrentValue;
// }

%}
%define api.pure full

%start  starting_production

%token <item>      NON_SQLTEXT_CHARACTER	/* Illegal character scanned */
%token <item>      ARITH_PLACEHOLDER
%token <item>      BOOL_PLACEHOLDER
%token <stringval> DELIMITED_IDENTIFIER
%token <stringval> BACKQUOTED_IDENTIFIER
%token <stringval> CALL_CASED_IDENTIFIER
%token <stringval> GOTO_CASED_IDENTIFIER
%token <stringval> PERFORM_CASED_IDENTIFIER
%token <stringval> HOSTVAR
%token <stringval> IDENTIFIER
%token <stringval> NUMERIC_LITERAL_APPROX
%token <stringval> NUMERIC_LITERAL_EXACT_NO_SCALE
%token <stringval> NUMERIC_LITERAL_EXACT_WITH_SCALE
%token <stringval> PARAMETER
%token <stringval> QUOTED_STRING
%token <stringval> ANY_STRING
%token <stringval> BACKSLASH_SYSTEM_NAME
%token <stringval> SYSTEM_VOLUME_NAME
%token <stringval> TOK_PICTURE
%token <stringval>  TOK_SBYTE_LITERAL		/* Single-byte string */
%token <wstringval> TOK_MBYTE_LITERAL		/* Multi-byte (NCHAR) string */
%token <stringval> SYSTEM_CPU_IDENTIFIER
%token <tokval> '('
%token <tokval> ')'
%token <tokval> '*'
%token <tokval> '+'
%token <tokval> ','
%token <tokval> '-'
%token <tokval> '.'
%token <tokval> '/'
%token <tokval> '<'
%token <tokval> '='
%token <tokval> '>'
%token <tokval> '$'
%token <tokval> ';'

%token <tokval> TOK_TYPE                /* ANSI SQL non-reserved word */
%token <tokval> TOK_TYPE_ANSI           /* ANSI SQL non-reserved word */
%token <tokval> TOK_TYPE_FS             /* ANSI SQL non-reserved word */
%token <tokval> TOK_TYPES
%token <tokval> TOK_DATETIME_CODE       /* Tandem extension non-reserved word */
%token <tokval> TOK_LENGTH              /* ANSI SQL non-reserved word */
%token <tokval> TOK_PRECISION
%token <tokval> TOK_SCALE               /* ANSI SQL non-reserved word */
%token <tokval> TOK_LEADING_PRECISION   /* Tandem extenstion non-reserved word */
%token <tokval> TOK_NULLABLE            /* ANSI SQL non-reserved word */

%token <tokval> TOK_CHARACTER_SET_CATALOG/*ANSI SQL non-reserved word */
%token <tokval> TOK_CHARACTER_SET_SCHEMA/* ANSI SQL non-reserved word */
%token <tokval> TOK_CHARACTER_SET_NAME  /* ANSI SQL non-reserved word */
%token <tokval> TOK_COLLATION
%token <tokval> TOK_COLLATION_CATALOG   /* ANSI SQL non-reserved word */
%token <tokval> TOK_COLLATION_SCHEMA    /* ANSI SQL non-reserved word */
%token <tokval> TOK_COLLATION_NAME      /* ANSI SQL non-reserved word */
%token <tokval> TOK_NAME                /* ANSI SQL non-reserved word */
%token <tokval> TOK_UNNAMED             /* ANSI SQL non-reserved word */
%token <tokval> TOK_INDICATOR_TYPE      /* Tandem extension non-reserved word */
%token <tokval> TOK_INET_ATON           /* MySQL extension non-reserved word */
%token <tokval> TOK_INET_NTOA           /* MySQL extension non-reserved word */
%token <tokval> TOK_VARIABLE_POINTER    /* Tandem extension non-reserved word */
%token <tokval> TOK_INDICATOR_POINTER   /* Tandem extension non-reserved word */
%token <tokval> TOK_RETURNED_LENGTH     /* ANSI SQL non-reserved word */
%token <tokval> TOK_RETURNED_OCTET_LENGTH/*ANSI SQL non-reserved word */
%token <tokval> TOK_VARIABLE_DATA       /* Tandem extension non-reserved word */
%token <tokval> TOK_INDICATOR_DATA      /* Tandem extension non-reserved word */

%token <tokval> TOK_CONDITION_NUMBER    /* ANSI SQL non-reserved word */
%token <tokval> TOK_RETURNED_SQLSTATE   /* ANSI SQL non-reserved word */
%token <tokval> TOK_CLASS_ORIGIN        /* ANSI SQL non-reserved word */
%token <tokval> TOK_SUBCLASS_ORIGIN     /* ANSI SQL non-reserved word */
%token <tokval> TOK_SERVER_NAME         /* ANSI SQL non-reserved word */
%token <tokval> TOK_CONNECTION_NAME     /* ANSI SQL non-reserved word */
%token <tokval> TOK_CONSTRAINT_CATALOG  /* ANSI SQL non-reserved word */ 
%token <tokval> TOK_CONSTRAINT_SCHEMA   /* ANSI SQL non-reserved word */
%token <tokval> TOK_CONSTRAINT_NAME     /* ANSI SQL non-reserved word */
%token <tokval> TOK_TRIGGER_CATALOG     /* ANSI SQL non-reserved word */ 
%token <tokval> TOK_TRIGGER_SCHEMA      /* ANSI SQL non-reserved word */
%token <tokval> TOK_TRIGGER_NAME        /* ANSI SQL non-reserved word */

%token <tokval> TOK_CATALOG_NAME        /* ANSI SQL non-reserved word */
%token <tokval> TOK_SCHEMA_NAME         /* ANSI SQL non-reserved word */
%token <tokval> TOK_TABLE_NAME          /* ANSI SQL non-reserved word */
%token <tokval> TOK_COLUMN_NAME         /* ANSI SQL non-reserved word */
%token <tokval> TOK_CURSOR_NAME         /* ANSI SQL non-reserved word */
%token <tokval> TOK_MESSAGE_TEXT        /* ANSI SQL non-reserved word */
%token <tokval> TOK_MESSAGE_LEN         /* ANSI SQL non-reserved word */
%token <tokval> TOK_MESSAGE_OCTET_LEN   /* ANSI SQL non-reserved word */
%token <tokval> TOK_COLUMN_NUMBER       /* Tandem extension non-reserved word */
%token <tokval> TOK_NATIVE              /* Tandem extension non-reserved word */
%token <tokval> TOK_ROW_NUMBER          /* Tandem extension non-reserved word */
%token <tokval> TOK_SOURCE              /* Tandem extension non-reserved word */
%token <tokval> TOK_SOURCE_FILE         /* Tandem extension non-reserved word */
%token <tokval> TOK_LINE_NUMBER         /* Tandem extension non-reserved word */
%token <tokval> TOK_SUBSYSTEM_ID        /* Tandem extension non-reserved word */
%token <tokval> TOK_ABORT
%token <tokval> TOK_ABS                 /* Tandem extension */
%token <tokval> TOK_ACOS
%token <tokval> TOK_ASIN
%token <tokval> TOK_ATAN
%token <tokval> TOK_ATAN2

%token <tokval> TOK_ACCESS              /* Tandem extension non-reserved word */
%token <tokval> TOK_ACCUMULATED
%token <tokval> TOK_ADD_MONTHS
%token <tokval> TOK_ADMIN               /* ANSI reserved word */
%token <tokval> TOK_AES_ENCRYPT
%token <tokval> TOK_AES_DECRYPT
%token <tokval> TOK_AFTER
%token <tokval> TOK_ALL
%token <tokval> TOK_ALL_DDL
%token <tokval> TOK_ALL_DML
%token <tokval> TOK_ALL_UTILITY
%token <tokval> TOK_ALLOCATE
%token <tokval> TOK_ALLOWED				// MV
%token <tokval> TOK_ALWAYS
%token <tokval> TOK_AND
%token <tokval> TOK_AQR
%token <tokval> TOK_ANSIVARCHAR         /* Tandem extension non-reserved word */
%token <tokval> TOK_ANY
%token <tokval> TOK_APPEND
%token <tokval> TOK_ARE
%token <tokval> TOK_AS
%token <tokval> TOK_ASC
%token <tokval> TOK_ASCII
%token <tokval> TOK_ATOMIC
%token <tokval> TOK_AUDITONREFRESH		// MV
%token <tokval> TOK_AUTOABORT
%token <tokval> TOK_AUTOBEGIN
%token <tokval> TOK_AUTOCOMMIT
%token <tokval> TOK_AUTOMATIC			// MV
%token <tokval> TOK_AVERAGE_STREAM_WAIT         /* Tandem extension non-reserved word */
%token <tokval> TOK_AVG
%token <tokval> TOK_BEFORE

%token <tokval> TOK_BEGIN
%token <tokval> TOK_BEGIN_HINT
%token <tokval> TOK_BT
%token <tokval> TOK_END_HINT
%token <tokval> TOK_BALANCE
%token <tokval> TOK_NOT_BETWEEN
%token <tokval> TOK_BETWEEN
%token <tokval> TOK_BIT
%token <tokval> TOK_BITAND
%token <tokval> TOK_BITOR
%token <tokval> TOK_BITXOR
%token <tokval> TOK_BITNOT
%token <tokval> TOK_BITEXTRACT
%token <tokval> TOK_CONVERTTOBITS
%token <tokval> TOK_BITOR_OPERATOR
%token <tokval> TOK_BLOB
%token <tokval> TOK_BLOCKS
%token <tokval> TOK_BOTH
%token <tokval> TOK_BOOLEAN
%token <tokval> TOK_BY
%token <tokval> TOK_BYTEINT             /* TD extension that HP wants to ignore */
%token <tokval> TOK_C                   /* HP Neo extension non-reserved word */
%token <tokval> TOK_CPP                 /* HP Neo extension non-reserved word */
%token <tokval> TOK_CALL      /* Ansi potential-reserved, AND used by Lexer! */
%token <tokval> TOK_CANCEL
%token <tokval> TOK_CARDINALITY
%token <tokval> TOK_CASE
%token <tokval> TOK_CAST
%token <tokval> TOK_CENTURY
%token <tokval> TOK_TYPECAST
%token <tokval> TOK_CATCHUP	  // MV
%token <tokval> TOK_TRANSLATE
%token <tokval> TOK_CEIL
%token <tokval> TOK_CEILING
%token <tokval> TOK_CHAR
%token <tokval> TOK_CHARS
%token <tokval> TOK_CHR
%token <tokval> TOK_CHARACTER
%token <tokval> TOK_CHARACTERS
%token <tokval> TOK_CHANGED
%token <tokval> TOK_CHANGES // MV 
%token <tokval> TOK_CHAR_LENGTH
%token <tokval> TOK_CLOB
%token <tokval> TOK_CLOSE
%token <tokval> TOK_CLUSTER
%token <tokval> TOK_CLUSTERS
%token <tokval> TOK_CLUSTERING          /* Tandem extension */
%token <tokval> TOK_COALESCE
%token <tokval> TOK_COLLATE
%token <tokval> TOK_COLUMN_CREATE
%token <tokval> TOK_COLUMN_LOOKUP
%token <tokval> TOK_COLUMN_DISPLAY
%token <tokval> TOK_HBASE_TIMESTAMP
%token <tokval> TOK_HBASE_VERSION
%token <tokval> TOK_COMMANDS
%token <tokval> TOK_COMMAND_FUNCTION    /* ANSI SQL non-reserved word */
%token <tokval> TOK_COMMENT
%token <tokval> TOK_COMMIT
%token <tokval> TOK_COMP
%token <tokval> TOK_COMPACT
%token <tokval> TOK_COMPARE
%token <tokval> TOK_COMPLETE
%token <tokval> TOK_COMPRESS            /* TD extension that HP wants to ignore */
%token <tokval> TOK_COMPRESSED
%token <tokval> TOK_CONCAT              /* ODBC extension   */
%token <tokval> TOK_CONCATENATION
%token <tokval> TOK_CONCURRENCY
%token <tokval> TOK_CONCURRENT
%token <tokval> TOK_CONVERT             /* ODBC extentsion  */
%token <tokval> TOK_CONVERTFROMHEX      /* Tandem extentsion  */
%token <tokval> TOK_CONVERTTIMESTAMP    /* Tandem extension */
%token <tokval> TOK_CONVERTTOHEX        /* Tandem extentsion  */
%token <tokval> TOK_CONVERTTOHX_INTN   /* Tandem extentsion  */
%token <tokval> TOK_CONTAINS            /* Tandem extension non-reserved word */
%token <tokval> TOK_CONTINUE
%token <tokval> TOK_CONTROL             /* Tandem extension non-reserved word */
%token <tokval> TOK_CORRESPONDING
%token <tokval> TOK_COS
%token <tokval> TOK_COSH
%token <tokval> TOK_COST
%token <tokval> TOK_COUNT
%token <tokval> TOK_CRC32
%token <tokval> TOK_CQD
%token <tokval> TOK_CROSS
%token <tokval> TOK_CURDATE             /* ODBC extension  */ 
%token <tokval> TOK_CURRENT
%token <tokval> TOK_CURRENT_DATE
%token <tokval> TOK_CURRENT_RUNNING
%token <tokval> TOK_CURRENT_TIME
%token <tokval> TOK_CURRENT_TIMESTAMP
%token <tokval> TOK_CURRENT_TIMESTAMP_RUNNING
%token <tokval> TOK_CURRENT_TIMESTAMP_UTC
%token <tokval> TOK_CURRENT_TIME_UTC
%token <tokval> TOK_CURRENT_USER
%token <tokval> TOK_CURRNT_USR_INTN
%token <tokval> TOK_CURSOR
%token <tokval> TOK_CURTIME             /* ODBC extension  */
%token <tokval> TOK_CACHE
%token <tokval> TOK_CYCLE
%token <tokval> TOK_D                   /* ODBC extension  */
%token <tokval> TOK_DATABASE
%token <tokval> TOK_DATE
%token <tokval> TOK_DATEADD
%token <tokval> TOK_DATE_ADD
%token <tokval> TOK_DATE_SUB
%token <tokval> TOK_DATE_PART
%token <tokval> TOK_DATE_BEFORE_QUOTE
%token <tokval> TOK_DATE_TRUNC
%token <tokval> TOK_DATEDIFF
%token <tokval> TOK_DATEFORMAT          /* Tandem extension */
%token <tokval> TOK_DATETIME            /* Tandem extension non-reserved word */
%token <tokval> TOK_DAY
%token <tokval> TOK_DAYNAME
%token <tokval> TOK_DAYOFWEEK           /* Tandem extension */
%token <tokval> TOK_DAYOFYEAR 
%token <tokval> TOK_DAYOFMONTH          /* ODBC extension  */
%token <tokval> TOK_DEALLOCATE
%token <tokval> TOK_DECIMAL
%token <tokval> TOK_DECLARE
%token <tokval> TOK_DEFAULT
%token <tokval> TOK_DEFAULTS
%token <tokval> TOK_DEFINITION          /* Tandem extension non-reserved word */
%token <tokval> TOK_DEBUG
%token <tokval> TOK_DEGREES
%token <tokval> TOK_DE	
%token <tokval> TOK_DECODE	
%token <tokval> TOK_DELAY				// MV REFRESH
%token <tokval> TOK_DELETE
%token <tokval> TOK_DESC
%token <tokval> TOK_DESCRIBE
%token <tokval> TOK_DESCRIPTOR
%token <tokval> TOK_DELIMITER
%token <tokval> TOK_DETAIL              /* Tandem extension non-reserved word */
%token <tokval> TOK_DETAILS
%token <tokval> TOK_DETERMINISTIC
%token <tokval> TOK_DIAGNOSTICS
%token <tokval> TOK_DISABLE         
%token <tokval> TOK_DIFF1
%token <tokval> TOK_DIFF2
%token <tokval> TOK_DIRECTEDBY      
%token <tokval> TOK_DISPLAY
%token <tokval> TOK_DISTINCT
%token <tokval> TOK_DIVISION            /* HP extension non-reserved word */
%token <tokval> TOK_DO
%token <tokval> TOK_DOT_STAR
%token <tokval> TOK_DOUBLE
%token <tokval> TOK_DOUBLE_IEEE
%token <tokval> TOK_DUPLICATE
%token <tokval> TOK_DYNAMIC
%token <tokval> TOK_DYNAMIC_FUNCTION    /* ANSI SQL non-reserved word */
%token <tokval> TOK_D_RANK             /* Tandem extension non-reserved word */
%token <tokval> TOK_DECADE
%token <tokval> TOK_DOW
%token <tokval> TOK_DOY
%token <tokval> TOK_EACH                
%token <tokval> TOK_EID
%token <tokval> TOK_ELSEIF
%token <tokval> TOK_ELSE
%token <tokval> TOK_ENABLE             
%token <tokval> TOK_END
%token <tokval> TOK_ENCODE_KEY          /* Tandem extension */
%token <tokval> TOK_ENCODE_BASE64
%token <tokval> TOK_DECODE_BASE64
%token <tokval> TOK_ENFORCED
%token <tokval> TOK_ENFORCERS
%token <tokval> TOK_ENTERPRISE
%token <tokval> TOK_ERROR
%token <tokval> TOK_ESCAPE
%token <tokval> TOK_ET
%token <tokval> TOK_EUROPEAN            /* Tandem extension non-reserved word */
%token <tokval> TOK_EVERY
%token <tokval> TOK_EXCEPT
%token <tokval> TOK_EXCEPTION
%token <tokval> TOK_EXCEPTIONS
%token <tokval> TOK_EXCEPTION_TABLE
%token <tokval> TOK_EXCHANGE            /* Tandem extension non-reserved word */
%token <tokval> TOK_EXCHANGE_AND_SORT
%token <tokval> TOK_EXCLUSIVE           /* Tandem extension non-reserved word */
%token <tokval> TOK_EXECUTE
%token <tokval> TOK_EXISTING            /* Tandem extension non-reserved word */
%token <tokval> TOK_EXISTS
%token <tokval> TOK_EXIT
%token <tokval> TOK_EXP
%token <tokval> TOK_EXPLAIN
%token <tokval> TOK_EXPONENTIATE
%token <tokval> TOK_EXTEND
%token <tokval> TOK_EXTERNAL
%token <tokval> TOK_EXTRACT
%token <tokval> TOK_EXTRACT_SOURCE
%token <tokval> TOK_EXTRACT_TARGET
%token <tokval> TOK_EPOCH
%token <tokval> TOK_FALSE
%token <tokval> TOK_FAMILY
%token <tokval> TOK_FEATURE_VERSION_INFO   /* Versioning. Non-reserved */
%token <tokval> TOK_FETCH
%token <tokval> TOK_FIRST
%token <tokval> TOK_FIRSTDAYOFYEAR
%token <tokval> TOK_FIRST_FSCODE
%token <tokval> TOK_FLOAT
%token <tokval> TOK_FLOAT_IEEE
%token <tokval> TOK_FLOOR
%token <tokval> TOK_FN                  /* ODBC extension non-reserved word */
%token <tokval> TOK_FOLLOWING
%token <tokval> TOK_FOR
%token <tokval> TOK_FOR_MAXRUNTIME
%token <tokval> TOK_LPAREN_BEFORE_DATATYPE
%token <tokval> TOK_LPAREN_BEFORE_DATE_AND_LPAREN
%token <tokval> TOK_LPAREN_BEFORE_DATE_COMMA_AND_FORMAT
%token <tokval> TOK_LPAREN_BEFORE_FORMAT
%token <tokval> TOK_LPAREN_BEFORE_NAMED
%token <tokval> TOK_FORCE
%token <tokval> TOK_FOR_BROWSE
%token <tokval> TOK_FOR_READ
%token <tokval> TOK_FOR_READ_ONLY
%token <tokval> TOK_FOR_REPEATABLE      /* FOR REPEATABLE */
%token <tokval> TOK_FOR_SERIALIZABLE    /* FOR SERIALIZABLE */
%token <tokval> TOK_FOR_STABLE          /* FOR STABLE */
%token <tokval> TOK_FOR_USER          /* FOR GET .. FOR USER */
%token <tokval> TOK_FOR_ROLE          /* FOR GET ... FOR ROLE */
%token <tokval> TOK_FOR_LIBRARY          /* FOR GET ... FOR LIBRARY */
%token <tokval> TOK_FOUND
%token <tokval> TOK_FRACTION            /* Tandem extension non-reserved word */
%token <tokval> TOK_FROM
%token <tokval> TOK_FROM_HEX
%token <tokval> TOK_FULL
%token <tokval> TOK_GENERAL             /* ANSI SQL potential-reserved word */
%token <tokval> TOK_GENERATE
%token <tokval> TOK_GENERATED 
%token <tokval> TOK_GET
%token <tokval> TOK_GLOBAL
%token <tokval> TOK_GO
%token <tokval> TOK_GOTO
%token <tokval> TOK_GREATER_EQUAL
%token <tokval> TOK_GREATEST
%token <tokval> TOK_GROUP
%token <tokval> TOK_GROUP_CONCAT
%token <tokval> TOK_GZIP
%token <tokval> TOK_HAVING
%token <tokval> TOK_HIVE
%token <tokval> TOK_HIVEMD
%token <tokval> TOK_QUALIFY
%token <tokval> TOK_HEADER
%token <tokval> TOK_TRAFODION
%token <tokval> TOK_HBASE
%token <tokval> TOK_HBASE_OPTIONS
%token <tokval> TOK_SERIALIZED
%token <tokval> TOK_HEX                 /* HP Neo extension non-reserved word */
%token <tokval> TOK_HEXADECIMAL         /* HP Neo extension non-reserved word */
%token <tokval> TOK_UNHEX
%token <tokval> TOK_HIGH_VALUE          /* Tandem extension non-reserved word */
// QSTUFF
%token <tokval> TOK_HOLD                /* standard holdable cursor */
// QSTUFF
%token <tokval> TOK_HOUR
%token <tokval> TOK_HOURS
%token <tokval> TOK_IDENTITY
%token <tokval> TOK_IF
%token <tokval> TOK_IGNORE	// MV
%token <tokval> TOK_IGNORETRIGGERS	// TRIGGERS
%token <tokval> TOK_IGNORE_TRIGGER
%token <tokval> TOK_IMMEDIATE
%token <tokval> TOK_IMMUTABLE
%token <tokval> TOK_IMPLICIT
%token <tokval> TOK_IN
%token <tokval> TOK_INCREMENT
%token <tokval> TOK_INCREMENTAL
%token <tokval> TOK_INOUT
%token <tokval> TOK_INSTR
%token <tokval> TOK_NOT_IN
%token <tokval> TOK_SYS_GUID
%token <tokval> TOK_INCLUSIVE
%token <tokval> TOK_INDICATOR
%token <tokval> TOK_INITIALIZATION // MV 
%token <tokval> TOK_INITIAL
%token <tokval> TOK_INITIALIZED      
%token <tokval> TOK_INGEST
%token <tokval> TOK_INNER
%token <tokval> TOK_INPUT
%token <tokval> TOK_INPUTS               /* HP Neo extension non-reserved word */
%token <tokval> TOK_BUFFERTOLOB
%token <tokval> TOK_EXTERNALTOLOB
%token <tokval> TOK_FILETOLOB
%token <tokval> TOK_FILETOEXTERNAL
%token <tokval> TOK_LOADTOLOB
%token <tokval> TOK_STRINGTOLOB
%token <tokval> TOK_STRINGTOEXTERNAL
%token <tokval> TOK_LOB
%token <tokval> TOK_LOBLENGTH
%token <tokval> TOK_LOBTOBUFFER
%token <tokval> TOK_LOBTOFILE
%token <tokval> TOK_LOBTOSTRING
%token <tokval> TOK_EXTERNALTOSTRING
%token <tokval> TOK_EMPTY_BLOB
%token <tokval> TOK_EMPTY_CLOB
%token <tokval> TOK_INSERT
%token <tokval> TOK_INSERT_ONLY
%token <tokval> TOK_INS
%token <tokval> TOK_ISOLATE              /* Tandem extension non-reserved word */
%token <tokval> TOK_INTEGER
%token <tokval> TOK_INTERNAL // MV REFRESH
%token <tokval> TOK_INTERNAL_EXPR
%token <tokval> TOK_INTERNAL_COLUMN_DEFINITION /*called by internal function*/
%token <tokval> TOK_INTERNALSP  /* Tdm ext., non-res., Internal Stored Procedure "TDMISP" */
%token <tokval> TOK_INTERSECT
%token <tokval> TOK_INTERVAL
%token <tokval> TOK_INTERVALS
%token <tokval> TOK_INTO
%token <tokval> TOK_INVOKE
%token <tokval> TOK_IS
%token <tokval> TOK_ISNULL
%token <tokval> TOK_IUDLOG	// MV REFRESH
%token <tokval> TOK_JAVA                /* Tandem extension non-reserved word */
%token <tokval> TOK_JOIN
%token <tokval> TOK_JSONOBJECTFIELDTEXT
%token <tokval> TOK_JULIANTIMESTAMP     /* Tandem extension */
%token <tokval> TOK_LAG                 /* LAG OLAP Function */
%token <tokval> TOK_LANGUAGE
%token <tokval> TOK_LARGEINT            /* Tandem extension non-reserved word */
%token <tokval> TOK_LASTNOTNULL
%token <tokval> TOK_LAST
%token <tokval> TOK_LAST_DAY
%token <tokval> TOK_LAST_FSCODE
%token <tokval> TOK_LAST_SYSKEY
%token <tokval> TOK_LASTSYSKEY
%token <tokval> TOK_LCASE               /* ODBC extension   */
%token <tokval> TOK_LEAD                /* LEAD OLAP Function */
%token <tokval> TOK_LEADING
%token <tokval> TOK_LEAST
%token <tokval> TOK_LEFT
%token <tokval> TOK_LESS_EQUAL
%token <tokval> TOK_LIBRARY
%token <tokval> TOK_LIBRARIES
%token <tokval> TOK_LIKE
%token <tokval> TOK_LIMIT
%token <tokval> TOK_LOAD
%token <tokval> TOK_LOAD_ID
%token <tokval> TOK_LOCAL
%token <tokval> TOK_LOCATE              /*  ODBC extension  */
%token <tokval> TOK_LOCK                /* Tandem extension */
%token <tokval> TOK_LOCK_ROW
%token <tokval> TOK_LOG
%token <tokval> TOK_LOGGABLE			//++ MV
%token <tokval> TOK_LOGON
%token <tokval> TOK_LZO
%token <tokval> TOK_IUD_LOG_TABLE          
%token <tokval> TOK_RANGE_LOG_TABLE		//++ MV
%token <tokval> TOK_LOG10
%token <tokval> TOK_LOG2
%token <tokval> TOK_LONGWVARCHAR

%token <tokval> TOK_LOW_VALUE           /* Tandem extension non-reserved word */
%token <tokval> TOK_LOWER
%token <tokval> TOK_LPAD
%token <tokval> TOK_LSDECIMAL
%token <tokval> TOK_LTRIM               /*  ODBC extension  */
%token <tokval> TOK_MAINTAIN
%token <tokval> TOK_MANAGEMENT
%token <tokval> TOK_MANUAL				// MV
%token <tokval> TOK_MASTER
%token <tokval> TOK_MATCH
%token <tokval> TOK_MATCHED
%token <tokval> TOK_MATERIALIZED        
%token <tokval> TOK_MAVG                /* Tandem extension non-reserved word */
%token <tokval> TOK_MAX
%token <tokval> TOK_MAXRUNTIME
%token <tokval> TOK_MAXVALUE
%token <tokval> TOK_MCOUNT              /* Tandem extension non-reserved word */
%token <tokval> TOK_MEMORY
%token <tokval> TOK_MERGE
%token <tokval> TOK_METADATA
%token <tokval> TOK_MD5
%token <tokval> TOK_MIN
%token <tokval> TOK_MINIMAL
%token <tokval> TOK_MINUTE
%token <tokval> TOK_MINUTES
%token <tokval> TOK_MINVALUE
%token <tokval> TOK_MIXED				// MV
%token <tokval> TOK_MOD
%token <tokval> TOK_MODIFIES
%token <tokval> TOK_MMAX                /* Tandem extension non-reserved word */
%token <tokval> TOK_MMIN                /* Tandem extension non-reserved word */
%token <tokval> TOK_MODE                /* Tandem extension non-reserved word */
%token <tokval> TOK_MODULE
%token <tokval> TOK_MODULES
%token <tokval> TOK_MONTH
%token <tokval> TOK_MONTHS_BETWEEN 
// %token <tokval> TOK_M -- already defined below
%token <tokval> TOK_MONTHNAME
%token <tokval> TOK_MORE                /* ANSI SQL non-reserved word */
%token <tokval> TOK_MRANK               /* Tandem extension non-reserved word */
%token <tokval> TOK_MSCK
%token <tokval> TOK_MSTDDEV             /* Tandem extension non-reserved word */
%token <tokval> TOK_MSUM                /* Tandem extension non-reserved word */
%token <tokval> TOK_MV                  
%token <tokval>	TOK_MVATTRIBUTE			// MV 
%token <tokval>	TOK_MVATTRIBUTES		// MV 
%token <tokval> TOK_MVS					// MV 
%token <tokval> TOK_MVSTATUS			// MV
%token <tokval> TOK_MV_TABLE            
%token <tokval> TOK_MVARIANCE           /* Tandem extension non-reserved word */
%token <tokval> TOK_MVGROUP			/*  */
%token <tokval> TOK_MVGROUPS
%token <tokval> TOK_MVS_UMD				// MV
%token <tokval> TOK_MVUID               // MV
%token <tokval> TOK_MULTI               /* Long Running */
%token <tokval> TOK_MULTIDELTA			// MV
%token <tokval> TOK_MULTISET
%token <tokval> TOK_NAMED
%token <tokval> TOK_NAMES
%token <tokval> TOK_NAMETYPE            /* Tandem extension non-reserved word */
%token <tokval> TOK_NATIONAL
%token <tokval> TOK_NATURAL
%token <tokval> TOK_NCHAR
%token <tokval> TOK_NECESSARY
%token <tokval> TOK_NEEDED
%token <tokval> TOK_NEW              
%token <tokval> TOK_NEXT
%token <tokval> TOK_NEXT_DAY
%token <tokval> TOK_NODELETE
%token <tokval> TOK_NODES
%token <tokval> TOK_NOT
%token <tokval> TOK_NOT_EQUAL
%token <tokval> TOK_NOW                 /* ODBC extension  */
%token <tokval> TOK_NSK_CODE            /* Tandem extension non-reserved word */
%token <tokval> TOK_NULL
%token <tokval> TOK_NULLIF
%token <tokval> TOK_NULLIFZERO
%token <tokval> TOK_NULL_STRING
%token <tokval> TOK_ZEROIFNULL
%token <tokval> TOK_NUMBER              /* ANSI SQL non-reserved word */
%token <tokval> TOK_NUMERIC
%token <tokval> TOK_NVL  
%token <tokval> TOK_OCTET_LENGTH
%token <tokval> TOK_OF
%token <tokval> TOK_OFFSET              /* Tandem extension non-reserved word */
%token <tokval> TOK_OJ                  /* ODBC extension  */
%token <tokval> TOK_OLD                
%token <tokval> TOK_ON
%token <tokval> TOK_ON_COMMIT           /* TD extension, non-reserved word */
%token <tokval> TOK_ONLY
%token <tokval> TOK_OPEN
%token <tokval> TOK_OR
%token <tokval> TOK_ORDER
%token <tokval> TOK_ORDERED
%token <tokval> TOK_OS_USERID
%token <tokval> TOK_OUT
%token <tokval> TOK_OUTER
%token <tokval> TOK_OUTPUT
%token <tokval> TOK_OVER
%token <tokval> TOK_OVERLAPS
%token <tokval> TOK_OVERRIDE
%token <tokval> TOK_OVERWRITE
%token <tokval> TOK_PAGE
%token <tokval> TOK_PAGES
%token <tokval> TOK_PARAMETER
%token <tokval> TOK_PARENT
%token <tokval> TOK_PARSERFLAGS
%token <tokval> TOK_ENVVAR
%token <tokval> TOK_ENVVARS
%token <tokval> TOK_PARTIAL
%token <tokval> TOK_PATH
%token <tokval> TOK_PERCENT
%token <tokval> TOK_PERFORM
%token <tokval> TOK_PERIODIC
%token <tokval> TOK_PERTABLE
%token <tokval> TOK_PHASE				// MV _REFRESH
%token <tokval> TOK_PI
%token <tokval> TOK_PIVOT
%token <tokval> TOK_PIVOT_GROUP
%token <tokval> TOK_POS
%token <tokval> TOK_POSITION
%token <tokval> TOK_POWER
%token <tokval> TOK_PRECEDING
%token <tokval> TOK_PREFER_FOR_SCAN_KEY
%token <tokval> TOK_PREPARE
%token <tokval> TOK_PRESERVE            /* TD extension that HP wants to ignore */
%token <tokval> TOK_PRIORITY
%token <tokval> TOK_PRIORITY_DELTA
%token <tokval> TOK_PROCEDURE
%token <tokval> TOK_PROCEDURES
%token <tokval> TOK_PROCESS
%token <tokval> TOK_PROGRESS
%token <tokval> TOK_PROTOTYPE           /* Tandem extension */
%token <tokval> TOK_QUERY               /* Tandem extension */
%token <tokval> TOK_QUERY_CACHE
%token <tokval> TOK_HYBRID_QUERY_CACHE
%token <tokval> TOK_HYBRID_QUERY_CACHE_ENTRIES
%token <tokval> TOK_CATMAN_CACHE
%token <tokval> TOK_NATABLE_CACHE
%token <tokval> TOK_NATABLE_CACHE_ENTRIES
%token <tokval> TOK_NAROUTINE_CACHE
%token <tokval> TOK_NAROUTINE_ACTION_CACHE
%token <tokval> TOK_QUERY_CACHE_ENTRIES
%token <tokval> TOK_QUERYID_EXTRACT
%token <tokval> TOK_QUARTER
%token <tokval> TOK_RADIANS
%token <tokval> TOK_RAND
%token <tokval> TOK_RANDOM
%token <tokval> TOK_RATE
%token <tokval> TOK_RAVG                /* Tandem extension non-reserved word */
%token <tokval> TOK_RCOUNT              /* Tandem extension non-reserved word */
%token <tokval> TOK_READ
%token <tokval> TOK_REAL
%token <tokval> TOK_REAL_IEEE
%token <tokval> TOK_RECOMPUTE             
%token <tokval> TOK_RECORD_SEPARATOR
%token <tokval> TOK_SEPARATOR
%token <tokval> TOK_RECOVER
%token <tokval> TOK_RECOVERY
%token <tokval> TOK_RECURSIVE 
%token <tokval> TOK_REFERENCING        
%token <tokval> TOK_REFRESH               
%token <tokval> TOK_RELATED
%token <tokval> TOK_RELATEDNESS        /* Versioning. Non-reserved */
%token <tokval> TOK_RELOAD
%token <tokval> TOK_REMOTE
%token <tokval> TOK_TEMP_TABLE         
%token <tokval> TOK_TEMPORARY
%token <tokval> TOK_REPAIR
%token <tokval> TOK_REPEAT
%token <tokval> TOK_REPEATABLE          /* ANSI SQL non-reserved word */ 
%token <tokval> TOK_REPEATABLE_ACCESS   /* Tandem extension */
%token <tokval> TOK_REPEATABLE_READ
%token <tokval> TOK_REPLACE
%token <tokval> TOK_REPOSITORY
%token <tokval> TOK_REQUEST            
%token <tokval> TOK_REQUIRED            /* Tandem extension non-reserved word */
%token <tokval> TOK_RESET
%token <tokval> TOK_RESTORE
%token <tokval> TOK_RESUME
%token <tokval> TOK_REWRITE              
%token <tokval> TOK_RESULT
%token <tokval> TOK_RETRIES
%token <tokval> TOK_RIGHT
%token <tokval> TOK_RMAX                /* Tandem extension non-reserved word */
%token <tokval> TOK_RMIN                /* Tandem extension non-reserved word */
%token <tokval> TOK_ROLE                /* ANSI SQL non-reserved word */
%token <tokval> TOK_ROLES
%token <tokval> TOK_ROLLBACK
%token <tokval> TOK_ROUND
%token <tokval> TOK_ROW
%token <tokval> TOK_ROW_COUNT           /* ANSI SQL non-reserved word */
%token <tokval> TOK_ROWNUM
%token <tokval> TOK_ROWS_DELETED	// MV _REFRESH
%token <tokval> TOK_ROWS_INSERTED	// MV _REFRESH
%token <tokval> TOK_ROWS_UPDATED	// MV _REFRESH 
%token <tokval> TOK_ROWS_COVERED	// MV AB_REFRESH 
%token <tokval> TOK_NUM_OF_RANGES	// MV AB_REFRESH 
%token <tokval> TOK_RPAD
%token <tokval> TOK_RRANK               /* Tandem extension non-reserved word */
%token <tokval> TOK_RSTDDEV             /* Tandem extension non-reserved word */
%token <tokval> TOK_RSUM                /* Tandem extension non-reserved word */
%token <tokval> TOK_RTRIM               /* ODBC extension  */
%token <tokval> TOK_RVARIANCE           /* Tandem extension non-reserved word */
%token <tokval> TOK_SAMPLE
%token <tokval> TOK_SAMPLE_FIRST
%token <tokval> TOK_SAMPLE_PERIODIC
%token <tokval> TOK_SAMPLE_RANDOM

%token <tokval> TOK_RUN
%token <tokval> TOK_STRING_SEARCH
%token <tokval> TOK_SECOND
%token <tokval> TOK_SECONDS
%token <tokval> TOK_SECTION
%token <tokval> TOK_SELECT
%token <tokval> TOK_SEL
%token <tokval> TOK_SELECTIVITY
%token <tokval> TOK_SEQNUM
%token <tokval> TOK_SEQUENCE            /* Tandem extension non-reserved word */
%token <tokval> TOK_SEQUENCES            
%token <tokval> TOK_SEQUENCE_BY         /* Tandem extension non-reserved word */
%token <tokval> TOK_SESSION
%token <tokval> TOK_SESSIONS
%token <tokval> TOK_SESSION_USER
%token <tokval> TOK_SESSN_USR_INTN
%token <tokval> TOK_SET
%token <tokval> TOK_SETS
%token <tokval> TOK_SG_TABLE
%token <tokval> TOK_SHA
%token <tokval> TOK_SHA1
%token <tokval> TOK_SHA2
%token <tokval> TOK_SHAPE
%token <tokval> TOK_SHARE               /* Tandem extension non-reserved word */
%token <tokval> TOK_SHARED              /* Tandem extension non-reserved word */
%token <tokval> TOK_SUSPEND
%token <tokval> TOK_SHOW
%token <tokval> TOK_SHOWCONTROL         /* Tandem extension     reserved word */
%token <tokval> TOK_SHOWDDL_ROLE
%token <tokval> TOK_SHOWDDL_COMPONENT
%token <tokval> TOK_SHOWDDL_LIBRARY
%token <tokval> TOK_SHOWDDL_SEQUENCE
%token <tokval> TOK_SHOWDDL_USER
%token <tokval> TOK_SHOWDDL             /* Tandem extension non-reserved word */
%token <tokval> TOK_SYSDATE
%token <tokval> TOK_SYSTIMESTAMP
%token <tokval> TOK_TARGET
%token <tokval> TOK_SYSTEM
%token <tokval> TOK_SHOWSTATS           /* Tandem extension non-reserved word*/
%token <tokval> TOK_SHOWTRANSACTION     /* Tandem extension non-reserved word*/
%token <tokval> TOK_ARKCMP              /* Tandem extension non-reserved word*/
%token <tokval> TOK_PROMPT              /* Tandem extension non-reserved word*/

%token <tokval> TOK_SHOWPLAN            /* Tandem extension     reserved word */
%token <tokval> TOK_SHOWSET             /* Tandem extension non-reserved word */ 
%token <tokval> TOK_SHOWSHAPE            /* Tandem extension     reserved word */
%token <tokval> TOK_SIGN                /* Tandem extension non-reserved word */
%token <tokval> TOK_SIGNAL
%token <tokval> TOK_SIGNED              /* Tandem extension non-reserved word */
%token <tokval> TOK_SIN
%token <tokval> TOK_SINCE               /* Tandem extension non-reserved word */
%token <tokval> TOK_SINGLEDELTA         // MV 
%token <tokval> TOK_SINH
%token <tokval> TOK_SLACK
%token <tokval> TOK_SPACE
%token <tokval> TOK_SMALLINT
%token <tokval> TOK_SOME
%token <tokval> TOK_SOUNDEX
%token <tokval> TOK_SORT                /* Tandem extension non-reserved word */
%token <tokval> TOK_SORT_KEY
%token <tokval> TOK_SP_RESULT_SET
%token <tokval> TOK_STATUS
%token <tokval> TOK_STDDEV              /* Tandem extension */
%token <tokval> TOK_STOP                /* Tandem extension */
%token <tokval> TOK_SPLIT_PART          /* Trafodion extension*/ 
%token <tokval> TOK_STORED
%token <tokval> TOK_SQL
%token <tokval> TOK_SQL_DOUBLE
%token <tokval> TOK_SQLCODE
%token <tokval> TOK_SQLERROR
%token <tokval> TOK_SQLSTATE
%token <tokval> TOK_SQL_WARNING         /* Tandem extension non-reserved word */
%token <tokval> TOK_SQRT
%token <tokval> TOK_STATEMENT           /* Tandem extension non-reserved word */
%token <tokval> TOK_STATIC              /* Tandem extension non-reserved word */
%token <tokval> TOK_STYLE               /* Tandem extension non-reserved word */
%token <tokval> TOK_SUBSTRING
%token <tokval> TOK_SUM
%token <tokval> TOK_SUMMARY
%token <tokval> TOK_T                   /* ODBC extension  */
%token <tokval> TOK_TABLE
%token <tokval> TOK_TABLES
%token <tokval> TOK_TABLESPACE
%token <tokval> TOK_TAN
%token <tokval> TOK_TANH
%token <tokval> TOK_THEN
%token <tokval> TOK_THIS
%token <tokval> TOK_TIME
%token <tokval> TOK_TIME_BEFORE_QUOTE
%token <tokval> TOK_TIMEOUT             
%token <tokval> TOK_TIMESTAMP
%token <tokval> TOK_TIMESTAMPADD
%token <tokval> TOK_TIMESTAMPDIFF
%token <tokval> TOK_TINYINT
%token <tokval> TOK_TITLE
%token <tokval> TOK_TO
%token <tokval> TOK_TO_BINARY
%token <tokval> TOK_TO_CHAR
%token <tokval> TOK_TO_DATE
%token <tokval> TOK_TO_HEX
%token <tokval> TOK_TO_NUMBER
%token <tokval> TOK_TO_TIME
%token <tokval> TOK_TO_TIMESTAMP
%token <tokval> TOK_TOKENSTR
%token <tokval> TOK_TRAILING
%token <tokval> TOK_TRANSACTION
%token <tokval> TOK_TRANSFORM
%token <tokval> TOK_TRANSPOSE           /* Tandem extenstion */
%token <tokval> TOK_TRIGGER             
%token <tokval> TOK_TRIGGERS
%token <tokval> TOK_TRIM
%token <tokval> TOK_TRUE
%token <tokval> TOK_TRUNC
%token <tokval> TOK_TRUNCATE
%token <tokval> TOK_TS                  /* ODBC extension  */
%token <tokval> TOK_UCASE               /* ODBC extension  */
%token <tokval> TOK_CODE_VALUE       /* Tandem extension */
%token <tokval> TOK_UNION
%token <tokval> TOK_UNION_JOIN
%token <tokval> TOK_UNIQUE
%token <tokval> TOK_UNIQUE_ID
%token <tokval> TOK_UUID
%token <tokval> TOK_UNKNOWN
%token <tokval> TOK_UNLOAD
%token <tokval> TOK_SCAN
%token <tokval> TOK_SNAPSHOT
%token <tokval> TOK_SUFFIX
%token <tokval> TOK_UNLOCK              /* Tandem extension */
%token <tokval> TOK_UNSIGNED            /* Tandem extension non-reserved word */
%token <tokval> TOK_UPDATE		
%token <tokval> TOK_UPDATE_STATS
%token <tokval> TOK_UPDATE_LOB		
%token <tokval> TOK_UPD
%token <tokval> TOK_UPGRADE
%token <tokval> TOK_UPPER
%token <tokval> TOK_UPSERT
%token <tokval> TOK_UPPERCASE           /* TD extension that HP maps to UPSHIFT */
%token <tokval> TOK_UPSHIFT             /* Tandem extension */
%token <tokval> TOK_USA                 /* Tandem extension non-reserved word */
%token <tokval> TOK_USAGE
%token <tokval> TOK_USE					// MV _REFRESH
%token <tokval> TOK_USER
%token <tokval> TOK_USERNAMEINTTOEXT
%token <tokval> TOK_USERS
%token <tokval> TOK_USING
%token <tokval> TOK_VALUE
%token <tokval> TOK_VALUES
%token <tokval> TOK_VARBINARY
%token <tokval> TOK_VARCHAR
%token <tokval> TOK_VARIANCE            /* Tandem extension */
%token <tokval> TOK_VARWCHAR
%token <tokval> TOK_VARYING
%token <tokval> TOK_VERSION
%token <tokval> TOK_VERSIONS
%token <tokval> TOK_VPROC
%token <tokval> TOK_VERSION_INFO        /* Versioning. Non-reserved */
%token <tokval> TOK_VOLATILE
%token <tokval> TOK_WAITED
%token <tokval> TOK_WAITEDIO
%token <tokval> TOK_WCHAR
%token <tokval> TOK_WEEK
%token <tokval> TOK_WOM
%token <tokval> TOK_WHEN
%token <tokval> TOK_WHENEVER
%token <tokval> TOK_WHERE
%token <tokval> TOK_WITH
%token <tokval> TOK_SLEEP
%token <tokval> TOK_UUID_SHORT
%token <tokval> TOK_UNIX_TIMESTAMP
// QSTUFF
%token <tokval> TOK_WITHOUT             /* standard holdable cursor */
// QSTUFF
%token <tokval> TOK_WORK
%token <tokval> TOK_WRITE
%token <tokval> TOK_XMLAGG
%token <tokval> TOK_XMLELEMENT
%token <tokval> TOK_YEAR

%token <tokval> TOK_ACTION
%token <tokval> TOK_ADD
%token <tokval> TOK_REMOVE				// MV -RG () Tandem extension	
%token <tokval> TOK_OPENBLOWNAWAY		// Y_TEST
%token <tokval> TOK_REDEFTIME			// _TEST
%token <tokval> TOK_ALTER
%token <tokval> TOK_ALTER_LIBRARY
%token <tokval> TOK_ALTER_MV
%token <tokval> TOK_ALTER_MV_GROUP
%token <tokval> TOK_ALTER_ROUTINE
%token <tokval> TOK_ALTER_ROUTINE_ACTION
%token <tokval> TOK_ALTER_SYNONYM
%token <tokval> TOK_ALTER_TABLE
%token <tokval> TOK_ALTER_TRIGGER
%token <tokval> TOK_ALTER_VIEW
%token <tokval> TOK_ASCENDING           /* Tandem extension */
%token <tokval> TOK_ASSERTION
%token <tokval> TOK_ATTRIBUTE           /* Tandem extension */
%token <tokval> TOK_ATTRIBUTES          /* Tandem extension */
%token <tokval> TOK_AUDIT               /* Tandem extension */
%token <tokval> TOK_AUDITCOMPRESS       /* Tandem extension */
%token <tokval> TOK_AUTHENTICATION
%token <tokval> TOK_AUTHNAME
%token <tokval> TOK_AUTHORIZATION
%token <tokval> TOK_AUTHTYPE
%token <tokval> TOK_BLOCKSIZE           /* Tandem extension */
%token <tokval> TOK_BRIEF               /* Tandem extension */
%token <tokval> TOK_BUFFER
%token <tokval> TOK_BUFFERED            /* Tandem extension */
%token <tokval> TOK_BYTE                /* TD extension that HP maps to CHAR */
%token <tokval> TOK_BYTES               /* Tandem extension */
%token <tokval> TOK_CAPTURE
%token <tokval> TOK_CASCADE
%token <tokval> TOK_CASCADED
%token <tokval> TOK_CATALOG
%token <tokval> TOK_CATALOGS
%token <tokval> TOK_CHECK
%token <tokval> TOK_CLEAN
%token <tokval> TOK_CLEANUP
%token <tokval> TOK_CLEANUP_OBSOLETE
%token <tokval> TOK_CLEAR               /* Tandem extension */
%token <tokval> TOK_CLEARONPURGE        /* Tandem extension */
%token <tokval> TOK_COLUMN
%token <tokval> TOK_COLUMNS		/* MV _REFRESH    */
%token <tokval> TOK_COMPILE	
%token <tokval> TOK_COMPONENT
%token <tokval> TOK_COMPONENTS
%token <tokval> TOK_COMPRESSION
%token <tokval> TOK_CONFIG              /* Tandem extension */
%token <tokval> TOK_CONSTRAINT
%token <tokval> TOK_CONSTRAINTS
%token <tokval> TOK_COPY
%token <tokval> TOK_CREATE
%token <tokval> TOK_CREATE_LIBRARY
%token <tokval> TOK_CREATE_MV
%token <tokval> TOK_CREATE_MV_GROUP
%token <tokval> TOK_CREATE_PROCEDURE
%token <tokval> TOK_CREATE_ROUTINE
%token <tokval> TOK_CREATE_ROUTINE_ACTION
%token <tokval> TOK_CREATE_TABLE
%token <tokval> TOK_CREATE_TRIGGER
%token <tokval> TOK_CREATE_SYNONYM
%token <tokval> TOK_CREATE_VIEW
%token <tokval> TOK_DATA                /* ANSI SQL non-reserved word*/
%token <tokval> TOK_DBA
%token <tokval> TOK_DCOMPRESS           /* Tandem extension */
%token <tokval> TOK_DDL
%token <tokval> TOK_DESCENDING          /* Tandem extension */
%token <tokval> TOK_DEPENDENT
%token <tokval> TOK_DROP
%token <tokval> TOK_DROP_LIBRARY
%token <tokval> TOK_DROP_MV
%token <tokval> TOK_DROP_MV_GROUP
%token <tokval> TOK_DROP_PROCEDURE
%token <tokval> TOK_DROP_ROUTINE
%token <tokval> TOK_DROP_ROUTINE_ACTION
%token <tokval> TOK_DROP_SYNONYM
%token <tokval> TOK_DROP_TABLE
%token <tokval> TOK_DROP_TRIGGER
%token <tokval> TOK_DROP_VIEW
%token <tokval> TOK_DROPPABLE           /* Tandem extension */
%token <tokval> TOK_DSLACK              /* Tandem extension */
%token <tokval> TOK_ENTRY               /* Tandem extension */
%token <tokval> TOK_ENTRIES             /* Tandem extension */
%token <tokval> TOK_EXECUTION		/* Tandem extension */
%token <tokval> TOK_FOREIGN
%token <tokval> TOK_G                   /* Tandem extension */
%token <tokval> TOK_GHOST               /* Tandem extension non-reserved word */
%token <tokval> TOK_GIVE                /* Tandem extension */
%token <tokval> TOK_GRANT
%token <tokval> TOK_GRANTEES
%token <tokval> TOK_GRANTED
%token <tokval> TOK_HARDWARE
%token <tokval> TOK_HASH                /* Tandem extension */
%token <tokval> TOK_HASH2               /* Tandem extension */
%token <tokval> TOK_HASHPARTFUNC        /* Tandem extension */
%token <tokval> TOK_HASH2PARTFUNC       /* Tandem extension */
%token <tokval> TOK_HEADING             /* Tandem extension */
%token <tokval> TOK_HEADINGS            /* Tandem extension */
%token <tokval> TOK_ICOMPRESS           /* Tandem extension */
%token <tokval> TOK_HORIZONTAL          /* Tandem extension non-reserved word */
%token <tokval> TOK_INITIALIZE          /* Tandem extension non-reserved word */
%token <tokval> TOK_INITIALIZE_MAINTAIN
%token <tokval> TOK_REINITIALIZE_MAINTAIN
%token <tokval> TOK_INITIALIZE_SQL
%token <tokval> TOK_INDEX               /* Tandem extension non-reserved word */
%token <tokval> TOK_INDEXES             /* Tandem extension non-reserved word */
%token <tokval> TOK_INDEX_TABLE         /* Tandem extension non-reserved word */
%token <tokval> TOK_INSERTLOG			// MV 
%token <tokval> TOK_INVALID
%token <tokval> TOK_INVALIDATE
%token <tokval> TOK_ISIPV4
%token <tokval> TOK_ISIPV6
%token <tokval> TOK_ISLACK              /* Tandem extension */
%token <tokval> TOK_K                   /* Tandem extension */
%token <tokval> TOK_KEY
%token <tokval> TOK_KEY_RANGE_COMPARE   /* Tandem extension */
%token <tokval> TOK_LABEL
%token <tokval> TOK_LABEL_CREATE        /* internal label creates */
%token <tokval> TOK_LABEL_DROP          /* internal label drops */
%token <tokval> TOK_LABEL_ALTER         /* internal label alter */
%token <tokval> TOK_LABEL_PURGEDATA
%token <tokval> TOK_LOCATION            /* Tandem extension */
%token <tokval> TOK_LOCKING             /* TD extension that HP wants to ignore */
%token <tokval> TOK_LOCKONREFRESH		// MV
%token <tokval> TOK_M                   /* Tandem extension */
%token <tokval> TOK_MOVE                /* Tandem extension */
%token <tokval> TOK_MOVEMENT            /* Tandem extension */
%token <tokval> TOK_MVLOG				// MV
%token <tokval> TOK_NAMESPACE    	/* Tandem extension */	
%token <tokval> TOK_NO
%token <tokval> TOK_NONE
%token <tokval> TOK_NOMVLOG				// MV
%token <tokval> TOK_NOLOG
%token <tokval> TOK_NO_DEFAULT          /* Tandem extension */
%token <tokval> TOK_NO_PARTITION        /* Tandem extension */
%token <tokval> TOK_NO_PARTITIONS       /* Tandem extension */
%token <tokval> TOK_NO_LOAD
%token <tokval> TOK_NOT_DROPPABLE       /* Tandem extension */
%token <tokval> TOK_NOT_ENFORCED        /* Tandem extension */
%token <tokval> TOK_OBSOLETE
%token <tokval> TOK_OBJECT
%token <tokval> TOK_OBJECTS
%token <tokval> TOK_OFF
%token <tokval> TOK_OFFLINE             /* Tandem extension */
%token <tokval> TOK_ONLINE              /* Tandem extension */
%token <tokval> TOK_OPCODE              /* internal label alter opcode */
%token <tokval> TOK_OPTION
%token <tokval> TOK_OPTIONS
%token <tokval> TOK_OSIM
%token <tokval> TOK_SIMULATE
%token <tokval> TOK_PARALLEL            /* Tandem extension */
%token <tokval> TOK_PARTITION           /* Tandem extension non-reserved word*/
%token <tokval> TOK_PARTITIONING        /* Tandem extension non-reserved word*/
%token <tokval> TOK_PARTITIONS          /* Tandem extension non-reserved word*/
%token <tokval> TOK_PIPELINE			/* MV  _REFRESH */ 
%token <tokval> TOK_POPULATE            /* Tandem extension */
%token <tokval> TOK_PRIMARY
%token <tokval> TOK_PRIMARY_INDEX
%token <tokval> TOK_PRIVATE              
%token <tokval> TOK_PRIVILEGE           /* HP extension non-reserved word */
%token <tokval> TOK_PRIVILEGES
%token <tokval> TOK_PUBLIC
%token <tokval> TOK_PURGEDATA
%token <tokval> TOK_RANGE               /* Tandem extension non-reserved word*/
%token <tokval> TOK_RANGE_N             /* TD extension that HP wants to ignore */
%token <tokval> TOK_RANGELOG			/* MV */
%token <tokval> TOK_REBUILD
%token <tokval> TOK_REFERENCES
%token <tokval> TOK_REGEXP
%token <tokval> TOK_REGION
%token <tokval> TOK_REGISTER            /* Tandem extension */
%token <tokval> TOK_REGISTERED
%token <tokval> TOK_UNREGISTER          /* Tandem extension */
%token <tokval> TOK_RENAME              /* Tandem extension */
%token <tokval> TOK_REPLICATE           /* Tandem extension non-reserved word*/
%token <tokval> TOK_RESTRICT
%token <tokval> TOK_REVOKE
%token <tokval> TOK_ROWS                /* Tandem extension */
%token <tokval> TOK_RRPARTFUNC          /* Tandem extension */
%token <tokval> TOK_SALT                /* HP extension non-reserved word */
%token <tokval> TOK_SCHEMA
%token <tokval> TOK_SCHEMAS
%token <tokval> TOK_SECURITY
%token <tokval> TOK_STORE               /* Tandem extension */
%token <tokval> TOK_STORAGE
%token <tokval> TOK_STATISTICS          /* Tandem extension non-reserved word */
%token <tokval> TOK_HBMAP_TABLE
%token <tokval> TOK_STATS
%token <tokval> TOK_UNBOUNDED           /* Tandem extension */
%token <tokval> TOK_VIEW
%token <tokval> TOK_VIEWS
%token <tokval> TOK_VALIDATE            /* Tandem extension */
%token <tokval> TOK_ALIAS               /* Tandem extension */
%token <tokval> TOK_SYNONYM             /* Tandem extension */
%token <tokval> TOK_SYNONYMS             /* Tandem extension */
%token <tokval> TOK_LONG                /* Tandem extension */
%token <tokval> TOK_BIGINT              /* Tandem extension */
%token <tokval> TOK_LEVEL
%token <tokval> TOK_LEVELS
%token <tokval> TOK_EOF
%token <tokval> TOK_ISOLATION
%token <tokval> TOK_COMMITTED           /* ANSI SQL non-reserved word*/
%token <tokval> TOK_UNAVAILABLE			// MV
%token <tokval> TOK_UNCOMMITTED         /* ANSI SQL non-reserved word*/
%token <tokval> TOK_SIZE
%token <tokval> TOK_SERIALIZABLE        /* ANSI SQL non-reserved word */ 
%token <tokval> TOK_SERIALIZABLE_ACCESS /* Tandem extension */
%token <tokval> TOK_SOFTWARE
%token <tokval> TOK_REINITIALIZE        /* Tandem extension non-reserved word */
%token <tokval> TOK_SEPARATE            /* Tandem extension */
%token <tokval> TOK_BACKUP

// QSTUFF
%token <tokval> TOK_STREAM              /* Tandem ext: table streams pub/sub */
%token <tokval> TOK_SKIP		/* Tandem ext: table streams pub/sub */
%token <tokval> TOK_CONFLICT  		/* Tandem ext: table streams pub/sub */
%token <tokval> TOK_SKIP_CONFLICT_ACCESS /* extension */
%token <tokval> TOK_FOR_SKIP		/* Tandem ext: table streams pub/sub */
%token <tokval> TOK_RETURN              /* Tandem ext: table streams pub/sub */
%token <tokval> TOK_CURSOR_WITH_HOLD
%token <tokval> TOK_CURSOR_WITHOUT_HOLD
// QSTUFF

%token <tokval> TOK_VSBB                /* Tandem extension non-reserved word */

%token <tokval> TOK_ROWSET
%token <tokval> TOK_ROWWISE
%token <tokval> TOK_ROWSET_SIZE              /* Tandem ext: non-reserved word : dynamic rowsets*/
%token <tokval> TOK_ROWSET_VAR_LAYOUT_SIZE   /* Tandem ext: non-reserved word : dynamic rowsets*/
%token <tokval> TOK_ROWSET_IND_LAYOUT_SIZE   /* Tandem ext: non-reserved word : dynamic rowsets*/
%token <stringval> DOLLAR_IDENTIFIER    /* identifier starting w/ dollar sign */
                                        /* It is a LOCATION name or ENV value */
%token <tokval> TOK_PARAMETER_MODE      /* ANSI SQL non-reserved word */
%token <tokval> TOK_PARAMETER_ORDINAL_POSITION /* ANSI SQL non-reserved word */
%token <tokval> TOK_PARAMETER_INDEX /* INTERNAL non-reserved word */

%token <tokval> TOK_ALIGNED             /* Tandem extension non-reserved word */
%token <tokval> TOK_PACKED              /* Tandem extension non-reserved word */
%token <tokval> TOK_QID              /* Tandem extension non-reserved word */
%token <tokval> TOK_QID_INTERNAL     /* Tandem extension non-reserved word */
%token <tokval> TOK_PID              /* Tandem extension non-reserved word */
%token <tokval> TOK_CPU              /* Tandem extension non-reserved word */
%token <tokval> TOK_ACTIVE           /* Tandem extension non-reserved word */
%token <tokval> TOK_RMS         /* Tandem extension non-reserved word */
%token <tokval> TOK_REVERSE
%token <tokval> TOK_OVERLAY
%token <tokval> TOK_STUFF      /* same as overlay */
%token <tokval> TOK_PLACING

%token <tokval> TOK_DATA_OFFSET        /* INTERNAL non-reserved word */
%token <tokval> TOK_NULL_IND_OFFSET    /* INTERNAL non-reserved word */
%token <tokval> TOK_ALIGNED_LENGTH     /* INTERNAL non-reserved word */

%token <tokval> TOK_ACTIVATE           /* INTERNAL non-reserved word */
%token <tokval> TOK_PARTITION_BY       /* compound token */
%token <tokval> TOK_UDF      /* non-reserved word */
%token <tokval> TOK_REPLICATE_PARTITION      /* compound token */


%token <tokval> TOK_RETURNS            /* ANSI SQL potential-reserved word */
%token <tokval> TOK_PASS               /* HP Neo extension non-reserved word */
%token <tokval> TOK_THROUGH            /* HP Neo extension non-reserved word */
%token <tokval> TOK_TEXT               /* HP Neo extension non-reserved word */
%token <tokval> TOK_FILE               /* HP Neo extension non-reserved word */
%token <tokval> TOK_FINAL              /* HP Neo extension non-reserved word */
%token <tokval> TOK_ALLOW              /* HP Neo extension non-reserved word */
%token <tokval> TOK_PARALLELISM        /* HP Neo extension non-reserved word */
%token <tokval> TOK_AREA               /* HP Neo extension non-reserved word */
%token <tokval> TOK_TABLE_MAPPING      /* HP Neo extension non-reserved word */
%token <tokval> TOK_SCALAR             /* HP Neo extension non-reserved word */
%token <tokval> TOK_TAG                /* HP Neo extension non-reserved word */
%token <tokval> TOK_UNIVERSAL          /* HP Neo extension non-reserved word */
%token <tokval> TOK_FAST               /* HP Neo extension non-reserved word */
%token <tokval> TOK_SAFE               /* HP Neo extension non-reserved word */
%token <tokval> TOK_MESSAGE            /* HP Neo extension non-reserved word */
%token <tokval> TOK_NORMAL             /* HP Neo extension non-reserved word */
%token <tokval> TOK_IO                 /* HP Neo extension non-reserved word */
%token <tokval> TOK_SAS_FORMAT         /* HP Neo extension non-reserved word */
%token <tokval> TOK_SAS_LOCALE         /* HP Neo extension non-reserved word */
%token <tokval> TOK_SAS_MODEL_INPUT_TABLE /* Neo extension non-reserved word */
%token <tokval> TOK_SQLROW             /* HP Neo extension non-reserved word */

%token <tokval> TOK_DEFINER            /* SPJ Definer Rights Support, non-reserved word */
%token <tokval> TOK_INVOKER            /* SPJ Definer Rights Support, non-reserved word */
%token <tokval> TOK_VERIFY            

/*
  ------------------------------------------------------------------------
   NOTE TO SPJ DEVELOPERS
  ------------------------------------------------------------------------
   (remove this note when merging from SPJ branch into a release branch)

  The tokens below represent SQL99 reserved words that are not yet
  being used in MX. The SPJ project has put to use many of these
  tokens, and in doing so moved token declarations from the list below
  to the large, alphabetized list above. When merging code between SPJ
  and other branches, make sure any SPJ-related reserved words are
  removed from the list below.

*/

/* ANSI SQL 99 additional reserved words not already used */
%token <tokval> TOK_AGGREGATE
%token <tokval> TOK_ARRAY
%token <tokval> TOK_BINARY

%token <tokval> TOK_CLASS
%token <tokval> TOK_CONSTRUCTOR
%token <tokval> TOK_CUBE
%token <tokval> TOK_CURRENT_PATH

%token <tokval> TOK_DEREF
%token <tokval> TOK_DESTROY
%token <tokval> TOK_DESTRUCTOR

%token <tokval> TOK_FREE
%token <tokval> TOK_FUNCTION
%token <tokval> TOK_FUNCTIONS
%token <tokval> TOK_GROUPING
%token <tokval> TOK_GROUPING_ID
%token <tokval> TOK_HOST

%token <tokval> TOK_ITERATE
%token <tokval> TOK_LARGE
%token <tokval> TOK_LATERAL
%token <tokval> TOK_LOCALTIME

%token <tokval> TOK_LOCALTIMESTAMP
%token <tokval> TOK_LOCATOR
%token <tokval> TOK_MAP
%token <tokval> TOK_NCLOB

%token <tokval> TOK_ORDINALITY
%token <tokval> TOK_POSTFIX

 //%token <tokval> TOK_PREFIX
%token <tokval> TOK_READS
%token <tokval> TOK_ROLLUP
%token <tokval> TOK_SCOPE

%token <tokval> TOK_SPECIFIC
%token <tokval> TOK_SPECIFICTYPE
%token <tokval> TOK_START
%token <tokval> TOK_STATE

%token <tokval> TOK_TERMINATE
%token <tokval> TOK_THAN
%token <tokval> TOK_TREAT
%token <tokval> TOK_UNNEST
%token <tokval> TOK_EXTENT
%token <tokval> TOK_MAXEXTENTS
%token <tokval> TOK_UID
%token <tokval> TOK_DISK
%token <tokval> TOK_POOL

%token <tokval> TOK_MTS

%token <tokval> TOK_CHECKSUM
%token <tokval> TOK_FALLBACK
%token <tokval> TOK_PROTECTED
%token <tokval> TOK_PROTECTION
%token <tokval> TOK_FREESPACE
%token <tokval> TOK_DUAL
%token <tokval> TOK_JOURNAL
%token <tokval> TOK_FORMAT
%token <tokval> TOK_CASESPECIFIC
%token <tokval> TOK_NOT_CASESPECIFIC
%token <tokval> TOK_FIXED

//
// Any tokens appended to the foregoing list likely need to be added to
// the "nonreserved_word" or "nonreserved_func_word" production at the 
// end of this file -- see comments there!

/* ',' has lower precedence than other operators,
 * that's why it comes FIRST in the following list
 */
%right ','
%left TOK_UNION TOK_INTERSECT TOK_EXCEPT
%left TOK_JOIN TOK_CROSS TOK_INNER TOK_NATURAL TOK_FULL TOK_LEFT TOK_RIGHT TOK_UNION_JOIN
%left TOK_ON
%left '>' '=' '<' TOK_GREATER_EQUAL TOK_LESS_EQUAL TOK_NOT_EQUAL
%left TOK_AND
%left '+' '-'
%left '*' '/'
%left '.'


%union
{
// This provides a way to exclude the union for modules which need the
// token defines, but do not want the union and all the references
// which come with it.
//
#ifdef INCLUDE_UNION
  Int32               	     	tokval;
  TokvalPlusYYText		tokval_plus_yytext;
  NAString             	     	*stringval;
  NAWString             	*wstringval;
  StringvalWithCharSet		stringval_with_charset;

  action               		*actn_ptr;
  TransMode::AccessType         accesstype;
  ComAnsiNameSpace              nameSpaceEnum;
  ComColumnOrdering 	     	columnOrderingEnum;
  ComCreateViewBehavior		createViewBehaviorEnum;
  ComDropBehavior   	     	dropBehaviorEnum;
  ComRegisterBehavior           registerBehaviorEnum;
  ComRoutineType                routineTypeEnum;
  ComUnregisterBehavior         unregisterBehaviorEnum;
  ComLevels                     levelEnum;
  ComOperation                  iudOp;
  ComObjectName                 *comObjectName;
  ComObjectType                 objectTypeEnum;
  ComPartitioningScheme         partitionType;
  ComParamDirection             routineParamMode;
  ComRoutineExecutionMode       routineExecutionMode;
  ComRoutinePassThroughInputType passThroughInputType;
  ComAuthenticationType         authTypeEnum;
  ComRCMatchOption  	     	matchTypeEnum;
  ComSchemaClass                schemaClassEnum;
  ComUnits          	     	fileAttrSizeUnitEnum;
  ComTableFeature		tableFeatureEnum;
  CorrName	       	     	*corrName;
  DatetimeQualifier             *datetimeQualifier;
  DescTypeList     		*descTypeList;
  Describe::Format              describeType;
  Describe::ShowcontrolOption   showcontrolEnum;
  designation          		*dsgtn;
  ElemDDLConstraint 		*pElemDDLConstraint;
  ElemDDLConstraintRI 		*pElemDDLConstraintRI;
  ElemDDLConstraintUnique 	*pElemDDLConstraintUnique;
  ElemDDLNode      	     	*pElemDDL;
  ElemDDLParamName              *pElemDDLParamName;
  ElemDDLPartition::optionEnum	partitionOptionEnum;
  ElemDDLSchemaName 		*pElemDDLSchemaName;
  CharInfo::CharSet	        charSetVal;
  CharInfo::Collation		collationVal;
  CollationAndCoercibility	collationAndCoercibility;
  CollationInfo::CollationType	CollationType;
  CollationInfo::SortDirection	SortDirection;
  TableTokens                  *tableTokens;
  ExprNode                      *exprnode;
  ExprNodePtrList               *exprnodeptrs;
  HVArgType      		*hvArgtype;
  HVArgTypeLookup      		*hvArgtypeLookup;
  Insert::InsertType            insertType;
  IntervalQualifier             *intervalQualifier;
  ItemExpr             		*item;
  ItemExprList        		*itemList;
  Lng32              	     	longint;
  Int64                         int64;
  LockMode                      lockmode;
  ForUpdateSpec			*forUpdateSpec;
  NABoolean         	     	boolean;
  NAType               		*na_type;
  OldNewNames                   *OldNewPtr;
  OperatorTypeEnum  	     	operator_type;
  PairOfUnsigned                *pairPtr;
  PartitionClause               *partitionClause;
  QualifiedName                 *pQualName;
  rec_datetime_field            datetimeField;
  RelExpr              		*relx;
  Scan                          *scan;
  double              		     doubleVal;
  Hint              		    *hint;
  HbaseAccessOptions          *hbaseAccessOptions;
  RelExpr::AtomicityType        atomicityType;
  SchemaName                    *pSchemaName;
  SequenceOfLong                *longSeq;
  ShortStringSequence  		*strSeq;
  SQLDESC_ITEM_ID             	descItemId;
  SQLDIAG_COND_INFO_ITEM_ID  	condInfoItemId;
  SQLDIAG_STMT_INFO_ITEM_ID   	stmtInfoItemId;
  StaticDescItem   		*staticDescItem;
  StmtDDLNode      	     	*pStmtDDL;
  StmtDDLCreateTrigger 	     	*pStmtDDLCreateTrigger;
  enum TableTokens::TableOptions tableLoadAttrEnum;
  enum TransMode::AccessMode	transAccessMode;
  enum TransMode::IsolationLevel isolation;
  StmtNode             		*stmt_ptr;
  //++ MV
  ComMVRefreshType              refreshType;    
  ComMVStatus			mvStatus;
  enum StmtDDLAlterMvRGroup::alterMvGroupType MVRGAlterActionType; 
  ComRangeLogType		rangelogType;
  ComMvsAllowed			mvsAllowedType;
  ComMvAuditType		mvAuditType;
  MvInitializationType          mvInitType;
  enum StmtDDLCommentOn::COMMENT_ON_TYPES  commentOnEnum;
	
  // internal refresh OZ_REFRESH 

  PipelineDefPtrList		*pPipelineDefPtrList;
  PipelineDef			*pPipelineDef;
  QualNamePtrList		*pQualifiedNamePtrList;
  NRowsClause			*pOptionalNRowsClause;
  PipelineClause		*pPipelineClause;
  DeltaDefinitionPtrList	*pDeltaDefinitionPtrList;
  DeltaDefinition		*pDeltaDefinition;
  IncrementalRefreshOption	*pIncrementalRefreshOption;
  RecomputeRefreshOption	*pRecomputeRefreshOption;

  DeltaOptions			*pDeltaOptions;
  DeltaDefLogs			*pDeltaDefLogs;  
  DeltaDefRangeLog		*pDeltaDefRangeLog; 
  DeltaDefIUDLog		*pDeltaDefIUDLog;
  IUDStatistics			*pIUDStatistics;
  IntegerList			*pIntegerList;
  ConstStringList               *pConstStringList;

  //-- MV
  StmtOrCursTag       		*stmt_or_curs;
  UInt32          	     	 uint;
  unsigned short    	     	 usmallint;
  BiRelat			*pBiRelat;

  NAList<PivotGroup::PivotOption*> * pivotOptionsList;
  PivotGroup::PivotOption * pivotOption;

  NAList<ExeUtilMaintainObject::MaintainObjectOption*> * maintainObjectOptionsList;
  ExeUtilMaintainObject::MaintainObjectOption * maintainObjectOption;

  NAList<ExeUtilAQR::AQROption*> * aqrOptionsList;
  ExeUtilAQR::AQROption * aqrOption;

  NAList<ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*> * hBaseBulkLoadOptionsList;
  ExeUtilHBaseBulkLoad::HBaseBulkLoadOption * hBaseBulkLoadOption;

  NAList<UnloadOption*> * hbbUnloadOptionsList;
  UnloadOption * hbbUnloadOption;

  ParTriggerScopeType    parTriggerScopeType;
  ExtractSource::ExtractType extractType;

  PtrPlaceHolder                *ptr_placeholder;
  ParAuxCharLenSpec             *pCharLenSpec;

  NAList<HbaseCreateOption*> * hbaseOptionsList;
  HbaseCreateOption * hbaseOption;

  NAList<HbaseColumnCreate::HbaseColumnCreateOptions *> * hbaseColumnCreateOptionsList;
  HbaseColumnCreate::HbaseColumnCreateOptions *hbaseColumnCreateOptions;


#endif   // INCLUDE_UNION
}

%type <stmt_ptr>  	     starting_production
%type <stmt_ptr>  	     starting_production2
%type <forUpdateSpec>        for_update_spec
%type <iudOp>                iud_event   
%type <boolean>              before_action_orientation //( Default/FALSE = ROW)
%type <boolean>              after_action_orientation // ( Def/TRUE =STATEMENT)
%type <OldNewPtr>            referencing_clause 
%type <item>                 triggered_before_action
%type <relx>                 triggered_after_action
%type <boolean>              enable_status
%type <boolean>              optional_all_of
%type <item>                 triggerred_when_clause
%type <itemList>      	     trigger_set_clause_list
%type <item>      	     trigger_set_clause
%type <refreshType>		  refresh_type
%type <pElemDDL>  		  create_mv_attribute_table_lists
%type <pElemDDL>  		  create_mv_one_attribute_table_list
%type <pElemDDL>  		  ignore_changes_on_table_list
%type <mvInitType>	          mv_initialization_clause
%type <boolean>			  optional_query_rewrite
%type <pElemDDL>  		  optional_create_mv_file_options
// table attributes
%type <pElemDDL>  		  file_attribute_rangelog_clause	
%type <rangelogType>  		  range_log_type 
%type <pElemDDL>  		  file_attribute_lockonrefresh_clause 
%type <pElemDDL>  		  file_attribute_insertlog_clause	
%type <pElemDDL>  		  file_attribute_mvs_allowed_clause	
%type <mvsAllowedType>		  mvs_allowed_type 
// mv attributes
%type <pElemDDL>  		  mv_file_attribute_clause
%type <tokval>			  mv_file_attribute_keyword
%type <pElemDDL>  		  mv_file_attribute_list
%type <pElemDDL>  		  mv_file_attribute
%type <mvAuditType>		  mv_audit_type
// for general use
%type <pElemDDL>  		  qual_name_list 
%type <pElemDDL>  		  qual_name
// MVGROUPS
%type <pStmtDDL>  		  create_mvrgroup_statement  
%type <pStmtDDL>  		  drop_mvrgroup_statement  
%type <pStmtDDL>		  alter_mv_refresh_group_statement 
%type <MVRGAlterActionType>	  mv_group_alter_action_type
%type <pQualName>		  mv_group_name_to_alter
%type <pElemDDL>		  mv_name_list
%type <pElemDDL>		  mv_name_node
// INTERANL REFRESH OZ_REFRESH
%type <relx>			  internal_refresh_command
%type <relx>			  internal_refresh_options
%type <pQualName>		  internal_refresh_mv_name
%type <pRecomputeRefreshOption>	  recompute_refresh_options
%type <pIncrementalRefreshOption> incremental_refresh_options
%type <pDeltaDefinitionPtrList>	  delta_definition_list
%type <pDeltaDefinition>	  delta_definition_node
%type <uint>			  begin_epoch
%type <uint>			  end_epoch
%type <pDeltaOptions>		  delta_options 
%type <pDeltaDefLogs>		  delta_def_logs
%type <pDeltaDefRangeLog>	  delta_def_range_log
%type <pDeltaDefIUDLog>		  delta_def_iud_log
%type <pIUDStatistics>		  iud_statistics_rows 
%type <uint>			  num_inserted 
%type <uint>			  num_deleted 
%type <uint>			  num_updated 
%type <pIntegerList>		  optional_update_collumns
%type <pIntegerList>		  columns_num_list
%type <pOptionalNRowsClause>	  optional_nrows_clause
%type <uint>			  phase_num
%type <item>			  optional_catchup
%type <pPipelineClause>		  optional_pipeline_clause
%type <pPipelineClause>		  pipeline_clause
%type <pPipelineDefPtrList>	  pipeline_def_list
%type <pPipelineDef>		  pipeline_def
%type <pQualifiedNamePtrList>	  pipeline_mv_name_list
%type <pQualName>	          pipeline_mv_name_node

// MVLOG
%type <relx>			  mvlog_command
%type <tokval>			  mvlog_keywords 
%type <pQualName>		  mvlog_table_name
%type <item>              mvlog_values_list

// IUD
%type <uint>                      no_check_log
%type <boolean>			  no_rollback
%type <boolean>			  ignore_triggers

// DIRECTEDBY comparison operator
%type <pIntegerList>		  direction_vector_comma_list
%type <pIntegerList>		  direction_vector
%type <tokval>			  direction_literal

//-- MV
%type <stmt_ptr>             open_cursor
%type <dsgtn>                extended_input_designation
%type <dsgtn>                using_descriptor
%type <dsgtn>                extended_output_designation
%type <dsgtn>                into_descriptor
%type <stmt_ptr>             fetch_cursor
%type <stmt_ptr>             dynamic_prepare
%type <stmt_ptr>             dynamic_execute
%type <stmt_ptr>             execute_immediate
%type <stmt_ptr>             alloc_desc_statement
%type <stmt_ptr>             dealloc_stmt_statement
%type <stmt_ptr>             dealloc_desc_statement
%type <longSeq>              set_info_item_list
%type <longint>              set_info_item
%type <longSeq>              get_info_item_list
%type <longint>              get_info_item
%type <longint>              info_item_name
%type <longSeq>              cond_info_item_list
%type <longint>              cond_info_item
%type <longint>              cond_info_item_name
%type <longSeq>              stmt_info_item_list
%type <longint>              stmt_info_item_name
%type <longint>              stmt_info_item
%type <longint>              simple_value_spec
%type <stmt_ptr>             get_desccount_statement
%type <stmt_ptr>             get_rowsetsize_statement
%type <stmt_ptr>             get_descitem_statement
%type <stmt_ptr>             set_desccount_statement
%type <stmt_ptr>             set_rowsetsize_statement
%type <stmt_ptr>             set_descitem_statement
%type <stmt_ptr>             get_stmtdiags_statement
%type <stmt_ptr>             get_conddiags_statement
%type <stmt_ptr>             close_statement
%type <stmt_ptr>             whenever_statement
%type <uint>                 whenever_condition
%type <actn_ptr>             whenever_action
%type <stmt_ptr>             describe_statement
%type <stringval>            describe_target
%type <uint>                 output_or_input
%type <uint>                 output_hostvar_list
%type <uint>                 input_hostvar_list
%type <boolean>              global_hint
%type <boolean>              set_quantifier
%type <tokval>               firstn_sorted
%type <item>                 sort_spec_list
%type <item>                 sort_spec
%type <item>                 order_by_clause
%type <item>                 order_by_clause_non_empty
%type <stmt_ptr>             declare_static_cursor
%type <relx>                 cursor_spec
%type <relx>		     query_exp_for_cursor
%type <stmt_ptr>             declare_dynamic_cursor
%type <stringval>            entity_name
%type <item>	             entity_name_as_item
%type <boolean>              scope_spec
%type <stmt_ptr>             alloc_static_desc_stmt
%type <uint>                 input_or_output
%type <stmt_or_curs>         for_stmt_or_curs
%type <staticDescItem>       host_var_type_item
%type <descTypeList>         host_var_type_list
%type <stmt_ptr>             procedure_stmt
%type <hvArgtype>            proc_arg_decl
%type <hvArgtypeLookup>      proc_arg_decls
%type <uint>                 argList_establishment
%type <stmt_ptr>             module_statement
%type <stmt_ptr> 		     source_file_statement
%type <stmt_ptr>             module_timestamp
%type <item>	  	     any_expression
%type <stmt_ptr>  	     sql_statement
%type <item>      		literal
%type <item>      		literal_negatable
%type <item>                   numeric_literal
%type <item>                   numeric_literal_exact
%type <item>                   character_literal_sbyte
%type <item>                   boolean_literal
%type <stringval> 		literal_as_string
%type <stringval> 		character_string_literal
%type <stringval>		sbyte_string_literal
%type <wstringval> 		unicode_string_literal
%type <tokval>    		sign
%type <corrName>  		table_name
%type <corrName>		special_table_name
%type <corrName>  		actual_table_name
%type <corrName>  		actual_table_name2
%type <corrName>		exception_table_name
%type <stringval> 		identifier
%type <stringval> 		identifier_with_hat
%type <stringval> 		identifier_with_dollar
%type <strSeq>    		qualified_name
%type <strSeq>    		schema_name_ss
%type <strSeq>    		module_name
%type <strSeq>    		routine_action_name
%type <stringval> 		correlation_name
%type <relx>      		table_reference
%type <relx>  		        table_name_and_hint
%type <relx>  		        upd_stmt_w_acc_type_and_as_clause
%type <relx>  		        upd_stmt_w_acc_type_and_as_clause_col_list
%type <relx>  		        upd_stmt_w_acc_type_rtn_list_and_as_clause
%type <relx>  		        upd_stmt_w_acc_type_rtn_list_and_as_clause_col_list
%type <relx>  		        del_stmt_w_acc_type_and_as_clause
%type <relx>  		        del_stmt_w_acc_type_and_as_clause_col_list
%type <relx>  		        del_stmt_w_acc_type_rtn_list_and_as_clause
%type <relx>  		        del_stmt_w_acc_type_rtn_list_and_as_clause_col_list
%type <relx>  		        table_name_as_clause_and_hint
%type <relx>  		        table_name_as_clause_hint_and_col_list
%type <relx>  		        rel_subquery_and_as_clause
%type <relx>  		        rel_subquery_as_clause_and_col_list
%type <relx>                    with_clause
%type <relx>                    with_clause_elements
%type <relx>                    with_clause_element
%type <hint>      		optimizer_hint
%type <hint>      		hints
%type <hint>      		index_hints
%type <hint>      		ignore_ms4_hints
%type <hbaseAccessOptions>     hbase_access_options
%type <stringval>    	index_hint
%type <doubleVal>       number
%type <doubleVal>       selectivity_number
%type <doubleVal>       predicate_selectivity_hint

//QSTUFF
%type <relx>            table_as_stream
%type <relx>            table_as_stream_any
//QSTUFF
%type <relx>                    table_as_tmudf_function

%type <relx>      		table_as_procedure
%type <relx>      		joined_table
%type <relx>      		joined_table_needing_spec
%type <relx>      		joined_table_needing_spec2
%type <item>      		derived_column_list
%type <charSetVal>      	    character_set
%type <charSetVal>      	    CHAR_FUNC_character_set
%type <charSetVal>      	    char_set
%type <collationVal>    	    collate_clause
%type <collationAndCoercibility>    collation_option
%type <item>      		sort_or_group_key
%type <tokval>    		ordering_spec
%type <columnOrderingEnum>  	ddl_ordering_spec
%type <item>      		set_function_specification
%type <operator_type>		set_function_type
%type <operator_type>		running_func_type
%type <operator_type>		moving_func_type
%type <item>				sequence_func_specification
%type <item>				running_sequence_function
%type <item>                moving_sequence_function
%type <item>                offset_sequence_function
%type <item>                this_sequence_function
%type <item>                olap_sequence_function
%type <item>                opt_olap_part_clause
%type <item>                opt_olap_order_clause
%type <longint>             olap_rows_spec
%type <longint>             olap_prec_follow
%type <item>                            insert_value_expression
%type <item>      			value_expression
%type <item>      			value_expression_sans_collate
%type <item>      			value_expression_list
%type <item>      			value_expression_list_comma
%type <item>      			value_expression_list_paren
%type <item>      			value_expression_list_lr
%type <item>                list_of_values

// left recursion for insert statement values.
%type <item>	      		insert_value_expression_list
%type <item>	      		insert_value_expression_list_comma
%type <item>				insert_value_expression_list_paren
// left recursion for insert statement values.

%type <hbaseColumnCreateOptionsList>                hbase_column_create_list
%type <hbaseColumnCreateOptions>                hbase_column_create_value
%type <item>      			cast_specification
%type <item>      			value_function
%type <item>                    optional_round_scale
%type <item>                    math_function
%type <operator_type>           math_func_0_operand
%type <operator_type>           math_func_1_operand
%type <operator_type>           math_func_2_operands
%type <item>                    misc_function
%type <operator_type>           date_time_operand
%type <charSetVal>		optional_character_set
%type <charSetVal>		CHAR_FUNC_optional_character_set
%type <item>                    string_function
%type <item>      		trim_operands
%type <item>                    insert_obj_to_lob_function
%type <item>                    update_obj_to_lob_function
%type <item>                    select_lob_to_obj_function
%type <item>                    insert_empty_blob_clob
%type <stringval>    		date_format
%type <tokval>    		trim_spec
%type <na_type>   		proc_arg_data_type
%type <na_type>   		data_type
%type <na_type>   		Set_Cast_Global_False_and_data_type
%type <na_type>   		routine_predef_type
%type <na_type>   		predef_type
%type <na_type>   		predefined_type
%type <na_type>   		date_time_type
%type <na_type>   		interval_type
%type <na_type>   		int_type
%type <na_type>   		non_int_type
%type <na_type>   		numeric_type
%type <tokval>                 numeric_type_token
%type <na_type>   		pic_type
%type <na_type>   		string_type
%type <na_type>                 blob_type
%type <na_type>                 boolean_type
%type <na_type>   		float_type
%type <na_type>   		proc_arg_float_type
%type <longint>                 pic_tail
%type <intervalQualifier>	interval_qualifier
%type <intervalQualifier>	single_datetime_field
%type <intervalQualifier>	start_field
%type <intervalQualifier>	end_field
%type <intervalQualifier>       fraction_only_interval
%type <datetimeField>		non_second_datetime_field
%type <datetimeField>		new_non_second_datetime_field
%type <datetimeField>		datetime_field
%type <datetimeQualifier>       datetime_qualifier           //For MP Datetime
%type <datetimeQualifier>       datetime_start_field         //For MP Datetime
%type <datetimeQualifier>       datetime_end_field           //For MP Datetime
%type <datetimeQualifier>       fraction_only_datetime       //For MP Datetime
%type <datetimeQualifier>       datetime_fraction_field      //For MP Datetime
%type <uint>                    interval_fraction_field
%type <item>	  	  datetime_keywords
%type <item>	  	  timestamp_keywords
%type <uint>      		unsigned_integer
%type <usmallint> 		unsigned_smallint
%type <uint>      		ts_left_unsigned_right
%type <uint>      		left_unsigned_right
%type <pCharLenSpec>		toggled_optional_left_charlen_right
%type <uint>      		optional_left_charlen_right
%type <longint>                 blob_optional_left_len_right
%type <longint>                 clob_optional_left_len_right
%type <pCharLenSpec>		new_optional_left_charlen_right
%type <tokval>      		nchar     
%type <tokval>      		nchar_varying
%type <tokval>      		optional_charlen_unit  
%type <tokval>			new_optional_charlen_unit  
%type <tokval>			tok_char_or_character
%type <tokval>			tok_char_or_character_or_byte
%type <uint>      		left_charlen_right 
%type <pCharLenSpec>		new_left_charlen_right
%type <uint>      		left_unsigned  
%type <item>      		left_largeint_right
%type <pairPtr>      		left_uint_uint_right
%type <item>      		term
%type <item>      		factor
%type <item>      		factor1
%type <item>      		primary
%type <item>      		dynamic_parameter
%type <item>                    dynamic_parameter_array
%type <item>      		internal_arith_placeholder
%type <item>      		internal_bool_placeholder
%type <relx>	  		table_value_constructor
%type <relx>      		table_expression
%type <relx>      		from_clause
%type <item>      		join_specification
%type <item>      		join_condition
%type <item>      		where_clause
%type <uint>                    multi_commit_size
%type <item>      		group_by_clause_non_empty
%type <item>      		having_clause_non_empty
%type <item>      		qualify_clause
%type <item>      		sort_by_key
%type <item>      		sort_by_key_list
%type <item>      		sort_by_value_expression
%type <item>      		sort_by_value_expression_list
%type <item>      		sort_by_clause
%type <item>      		sequence_by_clause
%type <relx>      		transpose_clause
%type <relx>      		transpose_clause_list
%type <relx>      		cond_transpose_clause_list
%type <item>      		transpose_list
%type <item>      		transpose_set
%type <item>      		transpose_item_list
%type <item>      		transpose_value
%type <item>      		transpose_col_list
%type <relx>      		query_specification
%type <relx>      		query_spec_body
%type <item>      		query_select_list //++ MV
%type <item>      		select_list
// QSTUFF
%type <item>      		return_list
// QSTUFF
%type <item>      		select_list_item
%type <item>      		derived_column
%type <stringval> 		as_clause
%type <relx>      		interactive_query_expression
%type <relx>			dml_query
%type <relx>			dml_statement
%type <relx>      		query_expression
%type <relx>      		query_term
%type <relx>			query_primary
%type <relx>      		non_join_query_expression
%type <relx>      		non_join_query_term
%type <relx>      		non_join_query_primary
%type <relx>      		simple_table
%type <relx>      		rel_subquery
%type <item>      		row_subquery
%type <item>      		predicate
%type <item>                    dml_column_reference
%type <item>      		null_predicate
%type <boolean>                 scan_key_hint
%type <pBiRelat>      		comparison_predicate
%type <item>      		directed_comparison_predicate
%type <item>                    key_comparison_predicate
%type <item>                    partitioning_key_type
%type <corrName>                pkey_access_path
%type <corrName>                ckey_access_path
%type <operator_type>  		comparison_operator
%type <tokval>  		between_operator
%type <tokval>    		quantifier
%type <tokval>    		select_token
%type <item>      		exists_predicate
%type <item>      		between_predicate
%type <item>      		in_predicate
%type <item>      		like_predicate
%type <tokval>	  		not_like
%type <item>	  		  overlaps_predicate 
%type <item>      		quantified_predicate
%type <item>      		search_condition
%type <item>      		boolean_term
%type <item>      		boolean_factor
%type <item>      		boolean_test
%type <tokval>    		truth_value
%type <item>      		boolean_primary
%type <relx>      		Rest_Of_insert_statement
%type <relx>      		Rest_Of_insert_wo_INTO_statement
%type <insertType>     		front_of_insert
%type <insertType>     		Front_Of_Insert
%type <insertType>                  front_of_insert_with_rwrs
//%type <corrName>  		optional_exception_table_name
%type <atomicityType>           atomic_clause
%type <atomicityType>           opt_atomic_clause
%type <item>      		column_list
%type <tokval>    		group_list
%type <tokval>    		id_group_list
%type <tokval>    		id_group
%type <tokval>    		id_list
%type <tokval>    		showstats_opts
%type <relx>      	        update_statement_searched
%type <relx>      		update_statement_searched_body
%type <scan>                    update_statement_target_table
%type <relx>                    merge_statement
// QSTUFF
%type <item>      		set_update_list
%type <item>      		set_update_commit_list
%type <item>      		set_update_rollback_list
%type <item>      		set_delete_list
%type <item>      		set_delete_rollback_list
// QSTUFF
%type <item>      		set_clause
%type <relx>      		delete_statement
%type <relx>      		delete_start_tokens
%type <relx>      		control_statement
%type <relx>            osim_statement
%type <boolean>   		optional_osim_force
%type <relx>      		set_statement  
%type <relx>      		set_table_statement  
%type <boolean>                 optional_stream
%type <corrName>  		set_table_name
%type <item>                    timeout_value
%type <relx>      		set_session_default_statement  

%type <relx>      		declare_or_set_cqd
%type <relx>                    transaction_statement
%type <boolean>   		on_off
%type <boolean>   		on_or_empty
// but cannot be empty. (i.e) must specify.
%type <longint>			autoabort_interval
%type <longint>                 maxruntime_interval
%type <tokval>			hour_hours
%type <tokval>			minute_minutes
%type <tokval>			second_seconds
%type <relx>                    lock_unlock_statement
%type <relx>                    lock_statement
%type <relx>                    unlock_statement
%type <boolean>                 lock_index_option
%type <lockmode>                lock_mode
%type <lockmode>                optional_lock_mode
%type <tokval>			query_shape_options
%type <exprnode>		query_shape_control
%type <relx>			query_default_control
%type <relx>			session_control
%type <relx>			table_control
%type <stringval>		default_identifier
%type <stringval>               table_control_identifier
%type <stringval>		optional_control_identifier
%type <stringval>               optional_options
%type <exprnodeptrs>		shape_arg_list
%type <stringval>		shape_identifier
%type <tokval>			token_shape_identifier
%type <relx>                    show_statement
%type <longint>                 optional_showddl_schema_options_list
%type <longint>                 optional_showddl_object_options_list
%type <longint>                 optional_showddl_role_option
%type <corrName>                optional_showddl_action_name_clause
%type <longint>                 showddl_options_list
%type <longint>                 showddl_options
%type <describeType>            showcontrol_type
//%type <uint>      		returning_clause
%type <item>      		input_hostvar_expression
%type <item>      		hostvar_expression
%type <item>      		simple_host_variable
%type <item>      		hostvar_and_prototype
%type <item>      		param_and_prototype
%type <boolean>			mvs_umd_option
%type <boolean>   		upshift_flag
%type <boolean>			notcasespecific_option
%type <boolean>			pic_notcasespecific_option
%type <boolean>			character_literal_notcasespecific_option
%type <boolean>   		signed_option
%type <stringval> 		regular_identifier
%type <stringval> 		regular_identifier_not_builtin
%type <comObjectName>           user_defined_function_name
%type <objectTypeEnum>          givable_object_type
%type <tokval>                  nonreserved_word
%type <tokval>                  nonreserved_word_for_explain
%type <tokval>                  nonreserved_func_word
%type <tokval>                  MP_nonreserved_word
%type <tokval>                  MP_nonreserved_func_word
%type <tokval>                  nonreserved_datatype
%type <stringval> 		column_name
%type <pElemDDL>  		column_name_spec
%type <pQualName> 		constraint_name
%type <pElemDDL>  		constraint_name_list
%type <pElemDDL>  		constraint_simple_name
%type <boolean>   		constraint_setting
%type <pSchemaName> 		schema_name
%type <pElemDDLSchemaName>	schema_name_clause
%type <schemaClassEnum>         schema_class
%type <stringval> 		schema_authorization_identifier
%type <stringval> 		authorization_identifier
%type <stringval> 		authorization_identifier_or_public
%type <pElemDDL>  		authorization_identifier_list
%type <stringval>               as_auth_clause
%type <pElemDDL>                optional_schema_clause
%type <stringval>               optional_as_auth_clause
%type <stringval> 		external_user_identifier
%type <tokval>	 		for_user_or_role
%type <tokval>                  procedure_or_function
%type <pStmtDDL>  		sql_schema_statement
%type <pStmtDDL>  		sql_schema_definition_statement
%type <pStmtDDL>  		sql_schema_manipulation_statement
%type <pStmtDDL>  		sql_schema_statement_prologue
%type <pStmtDDL>  		schema_definition
%type <uint>   	        	schema_or_database
%type <pStmtDDL>  		routine_definition
%type <pStmtDDL>                alter_function_statement
%type <pElemDDL>                routine_params_list
%type <pElemDDL>                routine_params_list_clause
%type <tokval>                  return_tokens
%type <pElemDDL>                optional_routine_returns_clause
%type <pElemDDL>                routine_returns_clause
%type <pElemDDL>                optional_passthrough_inputs_clause
%type <pElemDDL>                passthrough_inputs_clause
%type <pElemDDL>                optional_add_passthrough_inputs_clause
%type <pElemDDL>                optional_alter_passthrough_inputs_clause
%type <pElemDDL>                alter_passthrough_inputs_clause
%type <tokval>                  passthrough_inputs_clause_start_tokens
%type <routineTypeEnum>         create_scalar_function_tokens
%type <routineTypeEnum>         table_mapping_function_tokens
%type <routineTypeEnum>         universal_function_tokens
%type <routineTypeEnum>         drop_routine_type_tokens
%type <pElemDDL>                universal_function_param
%type <pElemDDL>                universal_function_param_list
%type <pElemDDL>                universal_function_param_clause
%type <pElemDDL>                passthrough_params_list
%type <pElemDDL>                passthrough_params
%type <pElemDDL>                passthrough_param
%type <pElemDDL>                alter_passthrough_params_list
%type <pElemDDL>                alter_passthrough_params
%type <pElemDDL>                alter_passthrough_param
%type <uint>                    passthrough_param_position
%type <passThroughInputType>    optional_passthrough_input_type
%type <pElemDDL>                passthrough_input_value
%type <routineExecutionMode>    routine_execution_mode
%type <pElemDDL>                routine_params
%type <pElemDDL>                routine_param
%type <pElemDDL>                routine_return_param
%type <pElemDDL>                routine_return_param_optional_not_null
%type <pElemDDL>                routine_return_param_list
%type <pElemDDL>                routine_return_params
%type <longint>                 extent_page
%type <longint>                 signed_extent_page
%type <tokval>                  optional_page
%type <pElemDDLParamName>       optional_param_name
%type <pElemDDLParamName>       param_name
%type <routineParamMode>        optional_param_mode
%type <routineParamMode>        optional_return_param_mode
%type <pElemDDL>                optional_library_clientname
%type <pElemDDL>                optional_library_clientfilename
/*
%type <pElemDDL>                optional_library_attribute_list
%type <pElemDDL>                library_attribute_list
%type <pElemDDL>                library_attribute
*/
%type <pElemDDL>                optional_create_routine_attribute_list
%type <pElemDDL>                create_routine_attribute_list
%type <pElemDDL>                create_routine_attribute
%type <pElemDDL>                optional_create_function_attribute_list
%type <pElemDDL>                create_function_attribute_list
%type <pElemDDL>                create_function_attribute
%type <pElemDDL>                create_function_udf_attribute
%type <pElemDDL>                create_function_udr_attribute
%type <pElemDDL>                udr_external_name_clause
%type <stringval>               std_char_string_literal
%type <pElemDDL>                udr_external_path_clause 
%type <pElemDDL>                udr_language_clause 
%type <pElemDDL>                udr_library_clause 
%type <pElemDDL>                udr_param_style_clause
%type <pElemDDL>                routine_parameter_style_sql
%type <pElemDDL>                routine_parameter_style_sqlrow
%type <pElemDDL>                udr_access_clause
%type <pElemDDL>                udr_result_sets_clause 
%type <pElemDDL>                udr_deterministic_clause 
%type <pElemDDL>                udr_isolate_clause 
%type <pElemDDL>                udr_transaction_clause
%type <pElemDDL>                udr_external_security_clause
%type <pElemDDL>                udr_external_security_invoker
%type <pElemDDL>                udr_external_security_definer
%type <pElemDDL>                udf_param_style_clause
%type <pElemDDL>                udf_special_attributes_clause
%type <stringval>               udf_special_attributes
%type <pElemDDL>                udf_final_call_clause
%type <pElemDDL>                udf_state_area_clause
%type <pElemDDL>                udf_parallelism_clause
%type <pElemDDL>                udf_execution_mode_clause
%type <pElemDDL>                udf_version_tag_clause
%type <pElemDDL>                udf_optimization_hint_clause
%type <pElemDDL>                udf_number_of_unique_values_clause
%type <tokval>                  number_of_unique_values_tokens
%type <pElemDDL>                number_of_unique_output_values
%type <itemList>                unique_output_value_list
%type <item>                    unique_output_value
%type <tokval>                  udf_optimization_stage
%type <tokval>                  udf_resource_kind
%type <longint>                 udf_cost
%type <pStmtDDL>  		table_definition
%type <pStmtDDL>  		view_definition
%type <pStmtDDL>  		mv_definition 
%type <boolean>                 create_mv_keywords
%type <createViewBehaviorEnum>  create_view_keywords
%type <pStmtDDL>  		trigger_definition
%type <pStmtDDL>  		before_trigger_definition
%type <pStmtDDL>  		after_trigger_definition
%type <pStmtDDLCreateTrigger>	before_trigger_prefix
%type <pStmtDDLCreateTrigger>	after_trigger_prefix
%type <pQualName>               routine_action_qualified_name
%type <pQualName>               ddl_qualified_name
%type <pQualName>               optional_ghost_ddl_qualified_name
%type <pQualName>               volatile_ddl_qualified_name
%type <pElemDDL>                optional_view_column_list
%type <pElemDDL>                optional_ignored_table_options
%type <pElemDDL>                optional_ignored_table_option
%type <pElemDDL>                optional_ignored_prefix
%type <pElemDDL>                optional_ignored_prefix2
%type <pElemDDL>                optional_ignored_suffix
%type <pElemDDL>                view_column_list
%type <pElemDDL>                view_column_def_list
%type <pElemDDL>                view_column_definition
%type <pElemDDL>                optional_with_check_option
%type <pElemDDL>                with_check_option
%type <levelEnum>               optional_levels_clause
%type <levelEnum>               levels_clause
%type <pStmtDDL>                comment_on_statement
%type <commentOnEnum>           comment_on_object_types

%type <stringval>               optional_component_detail_clause
%type <int64>                   optional_lob_unit
%type <stringval>               component_privilege_name
%type <stringval>               component_name
%type <stringval>               identifier_with_7_bit_ascii_chars_only
%type <stringval>               regular_identifier_with_7_bit_ascii_chars_only
%type <stringval>               component_str_lit
%type <stringval>               priv_abbrev_str_lit
%type <pConstStringList>        component_privilege_name_list
%type <tokval>                  privilege_or_privileges_token
%type <pStmtDDL>                alter_user_statement
%type <pStmtDDL>                alter_library_statement
%type <pStmtDDL>                create_library_stmt
%type <pStmtDDL>                drop_library_statement
%type <boolean>                 optional_system
%type <pStmtDDL>		give_statement
%type <pStmtDDL>                grant_component_privilege_stmt
%type <pStmtDDL>  		grant_statement
%type <pStmtDDL>  		grant_role_statement
%type <pStmtDDL>  		revoke_role_statement
%type <boolean>                 optional_with_admin_option
%type <boolean>                 optional_granted
 /*%type <boolean>                 admin_option_for*/
%type <pElemDDL>                optional_granted_by
%type <pStmtDDL>                create_component_privilege_stmt
%type <pStmtDDL>                drop_component_privilege_stmt
%type <pStmtDDL>                register_component_statement
%type <pStmtDDL>                register_user_statement
%type <pStmtDDL>                register_hive_statement
%type <pStmtDDL>                register_hbase_statement
%type <boolean>                 optional_internal_clause
%type <pStmtDDL>                unregister_component_statement
%type <pStmtDDL>		unregister_user_statement
%type <pStmtDDL>		unregister_hive_statement
%type <pStmtDDL>		unregister_hbase_statement
%type <pElemDDL>  		privileges
%type <pElemDDL>  		privilege_action_list
%type <pElemDDL>  		privilege_action
%type <pElemDDL>  		optional_privilege_column_list
%type <pElemDDL>  		privilege_column_list
%type <pElemDDL>  		optional_update_column_list 
%type <pQualName> 		ddl_object_name
%type <pQualName>               optional_action
%type <pElemDDL>  		grantee_list
%type <pElemDDL>  		grantee
%type <pElemDDL>  		optional_with_grant_option
%type <pElemDDL>  		with_grant_option
%type <pElemDDL>  	        optional_by_auth_identifier
%type <pStmtDDL>                create_role_statement
%type <pStmtDDL>                drop_role_statement
%type <pElemDDL>                optional_with_admin_clause
%type <pElemDDL>                with_admin_clause

%type <pStmtDDL>		grant_schema_statement

%type <pStmtDDL>		create_sequence_statement
%type <pStmtDDL>		alter_sequence_statement
%type <pStmtDDL>		drop_sequence_statement
%type <pStmtDDL>           cleanup_objects_statement
%type <boolean>               optional_cleanup_return_details

%type <pStmtDDL>  		catalog_definition
%type <pStmtDDL>  		catalog_definition2
%type <stringval>               catalog_name
%type <stringval>               sql_mx_catalog_name
%type <stringval>               sql_mp_catalog_name
%type <pElemDDL>                optional_create_catalog_attribute_list
%type <pElemDDL>                create_catalog_attribute_list
%type <pElemDDL>                create_catalog_attribute
%type <pStmtDDL>  		drop_schema_statement
%type <stringval>               nsk_node_name
%type <partitionOptionEnum>  	partition_add_drop_option
%type <pElemDDL>  		add_table_constraint_definition
%type <pStmtDDL>  		alter_table_column_clause
%type <pElemDDL>  		location_definition
%type <stringval>               guardian_volume_name
%type <partitionClause>         optional_special_table_loc_clause
%type <int64>                   optional_special_utility_open_clause
%type <boolean>                 optional_with_shared_access_clause
%type <stringval>               fully_expanded_guardian_loc_name
%type <stringval>               guardian_location_name
%type <stringval>               partition_name
%type <pElemDDL>  		location_list
%type <pElemDDL>  		source_location_list
%type <pElemDDL>  		dest_location_list
%type <pStmtDDL>  		alter_index_action
%type <pStmtDDL>  		alter_index_statement
%type <pStmtDDL>  		alter_trigger_statement
%type <pStmtDDL>  		alter_view_statement
//++ MV
%type <pStmtDDL>  		alter_mv_statement   
%type <pStmtDDL>  		alter_mv_body
%type <pStmtDDL>  		alter_mv_query_rewrite
%type <pStmtDDL>  		alter_mv_file_attribs
%type <pStmtDDL>  		alter_mv_mvfile_attribs
%type <pStmtDDL>                alter_mv_rename
%type <pStmtDDL>                alter_mv_attribute_table_lists
//-- MV

%type <pStmtDDL>		alter_audit_config_statement
%type <pStmtDDL>		alter_catalog_statement
%type <pStmtDDL>		alter_schema_statement
%type <pElemDDL>  		alter_table_move_clause
%type <pStmtDDL>  		alter_table_rename_clause
%type <pStmtDDL>                alter_table_enable_index_clause
%type <pStmtDDL>                alter_table_disable_index_clause
%type <uint>  		        alter_stored_descriptor_option
%type <boolean>   		optional_cascade
%type <boolean>                 optional_skip_view_check
%type <pStmtDDL>  		alter_table_add_column_clause
%type <pStmtDDL>  		alter_table_drop_column_clause
%type <pStmtDDL>  		alter_table_alter_column_clause //++ MV
%type <pStmtDDL>  		alter_table_alter_column_default_value 
%type <pStmtDDL>  		alter_table_alter_column_datatype
%type <pStmtDDL>  		alter_table_alter_column_set_sg_option 
%type <pStmtDDL>  		alter_table_alter_column_rename
%type <boolean>   		alter_column_type //++ MV
%type <pStmtDDL>  		alter_table_set_constraint_clause
%type <pStmtDDL>                alter_table_disable_constraint_clause
%type <pStmtDDL>                alter_table_enable_constraint_clause
%type <pStmtDDL>  		alter_table_action
%type <uint>   	        	alter_table_start_tokens
%type <uint>   	        	alter_view_start_tokens
%type <uint>   	        	alter_schema_start_tokens
%type <pStmtDDL>  		alter_table_statement
%type <boolean>                 optional_ghost
%type <pStmtDDL>  		revoke_schema_statement
%type <pStmtDDL>                revoke_component_privilege_stmt
%type <pStmtDDL>                alter_synonym_statement
%type <pStmtDDL>  		drop_table_statement
%type <uint>   	        	drop_table_start_tokens
%type <pStmtDDL>  		drop_trigger_statement
%type <pStmtDDL>  		drop_mv_statement
%type <pStmtDDL>  		drop_view_statement
%type <pStmtDDL>  		revoke_statement
%type <boolean>   		optional_grant_option_for
%type <boolean>   		grant_option_for
%type <pStmtDDL>  		drop_catalog_statement
%type <pStmtDDL>  		drop_index_statement
%type <pStmtDDL>  		drop_routine_statement
%type <pStmtDDL>  		initialize_sql_statement
%type <pElemDDL>                optional_register_user_list
%type <pElemDDL>                init_register_user_list
%type <pElemDDL>                init_register_user_element
%type <pElemDDL>                optional_create_role_list
%type <pElemDDL>                init_create_role_list
%type <pElemDDL>                init_create_role_element
%type <tokval>    		empty
%type <pElemDDL>  		table_definition_body
%type <pElemDDL>  		like_definition
%type <pElemDDL>  		optional_like_option_list
%type <pElemDDL>  		like_option_list
%type <pElemDDL>  		like_option
%type <corrName> 		source_table
%type <pElemDDL>  		table_element_list
%type <pElemDDL>  		table_elements
%type <pElemDDL>  		table_element
%type <pElemDDL>                external_table_definition
%type <pElemDDLConstraint>  	column_constraint
%type <pElemDDL>  		optional_loggable 
%type <pElemDDL>                optional_lobattrs
%type <pElemDDL>  		column_constraint_definition
%type <pElemDDL>  		heading_character_string_literal
%type <pElemDDL>  		heading
%type <pElemDDL>  		serialized
%type <pElemDDL>  		optional_compress_clause
%type <pElemDDL>  		compress_clause
%type <pElemDDL>  		table_constraint_definition
%type <pElemDDLConstraint>  	table_constraint
%type <pElemDDL>  		column_definition
%type <uint>      		        set_in_column_defn
%type <uint>      		        reset_in_column_defn
%type <pElemDDL>  		optional_column_attributes
%type <pElemDDL>  		column_attributes
%type <pElemDDL>  		column_attribute
%type <tokval>    		constraints_keyword
%type <pElemDDL>  		col_def_default_clause
%type <pElemDDL>  		col_def_default_clause_argument
%type <pElemDDL>                alter_col_default_clause_arg
%type <uint>      		sg_type
%type <boolean>                 sg_sign
%type <pElemDDL>  		sg_identity_option
%type <pElemDDL>  		sg_identity_function
%type <pElemDDL>  		sequence_generator_options
%type <pElemDDL>  		all_sequence_generator_options
%type <pElemDDL>  		sequence_generator_option
%type <pElemDDL>  		sequence_generator_option_list
%type <pElemDDL>  		start_with_option
%type <pElemDDL>  		increment_option
%type <pElemDDL>  		max_value_option
%type <pElemDDL>  		min_value_option
%type <pElemDDL>  		cache_option
%type <pElemDDL>  		cycle_option
%type <pElemDDL>  		reset_option
%type <pElemDDL>                   datatype_option
%type <item>      		datetime_value_function
%type <item>      		datetime_misc_function
%type <item>      		datetime_misc_function_used_as_default
%type <stringval>  		format_attributes
%type <pElemDDL>  		optional_constraint_attributes
%type <pElemDDL>  		constraint_attributes
%type <pElemDDL>  		constraint_attribute
%type <pElemDDL>  		constraint_attribute_droppable
%type <pElemDDL>  		constraint_attribute_enforced
%type <pQualName> 		constraint_name_definition
%type <pElemDDLConstraintUnique>  column_unique_specification
%type <pElemDDLConstraintUnique>  unique_constraint_specification
%type <pElemDDLConstraintUnique>  unique_specification
%type <pElemDDLConstraintRI>  	  references_specification
%type <matchTypeEnum>  		optional_ri_match_clause
%type <showcontrolEnum>  	optional_comma_match_clause
%type <matchTypeEnum>  		match_clause
%type <matchTypeEnum>  		match_type
%type <pElemDDL>  		referenced_table_and_columns
%type <pElemDDL>  		optional_referential_triggered_action
%type <pElemDDL>  		referential_triggered_actions
%type <pElemDDL>  		referential_triggered_action
%type <pElemDDL>  		update_rule
%type <pElemDDL>  		delete_rule
%type <pElemDDL>  		referential_action
%type <pElemDDLConstraint>  	unique_constraint_definition
%type <pElemDDL>  		unique_column_list
%type <pElemDDLConstraint>  	references_constraint_definition
%type <pElemDDL>  		referencing_columns
%type <pElemDDL>  		reference_column_list
%type <pElemDDL>  		column_name_list
%type <pElemDDL>  		column_reference_list
%type <pElemDDL>  		column_reference
%type <pElemDDLConstraint>  	check_constraint_definition
%type <tokval>                  check_constraint_starting_tokens
%type <pElemDDL>  		optional_create_table_attribute_list
%type <pElemDDL>  		create_table_attribute_list
%type <pElemDDL>  		create_table_attribute
%type <pElemDDL>  		file_attribute_clause
%type <pElemDDL>  		file_attribute
%type <pElemDDL>		partition_attribute
%type <pElemDDL>  		file_attribute_allocate_clause
%type <pElemDDL>  		file_attribute_audit_clause
%type <tokval>			file_attribute_keyword
%type <pElemDDL>  		file_attribute_audit_compress_clause
%type <pElemDDL>  		file_attribute_block_size_clause
%type <tokval>    		optional_block_size_unit
%type <pElemDDL>  		file_attribute_buffered_clause
%type <pElemDDL>  		file_attribute_clear_on_purge_clause
/*%type <pElemDDL>  		file_attribute_dcompress_clause*/
%type <pElemDDL>  		file_attribute_deallocate_clause
%type <pElemDDL>  		file_attribute_icompress_clause
%type <pElemDDL>  		file_attribute_list
%type <pElemDDL>                file_attribute_compression_clause
%type <pElemDDL>  		file_attribute_extent_clause
%type <pElemDDL>  		file_attribute_maxextent_clause
%type <pElemDDL>  		file_attribute_uid_clause
%type <pElemDDL>  		file_attribute_row_format_clause
%type <pElemDDL>  		file_attribute_default_col_fam
%type <pElemDDL>  		file_attribute_pos_clause
%type <pElemDDL>                attribute_num_rows_clause
%type <pElemDDL>                attribute_inmemory_options_clause
%type <pElemDDL>                file_attribute_no_label_update_clause
%type <pElemDDL>                file_attribute_owner_clause
%type <pElemDDL>		optional_location_clause
%type <pElemDDL>  		location_clause
%type <stringval>  		optional_partition_name_clause
%type <pElemDDL>  		optional_partition_attribute_list
%type <pElemDDL>  		partition_definition
%type <pElemDDL>  		partition_by_column_list
%type <pElemDDL>		partition_attribute_list
%type <pElemDDL>  		optional_partition_definition_body
%type <pElemDDL>  		partition_definition_body
%type <pElemDDL>  		partition_list
%type <partitionType>           partition_type
%type <pElemDDL>  		range_partition
%type <pElemDDL>  		range_partition_list
%type <pElemDDL>  		system_partition_list
%type <pElemDDL>  		system_partition
%type <pElemDDL>  		file_attribute_extent
%type <pElemDDL>  		file_attribute_maxextent
%type <item>      		null_constant
%type <pElemDDL>  		key_list
%type <pElemDDL>  		key_value
%type <pElemDDL>  		key_value_list
%type <item>      		builtin_function_user
%type <boolean>   		optional_unique_option
%type <uint>      		optional_unique_optional_ghost
%type <pStmtDDL>  		index_definition
%type <pStmtDDL>  		populate_index_definition
%type <boolean>      	optional_purgedata
%type <stringval> 		index_name
%type <pElemDDL>  		index_column_list
%type <pElemDDL>  		optional_index_option_list
%type <uint>                    optional_ignore_clause
%type <pElemDDL>  		index_option_list
%type <pElemDDL>  		index_option_spec
%type <pElemDDL>                populate_option
%type <pElemDDL>  		parallel_execution_clause
%type <pElemDDL>  		parallel_execution_spec
%type <pElemDDL>  		index_division_clause
%type <pElemDDL>  		salt_by_clause
%type <pElemDDL>  		salt_like_clause
%type <pElemDDL>                optional_salt_column_list
%type <pElemDDL>  		division_by_clause
%type <pElemDDL>            hbase_table_options
%type <hbaseOptionsList>  hbase_options_list
%type <hbaseOption>         hbase_option
%type <tokval>    		division_by_clause_starting_tokens
%type <pElemDDL>  		optional_division_column_names
%type <pElemDDL>  		store_by_clause
%type <pElemDDL>  		store_option_clause
%type <pElemDDL>  		unique_store_option
%type <pElemDDL>  		store_option
%type <item>                    range_n_args
%type <item>                    range_n_arg
%type <boolean>                 optional_in_memory_clause
%type <stringval>               optional_map_to_hbase_clause
%type <boolean>                 optional_hbase_data_format
%type <dropBehaviorEnum>  	extension_drop_behavior
%type <dropBehaviorEnum>  	optional_drop_behavior
%type <dropBehaviorEnum>  	optional_drop_index_behavior
%type <dropBehaviorEnum>  	optional_drop_invalidate_dependent_behavior
%type <dropBehaviorEnum>  	drop_behavior
%type <boolean>   		optional_validate
%type <boolean>   		optional_cleanup
%type <stringval> 		optional_logfile
%type <stringval> 		oss_path_name
%type <stringval> 		oss_path_name_elem
%type <stringval> 		volume_only_name
%type <item>	  		case_expression
%type <item>	  		case_operand
%type <item>	  		simple_when_then_list
%type <item>	  		simple_when_then
%type <item>	  		searched_when_then_list
%type <item>	  		searched_when_then
%type <item>	  		else_clause
%type <item>	  		result_expr
%type <accesstype>    		access_type
%type <pStmtDDL>                create_synonym_stmt
%type <pStmtDDL>                drop_synonym_stmt
%type <pStmtDDL>                drop_sql
%type <pStmtDDL>                drop_table_constraint_definition
%type <pStmtDDL>                drop_module
%type <pStmtDDL>                drop_exception_stmt
%type <pStmtDDL>                drop_all_exception_stmt
%type <operator_type>           proc_identifier
%type <stmt_ptr>                set_transaction_statement
%type <item>                    transaction_mode_list
%type <item>                    transaction_mode
%type <item>                    isolation_level
%type <item>                    transaction_access_mode
%type <item>                    diagnostics_size
%type <isolation>               isolation_level_enum
%type <transAccessMode>         transaction_access
%type <item>                    number_of_conditions
%type <item>			rollback_mode_on_off
%type <item>			autoabort_interval_stmt
%type <item>			multi_commit_mode
%type <tokval> 	  		full_outer
%type <tokval>    		right_outer
%type <tokval>    		left_outer
%type <tokval>    		optional_col_keyword
%type <boolean>                 optional_cast_spec_not_null_spec
%type <boolean>                 optional_nullable_pkey
%type <boolean>                 optional_encode_key_ordering_spec
%type <CollationType>		optional_Collation_type
%type <SortDirection>		optional_sort_direction
%type <item>                    encode_key_cast_spec
%type <relx>			psm_3gl_statement
%type <relx>			psm_3gl_block_start
%type <relx>			psm_3gl_block_end
%type <relx>			psm_3gl_stmt
%type <stmt_ptr>		dynamic_sql_disallowed_in_cs
%type <relx>			elseif_else_opt
%type <relx>			assignment_statement
%type <relx>                    assignment_value

%type <relx>                    signal_statement
%type <item>                    item_signal_statement

%type <na_type>   		rowset_type
%type <relx>      		rowset_derived_table
%type <relx>			rowset_for
%type <relx>			rowset_for_input
%type <relx>			rowset_for_output
%type <relx>			rowwise_rowset_info
%type <na_type>   		proc_arg_rowset_type
%type <item>      		rowset_input_host_variable
%type <item>      		rowset_input_host_variable_list
%type <item>      		rowset_size
%type <item>      		rowset_input_size
%type <item>      		rowset_output_size
%type <item>      		rowset_index
%type <relx>                    sample_clause
%type <relx>                    sample_clause_x
%type <item>                    sample_clusters
%type <item>                    sample_cluster_expr
%type <item>                    sample_size_expr
%type <item>                    sample_size_numeric
%type <boolean>                 sample_absolute
%type <boolean>                 sample_absolute_rows
%type <item>                    balance_when_then_list
%type <item>                    balance_when_then
%type <item>                    balance_else
%type <item>                    balance_expr
%type <longint>			showplan_options

%type <relx>                    routine_invocation
%type <relx>                    standalone_call_statement
%type <relx>                    exe_util_statement
%type <relx>                    exe_util_display_explain
%type <relx>                    exe_util_maintain_object
%type <relx>                    exe_util_cleanup_volatile_tables
%type <relx>                    exe_util_aqr
%type <relx>                    exe_util_get_region_access_stats
%type <boolean>                 stats_or_statistics
%type <aqrOptionsList>          aqr_options_list
%type <aqrOption>               aqr_option
%type <uint>                    aqr_task
%type <item>                   optional_limit_spec

%type <tokval>                  dummy_token_lookahead
%type <relx>                    exe_util_get_volatile_info
%type <relx>                    exe_util_get_error_info
%type <relx>                    exe_util_get_statistics
%type <relx>                    exe_util_get_uid
%type <relx>                    exe_util_get_qid
%type <relx>                    exe_util_get_lob_info
%type <relx>                    exe_util_hive_query
%type <relx>                    exe_util_populate_in_memory_statistics
%type <relx>                    exe_util_lob_extract
%type <relx>                    exe_util_lob_update
%type <relx>                    unload_statement
%type <relx>                    load_statement
%type <boolean>                 load_sample_option
%type <relx>                    exe_util_init_hbase
%type <hBaseBulkLoadOptionsList> optional_hbbload_options
%type <hBaseBulkLoadOptionsList> hbbload_option_list
%type <hBaseBulkLoadOption>      hbbload_option
%type <hBaseBulkLoadOption>      hbb_no_recovery_option
%type <hBaseBulkLoadOption>      hbb_truncate_option
%type <hBaseBulkLoadOption>      hbb_update_stats_option
%type <hBaseBulkLoadOption>      hbb_no_duplicate_check
%type <hBaseBulkLoadOption>      hbb_rebuild_indexes
%type <hBaseBulkLoadOption>      hbb_constraints
%type <hBaseBulkLoadOption>      hbb_no_output
%type <hBaseBulkLoadOption>      hbb_continue_on_error
%type <hBaseBulkLoadOption>      hbb_log_error_rows
%type <hBaseBulkLoadOption>      hbb_stop_after_n_error_rows
%type <hBaseBulkLoadOption>      hbb_index_table_only
%type <hBaseBulkLoadOption>      hbb_upsert_using_load
%type <hbbUnloadOptionsList> optional_hbb_unload_options
%type <hbbUnloadOptionsList> hbb_unload_option_list
%type <hbbUnloadOption>      hbb_unload_option
%type <hbbUnloadOption>      hbb_unload_empty_target
%type <hbbUnloadOption>      hbb_unload_compress
%type <hbbUnloadOption>      hbb_unload_one_file
%type <hbbUnloadOption>      hbb_unload_no_output
%type <hbbUnloadOption>      hbb_unload_delimiter
%type <hbbUnloadOption>      hbb_unload_record_separator
%type <hbbUnloadOption>      hbb_unload_null_string
%type <hbbUnloadOption>      hbb_unload_header
%type <hbbUnloadOption>      hbb_unload_append
%type <hbbUnloadOption>      hbb_unload_snapshot
%type <boolean>              hbb_unload_optional_overwrite
%type <boolean>             hbb_unload_existing_snap

%type <pSchemaName>             optional_from_schema
%type <stringval>               get_statistics_optional_options

%type <ptr_placeholder>         truncate_table_name
%type <relx>                    truncate_table

%type <relx>                    exe_util_get_metadata_info
%type <relx>                    exe_util_get_version_info
%type <stringval> 		object_identifier
%type <stringval> 		objects_identifier
%type <stringval>             hivemd_identifier
%type <stringval> 		cleanup_object_identifier

/* Added the following two to avoid increase in shift/reduce conflicts */
%type <stringval> 		privileges_identifier
%type <stringval> 		obj_priv_identifier

%type <stringval>               get_info_io_clause
%type <stringval>               get_info_aus_clause
%type <ptr_placeholder>         optional_no_header_and_match_pattern_clause

%type <stringval>               explain_starting_tokens
%type <stringval> 		explain_identifier
%type <stmt_ptr> 		explain_stmt_finalized
%type <uint>                    showplan_starting_tokens
%type <strSeq>                  routine_name
%type <item>                    routine_arg_list
%type <corrName>		actual_routine_name
%type <corrName>                actual_routine_action_name
%type <pElemDDL>                proxy_column
%type <pElemDDL>                proxy_columns
%type <item>                    spproxy_string
%type <itemList>                spproxy_string_list
/* Added the following to avoid increase in shift/reduce conflicts */
%type <boolean>                 sp_proxy_stmt_prefix

%type <corrName>                special_regular_table_name
%type <corrName>                special_index_table_name
%type <partitionClause>         special_table_loc_clause
%type <int>                     disableCharsetInference
%type <int>                     enableCharsetInferenceInColDefaultVal
%type <pConstStringList>	    quoted_string_list
%type <pConstStringList>	    col_fam_quoted_string_list

%type <pivotOptionsList>        pivot_options_list
%type <pivotOptionsList>        pivot_options
%type <pivotOption>             pivot_option

%type <pivotOptionsList>        concat_options_list
%type <pivotOptionsList>        concat_options
%type <pivotOption>             concat_option

%type <maintainObjectOptionsList>    maintain_object_options
%type <maintainObjectOptionsList>    maintain_object_options_list
%type <maintainObjectOption>         maintain_object_option
%type <uint>                        maintain_object_token
%type <stringval>                   optional_mt_options
%type <stringval>                   run_from
%type <stringval>                   run_to
%type <longint>                     run_for

%type <stringval>                   log_file_name
//%type <int>                         markSelectQueryPos

%type <pElemDDL>               optional_locking_stmt_list
%type <item>                   locking_stmt_list
%type <item>                   locking_stmt
%type <parTriggerScopeType>         optional_row_table

%type <stringval>              optional_hive_options

%type <tableTokens>            create_table_start_tokens
%type <tableLoadAttrEnum>      ctas_load_and_in_memory_options
%type <pElemDDL>               ctas_insert_columns
%type <pElemDDL>	       table_feature
%type <boolean>                is_not_droppable
%type <boolean>   	       online_or_offline
%type <boolean>   	       optional_validate_clause
%type <extractType>            extract_type
%type <boolean>                optional_if_not_exists_clause
%type <boolean>                optional_if_exists_clause
%type <boolean>                optional_if_not_registered_clause
%type <boolean>                optional_if_registered_clause

%type <uint>                    merge_stmt_start_tokens
%type <relx>                   merge_stmt_using_clause
%type <item>                   merge_stmt_on_condition
%type <item>      	       merge_stmt_set_clause
%type <ptr_placeholder>                   merge_stmt_when_clause
%type <ptr_placeholder>                   merge_stmt_when_matched
%type <ptr_placeholder>                   merge_stmt_when_not_matched
%type <ptr_placeholder>                   merge_insert_with_values
%type <stringval>              cpu_identifier
%type <stringval>              cpu_identifier_with_all
%type <stringval>              pid_identifier
%type <stringval>              qid_internal_identifier
%type <uint>                   qid_internal_stats_merge_clause
%type <uint>                   stats_active_clause
%type <uint>                   stats_merge_clause
%type <uint>                    reset_clause  
%type <stringval>		qid_identifier
%type <relx>                    query_suspend_safe
%type <relx>                    query_suspend_forced
%type <relx>                    query_activate
%type <stringval>               optional_for_user_clause
%type <stringval>               optional_authid_clause


%type <relx>                    query_cancel_qid
%type <relx>                    query_cancel_pname
%type <relx>                    query_cancel_nid_pid
%type <relx>                    query_cancel_no_comment
%type <relx>                    query_cancel_optional_comment

// Rules for UDFs.
%type <item>                    user_defined_scalar_function
%type <item>                    udr_value_expression_list
%type <item>                    table_name_dot_star
%type <relx>                    table_mapping_function_invocation
%type <relx>                    tmudf_table_expression
%type <relx>                    tmudf_query_expression
%type <item>      		optional_tmudf_order_by
%type <item>                    tmudf_param
%type <item>                    optional_tmudf_param_list_with_comma
%type <item>                    optional_tmudf_param_list
%type <item>                    tmudf_param_list
%%

// There are three flavors of literal non-terminal.  The following
// table should help explain.
//
// where used                           type     negatable non-terminal
//=====================================+========+=========+====================
// simple_value_spec		        string   yes	   literal_as_string
// primary                              ItemExpr no	   literal
// in  DDL, host_var_type_item, etc.,   ItemExpr yes	   literal_negatable
//
// And for literals occuring in the prototype of a hostvariable,
// currently prototypes can only be used for table names, and so
// those literals are restricted to character strings.


/* type tokval */
sign : '+' { $$ = $1; }
     | '-' { $$ = $1; }

disableCharsetInference : 
	{ 
	   turnUnknownCharSetToISO88591CurrentValue = turnUnknownCharSetToISO88591;
	   turnUnknownCharSetToISO88591 = TRUE;
	}

enableCharsetInferenceInColDefaultVal : 
	{ 
	   turnUnknownCharSetToISO88591CurrentValue = turnUnknownCharSetToISO88591;
	   turnUnknownCharSetToISO88591 = FALSE;
	}

/* type item */
numeric_literal_exact :       NUMERIC_LITERAL_EXACT_NO_SCALE
                {
                  $$ = literalOfNumericNoScale($1);
                  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                }

/* type item */
numeric_literal :       numeric_literal_exact
	      |	NUMERIC_LITERAL_EXACT_WITH_SCALE
                {
                  $$ = literalOfNumericWithScale($1);
                  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                }
	      | NUMERIC_LITERAL_APPROX
		{
                  $$ = literalOfApproxNumeric($1);
		  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
		}

character_literal_sbyte : sbyte_string_literal character_literal_notcasespecific_option
                {
//
// literal <-- sbyte_string_literal  character_literal_notcasespecific_option
//
                  CharInfo::CharSet cs = getStringCharSet(&$1);
                  const NAString& ns = *$1;

                  $$ = new (PARSERHEAP()) ConstValue(*$1, cs);
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  ((ConstValue*)$$)->setStrLitWithCharSetPrefixFlag(TRUE); // for use with DDL col def DEFAULT str lit only

                  if ($2/*character_literal_notcasespecific_option specified*/)
                  {
                    NAType * newType = ((ConstValue*)$$)->getType()->newCopy(PARSERHEAP());
                    ((CharType*)newType)->setCaseinsensitive(TRUE);
                    ((ConstValue*)$$)->changeType(newType);
                  }
                  delete $1/*sbyte_string_literal*/;
                }
             | /*no_charset_prefix*/std_char_string_literal character_literal_notcasespecific_option
                {
//
// literal <-- /*no_charset_prefix*/std_char_string_literal  character_literal_notcasespecific_option
//
                   CharInfo::CharSet cs = getStringCharSet(&$1);
                   const NAString& ns = *$1;

                   CharInfo::CharSet inputCS = (CharInfo::CharSet)SqlParser_CurrentParser->charset_;

                   NAString inferCharSetDefaultAttrVal;
                   NABoolean charsetInference = getCharSetInferenceSetting(inferCharSetDefaultAttrVal);


                   PARSERASSERT(cs == CharInfo::ISO88591 || cs == CharInfo::UTF8);
                   PARSERASSERT(inputCS == CharInfo::UTF8);

                   if ( charsetInference && ToStringvalWithCharSet(&$1)->isInferCSUnknownCSLogicEnabled() )
                   {
                     NAWString* wstr = NULL;
                     if ( $1->length() == 0 )
                     {
                       wstr = new (PARSERHEAP()) NAWString(PARSERHEAP());
                       $$ = new (PARSERHEAP()) ConstValue (*$1,*wstr);
                       SqlParser_CurrentParser->collectItem4HQC($$);
                     }
                     else // $1->length() != 0
                     {
                       // Convert to UCS2 because the existing code handles UCS2 string literals reliably.
                       wstr = charToUnicode ( (Lng32)cs     // char set of src str
                                            , $1->data()    // src str
                                            , $1->length()  // src str len in bytes
                                            , PARSERHEAP()  // heap for allocated target str
                                            );
                       if (wstr == NULL) // conversion failed
                       {
                         // The string argument contains characters that cannot be converted.
                         *CmpCommon::diags() << DgSqlCode(-8413);
                         YYERROR;
                       }
                       if (cs == CharInfo::ISO88591)
                       {
                         $$ = new (PARSERHEAP()) ConstValue (*$1,*wstr);
                         SqlParser_CurrentParser->collectItem4HQC($$);		 
                       }
                       else // cs == CharInfo::UTF8
                       {
                         // Convert to DEFAULT_CHARSET if possible to preserve the old behavior.
                         NAString * newstr = charToChar ( (Lng32)SqlParser_DEFAULT_CHARSET // targetCS
                                                        , $1->data()              // const char *s
                                                        , $1->length()            // Int32 sLenInBytes
                                                        , (Lng32)getStringCharSet(&$1)     // sourceCS
                                                        , PARSERHEAP() // heap for allocated target str
                                                        );
                         if (newstr == NULL) // conversion failed
                         {
                           $$ = new (PARSERHEAP()) ConstValue (*wstr, CharInfo::UnknownCharSet);
                           SqlParser_CurrentParser->collectItem4HQC($$);
                         }
                         else
                         {
                           $$ = new (PARSERHEAP()) ConstValue (*newstr,*wstr);
                           SqlParser_CurrentParser->collectItem4HQC($$);
                           delete newstr;
                         }
                       }
                     } // $1->length() != 0
                     delete wstr;
                   }
                   else // INFER_CHARSET == OFF || ToStringvalWithCharSet(&$1)->isInferCSUnknownCSLogicDisabled() 
                   {
                     if ( cs == CharInfo::ISO88591 )
                     {
                       // Note that an empty string has the ISO88591 character set attribute
                       $$ = new (PARSERHEAP()) ConstValue (*$1, CharInfo::ISO88591);
                       SqlParser_CurrentParser->collectItem4HQC($$);
                     }
                     else // cs == CharInfo::UTF8
                     {
                       // Convert to UCS2 because the existing code handles UCS2 string literals reliably.
                       NAWString * wstr3 = charToUnicode ( (Lng32)cs     // char set of src str
                                                         , $1->data()    // src str
                                                         , $1->length()  // src str len in bytes
                                                         , PARSERHEAP()  // heap for allocated target str
                                                         );
                       if (wstr3 != NULL) // str converted to UCS2/UTF16 successfully
                       {
                         // Convert to DEFAULT_CHARSET if possible to preserve the old behavior.
                         NAString * cstr3 = unicodeToChar ( wstr3->data()
                                                          , wstr3->length() // in NAWchars
                                                          , SqlParser_DEFAULT_CHARSET
                                                          , PARSERHEAP()
                                                          );
                         if (cstr3 != NULL) // str converted to DEFAULT_CHARSET successfully
                         {
                           $$ = new (PARSERHEAP()) ConstValue (*cstr3, SqlParser_DEFAULT_CHARSET);
                           SqlParser_CurrentParser->collectItem4HQC($$);
                           delete cstr3;
                         }
                         else
                         {
                           $$ = new (PARSERHEAP()) ConstValue (*wstr3, CharInfo::UCS2);
                           SqlParser_CurrentParser->collectItem4HQC($$);
                         }
                         delete wstr3;
                       }
                       else // charToUnicode conversion failed
                       {
                         $$ = new (PARSERHEAP()) ConstValue (*$1, getStringCharSet(&$1));
                         SqlParser_CurrentParser->collectItem4HQC($$);
                       }
                     }
                   }

		   if ($2)
		     {
		       NAType * newType = ((ConstValue*)$$)->getType()->newCopy(PARSERHEAP());
		       ((CharType*)newType)->setCaseinsensitive(TRUE);
		       ((ConstValue*)$$)->changeType(newType);
		     }

                  delete $1;
                }

/* type item */
literal :       numeric_literal
              | TOK_INTERVAL disableCharsetInference sign QUOTED_STRING interval_qualifier
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfInterval($4, $5, $3);
		  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();

                }
              | TOK_INTERVAL disableCharsetInference QUOTED_STRING interval_qualifier
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfInterval($3, $4);
		  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }
              | '{' TOK_INTERVAL disableCharsetInference sign QUOTED_STRING interval_qualifier '}'
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfInterval($5, $6, $4);
		  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }
              | '{' TOK_INTERVAL disableCharsetInference QUOTED_STRING interval_qualifier '}'
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfInterval($4, $5);
		  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }
              | '{' TOK_D disableCharsetInference QUOTED_STRING '}'
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfDate($4);		  
                  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);	  
                  restoreInferCharsetState();
                }
              | TOK_DATE_BEFORE_QUOTE disableCharsetInference QUOTED_STRING
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfDate($3);
		  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }
              | QUOTED_STRING TOK_LPAREN_BEFORE_DATE_COMMA_AND_FORMAT TOK_DATE ',' TOK_FORMAT QUOTED_STRING  ')'
                {
		  // CheckModeSpecial1(); -- Allow general NEO users to use
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		  // in MS2, formatting is done as part of Format function.
		  // Right now limit this to MS2. Once it is tested, we can do
		  // it for all modes.
                  /*		  if (CmpCommon::getDefault(MODE_SPECIAL_2) == DF_ON)
		    {
                      $$ = new (PARSERHEAP()) ConstValue
                        (*$1, getStringCharSet(&$1));
                      SqlParser_CurrentParser->collectItem4HQC($$);	
                      $$ = new (PARSERHEAP()) DateFormat($$, *$6, DateFormat::FORMAT_TO_DATE);
		    }
                    else*/
		    {
		      $$ = literalOfDate($1);
		      if (! $$) YYERROR;
                      SqlParser_CurrentParser->collectItem4HQC($$);
		      restoreInferCharsetState();
                      $$ = new (PARSERHEAP()) DateFormat($$, *$6, DateFormat::FORMAT_TO_CHAR);
		    }

                }
              | '{' TOK_T disableCharsetInference QUOTED_STRING '}'
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfTime($4);
                  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }
              | TOK_TIME_BEFORE_QUOTE disableCharsetInference QUOTED_STRING
                {
                  $$ = literalOfTime($3);
		  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }
              | TOK_TIMESTAMP disableCharsetInference QUOTED_STRING
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfTimestamp($3);
		  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }
              | '{' TOK_TS disableCharsetInference QUOTED_STRING '}'
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfTimestamp($4);
                  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }
              | character_literal_sbyte 
              | unicode_string_literal
                {
                  $$ = new (PARSERHEAP()) ConstValue(*$1, getStringCharSet(&$1));
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  ((ConstValue*)$$)->setStrLitWithCharSetPrefixFlag(TRUE); // for use with DDL col def DEFAULT str lit only
                  delete $1;
                }
              | TOK_DATETIME disableCharsetInference QUOTED_STRING datetime_qualifier
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfDateTime($3, $4);
                  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }
             | boolean_literal

boolean_literal : truth_value
                  {
                    if ($1 == TOK_UNKNOWN)
                      YYERROR;

                    char v = ($1 == TOK_TRUE ? 1 : 0);
                    NAString literalBuf($1 == TOK_TRUE ? "TRUE" : "FALSE");
                    $$ = new (PARSERHEAP()) ConstValue 
                      (new (PARSERHEAP()) SQLBooleanNative(PARSERHEAP(), FALSE),
                       (void *) &v, 1, &literalBuf);
                  }

character_literal_notcasespecific_option : '(' TOK_NOT_CASESPECIFIC ')'
                                            {$$=TRUE;}
                                           | '(' TOK_CASESPECIFIC ')'
                                            {$$=FALSE;}
                                           | empty
                                            {
                                              if (CmpCommon::getDefault(MODE_SPECIAL_1) == DF_ON)
						$$ = TRUE;
					      else
						$$=FALSE;
					    }

/* type item */
literal_negatable : literal
              | sign NUMERIC_LITERAL_EXACT_NO_SCALE
                {
                  $$ = literalOfNumericNoScale($2, $1);
                  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                }
	      |	sign NUMERIC_LITERAL_EXACT_WITH_SCALE
                {
                  $$ = literalOfNumericWithScale($2, $1);
                  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                }
	      | sign NUMERIC_LITERAL_APPROX
		{
                  $$ = literalOfApproxNumeric($2, $1);
                  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
		}
              | sign TOK_INTERVAL disableCharsetInference QUOTED_STRING interval_qualifier
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = literalOfInterval($4, $5, $1);
		  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }
              | sign TOK_INTERVAL disableCharsetInference sign QUOTED_STRING interval_qualifier
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		  char sign_sign = ($1 == $4) ? '+' : '-';
                  $$ = literalOfInterval($5, $6, sign_sign);
		  if (! $$) YYERROR;
                  SqlParser_CurrentParser->collectItem4HQC($$);
                  restoreInferCharsetState();
                }

/* type stringval */
literal_as_string :       NUMERIC_LITERAL_EXACT_NO_SCALE
	      |	NUMERIC_LITERAL_EXACT_WITH_SCALE
	      | NUMERIC_LITERAL_APPROX
              | TOK_INTERVAL disableCharsetInference sign QUOTED_STRING interval_qualifier
                { // bogus
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = NULL;
                  restoreInferCharsetState();
                }
              | TOK_INTERVAL disableCharsetInference QUOTED_STRING interval_qualifier
                { // bogus
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = NULL;
                  restoreInferCharsetState();
                }
              | sign NUMERIC_LITERAL_EXACT_NO_SCALE
                { $$ = $2; }
	      |	sign NUMERIC_LITERAL_EXACT_WITH_SCALE
                { $$ = $2; }
	      | sign NUMERIC_LITERAL_APPROX
                { $$ = $2; }
              | sign TOK_INTERVAL disableCharsetInference QUOTED_STRING interval_qualifier
                { // bogus
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = NULL;
                  restoreInferCharsetState();
                }
              | TOK_DATE disableCharsetInference QUOTED_STRING
                { // bogus
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = NULL;
                  restoreInferCharsetState();
                }
              | TOK_TIME disableCharsetInference QUOTED_STRING
                { // bogus
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = NULL;
                  restoreInferCharsetState();
                }
              | TOK_TIMESTAMP disableCharsetInference QUOTED_STRING
                { // bogus
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  $$ = NULL;
                  restoreInferCharsetState();
                }
              | character_string_literal
                /* DEFAULT_CHARSET has no effect on character_string_literal in this context */

/* type stringval */
character_string_literal: sbyte_string_literal
  {
    // character_string_literal ::= sbyte_string_literal

    if ( ( getStringCharSet(&$1) == CharInfo::ISO88591 && NOT NAStringHasOnly7BitAsciiChars(*$1)) ||
         ( getStringCharSet(&$1) != CharInfo::ISO88591 && getStringCharSet(&$1) != CharInfo::UTF8 ))
    {
      // Convert text from getStringCharSet(&$1) to UTF8 to keep the same semantic as
      // that of the non-terminal symbol std_char_string_literal.
      NAString * utf8str = charToChar ( (Lng32) CharInfo::UTF8 // targetCS
                                      , $1->data()             // source string
                                      , $1->length()           // src str len in bytes
                                      , getStringCharSet(&$1)  // sourceCS
                                      , PARSERHEAP()           // heap for target string
                                      , FALSE                  // allowInvalidChar
                                      );
      if (utf8str == NULL)
      {
        // The string argument contains characters that cannot be converted.
        *SqlParser_Diags << DgSqlCode(-8413);
        YYERROR;
      }
      ToStringvalWithCharSet(&$$)->shallowCopy(ToStringvalWithCharSet(&$1));
      ToStringvalWithCharSet(&$$)->stringval = utf8str; // same as $$ = utf8str;
      ToStringvalWithCharSet(&$$)->charSet_ = CharInfo::UTF8;
      ToStringvalWithCharSet(&$$)->/*max*/bytesPerChar_ = CharInfo::maxBytesPerChar(CharInfo::UTF8);
      delete $1;
    }
    else if ( getStringCharSet(&$1) == CharInfo::UTF8 && NAStringHasOnly7BitAsciiChars(*$1) )
    {
      // Keep the same semantic as that of the non-terminal symbol std_char_string_literal.
      ToStringvalWithCharSet(&$$)->shallowCopy(ToStringvalWithCharSet(&$1));
      ToStringvalWithCharSet(&$$)->charSet_ = CharInfo::ISO88591;
      ToStringvalWithCharSet(&$$)->bytesPerChar_ = CharInfo::maxBytesPerChar(CharInfo::ISO88591);
    }
  }
       | std_char_string_literal /* i.e., no charset prefix */

sbyte_string_literal : TOK_SBYTE_LITERAL
                      | sbyte_string_literal TOK_SBYTE_LITERAL
           {
             // Mismatch example: The user specifies _iso88591'abc' _utf8'def'
             if (charsetMismatchError(&$1, &$2)) YYERROR;

             // Example: The user specifies _iso88591'abc' _iso88591'defghij';
             // combine them to form _iso88591'abcdefghij'; we actually only
             // store abcdefghij in an NAString object pointed by $$ and
             // CharInfo::ISO88591 in the field ToStringvalWithCharSet(&$$)->charSet_
             // and 1 in the field ToStringvalWithCharSet(&$$)->bytesPerChar_

             $$ = $1;
             $$->append(*$2);
             delete $2;
           }
       | sbyte_string_literal QUOTED_STRING
           {
             // sbyte_string_literal ::= sbyte_string_literal QUOTED_STRING

             // Example: The user specifies _iso88591'abc' 'defghij'

             NAString defVal;
             NABoolean charsetInference = getCharSetInferenceSetting(defVal);

             
             PARSERASSERT( getStringCharSet(&$1/*sbyte_string_literal*/) != CharInfo::UnknownCharSet &&
                           ( getStringCharSet(&$2/*QUOTED_STRING*/) == CharInfo::ISO88591 ||
                             getStringCharSet(&$2/*QUOTED_STRING*/) == CharInfo::UTF8 ) );

             if ($2->length() == 0)
             {
               // An empty string can be in any character set so make it to have $1 character set attribute
               NAString * savedstr2 = $2;
               ToStringvalWithCharSet(&$2)->shallowCopy(ToStringvalWithCharSet(&$1));
               ToStringvalWithCharSet(&$2)->stringval = savedstr2; // shallow copy - same as $2 = savedstr2;
             }
             else if (getStringCharSet(&$1) != getStringCharSet(&$2))
             {
                NAString * newcstr = charToChar ( (Lng32)getStringCharSet(&$1) // targetCS
                                                , $2->data()              // const char *s
                                                , $2->length()            // Int32 sLenInBytes
                                                , (Lng32)getStringCharSet(&$2) // sourceCS
                                                , PARSERHEAP()            // heap for allocated target str
                                                );
                if (newcstr != NULL) // str converted successfully
                {
                  NAString * oldcstr = $2;
                  ToStringvalWithCharSet(&$2)->shallowCopy(ToStringvalWithCharSet(&$1));
                  ToStringvalWithCharSet(&$2)->stringval = newcstr; // shallow copy - same as $2 = newcstr;
                  delete oldcstr;
                }
             }
             // else keep getStringCharSet(&$2) setting, we will get a mismatched error below.
             if (charsetMismatchError(&$1, &$2)) YYERROR;

             // The following call is not required, the parser have already done this by default if the rhs is $1
             ToStringvalWithCharSet(&$$/*lhs*/)->shallowCopy(ToStringvalWithCharSet(&$1/*sbyte_string_literal*/)); // $$ = $1;
             $$->append(*$2);
             delete $2;

           }
       | std_char_string_literal TOK_SBYTE_LITERAL
           {
             // sbyte_string_literal ::= std_char_string_literal TOK_SBYTE_LITERAL

             // Example: The user specifies 'abcde' _iso88591'fghij';
             // we combine the two string literals into _iso88591'abcdefghij';


             PARSERASSERT( ( getStringCharSet(&$1/*std_char_string_literal*/) == CharInfo::ISO88591 ||
                             getStringCharSet(&$1/*std_char_string_literal*/) == CharInfo::UTF8 ) &&
                           getStringCharSet(&$2/*TOK_SBYTE_LITERAL*/) != CharInfo::UnknownCharSet );

             // Example: The user specifies 'abcde' _iso88591'fghij'
             // Combine them to form a new string literal _iso88591'abcdefghij'

             if ($1->length() == 0)
             {
               // An empty string can be in any character set so make it to have $2 character set attribute
               NAString * savedstr1 = $1;
               ToStringvalWithCharSet(&$1)->shallowCopy(ToStringvalWithCharSet(&$2));
               ToStringvalWithCharSet(&$1)->stringval = savedstr1; // shallow copy - same as $1 = savedstr1;
             }
             else if (getStringCharSet(&$1) != getStringCharSet(&$2))
             {
               NAString * newstr = charToChar ( (Lng32)getStringCharSet(&$2) // targetCS
                                              , $1->data()              // const char *s
                                              , $1->length()            // Int32 sLenInBytes
                                              , (Lng32)getStringCharSet(&$1) // sourceCS
                                              , PARSERHEAP()            // heap for allocated target str
                                              );
               if (newstr != NULL) // str converted successfully
               {
                 NAString * oldstr1 = $1;
                 ToStringvalWithCharSet(&$1)->shallowCopy(ToStringvalWithCharSet(&$2/*TOK_SBYTE_LITERAL*/));
                 ToStringvalWithCharSet(&$1)->stringval = newstr; // shallow copy - same as $1 = newstr;
                 delete oldstr1;
               }
             }

            if (charsetMismatchError(&$1, &$2)) YYERROR;

             NAString *savestr1 = $1/*std_char_string_literal*/;
             // The following call is required to copy the contents of the StringvalWithCharSet
             // data structure associating with $2 to the one associating with $$.
             ToStringvalWithCharSet(&$$/*lhs*/)->shallowCopy(ToStringvalWithCharSet(&$2/*TOK_SBYTE_LITERAL*/)); // must do this instead of $$ = $2;
             $$ = savestr1; // same as ToStringvalWithCharSet(&$$/*lhs*/)->stringval = savestr1;
             $$->append(*$2);
             delete $2;
           }
       | sbyte_string_literal TOK_MBYTE_LITERAL
           {
             // sbyte_string_literal ::= sbyte_string_literal TOK_MBYTE_LITERAL

             charsetMismatchError(&$1, &$2);
             YYERROR;
           }

/* type wstringval */
unicode_string_literal : TOK_MBYTE_LITERAL 
	   {
	     // unicode_string_literal ::= TOK_MBYTE_LITERAL 

	     NonISO88591LiteralEncountered = TRUE;
	     $$ = $1; // No need to call ToStringvalWithCharSet(&$$)->shallowCopy(ToStringvalWithCharSet(&$1) here.
	   }
       | unicode_string_literal TOK_MBYTE_LITERAL
           {
             // unicode_string_literal ::= unicode_string_literal TOK_MBYTE_LITERAL

	     NonISO88591LiteralEncountered = TRUE;
             // Mismatch example: The user specifies _ucs2'abc' _ucs4'def'
             if (charsetMismatchError(&$1, &$2)) YYERROR;
             $$ = $1; // No need to call ToStringvalWithCharSet(&$$)->shallowCopy(ToStringvalWithCharSet(&$1) here.
             $$->append(*$2);
             delete $2;
           }
       | std_char_string_literal TOK_MBYTE_LITERAL
           {
             // unicode_string_literal ::= std_char_string_literal TOK_MBYTE_LITERAL

             // Example: The user specifies 'abcde' _ucs2'fghij'
             // Combine them to form a new string literal _ucs2'abcdefghij'

             NonISO88591LiteralEncountered = TRUE;


             PARSERASSERT( ( getStringCharSet(&$1/*std_char_string_literal*/) == CharInfo::ISO88591 ||
                             getStringCharSet(&$1/*std_char_string_literal*/) == CharInfo::UTF8 ) &&
                           getStringCharSet(&$2/*TOK_MBYTE_LITERAL*/) == CharInfo::UCS2 );

             NAWString * newwstr = NULL;
             if ($1->length() == 0)
             {
               // An empty string can have any character set attribute
               newwstr = new(PARSERHEAP()) NAWString(PARSERHEAP());
             }
             else
             {
               newwstr = charToUnicode ( (Lng32)getStringCharSet(&$1)     // char set of src str
                                       , $1->data()             // src str
                                       , $1->length()           // src str len in bytes
                                       , PARSERHEAP()           // heap for allocated target str
                                       );
             }
             if (newwstr == NULL)
             {
               *SqlParser_Diags << DgSqlCode(-8413); // The string argument contains characters that cannot be converted.
               YYERROR;
             }

             // The following call is required to copy the contents of the StringvalWithCharSet
             // data structure associating with $2 to the one associating with $$.
             ToStringvalWithCharSet(&$$)->shallowCopy(ToStringvalWithCharSet(&$2/*TOK_MBYTE_LITERAL*/)); // do this intead of $$ = $2
             newwstr->append(*$2);
             ToStringvalWithCharSet(&$$)->wstringval = newwstr; // shallow copy - same as $$ = newwstr;

             delete $1/*std_char_string_literal*/;
           }
       | unicode_string_literal QUOTED_STRING
           {
             // unicode_string_literal ::= unicode_string_literal QUOTED_STRING

             NonISO88591LiteralEncountered = TRUE;

             // Example: The user specifies _ucs2'abc' 'defghij';
             // Combine them to form a new string literal _ucs2'abcdefghij'


             PARSERASSERT( getStringCharSet(&$1/*unicode_string_literal*/) == CharInfo::UCS2 &&
                           ( getStringCharSet(&$2/*QUOTED_STRING*/) == CharInfo::ISO88591 ||
                             getStringCharSet(&$2/*QUOTED_STRING*/) == CharInfo::UTF8 ) );
             
             NAWString* newwstr = NULL;
             if ($2->length() == 0)
             {
               // An empty string can have any character set attribute
               newwstr = new(PARSERHEAP()) NAWString(PARSERHEAP());
             }
             else
             {
               newwstr = charToUnicode ( (Lng32)getStringCharSet(&$2)     // char set of src str
                                       , $2->data()             // src str
                                       , $2->length()           // src str len in bytes
                                       , PARSERHEAP()           // heap for allocated target str
                                       );
               if (newwstr == NULL) // conversion failed
               {
                 *SqlParser_Diags << DgSqlCode(-8413); // The string argument contains characters that cannot be converted.
                 YYERROR;
               }
             }

             ToStringvalWithCharSet(&$$)->shallowCopy(ToStringvalWithCharSet(&$1)); // $$ = $1;
             $$->append(*newwstr);
             delete newwstr;
             delete $2/*QUOTED_STRING*/;

           }
       | unicode_string_literal TOK_SBYTE_LITERAL 
           {
             // unicode_string_literal ::= unicode_string_literal TOK_SBYTE_LITERAL

             charsetMismatchError(&$1, &$2);
             YYERROR;
           }

/* This is the production for declaring static cursors.
 * One difference from FULL ANSI is that there is no INSENSITIVE
 * nor SCROLL attributes allowed in the declaration.
 */
/* stmt_ptr */
declare_static_cursor : TOK_DECLARE entity_name TOK_CURSOR TOK_FOR cursor_spec
  {

    if ($2)
      {
	$$ = new (PARSERHEAP()) StmtDeclStatCurs($2,$5);
      }
    else
      /* entity_name is NULL, and was given by a host var string expression */
      {
	// In what appears from the cursor specification, to be a
	// static cursor declaration, you have a syntax error.
	// You attempted to name the cursor with a host variable expression.
	// You must name static cursors literally.
        *SqlParser_Diags << DgSqlCode(-3005);
	YYABORT;
      }

    if (intoClause)
      {
	// static cursors shouldn't have any into clause specified
	*SqlParser_Diags << DgSqlCode(-3142);
	YYABORT;
      }

    // A cursor on an embedded INSERT is not supported
    if(WeAreInAnEmbeddedInsert == TRUE)
      {
        WeAreInAnEmbeddedInsert = FALSE;
        *SqlParser_Diags << DgSqlCode(-3409);
        YYABORT;
      }

  }
  // QSTUFF
  | TOK_DECLARE entity_name TOK_CURSOR_WITH_HOLD TOK_FOR cursor_spec
  {
    if ($2)
      {
	$$ = new (PARSERHEAP()) StmtDeclStatCurs($2,$5,TRUE);
      }
    else
      /* with hold entity_name is NULL, and was given by a host var string expression */
      {
	// In what appears from the cursor specification, to be a
	// static cursor declaration, you have a syntax error.
	// You attempted to name the cursor with a host variable expression.
	// You must name static cursors literally.
        *SqlParser_Diags << DgSqlCode(-3005);
	YYABORT;
      }

    if (intoClause)
      {
	// static cursors shouldn't have any into clause specified
	*SqlParser_Diags << DgSqlCode(-3142);
	YYABORT;
      }

    // A cursor on an embedded INSERT is not supported
    if(WeAreInAnEmbeddedInsert == TRUE)
      {
        WeAreInAnEmbeddedInsert = FALSE;
        *SqlParser_Diags << DgSqlCode(-3409);
        YYABORT;
      }

  }
  | TOK_DECLARE entity_name TOK_CURSOR_WITHOUT_HOLD TOK_FOR cursor_spec
  {
   if ($2)
      {
	$$ = new (PARSERHEAP()) StmtDeclStatCurs($2,$5);
      }
    else
      /*  without hold entity_name is NULL, and was given by a host var string expression */
      {
	// In what appears from the cursor specification, to be a
	// static cursor declaration, you have a syntax error.
	// You attempted to name the cursor with a host variable expression.
	// You must name static cursors literally.
        *SqlParser_Diags << DgSqlCode(-3005);
	YYABORT;
      }

    if (intoClause)
      {
	// static cursors shouldn't have any into clause specified
	*SqlParser_Diags << DgSqlCode(-3142);
	YYABORT;
      }

    // A cursor on an embedded INSERT is not supported
    if(WeAreInAnEmbeddedInsert == TRUE)
      {
        WeAreInAnEmbeddedInsert = FALSE;
        *SqlParser_Diags << DgSqlCode(-3409);
        YYABORT;
      }

  }
 // QSTUFF

/* The dynamic cursor declaration
 * is a bit more flexible than for the static case.
 * The first entity_name is the cursor name and the second entity_name
 * is the statement name.  Note that an entity_name can be a string typed
 * host variable expression.
 *
 * The entity_name is either NULL, or a pointer to an NAString naming it.
 * We need to check for three cases here:
 *   + Where both entity_names are non-null, and hence, literally named, we
 *     create a StmtDeclDynCurs
 *   + Where both entity_names are NULL, and hence named by host variables,
 *     we cleverly use methods of the HvRoles.C in order to set the first
 *     to a cursor name role, and the last (second) to a statement name role.
 *   + If one of them is NULL and the other is non-null (two cases possible)
 *     that is an error that we flag.  I'm not sure how the arror propogates
 *     up and out, but it is an error.
 */

/* stmt_ptr */
declare_dynamic_cursor :
  TOK_DECLARE entity_name TOK_CURSOR TOK_FOR entity_name
  {
      if ($2 && $5)
	{
	  $$ = new (PARSERHEAP()) StmtDeclDynCurs($2,$5);
	}
      else if ($2 == NULL && $5 == NULL)
	{
	  TheHostVarRoles->setFirstUnassignedTo(HV_IS_CURSOR_NAME);
	  TheHostVarRoles->setLastUnassignedTo(HV_IS_STMT_NAME);
	  $$ = new (PARSERHEAP()) StmtXdynCurs();
	}
      else
	{
	  // Parse Error: In a dynamic cursor declaration you must name both
	  // the cursor and the statement the same way.  They must both be given
	  // by literals, or, by a string host variable expression. No mixing.

          *SqlParser_Diags << DgSqlCode(-3006);
	  YYABORT;
	}

      // A cursor on an embedded INSERT is not supported
      if(WeAreInAnEmbeddedInsert == TRUE)
        {
          WeAreInAnEmbeddedInsert = FALSE;
          *SqlParser_Diags << DgSqlCode(-3409);
          YYABORT;
        }

    }
   // QSTUFF
  | TOK_DECLARE entity_name TOK_CURSOR_WITH_HOLD TOK_FOR entity_name
  {
      if ($2 && $5)
	{
	  $$ = new (PARSERHEAP()) StmtDeclDynCurs($2,$5,TRUE);
	}
      else if ($2 == NULL && $5 == NULL)
	{
	  TheHostVarRoles->setFirstUnassignedTo(HV_IS_CURSOR_NAME);
	  TheHostVarRoles->setLastUnassignedTo(HV_IS_STMT_NAME);
	  $$ = new (PARSERHEAP()) StmtXdynCurs(TRUE);
	}
      else
	{
	  // Parse Error: In a dynamic cursor declaration you must name both
	  // the cursor and the statement the same way.  They must both be given
	  // by literals, or, by a string host variable expression. No mixing.

          *SqlParser_Diags << DgSqlCode(-3006);
	  YYABORT;
	}

      // A cursor on an embedded INSERT is not supported
      if(WeAreInAnEmbeddedInsert == TRUE)
        {
          WeAreInAnEmbeddedInsert = FALSE;
          *SqlParser_Diags << DgSqlCode(-3409);
          YYABORT;
        }

    }
  | TOK_DECLARE entity_name TOK_CURSOR_WITHOUT_HOLD TOK_FOR entity_name
  {
      if ($2 && $5)
	{
	  $$ = new (PARSERHEAP()) StmtDeclDynCurs($2,$5,FALSE);
	}
      else if ($2 == NULL && $5 == NULL)
	{
	  TheHostVarRoles->setFirstUnassignedTo(HV_IS_CURSOR_NAME);
	  TheHostVarRoles->setLastUnassignedTo(HV_IS_STMT_NAME);
	  $$ = new (PARSERHEAP()) StmtXdynCurs(FALSE);
	}
      else
	{
	  // Parse Error: In a dynamic cursor declaration you must name both
	  // the cursor and the statement the same way.  They must both be given
	  // by literals, or, by a string host variable expression. No mixing.

          *SqlParser_Diags << DgSqlCode(-3006);
	  YYABORT;
	}

      // A cursor on an embedded INSERT is not supported
      if(WeAreInAnEmbeddedInsert == TRUE)
        {
          WeAreInAnEmbeddedInsert = FALSE;
          *SqlParser_Diags << DgSqlCode(-3409);
          YYABORT;
        }

    }
   // QSTUFF
  |   TOK_ALLOCATE entity_name TOK_CURSOR TOK_FOR entity_name
   {

      if ($2 == NULL && $5 == NULL)
	{
	  TheHostVarRoles->setFirstUnassignedTo(HV_IS_CURSOR_NAME);
	  TheHostVarRoles->setLastUnassignedTo(HV_IS_STMT_NAME);
	  $$ = new (PARSERHEAP()) StmtXdynCurs();
	}
      else
	{
          // Parse Error: In an Allocate Cursor statement you must name both
          // the cursor and the statement using string host variables.
          *SqlParser_Diags << DgSqlCode(-3007);
	  YYABORT;
	}
    }
  // QSTUFF
    |   TOK_ALLOCATE entity_name TOK_CURSOR_WITH_HOLD TOK_FOR entity_name
   {

      if ($2 == NULL && $5 == NULL)
	{
	  TheHostVarRoles->setFirstUnassignedTo(HV_IS_CURSOR_NAME);
	  TheHostVarRoles->setLastUnassignedTo(HV_IS_STMT_NAME);
	  $$ = new (PARSERHEAP()) StmtXdynCurs(TRUE);
	}
      else
	{
          // Parse Error: In an Allocate Cursor statement you must name both
          // the cursor and the statement using string host variables.
          *SqlParser_Diags << DgSqlCode(-3007);
	  YYABORT;
	}
    }
   |   TOK_ALLOCATE entity_name TOK_CURSOR_WITHOUT_HOLD TOK_FOR entity_name
   {

      if ($2 == NULL && $5 == NULL)
	{
	  TheHostVarRoles->setFirstUnassignedTo(HV_IS_CURSOR_NAME);
	  TheHostVarRoles->setLastUnassignedTo(HV_IS_STMT_NAME);
	  $$ = new (PARSERHEAP()) StmtXdynCurs(FALSE);
	}
      else
	{
          // Parse Error: In an Allocate Cursor statement you must name both
          // the cursor and the statement using string host variables.
          *SqlParser_Diags << DgSqlCode(-3007);
	  YYABORT;
	}
    }
  // QSTUFF


/* The way that this non-terminal works is that its data has two states:
*    + If it is NULL, that means a host variable specified the entity name.
*      This is what happens in extended dynamic SQL.  In that case, the
*      production in which entity_name occurs must be sure to set up
*      TheHostVarRoles in its action part to set the role for the host variable
*      encountered here.  That means that the production must test whether
*      or not entity_name's data is NULL.
*    + If it is NOT NULL then it is a pointer to an NAString that contains the
*      literal string that names the entity.  No host variables involved.
*
* Note that currently we do not support the local/global scoping of entities.
*/

/* stringval */
entity_name : identifier  /* just return *NAString by default */
            | scope_spec character_string_literal
               {
                 // DEFAULT_CHARSET has no effect on character_string_literal in this context
		 // Upshift the literal, unless it's a delimited identifier
		 // in double quotes. NOTE: there is a similar piece of
		 // code in proc GetNameViaDesc() in file cli/Descriptor.cpp,
		 // make sure those two counterparts remain in sync, or
		 // otherwise literals for names will behave differently
		 // from host variables.
		 if (($2->data())[0] != '\"')
		   $2->toUpper();
		 ToStringvalWithCharSet(&$$)->shallowCopy(ToStringvalWithCharSet(&$2)); // do this instead of $$ = $2; to copy charset info
	       }
            | scope_spec simple_host_variable
               {
                 $$ = NULL;
               }

/* item */
entity_name_as_item : identifier
		{
		  $$ = new (PARSERHEAP()) ConstValue(*$1);
		}
		
            | simple_host_variable
               {
                  if (CmpCommon::getDefault(MODE_SPECIAL_4) == DF_OFF) 
                    {
                      TheHostVarRoles->setLastUnassignedTo(HV_IS_INPUT);
                      
                      $$ = $1;
                    }
               }

/* Note that there is a default on the scope_spec which is: local.          */
/* A value of TRUE means GLOBAL and FALSE means LOCAL.                      */

/* boolean */
scope_spec :   { $$ = FALSE;  /* default to LOCAL, FALSE */ }
           | TOK_GLOBAL   { $$ = TRUE; }
           | TOK_LOCAL    { $$ = FALSE; }



/* A cursor-spec, for now, is really just a query_expression.  We provide
 * the full syntax that includes the order_by_clause and so on, but
 * we warn the user that these clauses are ignored.  Later, we will
 * implement the semantic actions to support the syntax.
 */
cursor_spec : query_exp_for_cursor
	    | rowset_for_input query_exp_for_cursor
		{
		    // Make sure the root is on top of the rowsetfor node
		    // the parse tree is root->rowsetfor->previous child of root
		    $1->setChild(0, $2->child(0));
		    $2->setChild(0, $1);
		    $$ = $2;
		} 

query_exp_for_cursor : query_expression for_update_spec
			{
			    $$ = finalize($1, FALSE/*i.e., no outputVar count checking*/);
			    $2->finalizeUpdatability($$);
			}
		    | query_expression order_by_clause access_type optional_lock_mode for_update_spec
			{
			    $$ = finalize($1, FALSE/*i.e., no outputVar count checking*/);
			    ((RelRoot *)$$)->addOrderByTree($2);
			    if (!finalizeAccessOptions($$, $3, $4)) YYERROR;
			    $5->finalizeUpdatability($$);
			}

/* forUpdateSpec */
for_update_spec: TOK_FOR_READ_ONLY
                     { $$ = new (PARSERHEAP()) ForUpdateSpec(TRUE, FALSE); }
	       | TOK_FOR TOK_UPDATE
                     { $$ = new (PARSERHEAP()) ForUpdateSpec(TRUE, TRUE); }
               | TOK_FOR TOK_UPDATE TOK_OF column_list
                     { $$ = new (PARSERHEAP()) ForUpdateSpec(TRUE, TRUE, $4);}
               | /*empty*/
                     { $$ = new (PARSERHEAP()) ForUpdateSpec(FALSE); }


/* In order to setup the host var roles for the host variables in hostvar_list
 * we take the count obtained from hostvar_list and use it to
 * set the last n host vars whose roles are unassigned to HV_IS_INPUT.
 */

using_clause: TOK_USING input_hostvar_list
                   {
		     TheHostVarRoles->setLastNunassignedTo($2,HV_IS_INPUT);
		   }

/* Similar to the using clause, for the into_clause we set the roles
 * so obtained to HV_IS_OUTPUT. If we are in an a compound statement, then
 * the INTO clause is equivalent to a SET, or assignment, statement, in which
 * case the variable must be treated as both input and output
 */
into_clause: TOK_INTO {InAssignmentSt = TRUE;} output_hostvar_list
  {

    if (intoClause && (in3GL_ == 0)) {
      // More than one INTO statement in the same query is not supported
      *SqlParser_Diags << DgSqlCode(-30011);
      YYERROR;
	}
    ThereAreAssignments = (in3GL_ > 0);
	if (ThereAreAssignments) {
	  TheHostVarRoles->setLastNunassignedTo($3,HV_IS_INPUT_OUTPUT);
	}
	else {
      TheHostVarRoles->setLastNunassignedTo($3,HV_IS_OUTPUT);
	}
    intoClause = TRUE;	
	InAssignmentSt = FALSE;
    NumOfScalars = NumOfArrays = 0;
  }

/* This non-terminal must count how many host variable expressions occur and
 * then return that count as the data belonging to $$.
 */


/* uint */
output_hostvar_list : hostvar_expression
           {
			 // Get variable just inserted
			 HostVar *var = (HostVar *) ((*AllHostVars)[AllHostVars->entries() - 1]);

			 if (var->getType()->getTypeQualifier() == NA_ROWSET_TYPE) {
			    NumOfArrays++;
			 }
			 else {
			    NumOfScalars++;
			 }
			 
			 // In the output list, we should have only scalar or only arrays
			 if ((NumOfArrays > 0) && (NumOfScalars > 0)) {
			   *SqlParser_Diags << DgSqlCode(-30006);
               YYERROR;
			 }

		     $$  = 1;
		   }

        | output_hostvar_list ',' hostvar_expression
           {

			 // Get variable just inserted
			 HostVar *var = (HostVar *) ((*AllHostVars)[AllHostVars->entries() - 1]);

			 if (var->getType()->getTypeQualifier() == NA_ROWSET_TYPE) {
			    NumOfArrays++;
			 }
			 else {
			    NumOfScalars++;
			 }
			 
			 // In the output list, we should have only scalar or only arrays
			 if ((NumOfArrays > 0) && (NumOfScalars > 0)) {
			   *SqlParser_Diags << DgSqlCode(-30006);
               YYERROR;
			 }

		     $$ = $1 + 1;
		   }

/* uint */
input_hostvar_list : input_hostvar_expression
                   {
		     $$  = 1;
		   }

             | input_hostvar_list ',' input_hostvar_expression
                   {
		     $$ = $1 + 1;
		   }

/* OPEN CURSOR
 * -----------
 * We parse a general grammar
 * handling the static, dynamic, and extended dyanamic cases all as
 * going to a single non-terminal for the open statement.  This differs
 * from our approach to cursor declaration in that for cursor declaration
 * we have distinct non-terminals for these various cases.  However, the
 * consumers of these data structures are different in these two cases.
 * With the open cursor statement, only the preprocessor sees it, and the
 * preprocessor is designed to be able to translate the general case.
 *   We need merely to enforce certain constraints when we interpret
 * the parsed data (see the Preprocessor's dosql() routine).  Namely,
 * if the open cursor statement names the cursor statically, then there
 * can be no descriptor nor host variables named in the statement.  Conversely,
 * if there ARE host variables or descriptor named, then the cursor must
 * be designated by means of a name of a dynamic descriptor, or, by an
 * extended dynamic name given by a string valued host variable expression.
 * We can enforce that here in the parser.  The preprocessor code maps the
 * returned Statement Node to its internal structures for generating output.
 */

/* stmt_ptr */
open_cursor : TOK_OPEN entity_name
                 {
                   assignRoleToFirst($2,HV_IS_CURSOR_NAME);
                   $$ = new (PARSERHEAP())
		     StmtOpen( $2, new (PARSERHEAP()) designation(DT_NULL));
                 }

            | TOK_OPEN entity_name extended_input_designation
                {
                   assignRoleToFirst($2,HV_IS_CURSOR_NAME);
                   $$ = new (PARSERHEAP()) StmtOpen( $2, $3);
                }


/* Extended input designation is about specifying either an input host
 * variable list, OR, an input descriptor.
 *
 * using_clause takes care of setting host variable roles.
 *
 * In the case of entity_name, we need to do the usual assignment of roles.
 */


/* dsgtn */
extended_input_designation : using_clause
                   {
                      $$ = new (PARSERHEAP()) designation(DT_HVLIST);
                   }
                | using_descriptor

/* dsgtn */
using_descriptor : TOK_USING   TOK_SQL    TOK_DESCRIPTOR  entity_name
                    {
		      assignRoleToLast($4,HV_IS_DESC_SOURCE);
		      $$ = new (PARSERHEAP()) designation($4);
                    }

/* fetch cursor.  Fetch is just like open, EXCEPT, that the
 * extended_input_designation IS extended_output_designation.  So here
 * we go: observe the copy/paste results that follow, based on OPEN CURSOR.
 *
 * The only real difference (except for the input/output change) from
 * OPEN CURSOR to FETCH CURSOR is that with Fetch, the user MUST
 * provide at least one output host variable to receive the data.  With
 * OPEN, the user is NOT required to provide an input variable if they choose
 * not to.
 */


/* stmt_ptr */
fetch_cursor :  TOK_FETCH entity_name extended_output_designation
                {
                   assignRoleToFirst($2,HV_IS_CURSOR_NAME);
                   $$ = new (PARSERHEAP()) StmtFetch( $2, $3);
                }
             |  TOK_FETCH TOK_FROM entity_name extended_output_designation
                {
                   assignRoleToFirst($3,HV_IS_CURSOR_NAME);
                   $$ = new (PARSERHEAP()) StmtFetch( $3, $4);
                }


/* Extended output designation is about specifying either an output host    */
/* variable list, OR, an output descriptor.                                 */

/* dsgtn */
extended_output_designation :  into_clause
                   {
                      $$ = new (PARSERHEAP()) designation(DT_HVLIST);
                   }
                | into_descriptor

/* dsgtn */
into_descriptor : TOK_INTO  TOK_SQL      TOK_DESCRIPTOR  entity_name
                    {
		      assignRoleToLast($4,HV_IS_DESC_DEST);
                      $$ = new (PARSERHEAP()) designation($4);
                      intoClause = TRUE;
                    }

/* prepare dynamic statement                                                */
/* The entity_name has to be for a statement.  The host_variable            */
/* expression has to be string valued.                                      */

/* stmt_ptr */
dynamic_prepare : TOK_PREPARE entity_name TOK_FROM  simple_host_variable
                 {
		   assignRoleToFirst($2,HV_IS_STMT_NAME);
		   TheHostVarRoles->setLastUnassignedTo(HV_IS_STRING);
		   $$ = new (PARSERHEAP()) StmtPrepare($2);
                 }


/* See the preprocessor Internal Spec  and External Spec. for reference     */
/* to information concerning the RETURNING clause of the EXECUTE statement. */
/*                                                                          */
/* Note that in addition to not supporting the RETURNING clause, we also    */
/* are not supporting the INTO clause (for now, anyway).                    */

/* stmt_ptr */
dynamic_execute : TOK_EXECUTE     entity_name
                 {
		   assignRoleToFirst($2, HV_IS_STMT_NAME);
                   $$ = new (PARSERHEAP())
		     StmtExecute($2, new (PARSERHEAP()) designation(DT_NULL));
                 }

              | TOK_EXECUTE   entity_name    extended_input_designation
                 {
		   assignRoleToFirst($2, HV_IS_STMT_NAME);
                   $$ = new (PARSERHEAP()) StmtExecute($2,$3);
                 }

              | TOK_EXECUTE   entity_name    extended_output_designation
                 {
		   assignRoleToFirst($2, HV_IS_STMT_NAME);
                   $$ = new (PARSERHEAP()) StmtExecute($2,NULL,$3);
                 }

              | TOK_EXECUTE entity_name extended_input_designation extended_output_designation
                 {
		   assignRoleToFirst($2, HV_IS_STMT_NAME);
                   $$ = new (PARSERHEAP()) StmtExecute($2,$3,$4);
                 }

/* stmt_ptr */
execute_immediate : TOK_EXECUTE    TOK_IMMEDIATE    simple_host_variable
           {
	     TheHostVarRoles->setFirstUnassignedTo(HV_IS_STRING);
             $$ = new (PARSERHEAP()) StmtNode(STM_EXEC_IMMED); 
           }

/* stmt_ptr */
whenever_statement : TOK_WHENEVER 
          {
	    SqlParser_WheneverClause = TRUE;
	  }
		     whenever_condition whenever_action
          {
	    $$ = new (PARSERHEAP()) StmtWhenever((MBD_CONDITION)$3, $4);
	    SqlParser_WheneverClause = FALSE;
	  }

/* uint -- really some enumerations */
whenever_condition : TOK_NOT TOK_FOUND    { $$ = onEnd; }
                   | TOK_SQLERROR  { $$ = onError; }
                   | TOK_SQL_WARNING  { $$ = on_Warning; }

/* actn_ptr */
whenever_action : CALL_CASED_IDENTIFIER
                  {
                    NAString casedIdent;
                    parseCasedIdentifier(ParCALL_CASED_IDENTIFIER_CLAUSE,
                                         $1, casedIdent);
                    $$ = new (PARSERHEAP()) action;
                    $$->setActionLabel( CALL_ACTION, casedIdent);
                    delete $1;
                  }

                | CALL_CASED_IDENTIFIER '.' regular_identifier
                  {
                     NAString casedIdent,casedIdent2;
                     parseCasedIdentifier(ParCALL_CASED_IDENTIFIER_CLAUSE,
                                           $1, casedIdent);
                     $$ = new (PARSERHEAP()) action;
		     casedIdent.append(".");
                     casedIdent.append($3->data());
                     $$->setActionLabel( CALL_ACTION, casedIdent);
                     delete $1;
                     delete $3;
                  }

//                  TOK_CALL host_identifier
//                  {  $$ = new (PARSERHEAP()) action;
//                     $$->setActionLabel( CALL_ACTION, *$2);
//                     delete $2;
//                  }

//                | TOK_GOTO host_identifier
//                  {  $$ = new (PARSERHEAP()) action;
//                     $$->setActionLabel( GOTO_ACTION, *$2);
//                     delete $2;
//                  }
//
//                | TOK_GO TOK_TO host_identifier
//                  {  $$ = new (PARSERHEAP()) action;
//                     $$->setActionLabel( GOTO_ACTION, *$3);
//                     delete $3;
//                  }

                | GOTO_CASED_IDENTIFIER
                  {
                     NAString casedIdent;
                     parseCasedIdentifier(ParGOTO_CASED_IDENTIFIER_CLAUSE,
                                           $1, casedIdent);
                     $$ = new (PARSERHEAP()) action;
                     $$->setActionLabel( GOTO_ACTION, casedIdent);
                     delete $1;
                  }

                | PERFORM_CASED_IDENTIFIER
                  {
                     NAString casedIdent;
                     parseCasedIdentifier(ParPERFORM_CASED_IDENTIFIER_CLAUSE,
                                          $1, casedIdent);
                     $$ = new (PARSERHEAP()) action;
                     $$->setActionLabel( CALL_ACTION, casedIdent);
                     delete $1;
                  }

                | TOK_CONTINUE
                  {  $$ = new (PARSERHEAP()) action;
                     $$->setActionLabel( NULL_ACTION, "");
                  }

/* describe prepared statement.                                             */
/* We are going to create this assuming only ANSI descriptors and NOT       */
/* those wacky SQL/MP type descriptors.  That will be for another day       */
/* (read: for another milestone).                                           */
/*                                                                          */
/* The first entity_name is for a statement, the second entity_name is for  */
/* a descriptor. We need to be a little clever about how we assign roles to */
/* host vars used (if any) in the entity_name non terminals.  This is       */
/* because there may be zero, one, or two such host variables, and the      */
/* action of "assignRoleToFirst" (or last) won't be the same in all such    */
/* cases ;-)  */

/* stmt_ptr */
describe_statement :
   TOK_DESCRIBE   output_or_input     entity_name   describe_target
    {
      if ($3 == NULL)
	assignRoleToFirst($3, HV_IS_STMT_NAME);
//      if ($4 == NULL)
//	assignRoleToLast($4, HV_IS_DESC_NAME);
      $$ = new (PARSERHEAP()) StmtDescribe($2,$3,$4);
    }

describe_target : TOK_INTO entity_name
                  {
	            assignRoleToLast($2, HV_IS_DESC_NAME);
		    $$ = $2;
		  }
                | using_descriptor
                  {
		    $$ = $1->descName;
		  }
// 17.9 says that into can only be used in dynamic fetch or result using clause
// also, preprocessors conform to this and can't handle into usage
//                | into_descriptor
//                  {
//		    $$ = $1->descName;
//		  }

/* uint -- actually an enum */
output_or_input :   { $$ = OUTPUT_DIRECTION; }
                |  TOK_INPUT  { $$ = INPUT_DIRECTION; }
                |  TOK_OUTPUT { $$ = OUTPUT_DIRECTION; }



/* ALLOCATE STATIC input descriptor  name_of_desc for <statement | cursor> */
/* name_of_stmt_or_cursor <this is the host variable type list>            */
/*                                                                         */
/* The type of this non-terminal is stmt_ptr, since it is a kind of        */
/* statement to be represented by a StmtNode derived class.                */
/*                                                                         */
/* To satisfy the args of StmtAllocStaticDesc:                             */
/* For the namePlusDescPtr, we get a new one, and then supply the          */
/* descriptor name and the host_var_type_list.                             */
/* For theTag, we get that out of the for_stmt_or_curs struct.             */
/* For theName, we also get that out of the for_stmt_or_curs struct.       */
/*                                                                         */
/*                                                                         */

/* stmt_ptr */
alloc_static_desc_stmt : TOK_ALLOCATE TOK_STATIC input_or_output
        TOK_DESCRIPTOR identifier for_stmt_or_curs '(' host_var_type_list ')'

/* all we're going to do here is stuff the data we get back from the
 * right side of this production, stuff it into a structure,
 * StmtAllocStaticDesc.  It's already packaged up by the right side non-terms.
 */
       {
          $$ = new (PARSERHEAP()) StmtAllocStaticDesc
	    (new (PARSERHEAP()) NamePlusDesc($5,
					 $3==INPUT_DIRECTION,
					 $8),
	     $6->tag,
	     $6->theName);
       }

alloc_static_desc_stmt : TOK_ALLOCATE TOK_STATIC input_or_output
        TOK_DESCRIPTOR identifier for_stmt_or_curs TOK_LPAREN_BEFORE_DATATYPE host_var_type_list ')'

/* all we're going to do here is stuff the data we get back from the
 * right side of this production, stuff it into a structure,
 * StmtAllocStaticDesc.  It's already packaged up by the right side non-terms.
 */
       {
          $$ = new (PARSERHEAP()) StmtAllocStaticDesc
	    (new (PARSERHEAP()) NamePlusDesc($5,
					 $3==INPUT_DIRECTION,
					 $8),
	     $6->tag,
	     $6->theName);
       }

/* Then for the input_or_output non-term, it should return a value          */
/* that's an enumeration indicating the direction of the descriptor.        */
/* Note that it can be epsilon..which defaults to input.                    */
/*                                                                          */

/* uint -- actually an enum */
input_or_output :   { $$ = INPUT_DIRECTION; }
                |  TOK_INPUT  { $$ = INPUT_DIRECTION; }
                |  TOK_OUTPUT { $$ = OUTPUT_DIRECTION; }


/* A for_stmt_or_curs non-terminal can either be empty,                     */
/* or indicate a string which names                                         */
/* a cursor, or which names a statement.                                    */
/*                                                                          */
/* If it were simply a string pointer, it would have either a NULL or valid */
/* value, and then we need to pass a tag back, telling what kind as well.   */
/*                                                                          */
/* For the default case, we get a new StmtOrCursTag, its name will be empty */
/* as that is the default constructor's result for NAString.                */
/* Also, we set the StmtOrCursTag's                                         */
/* tag to NAME_ABSENT.                                                     */


/* stmt_or_curs */
for_stmt_or_curs :
                   {
                      $$ = new (PARSERHEAP()) StmtOrCursTag;
                      $$->tag = NAME_ABSENT;
                      $$->theName = new (PARSERHEAP()) NAString (PARSERHEAP()); // theName pts to empty str
                   }

              | TOK_FOR TOK_STATEMENT identifier
                   {
                      $$ = new (PARSERHEAP()) StmtOrCursTag;
                      $$->tag = NAME_STATEMENT;
                      $$->theName = $3;
                   }
              | TOK_FOR TOK_CURSOR    identifier
                   {
                      $$ = new (PARSERHEAP()) StmtOrCursTag;
                      $$->tag = NAME_CURSOR;
                      $$->theName = $3;
                   }

/* And... in addition to what it says next, this non-terminal
 * now supports the StaticDescItem as a member of the generated
 * data structure (a sequence).  (...more later...)
 */

/* The host variable type list is a sequence of
 * 0 or more pairs.  Each pair is a sql type followed by a string
 * that specifies either nullable, "NULL," or not nullable "NOT NULL."
 *
 * In the case that "NULL" appears, that means that there is a
 * raw-host-variable of SQL type "SMALLINT."
 *
 * All we have to do is make sure that we return a DescTypeList.  It
 * can be empty, have a single element, or, multiple elements.
 */

/* descTypeList */
host_var_type_list :  { /* this is the empty-list case */
                        $$ = new (PARSERHEAP()) DescTypeList (PARSERHEAP());
                      }
                   | host_var_type_item
                      {
                        $$ = new (PARSERHEAP()) DescTypeList (PARSERHEAP());
                        $$->append($1);
                      }
                   | host_var_type_list ',' host_var_type_item
                      {
                        $$ = $1;
                        $$->append($3);
                      }

/* The host_var_type_item is a SQL type followed by NULL or NOT NULL.
 *
 * Each host_var_type_item is a struct containing a flag and then
 * SQL data type.
 *
 * We can represent the NULLABLE/NOT NULLABLE by means of a boolean,
 * of course, say, isNullable.
 */

/* staticDescItem */
host_var_type_item : proc_arg_data_type TOK_NULL
                      {
			if ($1->isExternalType()) externalDataTypeCnt_--;
                        HostVarExprType *t = new (PARSERHEAP()) HostVarExprType;
                        t->isNullable = TRUE;
                        t->the_type = $1;
                        $$ = new (PARSERHEAP()) StaticDescItem(t);
                      }
                   | proc_arg_data_type TOK_NOT TOK_NULL
                      {
			if ($1->isExternalType()) externalDataTypeCnt_--;
                        HostVarExprType *t = new (PARSERHEAP()) HostVarExprType;
                        t->isNullable = FALSE;
                        t->the_type = $1;
                        $$ = new (PARSERHEAP()) StaticDescItem(t);
                      }
                   | literal_negatable
                      {
                        assert($1->getOperatorType() == ITM_CONSTANT);
                        $$ = new (PARSERHEAP()) StaticDescItem ((ConstValue *) $1);
                      }


/* The format of a procedure statement is pretty easy, actually:            */
/*                                                                          */
/* PROCEDURE name_of_proc ( proc_arg_decls ) sql_statement                  */
/*                                                                          */
/* Note that the parser COULD be the one which, at this point, verifies     */
/* that the host var list has names which match up exactly with the names   */
/* which occur in the sql statement.                                        */

/* stmt_ptr */
procedure_stmt : TOK_PROCEDURE identifier argList_establishment sql_statement
                 {
		   $$ = new (PARSERHEAP()) StmtProcedure( $2, $4);
                 }

/* The purpose of this production is to cause the
 * HVArgTypeLookup from the header of a procedure to be
 * assigned to the static var TheProcArgTypes.  This makes it available
 * later in the right side of procedure_stmt.  This is part of the scheme
 * of passing the types of host variables to the point where we do
 * the reduction to a HostVar() class object.
 */

/* uint -- but doesn't matter */
argList_establishment : '(' proc_arg_decls ')'
                 {
		   assert(!TheProcArgTypes);	// otherwise, memory leak!
                   TheProcArgTypes = $2;
                   $$ = 0;  // dummy value, doesn't matter
		 }

// An hvArgtypeLookup can be an empty list, or have one or more items.
//
// Each item is either a hostvar (:ident, per Ansi syntax 12.3 + 5.4)
// or an identifier (no colon in front, Tandem-extension),
// followed by a SQL datatype.
//
// This hostvar-or-ident flexibility has a tiny chance of causing an ambiguity;
// see comments in the HOSTVAR production in SqlLexer.l.
//
/* hvArgtype */
proc_arg_decl  : HOSTVAR proc_arg_data_type
		 {
		   // HOSTVAR $1 has a :colon, courtesy of SqlLexer
		   $$ = new (PARSERHEAP()) HVArgType($1, $2);
		   if ($2->isExternalType()) externalDataTypeCnt_--;
		 }
               | identifier proc_arg_data_type
		 {
		   $1->prepend(':');	// $1 is now :ident, same fmt as HOSTVAR
		   $$ = new (PARSERHEAP()) HVArgType($1, $2);
		   if ($2->isExternalType()) externalDataTypeCnt_--;
		 }

/* hvArgtypeLookup */
proc_arg_decls : {
		   $$ = new (PARSERHEAP()) HVArgTypeLookup (PARSERHEAP());
		 }
               | proc_arg_decl
		 {
		   $$ = new (PARSERHEAP()) HVArgTypeLookup (PARSERHEAP());
		   $$->insert($1);
		 }
               | proc_arg_decls ',' proc_arg_decl
		 {
		   if ($$->get($3->getName()))
		     {
		       // ANSI 12.3 SR 2  (err 3160 "param declared twice")
		       *SqlParser_Diags << DgSqlCode(-3160)
		         << DgString0(*$3->getName());
		       YYERROR;
		     }
		   $$->insert($3);
		 }


/* stmt_ptr */
module_statement : TOK_MODULE module_name TOK_NAMES TOK_ARE identifier
             {
	       QualifiedName *modName = qualifiedNameFromStrings($2);
	       if (!modName) YYERROR;
               $$ = new (PARSERHEAP()) StmtModule(*modName, *$5, PARSERHEAP());
             }
		 | TOK_MODULE module_name
             {
	       QualifiedName *modName = qualifiedNameFromStrings($2);
	       if (!modName) YYERROR;
	       NAString cs(CharInfo::getCharSetName(CharInfo::DefaultCharSet));
               $$ = new (PARSERHEAP()) StmtModule(*modName, cs, PARSERHEAP());
             }

/* stmt_ptr */
source_file_statement : TOK_SOURCE_FILE QUOTED_STRING
             { 
               // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
               $$ = new (PARSERHEAP()) StmtSourceFile($2);
             }

/* TIMESTAMP DEFINITION timestamp
 *
 * Does POSIX allow us to
 * use the seconds since midnight Jan. 1, 1970?  I'll bet yes, and that will
 * further mean that an unsigned long has just become what we are
 * going to represent <timestamp> as.
 *
 * So, for convenience reasons, then, we'll put parens around the
 * number in the timestamp. That's because I would prefer having only a single
 * non-terminal which does unsigned-verification of a NUMERIC_LITERAL
 * and the CLOSEST FIT to that requirement is left_unsigned_right.
 */
module_timestamp : TOK_TIMESTAMP TOK_DEFINITION left_largeint_right
        {
           NABoolean junkme = FALSE;
           ConstValue *theValue = $3->castToConstValue(junkme);
           $$ = new (PARSERHEAP()) StmtTimeStamp( 
                   * (Int64 *) (theValue->getConstValue()) );
        }


/* allocate dynamic descriptor */


dealloc_stmt_statement : TOK_DEALLOCATE TOK_PREPARE entity_name
   {
      assignRoleToLast($3, HV_IS_STMT_NAME);
      $$ = new (PARSERHEAP()) StmtDeallocStm($3);
   }

dealloc_desc_statement : TOK_DEALLOCATE TOK_DESCRIPTOR entity_name
   {
      assignRoleToLast($3, HV_IS_DESC_NAME);
      $$ = new (PARSERHEAP()) StmtDeallocDesc($3);
   }

close_statement : TOK_CLOSE entity_name
   {
      assignRoleToLast($2, HV_IS_CURSOR_NAME);
      $$ = new (PARSERHEAP()) StmtClose($2);
   }

// The grammar allows a SQL literal,
// or a simple input host variable.  No prototype is allowed, and
// no environment variable is allowed.
// The literal is as a string, and it gets queued into the StmtNode
// literal list.  If there is a host variable, its role gets set
// to "input."  A host variable's
// non-terminal value, a HostVar node, gets deleted.
// That's because the SQL compiler never looks at host variables used in
// simple value specifications.

simple_value_spec : literal_as_string
          {
             // enqueue the $1 literal string to the string list by appending
             (CURRENTSTMT->getParserStmtLiteralList()).append($1);
             TheHostVarRoles->addARole(HV_IS_LITERAL); 
             $$ = 0;  // just set 0 as a don't care value
          }
      | simple_host_variable
          {
            if (CmpCommon::getDefault(MODE_SPECIAL_4) == DF_OFF) 
              {
                // don't delete the hostvar since it is shared with AllHostVars...
                TheHostVarRoles->setLastUnassignedTo(HV_IS_INPUT);
                $$ = 0;  // just set 0 as a don't care value
              }
          }

// The ALLOCATE DESCRIPTOR has an optional "max value," so we yet
// need to implement that part of the syntax and supply the default
// value of 500.

alloc_desc_statement : TOK_ALLOCATE TOK_DESCRIPTOR entity_name
                         TOK_WITH TOK_MAX simple_value_spec
           {
              if ($3 == NULL)
                TheHostVarRoles->setFirstUnassignedTo(HV_IS_DESC_NAME);
              $$ = new (PARSERHEAP()) StmtAllocDesc($3); 
           }
        | TOK_ALLOCATE TOK_DESCRIPTOR entity_name
           {
              if ($3 == NULL)
                TheHostVarRoles->setFirstUnassignedTo(HV_IS_DESC_NAME);
              $$ = new (PARSERHEAP()) StmtAllocDesc($3); 
             (CURRENTSTMT->getParserStmtLiteralList()).append(new (PARSERHEAP()) 
                                               NAString("500", PARSERHEAP()));
              TheHostVarRoles->addARole(HV_IS_LITERAL); 
           }


// We need to make sure the entity_name ($3) gets a role of
// descriptor, in case a host variable gave the name of the descriptor.
// We discard the simple_host_variable's HostVar Node since we don't need it,
// but we let the preprocessor know that that host variable should have
// a mode of output.

get_desccount_statement : TOK_GET TOK_DESCRIPTOR entity_name
simple_host_variable '=' TOK_COUNT
      {
         if ($3 == NULL)
            TheHostVarRoles->setFirstUnassignedTo(HV_IS_DESC_NAME);
         delete $4;  // don't need the host variable node
         TheHostVarRoles->setLastUnassignedTo(HV_IS_OUTPUT);
         $$ = new (PARSERHEAP()) StmtGetDescCount($3);
      }

get_rowsetsize_statement : TOK_GET TOK_DESCRIPTOR entity_name
simple_host_variable '=' TOK_ROWSET_SIZE
      {
         if ($3 == NULL)
            TheHostVarRoles->setFirstUnassignedTo(HV_IS_DESC_NAME);
         delete $4;  // don't need the host variable node
         TheHostVarRoles->setLastUnassignedTo(HV_IS_OUTPUT);
         $$ = new (PARSERHEAP()) StmtGetRowsetSize($3);
      }

/* longSeq */
get_info_item_list : get_info_item
              {
                  $$ = new (PARSERHEAP()) SequenceOfLong (PARSERHEAP());
                  assert($$);
                  $$->append(new (PARSERHEAP()) long($1));
              }
           | get_info_item_list ',' get_info_item
              {
                  $$ = $1;
                  $$->append(new (PARSERHEAP()) long($3));
              }

/* longint */
get_info_item : simple_host_variable '=' info_item_name
              {
                 delete $1;
                 TheHostVarRoles->setLastUnassignedTo(HV_IS_OUTPUT);
                 $$ = $3;
              }

/* longint */
info_item_name :  TOK_TYPE        { $$ = SQLDESC_TYPE; }
   | TOK_TYPE_ANSI                { $$ = SQLDESC_TYPE; }
   | TOK_TYPE_FS                  { $$ = SQLDESC_TYPE_FS; } 
   | TOK_DATETIME_CODE            { $$ = SQLDESC_DATETIME_CODE; }
   | TOK_LENGTH                   { $$ = SQLDESC_LENGTH; }
   | TOK_OCTET_LENGTH             { $$ = SQLDESC_OCTET_LENGTH; }
   | TOK_PRECISION                { $$ = SQLDESC_PRECISION; }
   | TOK_SCALE                    { $$ = SQLDESC_SCALE; }
   | TOK_LEADING_PRECISION        { $$ = SQLDESC_INT_LEAD_PREC; }
   | TOK_NULLABLE                 { $$ = SQLDESC_NULLABLE; }
   | TOK_CHAR TOK_SET             { $$ = SQLDESC_CHAR_SET; }
   | TOK_CHARACTER TOK_SET        { $$ = SQLDESC_CHAR_SET; }
   | TOK_CHARACTER_SET_CATALOG    { $$ = SQLDESC_CHAR_SET_CAT; }
   | TOK_CHARACTER_SET_SCHEMA     { $$ = SQLDESC_CHAR_SET_SCH; }
   | TOK_CHARACTER_SET_NAME       { $$ = SQLDESC_CHAR_SET_NAM; }
   | TOK_COLLATION                { $$ = SQLDESC_COLLATION; }
   | TOK_COLLATION_CATALOG        { $$ = SQLDESC_COLL_CAT; }
   | TOK_COLLATION_SCHEMA         { $$ = SQLDESC_COLL_SCH; }
   | TOK_COLLATION_NAME           { $$ = SQLDESC_COLL_NAM; }
   | TOK_NAME                     { $$ = SQLDESC_NAME; }
   | TOK_UNNAMED                  { $$ = SQLDESC_UNNAMED; }
   | TOK_HEADING                  { $$ = SQLDESC_HEADING; }
   | TOK_INDICATOR_TYPE           { $$ = SQLDESC_IND_TYPE; }
   | TOK_VARIABLE_POINTER         { $$ = SQLDESC_VAR_PTR; }
   | TOK_ROWSET_VAR_LAYOUT_SIZE   { $$ = SQLDESC_ROWSET_VAR_LAYOUT_SIZE; }
   | TOK_INDICATOR_POINTER        { $$ = SQLDESC_IND_PTR; }
   | TOK_ROWSET_IND_LAYOUT_SIZE   { $$ = SQLDESC_ROWSET_IND_LAYOUT_SIZE; }
   | TOK_RETURNED_LENGTH          { $$ = SQLDESC_RET_LEN; }
   | TOK_RETURNED_OCTET_LENGTH    { $$ = SQLDESC_RET_OCTET_LEN; }
   | TOK_DATA                     { $$ = SQLDESC_VAR_DATA; }
   | TOK_VARIABLE_DATA            { $$ = SQLDESC_VAR_DATA; }
   | TOK_INDICATOR                { $$ = SQLDESC_IND_DATA; }
   | TOK_INDICATOR_DATA           { $$ = SQLDESC_IND_DATA; }
   | TOK_PARAMETER_MODE           { $$ = SQLDESC_PARAMETER_MODE; }
   | TOK_PARAMETER_ORDINAL_POSITION  { $$ = SQLDESC_ORDINAL_POSITION; }
   | TOK_PARAMETER_INDEX	     { $$ = SQLDESC_PARAMETER_INDEX; }
   | TOK_DATA_OFFSET              { $$ = SQLDESC_DATA_OFFSET; }
   | TOK_NULL_IND_OFFSET          { $$ = SQLDESC_NULL_IND_OFFSET; }
   | TOK_ALIGNED_LENGTH           { $$ = SQLDESC_ALIGNED_LENGTH; }

get_descitem_statement : TOK_GET TOK_DESCRIPTOR entity_name TOK_VALUE
          simple_value_spec get_info_item_list
      {
         if ($3 == NULL)
           TheHostVarRoles->setFirstUnassignedTo(HV_IS_DESC_NAME);
          $$ = new (PARSERHEAP()) StmtGetDescItem($3,$6);
      }

// This statement has a lot in common with "allocate descriptor" because
// the data involved is: 1) a name of a descriptor 2) a simple value spec.

set_desccount_statement : TOK_SET TOK_DESCRIPTOR entity_name TOK_COUNT
           '=' simple_value_spec
      {
         if ($3 == NULL)
           TheHostVarRoles->setFirstUnassignedTo(HV_IS_DESC_NAME);
         $$ = new (PARSERHEAP()) StmtSetDescCount($3); 
      }

set_rowsetsize_statement : TOK_SET TOK_DESCRIPTOR entity_name TOK_ROWSET_SIZE
           '=' simple_value_spec
      {
         if ($3 == NULL)
           TheHostVarRoles->setFirstUnassignedTo(HV_IS_DESC_NAME);
         $$ = new (PARSERHEAP()) StmtSetRowsetSize($3); 
      }

/* longSeq */
set_info_item_list : set_info_item
              {
                  $$ = new (PARSERHEAP()) SequenceOfLong (PARSERHEAP());
                  assert($$);
                  $$->append(new (PARSERHEAP()) long($1));
              }
           | set_info_item_list ',' set_info_item
              {
                  $$ = $1;
                  $$->append(new (PARSERHEAP()) long($3));
              }

/* longint */
set_info_item : info_item_name '=' simple_value_spec
              {
                 $$ = $1;
              }

set_descitem_statement : TOK_SET TOK_DESCRIPTOR entity_name TOK_VALUE
        simple_value_spec set_info_item_list
      {
         if ($3 == NULL)
           TheHostVarRoles->setFirstUnassignedTo(HV_IS_DESC_NAME);
         $$ = new (PARSERHEAP()) StmtSetDescItem($3,$6); 
      }

// For the first rule, we want to create a StmtDiagItemList
// fresh, and place the $1 into it.
// For the second rule, we want to append the new item to the
// list we should already have.

stmt_info_item_list : stmt_info_item
              {
                  $$ = new (PARSERHEAP()) SequenceOfLong (PARSERHEAP());
                  assert($$);
                  $$->append(new (PARSERHEAP()) long($1));
              }
           | stmt_info_item_list ',' stmt_info_item
              {
                  $$ = $1;
                  $$->append(new (PARSERHEAP()) long($3));
              }

stmt_info_item : simple_host_variable '=' stmt_info_item_name
              {
                 delete $1;
                 TheHostVarRoles->setLastUnassignedTo(HV_IS_OUTPUT);
                 $$ = $3;
              }


stmt_info_item_name :  TOK_NUMBER            { $$ = SQLDIAG_NUMBER; }
                     | TOK_MORE              { $$ = SQLDIAG_MORE;   }
                     | TOK_COMMAND_FUNCTION  { $$ = SQLDIAG_COMMAND_FUNC; }
                     | TOK_DYNAMIC_FUNCTION  { $$ = SQLDIAG_DYNAMIC_FUNC; }
                     | TOK_ROW_COUNT         { $$ = SQLDIAG_ROW_COUNT; }
                     | TOK_AVERAGE_STREAM_WAIT      { $$ = SQLDIAG_AVERAGE_STREAM_WAIT; }
                     | TOK_COST              { $$ = SQLDIAG_COST; }
                     | TOK_FIRST_FSCODE      { $$ = SQLDIAG_FIRST_FSCODE; }
                     | TOK_LAST_FSCODE       { $$ = SQLDIAG_LAST_FSCODE; }
                     | TOK_LAST_SYSKEY       { $$ = SQLDIAG_LAST_SYSKEY; }

get_stmtdiags_statement : TOK_GET TOK_DIAGNOSTICS stmt_info_item_list
      {
         $$ = new (PARSERHEAP()) StmtStmtDiag($3);
      }

// SequenceOfLong
cond_info_item_list : cond_info_item
              {
                  $$ = new (PARSERHEAP()) SequenceOfLong (PARSERHEAP());
                  assert($$);
                  $$->append(new (PARSERHEAP()) long($1));
              }
           | cond_info_item_list ',' cond_info_item
              {
                  $$ = $1;
                  $$->append(new (PARSERHEAP()) long($3));
              }

cond_info_item : simple_host_variable '=' cond_info_item_name
              {
                 delete $1;
                 TheHostVarRoles->setLastUnassignedTo(HV_IS_OUTPUT);
                 $$ = $3;
              }


cond_info_item_name : TOK_CONDITION_NUMBER { $$ = SQLDIAG_COND_NUMBER;}
  | TOK_SQLCODE                       { $$ = SQLDIAG_SQLCODE; }
  | TOK_RETURNED_SQLSTATE             { $$ = SQLDIAG_RET_SQLSTATE;}
  | TOK_CLASS_ORIGIN                  { $$ = SQLDIAG_CLASS_ORIG;}
  | TOK_SUBCLASS_ORIGIN               { $$ = SQLDIAG_SUBCLASS_ORIG;}
  | TOK_SERVER_NAME                   { $$ = SQLDIAG_SERVER_NAME;}
  | TOK_CONNECTION_NAME               { $$ = SQLDIAG_CONNECT_NAME;}
  | TOK_CONSTRAINT_CATALOG            { $$ = SQLDIAG_CONSTR_CAT;}
  | TOK_CONSTRAINT_SCHEMA             { $$ = SQLDIAG_CONSTR_SCHEMA;}
  | TOK_CONSTRAINT_NAME               { $$ = SQLDIAG_CONSTR_NAME;}
  | TOK_TRIGGER_CATALOG               { $$ = SQLDIAG_TRIGGER_CAT;}
  | TOK_TRIGGER_SCHEMA                { $$ = SQLDIAG_TRIGGER_SCHEMA;}
  | TOK_TRIGGER_NAME                  { $$ = SQLDIAG_TRIGGER_NAME;}
  | TOK_NSK_CODE                      { $$ = SQLDIAG_NSK_CODE;}
  | TOK_CATALOG_NAME                  { $$ = SQLDIAG_CATALOG_NAME;}
  | TOK_SCHEMA_NAME                   { $$ = SQLDIAG_SCHEMA_NAME;}
  | TOK_TABLE_NAME                    { $$ = SQLDIAG_TABLE_NAME;}
  | TOK_COLUMN_NAME                   { $$ = SQLDIAG_COLUMN_NAME;}
  | TOK_CURSOR_NAME                   { $$ = SQLDIAG_CURSOR_NAME;}
  | TOK_MESSAGE_TEXT                  { $$ = SQLDIAG_MSG_TEXT;}
  | TOK_MESSAGE_LEN                   { $$ = SQLDIAG_MSG_LEN;}
  | TOK_MESSAGE_OCTET_LEN             { $$ = SQLDIAG_MSG_OCTET_LEN;}
  | TOK_COLUMN_NUMBER                 { $$ = SQLDIAG_COLUMN_NUMBER;}
  | TOK_NATIVE                        { $$ = SQLDIAG_NATIVE;}
  | TOK_ROW_NUMBER                    { $$ = SQLDIAG_ROW_NUMBER;}
  | TOK_SOURCE_FILE                   { $$ = SQLDIAG_SOURCE_FILE;}
  | TOK_LINE_NUMBER                   { $$ = SQLDIAG_LINE_NUMBER;}
  | TOK_SUBSYSTEM_ID                  { $$ = SQLDIAG_SUBSYSTEM_ID;}


get_conddiags_statement : TOK_GET TOK_DIAGNOSTICS TOK_EXCEPTION
         simple_value_spec cond_info_item_list
      {
         $$ = new (PARSERHEAP()) StmtCondDiag( $5 );
      }


/****/
// About the host variables used for the environment variables giving a
// table name:
//
// The code is currently just experimental.  The issues remaining include:
// 1. The names for the host variable and indicator are always hard coded.
//    What should they really be?
// 2. The preprocessor really sets up a host variable of type char* which,
//    currently has no SQL equivalent.  What SQL type (SQLChar(100) is just
//    a placeholder, dummy type) should actually be used?
// 3. What should be the "return type" or the value placed into $$ for
//    this production?
// 4. Just a documentation issue: the production below accepts 
//	$foo	$Foo	$FOO	$ foo
//    all the same (resulting var is FOO), and
//	$"foo"	$"Foo"	$"FOO"	$" foo"
//    as all different (but note that	$ "foo"  ==  $"foo", of course).
/****/

/* type corrName */
table_name : special_table_name
	     | actual_table_name
	     | exception_table_name

/* type corrName */
special_index_table_name : TOK_TABLE '(' TOK_INDEX_TABLE actual_table_name
                           optional_special_table_loc_clause 
                           optional_special_utility_open_clause 
                           optional_with_shared_access_clause ')'
                {
                  if ((Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE)) ||
                      (Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL)))
                    {
                      // We don't allow a user to do their own index maint,
                      // nor even SELECT from an index (because that
                      // would become a bad habit).
                      // See CatROIndex.cpp & Parser::parseDML.
                      //
                      $4->setSpecialType(ExtendedQualName::INDEX_TABLE);
                      if ($5)
                        {
                          $4->setPartnClause(*$5);
                          delete $5;

			  if ($6 != -1)
			    $4->setUtilityOpenId($6);

			  // The isNSAOperation flag to TRUE if
			  // WITH SHARED ACCESS is specified in the 
			  // syntax.
			  $4->setIsNSAOperation($7);
			  
                        }
                      $$ = $4;  // actual_table_name
                    }
                  else
                    { yyerror(""); YYERROR; /*internal syntax only!*/}
                } 

           | TOK_TABLE '(' ghost TOK_INDEX_TABLE actual_table_name
                           optional_special_table_loc_clause 
                           optional_special_utility_open_clause 
                           optional_with_shared_access_clause ')'
                {
                  $5 /*actual_table_name*/ ->setSpecialType(ExtendedQualName::GHOST_INDEX_TABLE);
                  if ($6 /*optional_special_table_loc_clause*/)
                    {
                      $5 /*actual_table_name*/ ->setPartnClause(*$6 /*optional_special_table_loc_clause*/);
                      delete $6 /*optional_special_table_loc_clause*/;
  
                      if ($7 /*optional_special_utility_open_clause*/ != -1)
                        $5 /*actual_table_name*/ ->setUtilityOpenId($7 /*optional_special_utility_open_clause*/);
  
                      // Set the isNSAOperation flag to TRUE if
                      // WITH SHARED ACCESS is specified in the syntax.
                      $5 /*actual_table_name*/ ->setIsNSAOperation($8 /*optional_with_shared_access_clause*/);
  
                    }
                  $$ = $5 /*actual_table_name*/;
                }

special_regular_table_name : TOK_TABLE '(' TOK_TABLE actual_table_name
                             optional_special_table_loc_clause 
                             optional_special_utility_open_clause 
                             optional_with_shared_access_clause ')'
                {
                      // Since we DO want to allow the user to SELECT
                      // and also DELETE from, or LOCK or UNLOCK,
                      // an individual partition
                      // (since SELECT is useful and the others can do no harm),
                      // this is NOT disallowed here via SqlParser_Flags.
                      //
                      // See BindRelExpr.cpp, where INSERT and UPDATE
                      // are prevented unless ALLOW_SPECIALTABLETYPE is set.
                      //
                      if ($5)
                        {
                          $4->setPartnClause(*$5);
                          delete $5;

			  if ($6 != -1)
			    $4->setUtilityOpenId($6);

			  // The isNSAOperation flag to TRUE if
			  // WITH SHARED ACCESS is specified in the 
			  // syntax.
			  $4->setIsNSAOperation($7);

                        }
                      $$ = $4;  // actual_table_name
                }

special_table_name : special_regular_table_name

	   | special_index_table_name

	   | TOK_TABLE '(' TOK_TEMP_TABLE actual_table_name
             optional_special_table_loc_clause ')'
		{
                if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                  {
		      $4->setSpecialType(ExtendedQualName::TRIGTEMP_TABLE);
                      if ($5 /*optional_special_table_loc_clause*/ NEQ NULL)
                        {
                          $4/*actual_table_name*/->setPartnClause(*$5);
                          delete $5/*optional_special_table_loc_clause*/;
                        }
		      $$ = $4;  // actual_table_name
                }
                else
                  { yyerror(""); YYERROR; /*internal syntax only!*/}
		}
	   | TOK_TABLE '(' TOK_MV_TABLE actual_table_name
             optional_special_table_loc_clause ')'
		{
                if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                  {
					  $4->setSpecialType(ExtendedQualName::MV_TABLE);
                      if ($5 /*optional_special_table_loc_clause*/ NEQ NULL)
                        {
                          $4/*actual_table_name*/->setPartnClause(*$5);
                          delete $5/*optional_special_table_loc_clause*/;
                        }
		      $$ = $4;  // actual_table_name
                }
                else
                  { yyerror(""); YYERROR; /*internal syntax only!*/}
		}
	   | TOK_TABLE '(' TOK_IUD_LOG_TABLE actual_table_name
             optional_special_table_loc_clause ')'
		{
                if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                  {
		      $4->setSpecialType(ExtendedQualName::IUD_LOG_TABLE);
                      if ($5 /*optional_special_table_loc_clause*/ NEQ NULL)
                        {
                          $4/*actual_table_name*/->setPartnClause(*$5);
                          delete $5/*optional_special_table_loc_clause*/;
                        }
		      $$ = $4;  // actual_table_name
                }
                else
                  { yyerror(""); YYERROR; /*internal syntax only!*/}
		}
	   | TOK_TABLE '(' TOK_GHOST TOK_IUD_LOG_TABLE actual_table_name
             optional_special_table_loc_clause ')'
		{
                if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                  {
		      $5->setSpecialType(ExtendedQualName::GHOST_IUD_LOG_TABLE);
                      if ($6 /*optional_special_table_loc_clause*/ NEQ NULL)
                        {
                          $5/*actual_table_name*/->setPartnClause(*$6);
                          delete $6/*optional_special_table_loc_clause*/;
                        }
		      $$ = $5;  // actual_table_name
                }
                else
                  { yyerror(""); YYERROR; /*internal syntax only!*/}
		}

		   // OZ 

	   | TOK_TABLE '(' TOK_RANGE_LOG_TABLE actual_table_name 
             optional_special_table_loc_clause ')'
		{
                if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                  {
		      $4->setSpecialType(ExtendedQualName::RANGE_LOG_TABLE);
                      if ($5 /*optional_special_table_loc_clause*/ NEQ NULL)
                        {
                          $4/*actual_table_name*/->setPartnClause(*$5);
                          delete $5/*optional_special_table_loc_clause*/;
                        }
		      $$ = $4;  // actual_table_name
                }
                else
                  { yyerror(""); YYERROR; /*internal syntax only!*/}
		}

	   | TOK_TABLE '(' TOK_MVS_UMD actual_table_name
             optional_special_table_loc_clause ')'
		{
                if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                  {
		      $4->setSpecialType(ExtendedQualName::MVS_UMD);
                      if ($5 /*optional_special_table_loc_clause*/ NEQ NULL)
                        {
                          $4/*actual_table_name*/->setPartnClause(*$5);
                          delete $5/*optional_special_table_loc_clause*/;
                        }
		      $$ = $4;  // actual_table_name
                }
                else
                  { yyerror(""); YYERROR; /*internal syntax only!*/}
		}
	
           | TOK_TABLE '(' ghost TOK_TABLE actual_table_name
             optional_special_table_loc_clause ')'
                {
                  $5 /*actual_table_name*/ ->setSpecialType(ExtendedQualName::GHOST_TABLE);
                  if ($6 /*optional_special_table_loc_clause*/ NEQ NULL)
                  {
                    $5 /*actual_table_name*/ ->setPartnClause(*$6);
                    delete $6/*optional_special_table_loc_clause*/;
                  }
                  $$ = $5;  // actual_table_name
                }
  
           | TOK_TABLE '(' ghost TOK_MV_TABLE actual_table_name
             optional_special_table_loc_clause ')'
                {
                  $5 /*actual_table_name*/ ->setSpecialType(ExtendedQualName::GHOST_MV_TABLE);
                  if ($6 /*optional_special_table_loc_clause*/ NEQ NULL)
                  {
                    $5 /*actual_table_name*/ ->setPartnClause(*$6);
                    delete $6/*optional_special_table_loc_clause*/;
                  }
                  $$ = $5;  // actual_table_name
                }
	   | TOK_TABLE '(' TOK_EXCEPTION_TABLE actual_table_name
             optional_special_table_loc_clause ')'
		{
		  $4->setSpecialType(ExtendedQualName::EXCEPTION_TABLE);
                  if ($5 /*optional_special_table_loc_clause*/ NEQ NULL)
                    {
                      $4/*actual_table_name*/->setPartnClause(*$5);
                      delete $5/*optional_special_table_loc_clause*/;
                    }
		  $$ = $4;  // actual_table_name
		}
		
	   /* Sequence Generators */
	   | TOK_TABLE '(' TOK_SG_TABLE actual_table_name ')'
	      {
                if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                {
		      $4->setSpecialType(ExtendedQualName::SG_TABLE);
		      $$ = $4;  // actual_table_name
                }
                else
                  { yyerror(""); YYERROR; /*internal syntax only!*/}
              }

	   /* Hbase Mapped tables */
	   | TOK_TABLE '(' TOK_HBMAP_TABLE actual_table_name ')'
	      {
                $4->setSpecialType(ExtendedQualName::HBMAP_TABLE);
                $$ = $4;  // actual_table_name
              }
		
exception_table_name :  TOK_EXCEPTION TOK_TABLE actual_table_name 
		{
		  $3->setSpecialType(ExtendedQualName::EXCEPTION_TABLE);
		  $$ = $3;  // actual_table_name
		}	
		
/* type PartitionClause */
optional_special_table_loc_clause : empty
                  {
                    $$ = NULL;
                  }
           | ',' special_table_loc_clause
                  {
		    $$ = $2;
		  }

/* type int64 */
optional_special_utility_open_clause : empty
                  {
                    $$ = -1;
                  }
               | TOK_OPEN NUMERIC_LITERAL_EXACT_NO_SCALE
                 {
                   // assuming here SQL/MX Utility will 
		   // always pass a valid Int64 value (correct
                   // number of digits)
		   $$ = atoInt64($2->data()); 
		   delete $2;

                 }

/* type boolean */
optional_with_shared_access_clause : empty
                  {
                    $$ = FALSE;
                  }
               | TOK_WITH TOK_SHARED TOK_ACCESS
                  {
		    $$ = TRUE;
                  }

/* type PartitionClause */
special_table_loc_clause : TOK_LOCATION fully_expanded_guardian_loc_name
                  {
		    $$ = new (PARSERHEAP()) PartitionClause(PARSERHEAP());
		    $$->setLocationName(*$2); // fully_expanded_guardian_loc_name
                  }
		  | TOK_PARTITION partition_name
                  {
                     $$ = new (PARSERHEAP()) PartitionClause(*$2, PARSERHEAP());
		     delete $2;
                  }
		  | TOK_PARTITION TOK_NAME partition_name
		   {
                     $$ = new (PARSERHEAP()) PartitionClause(*$3, PARSERHEAP());
		     delete $3;
                  }
		  |  TOK_PARTITION TOK_NUMBER NUMERIC_LITERAL_EXACT_NO_SCALE
		  {
		     Int32 partNum = (Int32)atoi(*$3);
		     if (partNum < 0)
		      YYERROR;

                     $$ = new (PARSERHEAP()) PartitionClause(partNum, PARSERHEAP());
		     delete $3;
                  }
		  |  TOK_PARTITION TOK_NUMBER TOK_FROM NUMERIC_LITERAL_EXACT_NO_SCALE TOK_TO NUMERIC_LITERAL_EXACT_NO_SCALE
		  {
		    Int32 beginPartNum = (Int32)atoi(*$4);
		    if (beginPartNum <= 0)
		      YYERROR;
		    Int32 endPartNum = (Int32)atoi(*$6);
		    if (endPartNum <= 0)
		      YYERROR;
		    
		    if (beginPartNum > endPartNum)
		      YYERROR;
		    
		    $$ = new (PARSERHEAP()) 
		      PartitionClause(beginPartNum, endPartNum,
				      PARSERHEAP());
		    delete $4;
		    delete $6;
                  }
		  |  TOK_PARTITION TOK_NUMBER TOK_FROM NUMERIC_LITERAL_EXACT_NO_SCALE 
		  {
		    Int32 beginPartNum = (Int32)atoi(*$4);
		    if (beginPartNum <= 0)
		      YYERROR;
		    
		    $$ = new (PARSERHEAP()) 
		      PartitionClause(beginPartNum, -1,
				      PARSERHEAP());
		    delete $4;
                  }
		  |  TOK_PARTITION TOK_NUMBER TOK_TO NUMERIC_LITERAL_EXACT_NO_SCALE 
		  {
		    Int32 beginPartNum = -1;
		    Int32 endPartNum = (Int32)atoi(*$4);
		    if (endPartNum <= 0)
		      YYERROR;
		    
		    $$ = new (PARSERHEAP()) 
		      PartitionClause(-1, endPartNum,
				      PARSERHEAP());
		    delete $4;
                  }


/* type stringval */
fully_expanded_guardian_loc_name : guardian_location_name
                  {
                    ComLocationName locName(*$1,
                      ComLocationName::GUARDIAN_LOCATION_NAME_FORMAT);
                    if (NOT locName.isValid())
                      // The format of the specified location name
                      // $0~string0 is invalid.
                      *SqlParser_Diags << DgSqlCode(-3061)
                        << DgString0($1->data());
                    else  // valid location specified
                      *$1 = locName.
                            getGuardianFullyQualifiedName();
                    $1->toUpper();
                    $$ = $1;
                  }

/* type corrName */
actual_table_name : qualified_name  
		  {
		     // helps with computing view text
		     //
		     ParInsertNameLoc($1->getPosition(), $1->getNameLength());
		     //
		     // note that corrNameFromStrings()
		     // contains code that deletes $1
		     //
		     $$ = corrNameFromStrings($1);
		     if ($$ == NULL) YYABORT;

                     //ct-bug-10-030102-3803 -Begin
                     NAString *tmpName = new (PARSERHEAP()) NAString((""),PARSERHEAP()); 
                     NAString *tmp =new (PARSERHEAP()) NAString(( $$->getQualifiedNameObj().getCatalogName()),PARSERHEAP());
                     if(! (tmp->isNull()))
                     {
                       conditionalDelimit(*tmpName,*tmp);
                       tmpName->append(".",1);
                     }
                     tmp =new (PARSERHEAP()) NAString(( $$->getQualifiedNameObj().getSchemaName()),PARSERHEAP());
                     if(! (tmp->isNull()))
                     {
                       conditionalDelimit(*tmpName,*tmp);
                       tmpName->append(".",1);
                     }
                     tmp =new (PARSERHEAP()) NAString(( $$->getQualifiedNameObj().getObjectName()),PARSERHEAP());
                     if(! (tmp->isNull()))
                       conditionalDelimit(*tmpName,*tmp);
                     $$->setUgivenName(*tmpName);
                    //ct-bug-10-030102-3803 End
		  }
              | '=' identifier
                                {
                                  NAString *defineName =
				    new (PARSERHEAP()) NAString('=', PARSERHEAP());
				  defineName->append($2->data(), $2->length());
                                  delete $2;

				  HostVar *vvX = new (PARSERHEAP()) 
				    HostVar(*defineName, new (PARSERHEAP()) 
				      SQLChar(
				        PARSERHEAP(), ComAnsiNamePart::MAX_IDENTIFIER_EXT_LEN));
				  vvX->setIsDefine();
                                  $$ = new (PARSERHEAP())
				    CorrName("envVar$", 
                                             PARSERHEAP(),
					     vvX->getName(),  // debugging ease
					     "$bogus");
                                  assert($$);
				  $$->setPrototype(vvX);
                                  //ct-bug-10-030102-3803 -Begin
                                  NAString *tmpName =
				    new (PARSERHEAP()) NAString(vvX->getName(), PARSERHEAP());
                                  $$->setUgivenName(*tmpName);
                                  //ct-bug-10-030102-3803 -End
                                }

              | hostvar_and_prototype
                                {
                                  // don't delete hostvar because it's also
                                  // referenced from AllHostVars
				  HostVar *vv = (HostVar *)$1;
                                  $$ = new (PARSERHEAP())
				    CorrName("HostVar$", 
                                             PARSERHEAP(),
					     vv->getName(),   // debugging ease
					     "$bogus");
                                  assert($$);
				  $$->setPrototype(vv);
                                  //ct-bug-10-030102-3803 -Begin
                                  NAString *tmpName =
				    new (PARSERHEAP()) NAString(vv->getPrototypeValue(), PARSERHEAP());
                                  $$->setUgivenName(*tmpName);
                                  //ct-bug-10-030102-3803 -End
                                  //
                                  // does not support computing view text yet
                                }

              | param_and_prototype
                                {
                                  // don't delete hostvar because it's also
                                  // referenced from AllHostVars
				  HostVar *vv = (HostVar *)$1;
                                  $$ = new (PARSERHEAP())
				    CorrName("HostVar$", 
                                             PARSERHEAP(),
					     vv->getName(),   // debugging ease
					     "$bogus");
                                  assert($$);
				  $$->setPrototype(vv);
                                  //ct-bug-10-030102-3803 -Begin
                                  NAString *tmpName =
				    new (PARSERHEAP()) NAString(vv->getPrototypeValue(), PARSERHEAP());
                                  $$->setUgivenName(*tmpName);
                                  //ct-bug-10-030102-3803 -End
                                  //
                                  // does not support computing view text yet
                                }

/* type corrName */
actual_routine_name : qualified_name
                  {
		     $$ = corrNameFromStrings($1);
		     if ($$ == NULL) YYABORT;
		  }

/* type corrName */
actual_routine_action_name : routine_action_name
		  {
		     $$ = corrNameFromStrings($1);
		     if ($$ == NULL) YYABORT;
		     $$->getQualifiedNameObj().setObjectNameSpace(COM_UUDF_ACTION_NAME);
		  }

/* 100% identical to "actual_table_name", actual_table_name2 is provided only
 * for use in the "select_list_item" productions.  By doing so, it
 * provides a way to get around a reduce/reduce problem that would
 * otherwise occur.  Our Yacc has certain kinds of lookahead, you see....
 * and not others!
 */

/* type corrName */
actual_table_name2 : qualified_name
		  {
		     // helps with computing view text
		     //
		     ParInsertNameLoc($1->getPosition(), $1->getNameLength());
		     //
		     // note that corrNameFromStrings()
		     // contains code that deletes $1
		     //
		     $$ = corrNameFromStrings($1);
		     if ($$ == NULL) YYABORT;
                     //ct-bug-10-030102-3803 -Begin
                     NAString *tmpName = new (PARSERHEAP()) NAString((""),PARSERHEAP()); 
                     NAString *tmp =new (PARSERHEAP()) NAString(( $$->getQualifiedNameObj().getCatalogName()),PARSERHEAP());
                     if(! (tmp->isNull()))
                     {
                       conditionalDelimit(*tmpName,*tmp);
                       tmpName->append(".",1);
                     }
                     tmp =new (PARSERHEAP()) NAString(( $$->getQualifiedNameObj().getSchemaName()),PARSERHEAP());
                     if(! (tmp->isNull()))
                     {
                       conditionalDelimit(*tmpName,*tmp);
                       tmpName->append(".",1);
                     }
                     tmp =new (PARSERHEAP()) NAString(( $$->getQualifiedNameObj().getObjectName()),PARSERHEAP());
                     if(! (tmp->isNull()))
                       conditionalDelimit(*tmpName,*tmp);
                     $$->setUgivenName(*tmpName);
                     //ct-bug-10-030102-3803 End
		  }
| hostvar_and_prototype
{
                                  // don't delete hostvar because it's also
                                  // referenced from AllHostVars
				  HostVar *vv = (HostVar *)$1;
                                  $$ = new (PARSERHEAP())
				    CorrName("HostVar$", 
                                             PARSERHEAP(),
					     vv->getName(),   // debugging ease
					     "$bogus");
                                  assert($$);
				  $$->setPrototype(vv);
                                  //ct-bug-10-030102-3803 -Begin
                                  NAString *tmpName =
				    new (PARSERHEAP()) NAString(vv->getPrototypeValue(), PARSERHEAP());
                                  $$->setUgivenName(*tmpName);
                                  //ct-bug-10-030102-3803 -End
                                  //
                                  // does not support computing view text yet
                                }

/* type stringval */
//host_identifier : IDENTIFIER  // This allows C/C++ identifiers, a
                                // superset of Fortran ones, and COBOL words.
                                // We need to allow other funny host-language
                                // characters ('-' Cobol, '&' Mumps, ...).

/* type stringval */
identifier : regular_identifier
				{
				   $$=$1;
				   if ( ($$==NULL) || transformIdentifier(*$$)) YYERROR;
				}
              | DELIMITED_IDENTIFIER
				{
                                  $$=$1;
                                  if ( ($$==NULL) || transformIdentifier(*$$)) YYERROR;
				}
              | BACKQUOTED_IDENTIFIER
				{
                                  if (NOT SqlParser_CurrentParser->hiveDDLInfo_->checkForDDL_)
                                    {
                                      yyerror(""); 
                                      YYERROR;
                                    }

                                  $$=$1;
                                  if ( ($$==NULL) || transformIdentifier(*$$)) YYERROR;

                                  SqlParser_CurrentParser->hiveDDLInfo_->backquotedDelimFound_ = TRUE;

				}

/* type stringval */
// Delimited identifiers of this type may contain circumflex ("^") characters
identifier_with_hat : regular_identifier
				{
				   $$=$1;
				   if ( ($$==NULL) || transformIdentifier(*$$, TRUE, FALSE)) YYERROR;
				}
              | DELIMITED_IDENTIFIER
				{
				   $$=$1;
				   if ( ($$==NULL) || transformIdentifier(*$$, TRUE, TRUE)) YYERROR;
				}

/* type stringval */
// Delimited identifiers of routine actions may contain dollar sign ("$") characters
identifier_with_dollar : regular_identifier
				{
				   $$=$1;
				   if ( ($$==NULL) || transformIdentifier(*$$)) YYERROR;
				}
              | DELIMITED_IDENTIFIER
				{
				   $$=$1;
				   if ( ($$==NULL) || transformIdentifier(*$$, TRUE/*upCase - n/a to delim ident*/, FALSE/*^ ok?*/, NASTRING_DELIM_IDENT_WITH_DOLLAR_PREFIX) ) YYERROR;
				}

/* type stringval */
regular_identifier : IDENTIFIER
             | nonreserved_word
                {
                  // On the old  platform,
                  // This identifier string needs to be converted back to
                  // ISO88591 because it may be passed to catman code to
                  // determine if the named object exists. When catman 
                  // becomes Unicode-enabled, this ISO88591 conversion
                  // can go away. This comment also applies to other 
                  // unicodeToChar() call sites here & elsewhere.
                  //
                  // On SeaQuest Linux and Windows NT platforms,
                  // convert this identifier from UCS2/UTF16 to UTF8.
                  $$ = unicodeToChar
                    (ToTokvalPlusYYText(&$1)->yytext,
                     ToTokvalPlusYYText(&$1)->yyleng,
                     (CharInfo::CharSet) (
                                          ComGetNameInterfaceCharSet() // CharInfo::UTF8
                                          ),
                     PARSERHEAP());
				  // Do not toUpper here; let the enclosing
				  // production decide whether transformIdent
				  // should upcase it or not.
				  //$$->toUpper();
                }
             | nonreserved_func_word
                {
                  // Process the same as a nonreserved_word here.
                  $$ = unicodeToChar
                    (ToTokvalPlusYYText(&$1)->yytext,
                     ToTokvalPlusYYText(&$1)->yyleng,
                     (CharInfo::CharSet) (
                                          ComGetNameInterfaceCharSet()
                                          ),
                     PARSERHEAP());
                }
             | MP_nonreserved_word
                {
                  $$ = unicodeToChar
                    (ToTokvalPlusYYText(&$1)->yytext,
                     ToTokvalPlusYYText(&$1)->yyleng,
                     (CharInfo::CharSet) (
                                          ComGetNameInterfaceCharSet()
                                          ),
                     PARSERHEAP());
                }
             | MP_nonreserved_func_word
                {
                  $$ = unicodeToChar
                    (ToTokvalPlusYYText(&$1)->yytext,
                     ToTokvalPlusYYText(&$1)->yyleng,
                     (CharInfo::CharSet) (
                                          ComGetNameInterfaceCharSet()
                                          ),
                     PARSERHEAP());
                }
             | nonreserved_datatype
                {
                  $$ = unicodeToChar
                    (ToTokvalPlusYYText(&$1)->yytext,
                     ToTokvalPlusYYText(&$1)->yyleng,
                     (CharInfo::CharSet) (
                                          ComGetNameInterfaceCharSet()
                                          ),
                     PARSERHEAP());
                }


regular_identifier_not_builtin : IDENTIFIER
             | nonreserved_word
                {
                  // This identifier string needs to be converted back to
                  // ISO88591 because it may be passed to catman code to
                  // determine if the named object exists. When catman 
                  // becomes Unicode-enabled, this ISO88591 conversion
                  // can go away. This comment also applies to other 
                  // unicodeToChar() call sites here & elsewhere.
                  $$ = unicodeToChar
                    (ToTokvalPlusYYText(&$1)->yytext,
                     ToTokvalPlusYYText(&$1)->yyleng,
                     (CharInfo::CharSet) (
                                          ComGetNameInterfaceCharSet()
                                          ),
                     PARSERHEAP());
				  // Do not toUpper here; let the enclosing
				  // production decide whether transformIdent
				  // should upcase it or not.
				  //$$->toUpper();
                }
             | MP_nonreserved_word
                {
                  $$ = unicodeToChar
                    (ToTokvalPlusYYText(&$1)->yytext,
                     ToTokvalPlusYYText(&$1)->yyleng,
                     (CharInfo::CharSet) (
                                          ComGetNameInterfaceCharSet()
                                          ),
                     PARSERHEAP());
                }
             | nonreserved_datatype
                {
                  $$ = unicodeToChar
                    (ToTokvalPlusYYText(&$1)->yytext,
                     ToTokvalPlusYYText(&$1)->yyleng,
                     (CharInfo::CharSet) (
                                          ComGetNameInterfaceCharSet()
                                          ),
                     PARSERHEAP());
               }


/* type strSeq */
qualified_name : identifier
                {
                  ShortStringSequence *strseq =
                  new (PARSERHEAP()) ShortStringSequence($1);
                  if (! strseq->isValid()) YYABORT;
                  $$ = strseq;
                }
                | qualified_name '.' identifier
                {
                  if (Get_SqlParser_Flags(PARSING_IUS_WHERE_CLAUSE))
                    {
                      *SqlParser_Diags << DgSqlCode(-9237) << DgString0("qualified column name");
                      YYERROR;
                    }
                  $1->append($3);
                  if (! $1->isValid()) 
                    YYABORT;

                  $$ = $1;
                }

/* type strSeq */
// A module name is different from other types of ANSI names in that the
// object name part can contain circumflex ("^") characters
module_name : identifier_with_hat
			       {
				   ShortStringSequence *strseq =
				     new (PARSERHEAP()) ShortStringSequence($1);
				   if (! strseq->isValid()) YYABORT;
				   $$ = strseq;
			       }
              | qualified_name '.' identifier_with_hat
			       {
				   $1->append($3);
				   if (! $1->isValid()) YYABORT;
				   $$ = $1;
			       }

/* type strSeq */
// A routine action name is different from other types of ANSI names in that the
// object name part can contain dollar sign ("$") characters
routine_action_name : identifier_with_dollar
			       {
				   ShortStringSequence *strseq =
				     new (PARSERHEAP()) ShortStringSequence
				     ( $1 // identifier_with_dollar
				     , ( NASTRING_REGULAR_IDENT_WITH_DOLLAR_PREFIX |
				         NASTRING_DELIM_IDENT_WITH_DOLLAR_PREFIX )
				     );
				   if (! strseq->isValid()) YYABORT;
				   $$ = strseq;
			       }
              | qualified_name '.' identifier_with_dollar
			       {
				   $1->toInternalIdentifierFlags_ |=
				     ( NASTRING_REGULAR_IDENT_WITH_DOLLAR_PREFIX |
				       NASTRING_DELIM_IDENT_WITH_DOLLAR_PREFIX );
				   $1->append($3);
				   if (! $1->isValid()) YYABORT;
				   $$ = $1;
			       }

/* type stringval */
correlation_name : identifier

/* type relx */
table_as_procedure : 
TOK_TABLE '(' TOK_INTERNALSP '(' character_string_literal ')' ')'
{
  // DEFAULT_CHARSET has no effect on character_string_literal in this context
  $$ = new(PARSERHEAP())RelInternalSP(*$5, 0, REL_INTERNALSP, PARSERHEAP(), getTdmispArkcmpInfo(*$5));
  delete $5;  
}

| TOK_TABLE '(' TOK_INTERNALSP '(' character_string_literal ',' value_expression_list ')' ')'
{
  // DEFAULT_CHARSET has no effect on character_string_literal in this context
  $$=new(PARSERHEAP())RelInternalSP(*$5, $7, REL_INTERNALSP, PARSERHEAP(), getTdmispArkcmpInfo(*$5));
  delete $5;				  
}

| TOK_TABLE '(' proc_identifier '(' value_expression_list ')' ')'
				{
				  if ($3 == REL_EXPLAIN) {
				    $$ = new (PARSERHEAP()) ExplainFunc($5);
				  }
				  else if ($3 == REL_STATISTICS) {
				    $$ = new (PARSERHEAP()) StatisticsFunc($5);
				  }
				}
| TOK_TABLE '(' TOK_HIVEMD '(' hivemd_identifier ')' ')'
				{
                                  $$ = new (PARSERHEAP()) HiveMDaccessFunc($5);
				}
| TOK_TABLE '(' TOK_HIVEMD '(' hivemd_identifier ',' identifier ')' ')'
				{
                                  $$ = new (PARSERHEAP()) HiveMDaccessFunc($5, $7);
				}
| TOK_TABLE '(' TOK_HIVEMD '(' hivemd_identifier ',' identifier ',' identifier ')' ')'
				{
                                  $$ = new (PARSERHEAP()) HiveMDaccessFunc($5, $7, $9);
				}

| TOK_TABLE '(' TOK_QUERY_CACHE '(' value_expression_list ')' ')'
  {
    $$ = new (PARSERHEAP()) RelInternalSP("QUERYCACHE"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }
| TOK_TABLE '(' TOK_QUERY_CACHE_ENTRIES '(' value_expression_list ')' ')'
  {
    $$ =  new (PARSERHEAP()) RelInternalSP( "QUERYCACHEENTRIES"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }
|TOK_TABLE '(' TOK_HYBRID_QUERY_CACHE '(' value_expression_list ')' ')'
  {
      $$ =  new (PARSERHEAP()) RelInternalSP( "HYBRIDQUERYCACHE"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }
|TOK_TABLE '(' TOK_HYBRID_QUERY_CACHE_ENTRIES '(' value_expression_list ')' ')'
  {
      $$ =  new (PARSERHEAP()) RelInternalSP( "HYBRIDQUERYCACHEENTRIES"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }
| TOK_TABLE '(' TOK_CATMAN_CACHE '(' ')' ')'
  {
    $$ = new (PARSERHEAP()) RelInternalSP("CATMANCACHE"
                                          , 0
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }
| TOK_TABLE '(' TOK_NATABLE_CACHE '(' value_expression_list ')' ')'
  {
    $$ = new (PARSERHEAP()) RelInternalSP("NATABLECACHE"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }
| TOK_TABLE '(' TOK_NATABLE_CACHE_ENTRIES '(' value_expression_list ')' ')'
  {
    $$ =  new (PARSERHEAP()) RelInternalSP( "NATABLECACHEENTRIES"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }
| TOK_TABLE '(' TOK_NAROUTINE_CACHE '(' value_expression_list ')' ')'
  {
    $$ = new (PARSERHEAP()) RelInternalSP("NAROUTINECACHE"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }
| TOK_TABLE '(' TOK_NAROUTINE_ACTION_CACHE '(' value_expression_list ')' ')'
  {
    $$ = new (PARSERHEAP()) RelInternalSP("NAROUTINEACTIONCACHE"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }
| TOK_TABLE '(' TOK_VERSION_INFO '(' value_expression_list ')' ')'
  {
    $$ =  new (PARSERHEAP()) RelInternalSP( "VERSION_INFO"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp | 
                                            RelInternalSP::suppressDefaultSchema | 
                                            RelInternalSP::requiresTMFTransaction);
  }
| TOK_TABLE '(' TOK_RELATEDNESS '(' value_expression_list ')' ')'
  {
    $$ =  new (PARSERHEAP()) RelInternalSP( "RELATEDNESS"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp | 
                                            RelInternalSP::suppressDefaultSchema | 
                                            RelInternalSP::requiresTMFTransaction);
  }
| TOK_TABLE '(' TOK_FEATURE_VERSION_INFO '(' value_expression_list ')' ')'
  {
    $$ =  new (PARSERHEAP()) RelInternalSP( "FEATURE_VERSION_INFO"
                                          , $5
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp | 
                                            RelInternalSP::suppressDefaultSchema | 
                                            RelInternalSP::requiresTMFTransaction);
  }
| sp_proxy_stmt_prefix '(' proxy_columns ')' ')'
  {
    $$ =  new (PARSERHEAP()) SPProxyFunc($3, NULL, PARSERHEAP());
    inRSProxyStmt = FALSE;
  }
| sp_proxy_stmt_prefix '(' proxy_columns ',' spproxy_string_list ')' ')'
  {
    $$ =  new (PARSERHEAP()) SPProxyFunc($3, $5, PARSERHEAP());
    inRSProxyStmt = FALSE;
  }
| TOK_TABLE '(' TOK_EXTRACT_SOURCE '(' extract_type ',' QUOTED_STRING ','
                                       QUOTED_STRING ','
                                       proxy_columns ')' ')'
  {
    // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context

    if (CmpCommon::getDefault(IS_DB_TRANSPORTER) == DF_OFF)
      YYERROR;

    NAString &espPhandle = *$7;
    NAString &securityKey = *$9;
    ElemDDLNode *columns = $11;
    TrimNAStringSpace(espPhandle);
    TrimNAStringSpace(securityKey);
    $$ = new (PARSERHEAP()) ExtractSource(columns, espPhandle, securityKey,
                                          PARSERHEAP());
  }
| TOK_TABLE '(' TOK_LOB QUOTED_STRING ')'
  {
    ConstValue * handle = new(PARSERHEAP()) ConstValue(*$4);

    ExeUtilLobExtract * lle =
      new (PARSERHEAP ()) ExeUtilLobExtract
      (handle, 
       ExeUtilLobExtract::TO_STRING_,
       0, 0, 0, 0);

    $$ = lle;
  }
| TOK_TABLE '(' TOK_CLUSTER stats_or_statistics '(' ')' ')'
  {
    $$ = new (PARSERHEAP()) 
      ExeUtilRegionStats(CorrName(""), FALSE, FALSE, FALSE, TRUE, NULL, PARSERHEAP());
  }
| TOK_TABLE '(' TOK_REGION stats_or_statistics '(' ')' ')'
  {
    $$ = new (PARSERHEAP()) 
      ExeUtilRegionStats(CorrName(""), FALSE, FALSE, FALSE, FALSE, NULL, PARSERHEAP());
  }
| TOK_TABLE '(' TOK_REGION stats_or_statistics '(' table_name ')' ')'
  {
    $$ = new (PARSERHEAP()) 
      ExeUtilRegionStats(*$6, FALSE, FALSE, FALSE, FALSE, NULL, PARSERHEAP());
  }
| TOK_TABLE '(' TOK_REGION stats_or_statistics '(' TOK_INDEX table_name ')' ')'
  {
    $7->setSpecialType(ExtendedQualName::INDEX_TABLE);
    $$ = new (PARSERHEAP()) 
      ExeUtilRegionStats(*$7, FALSE, TRUE, FALSE, FALSE, NULL, PARSERHEAP());
  }
| TOK_TABLE '(' TOK_LOB stats_or_statistics '(' ')' ')'
  {
    $$ = new (PARSERHEAP()) 
      ExeUtilLobInfo(CorrName(""), TRUE,  NULL, PARSERHEAP());
  }
| TOK_TABLE '(' TOK_LOB stats_or_statistics '(' table_name ')' ')'
  {
    $$ = new (PARSERHEAP()) 
      ExeUtilLobInfo(*$6, TRUE,  NULL, PARSERHEAP());
  }
| TOK_TABLE '(' TOK_REGION stats_or_statistics '(' TOK_USING rel_subquery ')' ')'
  {
    $$ = new (PARSERHEAP()) 
      ExeUtilRegionStats(CorrName("DUMMY"), FALSE, FALSE, FALSE, FALSE, $7, PARSERHEAP());
  }

hivemd_identifier : 
                    TOK_ALIAS { $$ = new (PARSERHEAP()) NAString("ALIAS"); }
                  | TOK_COLUMNS { $$ = new (PARSERHEAP()) NAString("COLUMNS"); }
                  | TOK_PRIMARY TOK_KEY { $$ = new (PARSERHEAP()) NAString("PKEYS"); }
                  | TOK_FOREIGN TOK_KEY { $$ = new (PARSERHEAP()) NAString("FKEYS"); }
                  | TOK_SYNONYMS { $$ = new (PARSERHEAP()) NAString("SYNONYMS"); }
                  | TOK_TABLES   { $$ = new (PARSERHEAP()) NAString("TABLES"); }
                  | TOK_VIEWS    { $$ = new (PARSERHEAP()) NAString("VIEWS"); }
                  | TOK_SYSTEM TOK_TABLES { $$ = new (PARSERHEAP()) NAString("SYSTEM_TABLES"); }
                  | TOK_SCHEMAS { $$ = new (PARSERHEAP()) NAString("SCHEMAS"); }

/* type boolean */
sp_proxy_stmt_prefix : TOK_TABLE '(' TOK_SP_RESULT_SET 
{
   beginRSProxyStmtParsing();
   $$ = TRUE;
}

/* type extractType */
extract_type : QUOTED_STRING
{
  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
  NAString &token = *$1;
  TrimNAStringSpace(token);

  // Right now we are enforcing that the literal must be a
  // single-quoted 'ESP' otherwise we report a parse error.
  if (token.compareTo("ESP", NAString::ignoreCase) == 0)
    $$ = ExtractSource::ESP;
  else
    YYERROR;
}

/* type pElemDDL */
proxy_column : qualified_name data_type optional_column_attributes
               {
                 ShortStringSequence *seq = (ShortStringSequence *) $1;
                 UInt32 numParts = seq->numParts();
                 
                 if (numParts != 1 && numParts != 4)
                   YYABORT;
                 
                 NAString *colName = seq->extract(numParts - 1);
                 
                 QualifiedName *tblName = NULL;
                 if (numParts == 4)
                 {
                   tblName = new (PARSERHEAP())
                     QualifiedName(*(seq->extract(2)),
                                   *(seq->extract(1)),
                                   *(seq->extract(0)),
                                   PARSERHEAP(),
                                   0);
                 }
                 
                 $$ = new (PARSERHEAP())
                   ElemProxyColDef(tblName  /* optional table name */,
                                   *colName /* 1-part column name */,
                                   $2       /* data type */,
                                   $3       /* column attributes */,
                                   PARSERHEAP());
               }

/* type pElemDDL */
proxy_columns : proxy_column
              | proxy_columns ',' proxy_column
                {
                  $$ = new (PARSERHEAP()) ElemDDLList($1, $3);
                }

/* type item */
spproxy_string : QUOTED_STRING
                 {
                   // DEFAULT_CHARSET setting has no effect
                   const NAString &s = *$1;
                   $$ = new (PARSERHEAP()) ConstValue(s);
                 }

/*type itemList */
spproxy_string_list : spproxy_string
                      {
                        ItemExprList *l = new (PARSERHEAP())
                          ItemExprList(PARSERHEAP());
                        l->insert($1);
                        $$ = l;
                      }
                    | spproxy_string_list ',' spproxy_string
                      {
                        ((ItemExprList *)$1)->insert($3);
                        $$ = $1;
                      }

/* type relx  */

//QSTUFF
table_as_stream_any   : table_as_stream | 
                        table_as_stream TOK_AFTER TOK_LAST TOK_ROW 
                        {
				((RelExpr *)$$)->getGroupAttr()->setSkipInitialScan(TRUE);				
                        }

table_as_stream : TOK_STREAM '(' table_name optimizer_hint ')'
			{
                           if (in3GL_ > 0)
                           {
                             *SqlParser_Diags << DgSqlCode(-3180);
                             YYERROR;
                           }
                           // Streams are not supported in MVs
                           if(WeAreInACreateMVStatement == TRUE)
                           {
                             *SqlParser_Diags << DgSqlCode(-12065);
                             YYABORT;
                           }
                           $$ = new(PARSERHEAP())Scan(*$3,TRUE);
                           $$->getGroupAttr()->setStream(TRUE);
                           if ($4)
                             $$->setHint($4);
                           delete $3;
			}
//QSTUFF

/* type operator_type */
proc_identifier : TOK_EXPLAIN
                           {
			     $$ = REL_EXPLAIN;
			   }
                     | TOK_STATISTICS
                          {
			    $$ = REL_STATISTICS;
			  }

/* type item */
rowset_input_host_variable: hostvar_expression
{
  TheHostVarRoles->setLastUnassignedTo(HV_IS_INPUT);
  $$ = $1;
}

/* type item */
rowset_input_host_variable_list : rowset_input_host_variable
   {
     // A Null Terminated list
     $$ = new (PARSERHEAP()) ItemList( $1, NULL);
   }
|  rowset_input_host_variable ',' rowset_input_host_variable_list
   {
     $$ = new (PARSERHEAP()) ItemList( $1, $3 );
   }

/* type item */
rowset_size: unsigned_integer
   {
     $$ = new (PARSERHEAP()) ConstValue($1);
   }
| simple_host_variable
   {
     TheHostVarRoles->setLastUnassignedTo(HV_IS_INPUT);
     $$ = $1;
   }
| dynamic_parameter
   

/* type relx */
rowset_derived_table :
TOK_ROWSET '(' rowset_input_host_variable_list ')'
       {
         $$ = new (PARSERHEAP()) Rowset($3);
       }
| TOK_ROWSET '(' rowset_input_host_variable_list ')' rowset_index
       {
         $$ = new (PARSERHEAP()) Rowset($3, $5);
       }
| TOK_ROWSET rowset_size '(' rowset_input_host_variable_list ')'
       {
         $$ = new (PARSERHEAP()) Rowset($4, NULL, $2);
       }
| TOK_ROWSET rowset_size '(' rowset_input_host_variable_list ')' rowset_index
       {
         $$ = new (PARSERHEAP()) Rowset($4, $6, $2);
       }

/* type boolean */
global_hint : empty { $$ = FALSE; }
    | TOK_BEGIN_HINT TOK_ORDERED TOK_END_HINT 
      { $$ = TRUE; QueryAnalysis::Instance()->setJoinOrderByUser(); }

/* type hbaseAccessOptions */
hbase_access_options : empty 
       {
         Lng32 n = CmpCommon::getDefaultNumeric(TRAF_NUM_HBASE_VERSIONS);
         if (n == -1)
           $$ = new (PARSERHEAP()) HbaseAccessOptions(-1, PARSERHEAP());
         else if (n == -2)
           $$ = new (PARSERHEAP()) HbaseAccessOptions(-2, PARSERHEAP());
         else if (n > 1)
           $$ = new (PARSERHEAP()) HbaseAccessOptions(n, PARSERHEAP());
         else
           $$ = NULL; 
       }
    | '{' TOK_VERSIONS NUMERIC_LITERAL_EXACT_NO_SCALE '}'
      {
        Int64 value = atoInt64($3->data()); 
        if (value <= 0)
          YYERROR;

        if (value > 1)
          $$ = new (PARSERHEAP()) HbaseAccessOptions(value, PARSERHEAP());
        else
          $$ = NULL;
      }
    | '{' TOK_VERSIONS TOK_MAX '}'
      {
        $$ = new (PARSERHEAP()) HbaseAccessOptions(-1, PARSERHEAP());
      }
    | '{' TOK_VERSIONS TOK_ALL '}'
      {
        $$ = new (PARSERHEAP()) HbaseAccessOptions(-2, PARSERHEAP());
      }

/* type hint */
optimizer_hint : empty { $$ = NULL; }
    | TOK_BEGIN_HINT hints TOK_END_HINT { $$ = $2; }

/* type hint */
hints : TOK_CARDINALITY number
      { $$ = new (PARSERHEAP()) Hint(PARSERHEAP()); $$->setCardinality($2); }
    | TOK_INDEX index_hints { $$ = $2; }
    | TOK_SELECTIVITY number 
      { $$ = new (PARSERHEAP()) Hint($2, PARSERHEAP()); }
    | TOK_CARDINALITY number TOK_BITOR_OPERATOR TOK_INDEX index_hints
      { $$ = $5->setCardinality($2); }
    | TOK_CARDINALITY number TOK_BITOR_OPERATOR TOK_SELECTIVITY number
      { $$ = new (PARSERHEAP()) Hint($2, $5, PARSERHEAP()); }
    | TOK_INDEX index_hints TOK_BITOR_OPERATOR TOK_CARDINALITY number
      { $$ = $2->setCardinality($5); }
    | TOK_INDEX index_hints TOK_BITOR_OPERATOR TOK_SELECTIVITY number
      { $$ = $2->setSelectivity($5); }
    | TOK_SELECTIVITY number TOK_BITOR_OPERATOR TOK_INDEX index_hints
      { $$ = $5->setSelectivity($2); }
    | TOK_SELECTIVITY number TOK_BITOR_OPERATOR TOK_CARDINALITY number
      { $$ = new (PARSERHEAP()) Hint($5, $2, PARSERHEAP()); }
    | TOK_CARDINALITY number TOK_BITOR_OPERATOR TOK_INDEX index_hints 
      TOK_BITOR_OPERATOR TOK_SELECTIVITY number
      { $$ = $5->setCardinality($2); $$->setSelectivity($8); }
    | TOK_CARDINALITY number TOK_BITOR_OPERATOR TOK_SELECTIVITY number 
      TOK_BITOR_OPERATOR TOK_INDEX index_hints
      { $$ = $8->setCardinality($2); $$->setSelectivity($5); }
    | TOK_INDEX index_hints TOK_BITOR_OPERATOR TOK_CARDINALITY number 
      TOK_BITOR_OPERATOR TOK_SELECTIVITY number
      { $$ = $2->setSelectivity($8); $$->setCardinality($5); }
    | TOK_INDEX index_hints TOK_BITOR_OPERATOR TOK_SELECTIVITY number 
      TOK_BITOR_OPERATOR TOK_CARDINALITY number
      { $$ = $2->setSelectivity($5); $$->setCardinality($8); }
    | TOK_SELECTIVITY number TOK_BITOR_OPERATOR TOK_INDEX index_hints 
      TOK_BITOR_OPERATOR TOK_CARDINALITY number
      { $$ = $5->setSelectivity($2); $$->setCardinality($8); }
    | TOK_SELECTIVITY number TOK_BITOR_OPERATOR TOK_CARDINALITY number 
      TOK_BITOR_OPERATOR TOK_INDEX index_hints
      { $$ = $8->setSelectivity($2); $$->setCardinality($5); }

/* type doubleVal */
number : NUMERIC_LITERAL_APPROX 
        { 
          double val; NABoolean singleP, result;
          result = literalToDouble($1, val, singleP);
          delete $1;
          if (!result) {
            YYERROR;
          }
          else {
            $$ = val;
          }
        }
    | NUMERIC_LITERAL_EXACT_WITH_SCALE
        { 
          double val; 
          if (!literalToNumeric($1, val)) {
            YYERROR;
          }
          else {
            $$ = val;
          }
        }

/* type hint */
index_hints : index_hint { $$ = new (PARSERHEAP()) Hint(*$1, PARSERHEAP()); }
    | index_hints ',' index_hint { $$ = $1->addIndexHint(*$3); }

/* type stringval */
index_hint : qualified_name 
      { 
        $$ = new (PARSERHEAP()) NAString
          (qualifiedNameFromStrings($1)->getQualifiedNameAsAnsiString(),
           PARSERHEAP()); 
      }

/* type relx */
table_reference : table_name_and_hint
                  { $$ = $1; }

              | table_as_procedure
              | table_as_procedure as_clause
	                        {
                                  $$ = new (PARSERHEAP())
				    RenameTable($1, *$2);
                                  delete $2;
                                }
              | table_as_procedure as_clause '(' derived_column_list ')'
                                {
                                  $$ = new (PARSERHEAP())
								  RenameTable($1, *$2, $4);
                                  delete $2;
                                }

//QSTUFF
              | table_as_stream_any
              | table_as_stream_any as_clause
	                        {
                                  $$ = new (PARSERHEAP())
                                    RenameTable($1, *$2);
                                  delete $2;
                                }
              | table_as_stream_any as_clause '(' derived_column_list ')'
                                {
                                   $$ = new (PARSERHEAP())
                                     RenameTable($1, *$2, $4);
                                   delete $2;
                                }

              | upd_stmt_w_acc_type_and_as_clause
                { $$ = $1; }

              | upd_stmt_w_acc_type_and_as_clause_col_list
                { $$ = $1; }

              | upd_stmt_w_acc_type_rtn_list_and_as_clause
                { $$ = $1; }

              | upd_stmt_w_acc_type_rtn_list_and_as_clause_col_list
                { $$ = $1; }

              | del_stmt_w_acc_type_and_as_clause
                { $$ = $1; }

              | del_stmt_w_acc_type_and_as_clause_col_list
                { $$ = $1; }

              | del_stmt_w_acc_type_rtn_list_and_as_clause
                { $$ = $1; }

              | del_stmt_w_acc_type_rtn_list_and_as_clause_col_list
                { $$ = $1; }

             | '(' front_of_insert TOK_WITH TOK_MTS TOK_INTO table_name 
                    query_expression ')' as_clause
               {
		 Insert *insert = new (PARSERHEAP())
		   Insert(CorrName(*$6, PARSERHEAP()),
			  NULL,
			  REL_UNARY_INSERT,
			  $7);
		 insert->setInsertType($2);
		 ((GenericUpdate *)insert)->setMtsStatement(TRUE);

		 if (NOT Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
		   {
		     yyerror(""); YYERROR; /*internal syntax only!*/
		   }

		 RelRoot *root = new (PARSERHEAP())
		   RelRoot(insert, REL_ROOT);
		 
		 $$ = new (PARSERHEAP()) RenameTable(root, *$9);
		 delete $6;
	       }

             | '(' front_of_insert TOK_WITH TOK_MTS TOK_INTO table_name 
                   query_expression ')' as_clause '(' derived_column_list ')'
                {
		  Insert *insert = new (PARSERHEAP())
		    Insert(CorrName(*$6, PARSERHEAP()),
			   NULL,
			   REL_UNARY_INSERT,
			   $7);
		  insert->setInsertType($2);
		  ((GenericUpdate *)insert)->setMtsStatement(TRUE);
		 
		 if (NOT Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
		   {
		     yyerror(""); YYERROR; /*internal syntax only!*/
		   }
 
		  RelRoot *root = new (PARSERHEAP())
		    RelRoot(insert, REL_ROOT);
		  
		  $$ = new (PARSERHEAP()) RenameTable(root, *$9, $11);
		  delete $6;
		}

             | '(' Front_Of_Insert Rest_Of_insert_statement ')' as_clause 
               {
                 // Embedded inserts are not supported in MVs
                 if(WeAreInACreateMVStatement == TRUE)
                 {
                   *SqlParser_Diags << DgSqlCode(-12066)
                                    << DgString0("INSERT");
                   YYABORT;
                 }

                 // A cursor on an embedded INSERT is not supported
                 WeAreInAnEmbeddedInsert = TRUE;

                 ((Insert*)$3)->setInsertType($2);

                 //  Embedded INSERT.
                 //  Supports returning the generated Identity column
                 //  back to the user.

                 ((GenericUpdate *)$3)->setMtsStatement(TRUE);

                 // Set this as an embedded insert
                 $3->getGroupAttr()->setEmbeddedIUD(REL_UNARY_INSERT);

                 RelRoot * root = new (PARSERHEAP())
                   RelRoot($3, 
                           TransMode::ACCESS_TYPE_NOT_SPECIFIED_, 
                           LOCK_MODE_NOT_SPECIFIED_, 
                           REL_ROOT);

                 $$ = new (PARSERHEAP()) RenameTable(root, *$5);
                 delete $5;
               }

             | '(' Front_Of_Insert Rest_Of_insert_statement ')' as_clause '(' derived_column_list ')'

               {
                 // Embedded inserts are not supported in MVs
                 if(WeAreInACreateMVStatement == TRUE)
                 {
                   *SqlParser_Diags << DgSqlCode(-12066)
                                    << DgString0("INSERT");
                   YYABORT;
                 }

                 // A cursor on an embedded INSERT is not supported
                 WeAreInAnEmbeddedInsert = TRUE;

                 ((Insert*)$3)->setInsertType($2);

                 //  Embedded INSERT.
                 //  Supports returning the generated Identity column
                 //  back to the user.

		 ((GenericUpdate *)$3)->setMtsStatement(TRUE);
		 
		 // Set this as an embedded insert
		 $3->getGroupAttr()->setEmbeddedIUD(REL_UNARY_INSERT);
		 
		 RelRoot * root = new (PARSERHEAP())
		   RelRoot($3, 
			   TransMode::ACCESS_TYPE_NOT_SPECIFIED_, 
			   LOCK_MODE_NOT_SPECIFIED_, 
			   REL_ROOT);
                 $$ = new (PARSERHEAP())
                    RenameTable(root, *$5, $7);
                 delete $5;
               }

              | table_name_as_clause_and_hint
                { $$ = $1; }

              | table_name_as_clause_hint_and_col_list
                { $$ = $1; }
             | '(' exe_util_get_statistics ')' as_clause '(' derived_column_list ')'
                                {

				  RelRoot *root = new (PARSERHEAP())
				    RelRoot($2, REL_ROOT);

                                  $$ = new (PARSERHEAP())
				    RenameTable(root, *$4, $6);
                                  delete $4;
                                }


             | '(' exe_util_get_metadata_info ')' as_clause '(' derived_column_list ')'
                                {
				  ((ExeUtilGetMetadataInfo *)$2)->setNoHeader(TRUE);

				  RelRoot *root = new (PARSERHEAP())
				    RelRoot($2, REL_ROOT);

                                  $$ = new (PARSERHEAP())
				    RenameTable(root, *$4, $6);
                                  delete $4;
                                }
             | '(' exe_util_get_version_info ')' as_clause '(' derived_column_list ')'
                                {

				  RelRoot *root = new (PARSERHEAP())
				    RelRoot($2, REL_ROOT);

                                  $$ = new (PARSERHEAP())
				    RenameTable(root, *$4, $6);
                                  delete $4;
                                }

             | '(' exe_util_get_uid ')' as_clause '(' derived_column_list ')'
                                {

				  RelRoot *root = new (PARSERHEAP())
				    RelRoot($2, REL_ROOT);

                                  $$ = new (PARSERHEAP())
				    RenameTable(root, *$4, $6);
                                  delete $4;
                                }

              | rel_subquery_and_as_clause
                { $$ = $1; }

              | rel_subquery_as_clause_and_col_list
                { $$ = $1; }

              | rel_subquery
                 {
                   Int64 sqAddr = (Int64)$1;
                   char sqAddrStr[100];
                   str_itoa(sqAddr, sqAddrStr);
                   NAString corrName("X");
                   corrName += sqAddrStr;
                   $$ = new (PARSERHEAP()) RenameTable($1, corrName);
                 }

             | joined_table  /* default action is fine: $$ = $1  */
                                {
                                  $$ = $1;
                                }

             | rowset_derived_table as_clause '(' derived_column_list ')'
                                {
                                  // Part of Rowset. 
                                  // This comment is used to identify 
                                  // location in generated file 
                                  // for debugging purposes
                                  $$ = new (PARSERHEAP())
                                    RenameTable($1, *$2, $4);
                                  delete $2;
                                }

             | table_as_tmudf_function
             | table_as_tmudf_function as_clause
				{
                                  $$=new(PARSERHEAP()) RenameTable($1, *$2);
                                  ((TableMappingUDF*)$1)->setCorrName(*$2);
                                  delete $2;
				 } 
	     | table_as_tmudf_function as_clause '(' derived_column_list ')'
                {
                    $$ = new(PARSERHEAP()) RenameTable($1,*$2,$4);
                    ((TableMappingUDF*)$1)->setCorrName(*$2);
                    delete $2;
                } 
             | TOK_DUAL
              {


                ConstValue * cv = 
                  (ConstValue*)literalOfNumericNoScale(new (PARSERHEAP()) NAString("0", PARSERHEAP()));
                
                Tuple * t = new (PARSERHEAP()) Tuple(cv);
                
                NAString id("x");
                RelRoot * root = new (PARSERHEAP())
                  RelRoot(t, 
                          TransMode::ACCESS_TYPE_NOT_SPECIFIED_, 
                          LOCK_MODE_NOT_SPECIFIED_, 
                          REL_ROOT);
                
                $$ = new (PARSERHEAP()) RenameTable(root, id);
              }

table_as_tmudf_function : TOK_UDF '(' table_mapping_function_invocation ')'
  {
    $$ = $3;
  }

table_name_and_hint : table_name optimizer_hint hbase_access_options
                      {
                        NAString cteName = ((*$1).getQualifiedNameAsString());
                        if(SqlParser_CurrentParser->hasWithDefinition(&cteName) )
                        {
                          RelExpr *re = SqlParser_CurrentParser->getWithDefinition(&cteName);
                          if (CmpCommon::getDefault(CSE_FOR_WITH) == DF_ON)
                            {
                              CommonSubExprRef *cse =
                                new(PARSERHEAP()) CommonSubExprRef(re,cteName);

                              if (!cse->isFirstReference())
                                cse->setChild(0, re->copyTree(PARSERHEAP()));

                              if ($2)
                                cse->setHint($2);
                              if ($3)
                                cse->setHbaseAccessOptions($3);

                              cse->addToCmpStatement(TRUE);
                              $$ = cse;
                            }
                          else
                            $$=re->copyTree(PARSERHEAP());
                          delete $1;
                        }
                        else
                        {
                          $$ = new (PARSERHEAP()) Scan(*$1);
                          if ($2)
                            $$->setHint($2);

                          if ($3)
                            ((Scan*)$$)->setHbaseAccessOptions($3);

                          delete $1;
                        }
                      }

                    | '(' table_name_and_hint ')'
                      {
                        CheckModeSpecial1();
                        $$ = $2;
                      }

upd_stmt_w_acc_type_and_as_clause : '(' update_statement_searched access_type ')' as_clause
					 {
                                           // Embedded updates are not supported in MVs
                                           if(WeAreInACreateMVStatement == TRUE)
	                                   {
                                             *SqlParser_Diags << DgSqlCode(-12066)
                                                              << DgString0("UPDATE");
                                             YYABORT;
	                                   }

					   ColRefName *starName = 
					     new (PARSERHEAP()) ColRefName(TRUE, 
									   CorrName("NEW", PARSERHEAP()), PARSERHEAP());
					   ColReference *colRef = new (PARSERHEAP()) ColReference(starName);

					   RelRoot *update =
					     new(PARSERHEAP()) 
					     RelRoot($2,REL_ROOT,colRef);
					   
					   if ($3  != TransMode::ACCESS_TYPE_NOT_SPECIFIED_)
					     update->accessOptions().accessType() = $3;
					   
					   $2->child(0)->getGroupAttr()->setEmbeddedIUD(REL_UNARY_UPDATE);
					   
					   $$ = new (PARSERHEAP()) RenameTable(update, *$5);
					   delete $5;
					 }

                                  | '(' upd_stmt_w_acc_type_and_as_clause ')'
                                    {
                                      CheckModeSpecial1();
                                      $$ = $2;
                                    }

upd_stmt_w_acc_type_and_as_clause_col_list : '(' update_statement_searched access_type ')' as_clause '(' derived_column_list ')'
					 {
                                           // Embedded updates are not supported in MVs
                                           if(WeAreInACreateMVStatement == TRUE)
	                                   {
                                             *SqlParser_Diags << DgSqlCode(-12066)
                                                              << DgString0("UPDATE");
                                             YYABORT;
	                                   }
					
					   ColRefName *starName =
					     new (PARSERHEAP()) ColRefName(TRUE,
									   CorrName("NEW", PARSERHEAP()), PARSERHEAP());
					   ColReference *colRef = new (PARSERHEAP()) ColReference(starName);

					   RelRoot *update =
					     new(PARSERHEAP())
					     RelRoot($2,REL_ROOT,colRef);
					
					   if ($3 != TransMode::ACCESS_TYPE_NOT_SPECIFIED_)
					     update->accessOptions().accessType() = $3;

					   $2->child(0)->getGroupAttr()->setEmbeddedIUD(REL_UNARY_UPDATE);
					
					   $$ = new (PARSERHEAP()) RenameTable(update,*$5,$7);
					   delete $5;
					 }

                                       | '(' upd_stmt_w_acc_type_and_as_clause_col_list ')'
                                         {
                                           CheckModeSpecial1();
                                           $$ = $2;
                                         }

upd_stmt_w_acc_type_rtn_list_and_as_clause : '(' update_statement_searched access_type return_list ')' as_clause

				  {
                                    // Embedded updates are not supported in MVs
                                    if(WeAreInACreateMVStatement == TRUE)
	                            {
                                      *SqlParser_Diags << DgSqlCode(-12066)
                                                       << DgString0("UPDATE");
                                      YYABORT;
	                            }

				    RelRoot *update =
				      new(PARSERHEAP()) 
				      RelRoot($2,REL_ROOT,$4);
				    
				    if ($3 != TransMode::ACCESS_TYPE_NOT_SPECIFIED_)
				      update->accessOptions().accessType() = $3;
				    
				    $2->child(0)->getGroupAttr()->setEmbeddedIUD(REL_UNARY_UPDATE);
				    
				    $$ = new (PARSERHEAP()) RenameTable(update, *$6);
				    delete $6;
				  }
                               | '(' upd_stmt_w_acc_type_rtn_list_and_as_clause ')'
                                  {
                                    CheckModeSpecial1();
                                    $$ = $2;
                                  }

upd_stmt_w_acc_type_rtn_list_and_as_clause_col_list : '('  update_statement_searched access_type return_list ')' as_clause '(' derived_column_list ')'

				 {
                                    // Embedded updates are not supported in MVs
                                    if(WeAreInACreateMVStatement == TRUE)
	                            {
                                      *SqlParser_Diags << DgSqlCode(-12066)
                                                       << DgString0("UPDATE");
                                      YYABORT;
	                            }

				   RelRoot *update =
				     new(PARSERHEAP()) RelRoot($2,REL_ROOT,$4);
				   
				   if ($3 != TransMode::ACCESS_TYPE_NOT_SPECIFIED_)
				     update->accessOptions().accessType() = $3;
				   
				   $2->child(0)->getGroupAttr()->setEmbeddedIUD(REL_UNARY_UPDATE);

				   $$ = new (PARSERHEAP()) RenameTable(update, *$6, $8);
				   
				   delete $6;
				 }
            | '(' upd_stmt_w_acc_type_rtn_list_and_as_clause_col_list ')'
               {
                 CheckModeSpecial1();
                 $$ = $2;
               }

del_stmt_w_acc_type_and_as_clause : '(' delete_statement access_type ')' as_clause
                                 {
                                   // Embedded deletes are not supported in MVs
                                   if(WeAreInACreateMVStatement == TRUE)
                                   {
                                      *SqlParser_Diags << DgSqlCode(-12066)
                                                       << DgString0("DELETE");
                                      YYABORT;
	                           }

                                   // Embedded deletes are not supported with LRU
                                   if(WeAreInALRUOperation == TRUE)
                                   {
				     WeAreInALRUOperation = FALSE;
                                      *SqlParser_Diags << DgSqlCode(-3425)
                                                       << DgString0("DELETE");
                                      YYABORT;
	                           }


				   RelRoot *update = 
				     new(PARSERHEAP()) RelRoot($2,REL_ROOT);
				   
				   if ($3 != TransMode::ACCESS_TYPE_NOT_SPECIFIED_)
				     update->accessOptions().accessType() = $3;
				   
				   // If firstN rows flag is set, then this statement is considered an MTS delete 
				   // and not a Pub/Sub Delete.
				   if ($2->getFirstNRows() == -1)  
				     $2->child(0)->getGroupAttr()->setEmbeddedIUD(REL_UNARY_DELETE);
				   
				   $$ = new (PARSERHEAP()) RenameTable(update, *$5);
				   delete $5;
				   
				 }
                              | '(' del_stmt_w_acc_type_and_as_clause ')'
                                 {
                                   CheckModeSpecial1();
                                   $$ = $2;
                                 }

del_stmt_w_acc_type_and_as_clause_col_list : '('  delete_statement access_type ')' as_clause '(' derived_column_list ')'
		    {
                      // Embedded deletes are not supported in MVs
                      if(WeAreInACreateMVStatement == TRUE)
                      {
                         *SqlParser_Diags << DgSqlCode(-12066)
                                          << DgString0("DELETE");
                         YYABORT;
                      }

                     // Embedded deletes are not supported with LRU
                     if(WeAreInALRUOperation == TRUE)
                       {
			 WeAreInALRUOperation = FALSE;
			 *SqlParser_Diags << DgSqlCode(-3425)
					  << DgString0("DELETE");
			 YYABORT;
		       }

		      RelRoot *update = 
			new(PARSERHEAP()) RelRoot($2,REL_ROOT);
		      
		      if ($3 != TransMode::ACCESS_TYPE_NOT_SPECIFIED_)
			update->accessOptions().accessType() = $3;
		      
		      // If firstN rows flag is set, then this statement is considered an MTS delete 
		      // and not a Pub/Sub Delete.
		      if ($2->getFirstNRows() == -1)  
			$2->child(0)->getGroupAttr()->setEmbeddedIUD(REL_UNARY_DELETE);

		      $$ = new (PARSERHEAP()) RenameTable(update, *$5, $7);
		      
		      delete $5;	  
		    }
                  | '(' del_stmt_w_acc_type_and_as_clause_col_list ')'
                     {
                       CheckModeSpecial1();
                       $$ = $2;
                     }

del_stmt_w_acc_type_rtn_list_and_as_clause : '(' delete_statement access_type return_list ')' as_clause
		    {
                      // Embedded deletes are not supported in MVs
                      if(WeAreInACreateMVStatement == TRUE)
                      {
                         *SqlParser_Diags << DgSqlCode(-12066)
                                          << DgString0("DELETE");
                         YYABORT;
                      }

                     // Embedded deletes are not supported with LRU
		      if(WeAreInALRUOperation == TRUE)
			{
			  WeAreInALRUOperation = FALSE;
			  *SqlParser_Diags << DgSqlCode(-3425)
					   << DgString0("DELETE");
			  YYABORT;
			}


		      RelRoot *update = 
			new(PARSERHEAP()) RelRoot($2,REL_ROOT,$4);
		      
		      if ($3 != TransMode::ACCESS_TYPE_NOT_SPECIFIED_)
			update->accessOptions().accessType() = $3;
		      
		      // If firstN rows flag is set, then this statement is considered an MTS delete 
		      // and not a Pub/Sub Delete.
		      if ($2->getFirstNRows() == -1)  
			$2->child(0)->getGroupAttr()->setEmbeddedIUD(REL_UNARY_DELETE);
		      
		      $$ = new (PARSERHEAP()) RenameTable(update, *$6);
		      delete $6;
		      
		    }
                  | '(' del_stmt_w_acc_type_rtn_list_and_as_clause ')'
                     {
                       CheckModeSpecial1();
                       $$ = $2;
                     }

del_stmt_w_acc_type_rtn_list_and_as_clause_col_list : '('  delete_statement access_type return_list ')' as_clause '(' derived_column_list ')'
		{
                  // Embedded deletes are not supported in MVs
                  if(WeAreInACreateMVStatement == TRUE)
                  {
                     *SqlParser_Diags << DgSqlCode(-12066)
                                      << DgString0("DELETE");
                      YYABORT;
                  }


		  // Embedded deletes are not supported with LRU
		  if(WeAreInALRUOperation == TRUE)
		    {
		      WeAreInALRUOperation = FALSE;
		      *SqlParser_Diags << DgSqlCode(-3425)
				       << DgString0("DELETE");
		      YYABORT;
		    }
		  
		  RelRoot *update =
		    new(PARSERHEAP()) RelRoot($2,REL_ROOT, $4);
		  
		  if ($3 != TransMode::ACCESS_TYPE_NOT_SPECIFIED_)
		    update->accessOptions().accessType() = $3;
		  
		  // If firstN rows flag is set, then this statement is considered an MTS delete 
		  // and not a Pub/Sub Delete.
		  if ($2->getFirstNRows() == -1)  
		    $2->child(0)->getGroupAttr()->setEmbeddedIUD(REL_UNARY_DELETE);
		  
		  $$ = new (PARSERHEAP()) RenameTable(update, *$6, $8);
		  
		  delete $6;	  
		}
              | '(' del_stmt_w_acc_type_rtn_list_and_as_clause_col_list ')'
                 {
                   CheckModeSpecial1();
                   $$ = $2;
                 }

table_name_as_clause_and_hint : table_name as_clause optimizer_hint hbase_access_options
                                {
                                   NAString cteName = ((*$1).getQualifiedNameAsString());
                                   if(SqlParser_CurrentParser->hasWithDefinition(&cteName) )
                                   {     
                                     RelExpr *re = SqlParser_CurrentParser->getWithDefinition(&cteName);
                                     if (CmpCommon::getDefault(CSE_FOR_WITH) == DF_ON)
                                       {
                                         CommonSubExprRef *cse =
                                           new(PARSERHEAP()) CommonSubExprRef(re,cteName);

                                         if (!cse->isFirstReference())
                                           cse->setChild(0, re->copyTree(PARSERHEAP()));

                                         if ($3) 
                                           cse->setHint($3);
                                         if ($4)
                                           cse->setHbaseAccessOptions($4);

                                         cse->addToCmpStatement(TRUE);
                                         $$ = cse;
                                       }
                                     else
                                       $$=re->copyTree(PARSERHEAP());
                                     $$ = new (PARSERHEAP()) RenameTable($$, *$2);
                                  }
                                  else
                                  {
                                    $1->setCorrName(*$2);
                                    $$ = new (PARSERHEAP()) Scan(*$1);
                                    if ($3) 
                                      $$->setHint($3);
                                    if ($4)
                                      ((Scan*)$$)->setHbaseAccessOptions($4);
                                  }  
                                  delete $1;
                                  delete $2;
                                }
                              | '(' table_name_as_clause_and_hint ')'
                                {
                                  CheckModeSpecial1();
                                  $$ = $2;
                                }

table_name_as_clause_hint_and_col_list : table_name as_clause optimizer_hint hbase_access_options '(' derived_column_list ')'
                                         {
                                           Scan * sc = new (PARSERHEAP()) Scan(*$1);
                                           $$ = new (PARSERHEAP())
				             RenameTable(sc, *$2, $6);

                                           if ($3) 
                                             $$->setHint($3);

                                           if ($4)
                                             sc->setHbaseAccessOptions($4);
                                           
                                           delete $1;
                                           delete $2;
                                         }
                                       | '(' table_name_as_clause_hint_and_col_list ')'
                                         {
                                           CheckModeSpecial1();
                                           $$ = $2;
                                         }

rel_subquery_and_as_clause : rel_subquery as_clause
                             {
                               $$ = new (PARSERHEAP()) RenameTable($1, *$2);
                               delete $2;
                             }
                           | '(' rel_subquery_and_as_clause ')'
                             {
                               CheckModeSpecial1();
                               $$ = $2;
                             }
with_clause : 
              TOK_WITH with_clause_elements
              {
                 $$ = NULL;
              }
              | TOK_WITH TOK_RECURSIVE with_clause_elements
              {
                        *SqlParser_Diags << DgSqlCode(-3022) << DgString0("WITH RECURSIVE");
                        YYERROR;
              }

with_clause_elements : with_clause_element
              {
                 $$ = NULL;
              }
              | with_clause_elements ',' with_clause_element
              {
                 $$ = NULL;
              }

with_clause_element : correlation_name TOK_AS '(' query_expression ')'
                      {
                         RelExpr *root = $4;

                         if (root->getOperatorType() != REL_ROOT)
                           root = new (PARSERHEAP()) RelRoot(root, REL_ROOT);

                         $$= new (PARSERHEAP()) RenameTable(root, *$1); 

                         //Duplicated definition of WITH
                         if(SqlParser_CurrentParser->hasWithDefinition($1) )
                          {
                            *SqlParser_Diags << DgSqlCode(-3288)
                                             << DgString0((*$1).toCharStar());
                             YYERROR;
                          }

                          SqlParser_CurrentParser->insertWithDefinition($1 , $$);
                      }

rel_subquery_as_clause_and_col_list : rel_subquery as_clause '(' derived_column_list ')'
                                      {
                                        $$ = new (PARSERHEAP())
				          RenameTable($1, *$2, $4);
                                        delete $2;
                                      }
                                    | '(' rel_subquery_as_clause_and_col_list ')'
                                      {
                                        CheckModeSpecial1();
                                        $$ = $2;
                                      }


/* type relx */
joined_table_needing_spec: joined_table_needing_spec2
	   {
	     inJoinSpec->push(SqlParser_ParenDepth + STACKDELTA_ENSURES_NONZERO);
	   }

joined_table_needing_spec2:
         table_reference TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $3, REL_JOIN);
	   }
       | table_reference TOK_INNER TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $4, REL_JOIN);
	   }
       | table_reference left_outer TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $4, REL_LEFT_JOIN);
	   }
       | table_reference right_outer TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $4, REL_RIGHT_JOIN);
	   }
       | table_reference full_outer TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $4, REL_FULL_JOIN);
	   }

/* type relx */
joined_table :  '(' joined_table ')'   { $$ = $2; }

       // ODBC extension to support {oj outer-join-expression}
       |  '{' TOK_OJ joined_table '}'
           {
             $$ = $3;
             if ($$->getOperatorType() != REL_LEFT_JOIN && 
                 $$->getOperatorType() != REL_RIGHT_JOIN && 
                 $$->getOperatorType() != REL_FULL_JOIN &&
                 $$->getOperatorType() != REL_JOIN
                ) 
             {
               *SqlParser_Diags << DgSqlCode(-3136);
               YYERROR;
             }
           }

       |  table_reference TOK_CROSS TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $4, REL_JOIN);
	   }

	 /* non NATURAL joins must have join_specifications  -- ANSI */
	 /* note that a join is an INNER join by default -- ANSI */
       |  joined_table_needing_spec join_specification
	   {
	     ((Join *)$$)->setJoinPredTree($2);
	     inJoinSpec->pop();
	   }

	 /* NATURAL joins CANNOT have a join specification  -- ANSI */
	 /* note that a join is an INNER join by default -- ANSI */
	 /* No such thing as a "NATURAL UNION" join -- ANSI */
       | table_reference TOK_NATURAL TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $4, REL_JOIN, NULL, TRUE);
	   }
       | table_reference TOK_NATURAL TOK_INNER TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $5, REL_JOIN, NULL, TRUE);
	   }
       | table_reference TOK_NATURAL left_outer TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $5, REL_LEFT_JOIN, NULL, TRUE);
	   }
       | table_reference TOK_NATURAL right_outer TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $5, REL_RIGHT_JOIN, NULL, TRUE);
	   }
       | table_reference TOK_NATURAL full_outer TOK_JOIN table_reference
	   {
	     $$ = new (PARSERHEAP()) Join($1, $5, REL_FULL_JOIN, NULL, TRUE);
	   }

	 /* UNION joins CANNOT have a join specification -- ANSI */
       | table_reference TOK_UNION_JOIN table_reference
	   { 
		   *SqlParser_Diags << DgSqlCode(-3137);
		   //yyerror("");
		   //YYERROR;
		   YYABORT;
	    }

full_outer : TOK_FULL 
             { 
                $$ = 0;
             }
             | TOK_FULL TOK_OUTER
             {
	       $$ = NULL;
             }          

right_outer : TOK_RIGHT 
            {
	      $$ = NULL;
            }
            | TOK_RIGHT TOK_OUTER
            {
              $$ = NULL;
            }


left_outer : TOK_LEFT 
            {
              $$ = NULL;
            }
            | TOK_LEFT TOK_OUTER
            {
              $$ = NULL;
            }




/* type item */
derived_column_list : identifier
				{
				  $$ = new (PARSERHEAP())
				    RenameCol(NULL, new (PARSERHEAP())
				      ColRefName(*$1, PARSERHEAP()));
				  delete $1;
				}
	      | identifier ',' derived_column_list
				{
				  $$ = new (PARSERHEAP())
				    ItemList(new (PARSERHEAP())
				      RenameCol(NULL, new (PARSERHEAP())
				        ColRefName(*$1, PARSERHEAP())),
				      $3);
				  delete $1;
				}

/* type item */
set_function_specification : set_function_type '(' set_quantifier value_expression ')'
			   {
			     if ($1 == ITM_COUNT)
			       {
				 // count of all non-null operand is
				 // to be returned.
				 if ($4->getOperatorType() != ITM_CONSTANT)
				   $1 = ITM_COUNT_NONULL;

				 $$ = new (PARSERHEAP())
				   Aggregate($1, $4, $3, ITM_COUNT, '!');
			       }
			     else if ($1 == ITM_VARIANCE || $1 == ITM_STDDEV)
			       $$ = new (PARSERHEAP()) Variance($1, $4, NULL, $3);
			     else
			       $$ = new (PARSERHEAP()) Aggregate($1, $4, $3);
			   }
              | set_function_type '(' set_quantifier value_expression ',' 
                                                     value_expression ')'
			   {
			     if ($1 == ITM_VARIANCE || $1 == ITM_STDDEV)
			       $$ = new (PARSERHEAP()) Variance($1, $4, $6, $3);
			     else
			       {
				 // no other aggs accept 2 operands
				 Aggregate a($1, $4, $3);
				 *SqlParser_Diags << DgSqlCode(-3129)
				   << DgString0(a.getTextUpper());
				 YYERROR;  // CHANGE TO YYABORT
			       }
			   }
	      | set_function_type '(' '*' ')'
			   {
                              if ($1 != ITM_COUNT)
                              {
                                // only COUNT allows (*)
                                *SqlParser_Diags << DgSqlCode(-3012);
                                YYERROR;  // CHANGE TO YYABORT
                              }
                              else
                              {
                                $$ = new (PARSERHEAP())
				  Aggregate(ITM_COUNT,
					    new (PARSERHEAP()) SystemLiteral(1),
					    FALSE /*i.e. not distinct*/,
					    ITM_COUNT_STAR__ORIGINALLY,
					    '!');
                              }
			   }
              | TOK_GROUP_CONCAT '('  set_quantifier value_expression concat_options ')' 
               {
                  $$ = new (PARSERHEAP())
                  PivotGroup(ITM_PIVOT_GROUP, $4, $5, $3);
 
               }
              | TOK_PIVOT '(' set_quantifier value_expression pivot_options ')'
                  {

                    $$ = new (PARSERHEAP()) PivotGroup(ITM_PIVOT_GROUP, $4, $5, $3);
                  }
              | TOK_PIVOT_GROUP '(' set_quantifier value_expression pivot_options ')'
                  {

                    $$ = new (PARSERHEAP()) PivotGroup(ITM_PIVOT_GROUP, $4, $5, $3);
                  }
              | TOK_XMLAGG '(' TOK_XMLELEMENT '(' identifier ',' value_expression ')' order_by_clause ')' '.' TOK_EXTRACT '(' QUOTED_STRING ')' '.' identifier '(' ')'
                 {
                   CheckModeSpecial4;

                   PivotGroup::PivotOption * po = 
                     new (PARSERHEAP ()) PivotGroup::PivotOption
                     (PivotGroup::DELIMITER_, NULL, (char*)"", -1);

                   NAList<PivotGroup::PivotOption*> * frol =
                     new (PARSERHEAP ()) NAList<PivotGroup::PivotOption*>(PARSERHEAP ());
                   frol->insert(po);
                   
                   $$ = new (PARSERHEAP()) PivotGroup(ITM_PIVOT_GROUP, $7, frol);
                  }

/* type operator_type */
set_function_type :   TOK_AVG 		{ $$ = ITM_AVG; }
                    | TOK_MAX 		{ $$ = ITM_MAX; }
                    | TOK_MIN 		{ $$ = ITM_MIN; }
                    | TOK_SUM 		{ $$ = ITM_SUM; }
                    | TOK_COUNT 	{ $$ = ITM_COUNT; }
                    | TOK_VARIANCE 	{ $$ = ITM_VARIANCE; }
                    | TOK_STDDEV 	{ $$ = ITM_STDDEV; }
                    | TOK_GROUPING 	{ $$ = ITM_GROUPING; }

concat_options : empty
                       {
                         $$ = NULL;
                       }
                    |  concat_options_list
                      {
                        $$ = $1;
                      }

pivot_options : empty
                       {
                         $$ = NULL;
                       }
                    | ',' pivot_options_list
                      {
                        $$ = $2;
                      }
concat_options_list : concat_option
                      {
                        NAList<PivotGroup::PivotOption*> * frol =
                          new (PARSERHEAP ()) NAList<PivotGroup::PivotOption*>(PARSERHEAP ());
                        frol->insert($1);
                        $$ = frol;
                      }
                    | concat_option  concat_options_list
                      {
                        $2->insert($1);
                        $$ = $2;
                      }

pivot_options_list : pivot_option
                      {
			NAList<PivotGroup::PivotOption*> * frol =
			  new (PARSERHEAP ()) NAList<PivotGroup::PivotOption*>(PARSERHEAP ());
			frol->insert($1);
			$$ = frol;
		      }
                    | pivot_option ',' pivot_options_list
                      {
			$3->insert($1);
			$$ = $3;
		      }
;

concat_option : TOK_SEPARATOR QUOTED_STRING
                      {
                        PivotGroup::PivotOption * po =
                          new (PARSERHEAP ()) PivotGroup::PivotOption
                          (PivotGroup::DELIMITER_, NULL, (char*)$2->data(), -1);

                        $$ = po;
                      }
                   | TOK_ORDER TOK_BY sort_spec_list  
                      {
                        PivotGroup::PivotOption * po =
                          new (PARSERHEAP ()) PivotGroup::PivotOption
                          (PivotGroup::ORDER_BY_, $3, NULL, -1);

                        $$ = po;
                      }
                   | TOK_MAX TOK_LENGTH NUMERIC_LITERAL_EXACT_NO_SCALE
                      {
                        Int64 value = atoInt64($3->data());

                        PivotGroup::PivotOption * po =
                          new (PARSERHEAP ()) PivotGroup::PivotOption
                          (PivotGroup::MAX_LENGTH_, NULL, NULL, (Lng32)value);

                        $$ = po;
                      }

pivot_option : TOK_DELIMITER QUOTED_STRING
                      {
			PivotGroup::PivotOption * po = 
			  new (PARSERHEAP ()) PivotGroup::PivotOption
			  (PivotGroup::DELIMITER_, NULL, (char*)$2->data(), -1);
			
			$$ = po;
		      }
                   | TOK_ORDER TOK_BY '('  sort_spec_list  ')'
                      {
			PivotGroup::PivotOption * po = 
			  new (PARSERHEAP ()) PivotGroup::PivotOption
			  (PivotGroup::ORDER_BY_, $4, NULL, -1);
			
			$$ = po;
		      }
                   | TOK_MAX TOK_LENGTH NUMERIC_LITERAL_EXACT_NO_SCALE
                      {
                        Int64 value = atoInt64($3->data()); 
  
			PivotGroup::PivotOption * po = 
			  new (PARSERHEAP ()) PivotGroup::PivotOption
			  (PivotGroup::MAX_LENGTH_, NULL, NULL, (Lng32)value);
			
			$$ = po;
		      }


/* type item */
sequence_func_specification : offset_sequence_function
                            | this_sequence_function
                            | moving_sequence_function
                            | running_sequence_function
                            | olap_sequence_function

/* type item */

this_sequence_function : TOK_THIS '(' value_expression ')'
                           {
                             $$ = new (PARSERHEAP())
                               ItmSeqThisFunction($3);
                           }

/* type item */

offset_sequence_function : TOK_OFFSET '(' value_expression ',' 
                                          value_expression ')'
                           {
                             $$ = new (PARSERHEAP())
                               ItmSeqOffset($3, $5);
                           }
                        | TOK_OFFSET '(' value_expression ',' 
                                         value_expression ',' 
                                         value_expression ')'
                           {
                             $$ = new (PARSERHEAP())
                               ItmSeqOffset($3, $5, $7);
                           }

                        |  TOK_DIFF1 '('  value_expression ')'
                           {
                             $$ = new (PARSERHEAP())
                               ItmSeqDiff1($3);
                           }

                        |  TOK_DIFF1 '('  value_expression ','
                                          value_expression ')'
                           {
                             $$ = new (PARSERHEAP())
                               ItmSeqDiff1($3, $5);
                           }

                        |  TOK_DIFF2 '('  value_expression ')'
                           {
                             $$ = new (PARSERHEAP())
                               ItmSeqDiff2($3);
                           }
                        |  TOK_DIFF2 '('  value_expression ','
                                          value_expression ')'
                           {
                             $$ = new (PARSERHEAP())
                               ItmSeqDiff2($3, $5);
                           }

/* type item */            

running_sequence_function : TOK_RCOUNT '(' '*' ')'
                             {
                               $$ = new (PARSERHEAP())
                                 ItmSeqRunningFunction(ITM_RUNNING_COUNT,
                                                    new (PARSERHEAP()) SystemLiteral(1));
                             }
                          | TOK_RCOUNT '(' value_expression ')'
                             {
                               $$ = new (PARSERHEAP())
                                 ItmSeqRunningFunction(ITM_RUNNING_COUNT, $3);
                             }

                          | TOK_ROWS TOK_SINCE TOK_CHANGED '(' value_expression_list ')'
                             {
                              $$ = new (PARSERHEAP())
                               ItmSeqRunningFunction(ITM_RUNNING_CHANGE, $5);
                             }

                          | running_func_type '(' value_expression ')'
                            {
                              $$ = new (PARSERHEAP())
                               ItmSeqRunningFunction($1, $3);
                            }
                            
                          | TOK_RRANK '(' sort_by_value_expression_list ')'
                            {
                            
                            ItmSeqRunningFunction *tmp = new (PARSERHEAP())
                                                  ItmSeqRunningFunction(ITM_RUNNING_RANK, $3);
                                                       
                            if (SqlParser_CurrentParser->modeSpecial1()	|| 
                                  CmpCommon::getDefault(COMP_BOOL_200) == DF_ON) 
                              {               
                                // group by becomes the partition by for TD.
                                // see getTableExpressionRelExpr in SqlParserAux.cpp
                                tmp->setOLAPInfo(NULL, $3, TRUE);
                                if (SqlParser_CurrentParser->hasTDFunctionsEntries() == 0)
                                {
                                  YYERROR;
                                } 

                                SqlParser_CurrentParser->setTopHasTDFunctions(TRUE);
                              }              
                              
                              $$ = tmp;                
                            }


running_func_type        :  TOK_RAVG         { $$ = ITM_RUNNING_AVG; }
                         | TOK_LASTNOTNULL    { $$ = ITM_LAST_NOT_NULL; }
                         | TOK_RMAX           { $$ = ITM_RUNNING_MAX; }
                         | TOK_RMIN           { $$ = ITM_RUNNING_MIN; }
                         | TOK_RSTDDEV        { $$ = ITM_RUNNING_SDEV; }
                         | TOK_RSUM           { $$ = ITM_RUNNING_SUM; }
                         | TOK_RVARIANCE      { $$ = ITM_RUNNING_VARIANCE; }

/* type item */
moving_sequence_function  : TOK_ROWS TOK_SINCE '(' search_condition ')'
                            {
                              $$ = new (PARSERHEAP())
                                ItmSeqRowsSince( $4,  /*search_condition */
                                                 NULL,
                                                 FALSE );
                            }
                          | TOK_ROWS TOK_SINCE '(' search_condition ',' value_expression ')'
                            {
                              $$ = new (PARSERHEAP())
                                ItmSeqRowsSince( $4,  /*search_condition */
                                                 $6,  /*value_expression*/
                                                 FALSE                      );
                            }

                          | TOK_ROWS TOK_SINCE TOK_INCLUSIVE '(' search_condition ')'
                            {
                              $$ = new (PARSERHEAP())
                                ItmSeqRowsSince( $5,  /*search_condition */
                                                 NULL,
                                                 TRUE                      );
                            }
                          | TOK_ROWS TOK_SINCE TOK_INCLUSIVE '(' search_condition ',' value_expression')'
                            {
                              $$ = new (PARSERHEAP())
                                ItmSeqRowsSince( $5,  /*search_condition */
                                                 $7,  /*value_expression*/
                                                 TRUE                      );
                            }
                          | TOK_MCOUNT '(' '*' ',' value_expression ')'
                            {
                              $$ = new (PARSERHEAP())
                                ItmSeqMovingFunction(ITM_MOVING_COUNT,
                                                   new (PARSERHEAP()) SystemLiteral(1),
                                                   $5);
                            }
                          | TOK_MCOUNT '(' '*' ',' value_expression ',' value_expression')'     // three argument version
                            {
                              $$ = new (PARSERHEAP())
                                ItmSeqMovingFunction(ITM_MOVING_COUNT, 
                                                   new (PARSERHEAP()) SystemLiteral(1),
                                                   $5,
                                                   $7);
                            }
                          | TOK_MCOUNT '(' value_expression ',' value_expression')'     // two argument version
                            {
                              $$ = new (PARSERHEAP())
                               ItmSeqMovingFunction(ITM_MOVING_COUNT, $3, $5);
                            }
                          | TOK_MCOUNT '(' value_expression ',' value_expression ',' value_expression')'     // three argument version
                            {
                              $$ = new (PARSERHEAP())
                               ItmSeqMovingFunction(ITM_MOVING_COUNT, $3, $5, $7);
                            }

                         | moving_func_type '(' value_expression ',' value_expression ')'     // two argument version
                            {
                              $$ = new (PARSERHEAP())
                               ItmSeqMovingFunction($1, $3, $5);
                            }
                         | moving_func_type '(' value_expression ',' value_expression ',' value_expression')'     // three argument version
                            {
                              $$ = new (PARSERHEAP())
                               ItmSeqMovingFunction($1, $3, $5, $7);
                            }

moving_func_type         :  TOK_MAVG      { $$ = ITM_MOVING_AVG; }
                         | TOK_MMAX      { $$ = ITM_MOVING_MAX; }
                         | TOK_MMIN      { $$ = ITM_MOVING_MIN; }
                         | TOK_MSTDDEV   { $$ = ITM_MOVING_SDEV; }
                         | TOK_MSUM      { $$ = ITM_MOVING_SUM; }
                         | TOK_MVARIANCE { $$ = ITM_MOVING_VARIANCE; }
                         | TOK_MRANK     { $$ = ITM_MOVING_RANK; }

/* type item */
olap_sequence_function : set_function_specification TOK_OVER '('
                         opt_olap_part_clause
                         opt_olap_order_clause
                         ')'
                            {
                              $$ = $1;
                              if ($5 == NULL)
                              {
				((Aggregate *)$$)->setOLAPInfo($4, $5, -INT_MAX, INT_MAX);
			      }
			      else
			      {
				((Aggregate *)$$)->setOLAPInfo($4, $5, -INT_MAX, 0);
			      }
			      if (SqlParser_CurrentParser->hasOlapFunctionsEntries() == 0)
			      {
				YYABORT;
			      } 
                              SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                            }

                       | set_function_specification TOK_OVER '('
                         opt_olap_part_clause
                         opt_olap_order_clause
                         TOK_ROWS olap_rows_spec
                         ')'
                            {
                              $$ = $1;
                              ((Aggregate *)$$)->setOLAPInfo($4, $5, $7, 0);
       			      if (SqlParser_CurrentParser->hasOlapFunctionsEntries() == 0)
			      {
				YYABORT;
			      } 
                              SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                            }

                       | set_function_specification TOK_OVER '('
                         opt_olap_part_clause
                         opt_olap_order_clause
                         TOK_ROWS TOK_BETWEEN olap_rows_spec TOK_AND olap_rows_spec
                         ')'
                            {
                              $$ = $1;
                              ((Aggregate *)$$)->setOLAPInfo($4, $5, $8, $10);
			      if (SqlParser_CurrentParser->hasOlapFunctionsEntries() == 0)
			      {
				YYABORT;
			      } 
                              SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                            }

                       | TOK_RRANK '(' ')' TOK_OVER '('
                         opt_olap_part_clause
                         opt_olap_order_clause ')'
                            {
                              $$ = new (PARSERHEAP()) 
                              //ITM_RUNNING_RANK is not really an aggregate, it was added to support olap
                                Aggregate(ITM_RUNNING_RANK, $7);
                              ((Aggregate *)$$)->setOLAPInfo($6, $7, -INT_MAX, 0);
			      if (SqlParser_CurrentParser->hasOlapFunctionsEntries() == 0)
			      {
				YYABORT;
			      } 
                              SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                            }

                       | TOK_D_RANK '(' ')' TOK_OVER '('
                         opt_olap_part_clause
                         opt_olap_order_clause ')'
                            {
                              $$ = new (PARSERHEAP()) 
                              //ITM_RUNNING_DRANK is not really an aggregate, it was added to support olap
                                Aggregate(ITM_RUNNING_DRANK, $7);
                              ((Aggregate *)$$)->setOLAPInfo($6, $7, -INT_MAX, 0);
			      if (SqlParser_CurrentParser->hasOlapFunctionsEntries() == 0)
			      {
				YYABORT;
			      } 
                              SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                              
                            }
                         
                       | TOK_ROW_NUMBER '(' ')' TOK_OVER '('
                         opt_olap_part_clause
                         opt_olap_order_clause ')'
                            {
                              $$ = new (PARSERHEAP()) 
                                Aggregate(ITM_COUNT, 
                                          new (PARSERHEAP()) SystemLiteral(1),
                                          FALSE /*i.e. not distinct*/,
                                          ITM_COUNT_STAR__ORIGINALLY,
                                          '!');
                              ((Aggregate *)$$)->setOLAPInfo($6, $7, -INT_MAX, 0);
			      if (SqlParser_CurrentParser->hasOlapFunctionsEntries() == 0)
			      {
				YYABORT;
			      } 
                              SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                            }

// start of OLAP LEAD function()
                       | TOK_LEAD '(' value_expression ')' TOK_OVER '('
                         opt_olap_part_clause opt_olap_order_clause ')'
                        {
                          ItmLeadOlapFunction* leadExpr =
                                       new (PARSERHEAP()) ItmLeadOlapFunction($3, 1);
                          leadExpr->setOLAPInfo($7, $8);
                          $$=leadExpr;

                          SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                        }
                       | TOK_LEAD '(' value_expression ',' value_expression ')' TOK_OVER '('
                         opt_olap_part_clause opt_olap_order_clause ')'
                        { 
                          ItmLeadOlapFunction* leadExpr = 
                                       new (PARSERHEAP()) ItmLeadOlapFunction($3, $5);
                          leadExpr->setOLAPInfo($9, $10);
                          $$=leadExpr;
                          
                          SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                        }
                       | TOK_LEAD '(' value_expression ',' value_expression ',' value_expression ')' TOK_OVER '('
                         opt_olap_part_clause opt_olap_order_clause ')'
                        { 
                          ItmLeadOlapFunction* leadExpr = 
                                       new (PARSERHEAP()) ItmLeadOlapFunction($3, $5, $7);
                          leadExpr->setOLAPInfo($11, $12);
                          $$=leadExpr;
                          
                          SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                        }
// end of OLAP LEAD function()
// start of OLAP LAG function()
                       |TOK_LAG '(' value_expression ','  value_expression ','  value_expression ')'  TOK_OVER '('
                         opt_olap_part_clause
                         opt_olap_order_clause ')'
                         {
                             //3rd value_expression is default value    
                              ItmLagOlapFunction* lagExpr =
                                                       new (PARSERHEAP()) ItmLagOlapFunction($3, $5, $7);
                             lagExpr->setOLAPInfo($11, $12);
                             $$=lagExpr;
                             SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                         }
                       |TOK_LAG '(' value_expression ','  value_expression ')'  TOK_OVER '('
                         opt_olap_part_clause
                         opt_olap_order_clause ')'
                         {
                              ItmLagOlapFunction* lagExpr =
                                                       new (PARSERHEAP()) ItmLagOlapFunction($3, $5);
                             lagExpr->setOLAPInfo($9, $10);
                             $$=lagExpr;
                             SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                         }
                       |TOK_LAG '(' value_expression  ')'  TOK_OVER '('
                          opt_olap_part_clause
                          opt_olap_order_clause ')'
                          {    
                               //default offset is 1;
                               NAString * defaultOffset = new (PARSERHEAP()) NAString("1");
                               ItemExpr * offsetExpr = literalOfNumericNoScale(defaultOffset);
                               if (!offsetExpr) YYERROR;   
                               ItmLagOlapFunction* lagExpr =
                                                        new (PARSERHEAP()) ItmLagOlapFunction($3, offsetExpr);
                              lagExpr->setOLAPInfo($7, $8);
                              $$=lagExpr;
                              SqlParser_CurrentParser->setTopHasOlapFunctions(TRUE);
                          }
// end of OLAP LAG function()



opt_olap_part_clause   : empty
                         {
                           $$ = NULL;
                         }
                       | TOK_PARTITION_BY value_expression_list
                         {
                           $$ = $2;
                         }

opt_olap_order_clause  : empty
                         {
                           $$ = NULL;
                         }
                       | TOK_ORDER TOK_BY sort_by_value_expression_list
                         { 
                           $$ = $3; 
                         }

olap_rows_spec         : TOK_UNBOUNDED olap_prec_follow
                         {
                           $$ = INT_MAX * $2;
                         }
                       | unsigned_smallint olap_prec_follow
                         {
                           $$ = $1 * $2;
                         }
                       | TOK_CURRENT TOK_ROW
                         {
                           $$ = 0;
                         }


olap_prec_follow       : TOK_PRECEDING
                         {
                           $$ = -1;
                         }
                       | TOK_FOLLOWING
                         {
                           $$ = 1;
                         }

//
// This list, VEL, can be any of:
// VE		-- which, through rule "primary", can be '(VE)'		[VE]
// 'VE,VE'	-- Tandem extension to row-value-constructor		[VELC]
// '(VE,VE)'	-- Ansi row-value-ctor, which can also be '((VE,VE))'	[VELP]
//
// A VEL has one or more items; a VELC or VELP has two or more.
// In other right-hand-sides in other rules herein, you often see
//	'(' value_expression_list ')'
// which is NOT the same as
//	value_expression_list_paren
// because the first can have one item while the second must have two or more.
//
// Note that the ItemLists, to preserve order, are built right-recursively
// (so yacc shifts its stack rather than reducing, unfortunately).
//
// The %precedence means that these rules won't be reduced when we
// have the opportunity to shift in the comparison_predicate rule
// (has the higher %prec '=' '<' '>' etc).
// (Shift is always already taken in the between_predicate rule, %prec TOK_AND.)
// This is part of the fix for Genesis 10-971104-1441.

value_expression_list : value_expression			%prec ','
		      	    | value_expression_list_comma	%prec ','
		      	    | value_expression_list_paren	%prec ','

value_expression_list_paren : '(' value_expression_list_comma ')'
				  {
				    $$ = $2;
				  }
			    | '(' value_expression_list_paren ')'
				  {
				    $$ = $2;
				  }

value_expression_list_comma : value_expression ',' value_expression
				  {
				    $$ = new (PARSERHEAP()) ItemList( $1, $3 );
				  }
		      	    | value_expression ',' value_expression_list_comma
				  {
				    $$ = new (PARSERHEAP()) ItemList( $1, $3 );
				  }

			    // The next subrules are a palliative for
			    // Genesis 10-970929-8459: that is, we just want
			    // to issue a more helpful error message for the
			    // ambiguity introduced by our Tandem extension
			    // of not requiring parens around a value-expr-list.
			    //
			    // The subrules below are abstracted from the
			    // actual_table_name and table_reference rules
			    // (cannot use those directly because that makes
			    // hundreds of yacc conflicts!).
			    //
			    // Other similar "fixes" are also in the Binder,
			    // for cases that cannot be detected here
			    // without yacc conflicts.
			    //
		      	    | value_expression ',' value_expression as_clause
				  {
				    checkError4101($4, $3);
				    YYABORT;
				  }
		      	    | value_expression ',' HOSTVAR TOK_PROTOTYPE
				  {
				    checkError4101($3);
				    YYABORT;
				  }
		      	    | value_expression ',' SYSTEM_VOLUME_NAME
				  {
				    checkError4101($3);
				    YYABORT;
				  }
		      	    | value_expression ',' DOLLAR_IDENTIFIER
				  {
				    checkError4101($3);
				    YYABORT;
				  }

/* type item */
value_expression_list_lr    : value_expression		
		      	    | value_expression_list_lr ',' value_expression
				{
				  ItemList * il =
				    new (PARSERHEAP()) ItemList( $3, $1 );

				  NABoolean lcConst = FALSE;
				  NABoolean rcConst = FALSE;
				  /* isStrict = TRUE, considerVEG = FALSE are the args for
				  doesExprEvaluateToConstant */
				  if ($3->castToItemExpr()->doesExprEvaluateToConstant(TRUE,FALSE))
				    {
				      rcConst = TRUE;
				    }
				  
				  if ($1->castToItemExpr()->getOperatorType()
				      == ITM_ITEM_LIST)
				    {
				      ItemList * lc = 
					(ItemList*)($1->castToItemExpr());
				      il->numOfItems() = 
					lc->numOfItems() + 1;
				      
				      if (lc->constChild())
					lcConst = TRUE;
				    }
				  else
				    {
				      // left is not a list.
				      if ($1->castToItemExpr()->doesExprEvaluateToConstant(TRUE,FALSE))
					lcConst = TRUE;
				      il->numOfItems() = 2;
				    }
				  if (lcConst && rcConst)
				    il->constChild() = TRUE;

				  $$ = il;
				}


/* type item */
value_expression : value_expression_sans_collate collation_option
			    {
				if ($2.collation_  == CharInfo::CZECH_COLLATION){
				  *SqlParser_Diags << DgSqlCode(-3430)<<  DgString0(SQLCOLLATIONSTRING_CZECH);
				  YYERROR;
				  }
			      if ($2.coercibility_ == CharInfo::EXPLICIT) {
				// Per ANSI 6.13 SR 4(a)(i), overwrite
				// any collation, even an EXPLICIT one.
				//
				// We must let the Binder apply (or reject)
				// this collation during type synthesis.
				//
				$1->collateClause() = new (PARSERHEAP())
				  CollationAndCoercibility;
				memcpy($1->collateClause(), &$2, sizeof($2));
			      }
			    }

/* type item */
value_expression_sans_collate : term
              | value_expression '+' term
				{
				  $$ = new (PARSERHEAP())
				    BiArith(ITM_PLUS, $1, $3);
				}
              | value_expression '-' term
				{
				  $$ = new (PARSERHEAP())
				    BiArith(ITM_MINUS, $1, $3);
				}
              | value_expression TOK_CONCATENATION term
                                {
                                  $$ = new (PARSERHEAP())
				    Concat( $1, $3);
                                }
              | value_expression '&' term
                {
		  $$ = new (PARSERHEAP()) BitOperFunc(ITM_BITAND, $1, $3);
		}
              | value_expression TOK_BITOR_OPERATOR term
                {
		  $$ = new (PARSERHEAP()) BitOperFunc(ITM_BITOR, $1, $3);
		}
              | value_expression '^' term
                {
		  $$ = new (PARSERHEAP()) BitOperFunc(ITM_BITXOR, $1, $3);
		}
             | '~' term
                {
		  $$ = new (PARSERHEAP()) BitOperFunc(ITM_BITNOT, $2);
		}

/* type item */
term : factor1
              | term '*' factor1
				{
				  $$ = new (PARSERHEAP())
				    BiArith(ITM_TIMES, $1, $3);
				}
              | term '/' factor1
				{
				  $$ = new (PARSERHEAP())
				    BiArith(ITM_DIVIDE, $1, $3);
				}

/* type item */
factor1 : factor
        | factor TOK_EXPONENTIATE factor1
				{
				  $$ = new (PARSERHEAP())
				    MathFunc(ITM_EXPONENT, $1, $3);
				}

/* type item */
factor : sign primary
				{
				  if ($1 == '+') // just eat the unnecessary '+'
				    $$ = $2;
				  else {
				    // **NO: $$ = new UnArith(ITM_NEGATE, $2);**
				    //
				    // Represent unary "-$2" as binary "0 - $2"
				    $$ = new (PARSERHEAP()) // "-$2" => "0 - $2"
				      BiArith(ITM_MINUS,
					      literalOfNumericNoScale(
						new (PARSERHEAP()) NAString("0", PARSERHEAP())),
					      $2);
				    ((BiArith*) $$)->setIsUnaryNegate();
				    //fixup hqc constant list for UnaryNegate, not for 1.1
				    //SqlParser_CurrentParser->FixupForUnaryNegate((BiArith*) $$);
				    }
				}
              | '!' primary
              {
                $$ = new (PARSERHEAP())
                  UnArith($2);
              }
              | primary
	      | primary TOK_LPAREN_BEFORE_FORMAT TOK_FORMAT character_string_literal ')'
                               {
                                 // DEFAULT_CHARSET has no effect on character_string_literal in this context
				 $$ = new (PARSERHEAP()) Format($1, *$4, FALSE);
			       }
	      | primary TOK_LPAREN_BEFORE_FORMAT TOK_FORMAT character_string_literal ')'
                        TOK_LPAREN_BEFORE_DATATYPE data_type ')'
                               {
                                 // DEFAULT_CHARSET has no effect on character_string_literal in this context
				 CheckModeSpecial1();
				 $$ = new (PARSERHEAP()) Cast($1, $7);
			       }

	      | primary TOK_LPAREN_BEFORE_FORMAT TOK_FORMAT character_string_literal ',' TOK_TITLE character_string_literal ')'
                               {
                                 // DEFAULT_CHARSET has no effect on character_string_literal in this context
				 $$ = new (PARSERHEAP()) Format($1, *$4, FALSE);
			       }
	      | primary TOK_LPAREN_BEFORE_FORMAT TOK_FORMAT character_string_literal ',' TOK_TITLE character_string_literal ')' TOK_LPAREN_BEFORE_DATATYPE data_type ')'
                               {
                                 // DEFAULT_CHARSET has no effect on character_string_literal in this context
				 CheckModeSpecial1();
				 
				 $$ = new (PARSERHEAP()) Cast($1, $10);
			       }

	      | primary TOK_LPAREN_BEFORE_NAMED TOK_NAMED correlation_name ')'
                               {
				 CheckModeSpecial1();
				 
				 $$ = new (PARSERHEAP())
				   RenameCol($1, new (PARSERHEAP()) 
					     ColRefName(*$4, PARSERHEAP()));
				 delete $4;
			       }

	      | primary TOK_LPAREN_BEFORE_DATATYPE data_type optional_cast_spec_not_null_spec ')'
                               {
				 CheckModeSpecial1();
				 
				 $$ = new (PARSERHEAP()) Cast($1, $3);
                                  if ($4) // NOT NULL phrase specified
                                  {
                                    $3->setNullable(FALSE);
                                  }

			       }

/* type item (Scalar Subquery) */
row_subquery :  rel_subquery { $$ = new (PARSERHEAP()) RowSubquery($1); }
	     | '(' row_subquery ')' 
                                { $$ = $2; }

/* type item */
primary :     '(' value_expression ')'
				{ $$ = $2; }
	      | '(' value_expression ')' interval_qualifier
				{
				  if ($2->getOperatorType() == ITM_MINUS)
                                  {
                                    SQLInterval *iq =
				      new (PARSERHEAP()) SQLInterval(
					PARSERHEAP(), TRUE,
					$4->getStartField(),
					$4->getLeadingPrecision(),
					$4->getEndField(),
					$4->getFractionPrecision());
				    delete $4;
                                    if (! iq->checkValid(SqlParser_Diags))
                                      YYERROR;
				    $$ = new (PARSERHEAP()) Cast ($2, iq);
                                  } 
                                  else
                                  {
				    // Only minus allowed: "(dt - dt) iq"
                                    *SqlParser_Diags << DgSqlCode(-3013);
                                     YYERROR;
                                  }  
				}
	      | row_subquery
	      | dml_column_reference
	      | dml_column_reference TOK_LPAREN_BEFORE_DATE_COMMA_AND_FORMAT TOK_DATE ',' TOK_FORMAT character_string_literal ')'
                {
                  // DEFAULT_CHARSET has no effect on character_string_literal in this context
                  $$ = new (PARSERHEAP()) DateFormat($1, *$6, DateFormat::FORMAT_TO_CHAR);
		}

              | hostvar_expression
                        {
                          if (CmpCommon::getDefault(MODE_SPECIAL_4) == DF_OFF) 
                            {
                              TheHostVarRoles->setLastUnassignedTo(HV_IS_INPUT);
                              $$ = $1;
                            }
			}
              | literal
                        {
                          $$ = $1;
			}
              | dynamic_parameter
	      | dynamic_parameter_array
	      | internal_arith_placeholder
              | set_function_specification
              | sequence_func_specification
              | cast_specification
	      | value_function

              /* ODBC extension, map {fn scalar-function} to scalar-function */
              | '{' TOK_FN set_function_specification '}'
                        {
                         $$ = $3;
                        }

              | '{' TOK_FN value_function '}'
                        {
                          $$ = $3;
			}

              /* added ODBC extension: map LENGTH(str) in ODBC to Char LENGTH.
	       Trim the trailing blanks...that's what ODBC wants */
              | '{' TOK_FN TOK_LENGTH '(' value_expression ')' '}'
                         {
			   $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_ODBC_LENGTH, $5);
                         }

              | '{' TOK_FN cast_specification '}'
                        {
                          $$ = $3;
			}
	      | TOK_USERNAMEINTTOEXT '(' value_expression ')'
	      {
		NAString ldap("USER_NAME");
		ColRefName  *ldapuser =  new (PARSERHEAP()) ColRefName(ldap);
		ItemExpr* select_list = new (PARSERHEAP()) ColReference(ldapuser);

		NAString usercat("MANAGEABILITY");
		NAString usersch("USER_MANAGEMENT");
		NAString usertab("USERDATA");
		CorrName * tabName = new (PARSERHEAP()) CorrName(usertab, 0, usersch, usercat);
		RelExpr * from_clause = new (PARSERHEAP()) Scan(*tabName);

		NAString neouser_colname("NEOUSER_NAME");
		ColRefName  *neouser = new (PARSERHEAP()) ColRefName(neouser_colname);
		ItemExpr* wc_col = new (PARSERHEAP()) ColReference(neouser);
		ItemExpr* where_clause = new (PARSERHEAP()) BiRelat(ITM_EQUAL, wc_col, $3);

		RelExpr * root_child = getTableExpressionRelExpr(from_clause, where_clause, NULL, NULL, NULL, NULL, NULL);
		RelRoot *root =  new (PARSERHEAP())
					    RelRoot(root_child, TransMode::ACCESS_TYPE_NOT_SPECIFIED_, LOCK_MODE_NOT_SPECIFIED_, REL_ROOT, select_list);
		RelRoot * root1 = finalize(root);
		$$ = new (PARSERHEAP()) RowSubquery(root1);
	      }

	      | TOK_DEFAULT		// Genesis 10-980217-0715, -0716
	         {
	           $$ = new (PARSERHEAP()) DefaultSpecification();
	         }
	      | null_constant

// CURRENTLY UNUSED...
// /* type item */
// value_specification : literal
//                     | dynamic_parameter
//                     | hostvar_expression
//                     {
//                       TheHostVarRoles->setLastUnassignedTo(HV_IS_INPUT);
//                       $$ = $1;
//                     }

/* type item */
null_constant : TOK_NULL
                                {
                                  $$ = new (PARSERHEAP()) ConstValue();
                                  SqlParser_CurrentParser->collectItem4HQC($$);
                                }

/* type item */
value_function :
       builtin_function_user

     | datetime_misc_function

     | datetime_misc_function_used_as_default

     | datetime_value_function

     | math_function

     | misc_function

     | string_function

     | user_defined_scalar_function

     | select_lob_to_obj_function

/* Get user defined function name.  Allow function only, or with schema, or catalog and schema.
   Must use ShortStringSequence to collect names for use with ComObjectName - in case any are
   delimited.  The function name must be changed to upper case, since it cannot be delimited 
   and the INTERNAL_FORMAT flag to ComObjectName is being used.  An INTERNAL_FORMAT name must
   be capitalized or it will be treated as a delimited name.
*/
user_defined_function_name : 
       regular_identifier_not_builtin 
         {
           // Function name only.
           $1->toUpper();
           ComObjectName *name = new (PARSERHEAP()) 
             ComObjectName(*$1, COM_UDF_NAME, 1, PARSERHEAP());
           if (name == NULL) YYABORT;
           $$ = name;
         }
     | DELIMITED_IDENTIFIER
         {
           ComObjectName *name = new (PARSERHEAP()) 
             ComObjectName(*$1, COM_UDF_NAME, 1, PARSERHEAP());
           if (name == NULL) YYABORT;
           $$ = name;
         }
     | qualified_name '.' regular_identifier_not_builtin
         {
           // qualified name can't be more than 2 parts.
           if ($1->numParts() > 2) YYABORT;

           NAString cat, sch;
           if ($1->numParts() == 2) 
           {
             cat=*($1->extract(0));
             sch=*($1->extract(1));
           }
           else if ($1->numParts() == 1) 
             sch=*($1->extract(0));

           $3->toUpper(); // UDF names can't be delimited.
           ComObjectName *comName = new (PARSERHEAP()) 
             ComObjectName(cat, sch, *$3,
                           COM_UDF_NAME, 
                           ComAnsiNamePart::INTERNAL_FORMAT, 
                           PARSERHEAP());
           if (comName == NULL) YYABORT;
           $$ = comName;
         }
user_defined_scalar_function : user_defined_function_name '(' udr_value_expression_list ')'
     {
        // UDFs - returns a UDFunction (ItemExpr).
        ComObjectName functionName(*$1, PARSERHEAP());
        LIST(ItemExpr *) newList(PARSERHEAP(), 0);
        newList = PARSERHEAP();


        // Insert arguments from a one-sided tree to a list.
        Int32 i=0;
        ItemExpr *expr = (ItemExpr *) $3;
        while (expr && expr->getOperatorType() == ITM_ITEM_LIST)
        { 
          // Child(1) always has the value expression to insert to list.
          // Child(0) always has the next node with 2 children.
          if (expr->child(1)) newList.insertAt((CollIndex) i++, (ItemExpr *)expr->child(1));
          expr = (ItemExpr *) expr->child(0);
        }
        if (expr) newList.insertAt((CollIndex) i, expr); // Insert last argument.

        UDFunction *udf = new (PARSERHEAP()) UDFunction(functionName, newList, PARSERHEAP());

        // The following is for computing view text (and MV, ... 
        // We need to save the position of the UDF name (and length) in the query
        // statement so that MVs, views, and triggers can rewrite the query to 
        // substitute fully qualified names.  Unfortunately, we cannot directly
        // use the same approach for columns and tables elsewhere in the parser.  
        // However, there should be a better way of doing it than what we have here.
        NAWchar *inputStr = SQLTEXTW();
        const ParScannedTokenQueue::scannedTokenInfo &tokInfo
            = ParScannedTokens->getScannedTokenInfo(0);
        Int32 pos = tokInfo.tokenStrPos - tokInfo.tokenStrOffset +
                    tokInfo.tokenStrLen;
        //TRAFODION-2931
	//Chinese character of inputStr will cause core dump
        //NAString *input = unicodeToChar(&inputStr[0], pos, (long) SqlParser_ISO_MAPPING,
        //                                 PARSERHEAP());
        NAString *input = unicodeToChar(&inputStr[0],
                                        pos,
                                        (CharInfo::CharSet) (ComGetNameInterfaceCharSet()),
                                        PARSERHEAP());
        //TRAFODION-2931
        char *inputC = new (PARSERHEAP()) char[pos+1];
        strncpy(inputC, input->data(), pos+1);
        delete input;
        
        Int32 openParen=0, openQuote=0, openSQuote=0,
              endOfUdfName=0, begOfUdfName=0, prevWasLetter=0, startPos=pos;
        do 
        {
          // We must backtrack through the query from the current position, which is
          // the closing paren for the UDF argument list and find the beginning of the
          // UDF name.  This backtrace must cross all arguments, which could be other
          // UDFs, subqueries, and include delimited names.  
          char c = inputC[pos];
          if (c == 0)        continue;
          if (c == '"')      openQuote  = openQuote  ? 0 : 1;
          if (openQuote > 0) continue;    // skip text in double quotes.
          if (c == '\'')     openSQuote = openSQuote ? 0 : 1;
          if (openSQuote > 0) continue;   // skip text in single quotes.
          if (c == ')')      openParen++;
          if (c == '(')      openParen--;
          if (openParen > 0) continue;    // skip text in parens
          if (c == ' ' || c == ',')       // Prev char could be beg of name.
            if (pos<startPos && isalnum(inputC[pos+1])) prevWasLetter=1;
             
          // Not text in parens or quotes:
          if (endOfUdfName == 0)  endOfUdfName = pos;
          else if (prevWasLetter == 1) { begOfUdfName = pos+1; break; }
          else if (openParen == -1)    { begOfUdfName = pos+1; break; }    
          prevWasLetter=0;
        } while (--pos>0);
        // end code for computing UDF func name position.

        ParInsertNameLocInOrder(begOfUdfName, endOfUdfName-begOfUdfName);
        udf->setNamePosOfUdfInQuery(begOfUdfName);

        NADELETEBASIC(inputC, PARSERHEAP());

	$$ = udf;
     }

table_mapping_function_invocation :
     qualified_name '(' tmudf_table_expression ',' tmudf_table_expression optional_tmudf_param_list_with_comma ')' 
   {
     // TBD: Support TMUDFs with two table-valued inputs
     YYERROR;
   }
   | qualified_name '(' tmudf_table_expression optional_tmudf_param_list_with_comma ')' 
   {
     //Table mapping UDF returns a TMUDFunction (RelExpr)
     CorrName  *functionName = corrNameFromStrings($1);
     if (functionName == NULL)
		YYABORT;

     TableMappingUDF *tmudf =
       new (PARSERHEAP()) TableMappingUDF(1, *functionName, $4 );

     tmudf->child(0) = $3;
     $$ = tmudf;
   }
   |  qualified_name '(' optional_tmudf_param_list ')' 
   {
     //Table mapping UDF returns a TMUDFunction (RelExpr)
     CorrName  *functionName = corrNameFromStrings($1);
     if (functionName == NULL)
		YYABORT;

     $$ = new (PARSERHEAP()) TableMappingUDF(0, *functionName, $3 );
   } 



tmudf_table_expression : TOK_TABLE '(' tmudf_query_expression ')' 
                         {
                           $$ = $3;
                         }
                         | 
                         TOK_TABLE '(' tmudf_query_expression ')' as_clause
                         {
                           $$=new (PARSERHEAP()) RenameTable($3, *$5);
                           delete $5;
                         }
                         | TOK_TABLE '(' tmudf_query_expression ')' as_clause '(' derived_column_list ')'
			 {
                           $$ = new(PARSERHEAP()) RenameTable($3,*$5,$7);
                           delete $5;
                         }

tmudf_query_expression : query_specification optional_tmudf_order_by
                           {
                             if ($2)
                               ((RelRoot*)$1)->addOrderByTree($2);
                             $$ = $1;
                           }
                       | query_specification TOK_PARTITION_BY value_expression_list optional_tmudf_order_by
                           {
                             ((RelRoot*)$1)->addPartitionByTree($3);
                             ((RelRoot*)$1)->setPartReqType(SPECIFIED_PARTITIONING);
                             if ($4)
                               ((RelRoot*)$1)->addOrderByTree($4);
                             $$ = $1;
                           }
                       | query_specification TOK_NO_PARTITION optional_tmudf_order_by
                           {
                             ((RelRoot*)$1)->setPartReqType(NO_PARTITIONING);
                             if ($3)
                               ((RelRoot*)$1)->addOrderByTree($3);
                             $$ = $1;
                           }
                       | query_specification TOK_REPLICATE_PARTITION optional_tmudf_order_by
                           {
                             ((RelRoot*)$1)->setPartReqType(REPLICATE_PARTITIONING);
                             $$ = $1;
                             if ($3)
                               ((RelRoot*)$1)->addOrderByTree($3);
                           }

optional_tmudf_order_by : empty
                           {
                             $$ = NULL;
                           }
                        | TOK_ORDER TOK_BY sort_by_value_expression_list
                           {
                             $$ = $3;
                           }

/* type item */
optional_tmudf_param_list_with_comma : empty
                   {
                     $$ = NULL;
                   }
               | ',' tmudf_param_list
                   {
                     $$ = $2;
                   }

/* type item */
optional_tmudf_param_list : empty
                   {
                     $$ = NULL;
                   }
               | tmudf_param_list

/* type item */
tmudf_param_list : tmudf_param
                   {
                     $$ = $1;
                   }
                   | tmudf_param ',' tmudf_param_list
                   {
		     $$ = new(PARSERHEAP()) ItemList($1, $3);
                   } 

/* type item */
tmudf_param : value_expression


udr_value_expression_list : 
       value_expression
     | table_name_dot_star
     | value_expression ',' udr_value_expression_list
        {
          ItemList * il = new (PARSERHEAP()) ItemList( $3, $1 );
          $$ = il; // ItemList *
        }
     | table_name_dot_star ',' udr_value_expression_list
        {
          ItemList * il = new (PARSERHEAP()) ItemList( $3, $1 );
          $$ = il; // ItemList *
        }
     | empty
        {
          $$ = NULL;
        }

table_name_dot_star : actual_table_name TOK_DOT_STAR
     {
        // Returns a ColReference ItemExpr.
        ColRefName *starName
          = new (PARSERHEAP()) ColRefName(TRUE, CorrName(*$1, PARSERHEAP()), PARSERHEAP());
        $$ = new (PARSERHEAP()) ColReference(starName);
        ParUpdateNameLocForDotStar(starName);
        delete $1;
     }

/* type item */
datetime_value_function : TOK_CURDATE '(' ')'
                                {
                                  /* ODBC extension, map to  */
                                  /* TOK_CURRENT_DATE        */
                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                 DatetimeType::SUBTYPE_SQLDate, 0);
                                }
     | TOK_CURRENT_DATE
                                {
                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                       DatetimeType::SUBTYPE_SQLDate, 0);
                                }
     | TOK_SYSDATE
                                {
                                  if (CmpCommon::getDefault(MODE_SPECIAL_4) == DF_ON) 
                                    {
                                      $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                           DatetimeType::SUBTYPE_SQLTimestamp, 0);
                                    }
                                  else
                                    {
                                      $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                           DatetimeType::SUBTYPE_SQLDate, 0);
                                    }
                                }
     | TOK_DATE
                                {
				  CheckModeSpecial1();

				  /* special1 mode extenstion*/
                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                       DatetimeType::SUBTYPE_SQLDate, 0);
                                }
     | TOK_TIME
				{
				  CheckModeSpecial1();

                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                       DatetimeType::SUBTYPE_SQLTime, 
                                                                       SQLTime::DEFAULT_FRACTION_PRECISION);
				}

     | TOK_LPAREN_BEFORE_DATE_AND_LPAREN TOK_DATE TOK_LPAREN_BEFORE_FORMAT TOK_FORMAT character_string_literal ',' TOK_TITLE character_string_literal ')' ')'
                                {
                                  // DEFAULT_CHARSET has no effect on character_string_literal in this context
				  CheckModeSpecial1();
                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                       DatetimeType::SUBTYPE_SQLDate, 0);
                                }

     | TOK_LPAREN_BEFORE_DATE_AND_LPAREN TOK_DATE TOK_LPAREN_BEFORE_FORMAT TOK_FORMAT character_string_literal ')' ')'
                                {
                                  // DEFAULT_CHARSET has no effect on character_string_literal in this context
				  CheckModeSpecial1();

                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                       DatetimeType::SUBTYPE_SQLDate, 0);
                                 }

     | TOK_CURRENT
				{
                                  $$ = CurrentTimestamp::construct(PARSERHEAP());
				}

     | TOK_CURRENT ts_left_unsigned_right
				{
				  if ($2 > DatetimeType::MAX_FRACTION_PRECISION)
				    {
				      *SqlParser_Diags << DgSqlCode(-3134)
						       << DgInt0($2);
				      YYERROR;
				    }
                                  
                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                       DatetimeType::SUBTYPE_SQLTimestamp, $2);
				}

     /* CURRENT for MP DATETIME with start-end fields */
     | TOK_CURRENT datetime_qualifier
             {
                 DatetimeType *dt = DatetimeType::constructSubtype( 
                                 TRUE,                           
                                 $2->getStartField(),
                                 $2->getEndField(),
                                 $2->getFractionPrecision(),
                                 PARSERHEAP()
                                 );
                                 if (dt == NULL) 
                                     {
                                     *SqlParser_Diags << DgSqlCode(-3158) <<          
                                     DgString0(""); // Error - invalid datetime
                                     YYERROR;
                                     }

                                 $$ = new (PARSERHEAP()) Cast (new (PARSERHEAP())
                                                               CurrentTimestamp(), dt);
                 }

     | TOK_CURRENT_TIME
				{
                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                       DatetimeType::SUBTYPE_SQLTime, 
                                                                       SQLTime::DEFAULT_FRACTION_PRECISION);
				}
     | TOK_CURRENT_TIME ts_left_unsigned_right
				{
				  if ($2 > DatetimeType::MAX_FRACTION_PRECISION)
				    {
				      *SqlParser_Diags << DgSqlCode(-3134)
						       << DgInt0($2);
				      YYERROR;
				    }

                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                       DatetimeType::SUBTYPE_SQLTime, 
                                                                       $2);
				}
     | TOK_CURRENT_TIMESTAMP
				{
                                  $$ = CurrentTimestamp::construct(PARSERHEAP());
				}
     | TOK_SYSTIMESTAMP
				{
                                  $$ = CurrentTimestamp::construct(PARSERHEAP());
				}
     | TOK_CURRENT_TIMESTAMP ts_left_unsigned_right
				{
				  if ($2 > DatetimeType::MAX_FRACTION_PRECISION)
				    {
				      *SqlParser_Diags << DgSqlCode(-3134)
						       << DgInt0($2);
				      YYERROR;
				    }

                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                       DatetimeType::SUBTYPE_SQLTimestamp, $2);
				}
     | TOK_CURRENT_RUNNING
				{
				  $$ = new (PARSERHEAP())
				    CurrentTimestampRunning();
				}

     | TOK_CURRENT_TIMESTAMP_RUNNING
				{
				  $$ = new (PARSERHEAP())
				    CurrentTimestampRunning();
				}
     | TOK_CURRENT_TIMESTAMP_UTC
        {
          $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_CURRENT_TIMESTAMP_UTC);
        }
     | TOK_CURRENT_TIME_UTC
        {
          $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_CURRENT_TIME_UTC);
        }
      /* ODBC extension, map TOK_CURTIME to TOK_CURRENT_TIME */
     | TOK_CURTIME '(' ')'
                                {
                                  $$ = CurrentTimestamp::construct(PARSERHEAP(),
                                                                       DatetimeType::SUBTYPE_SQLTime, 
                                                                       SQLTime::DEFAULT_FRACTION_PRECISION);
                                }
     | TOK_NOW '(' ')'
                                {
  /* ODBC extension, map TOK_NOW to TOK_CURRENT_TIMESTAMP */
                                  $$ = CurrentTimestamp::construct(PARSERHEAP());
                                }

    | TOK_UNIX_TIMESTAMP '(' ')'
                                {
                                   NAType * type;
                                   type = new (PARSERHEAP())
                                      SQLLargeInt(PARSERHEAP() , FALSE , FALSE);
                                   ItemExpr * ie = new (PARSERHEAP()) UnixTimestamp();
                                   $$ = new (PARSERHEAP()) Cast(ie, type);
                                }
    | TOK_UNIX_TIMESTAMP '(' value_expression ')'
                                {
                                   NAType * type;
                                   type = new (PARSERHEAP())
                                      SQLLargeInt(PARSERHEAP() , FALSE , FALSE);
                                   ItemExpr * ie = new (PARSERHEAP()) UnixTimestamp($3);
                                   $$ = new (PARSERHEAP()) Cast(ie, type);
				}
    | TOK_SYS_GUID '(' ')'
              {
                  ItemExpr * uniqueId =  new (PARSERHEAP()) BuiltinFunction(ITM_UNIQUE_ID_SYS_GUID, PARSERHEAP());
                  ItemExpr *conv = new (PARSERHEAP()) ConvertHex(ITM_CONVERTTOHEX, uniqueId);
                  NAType * type;
                  type = new (PARSERHEAP())
                       SQLVarChar(PARSERHEAP() , 32, FALSE);
                  $$ = new (PARSERHEAP()) Cast(conv,type);
              }
    | TOK_UUID '(' ')'
              {
                  ItemExpr * uniqueId =  new (PARSERHEAP()) BuiltinFunction(ITM_UNIQUE_ID, PARSERHEAP());
                  NAType * type;
                  type = new (PARSERHEAP())
                       SQLVarChar(PARSERHEAP() , 36, FALSE);
                  $$ = new (PARSERHEAP()) Cast(uniqueId,type);
              }
    | TOK_UUID_SHORT '(' ')'
              {
                  ItemExpr * uniqueId =  new (PARSERHEAP()) BuiltinFunction(ITM_UNIQUE_SHORT_ID, PARSERHEAP());
                  NAType * type;
                  type = new (PARSERHEAP())
                       SQLVarChar(PARSERHEAP() , 36, FALSE);
                  $$ = new (PARSERHEAP()) Cast(uniqueId,type);
              }

/* type item */
datetime_misc_function_used_as_default: TOK_TO_CHAR '(' value_expression ',' character_string_literal ')'
                               {
                                 NAString * ves= unicodeToChar
                                   (ToTokvalPlusYYText(&$3)->yytext,
                                   ToTokvalPlusYYText(&$3)->yyleng,
                                   (CharInfo::CharSet) (
                                          ComGetNameInterfaceCharSet() // CharInfo::UTF8
                                          ),
                                   PARSERHEAP()); 
                                 //save the original text
                                 NAString fullstr;
                                 fullstr  += "TO_CHAR(";
                                 //Column Reference will not be able to convert to NAString
                                 //And it is not be allowed bo become default value, so no need to save original text 
                                 if( ves != NULL) 
                                 {
                                   fullstr += *ves + ", '" +  *$5 + "')";
                                 }
                                 $$ = new (PARSERHEAP()) 
                                   DateFormat($3, *$5, DateFormat::FORMAT_TO_CHAR);
                                 ((DateFormat *)$$)->setOriginalString(fullstr);
                               }
/* type item */
datetime_misc_function : TOK_CONVERTTIMESTAMP '(' value_expression ')'
				{
				  $$ = new (PARSERHEAP())
				    ConvertTimestamp($3);
				}
     | TOK_DATEFORMAT '(' value_expression ',' date_format  ')'
                                {
                                  $$ = new (PARSERHEAP()) 
                                    DateFormat($3, *$5, 
                                               DateFormat::FORMAT_TO_CHAR,
                                               TRUE);
                                }
				    
     | TOK_DAYOFWEEK '(' value_expression ')'
				{
				  $$ = new (PARSERHEAP())
				    DayOfWeek($3);
				}
     | TOK_DAYOFYEAR '(' value_expression ')'
        {
	  $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_DAYOFYEAR, $3);
	}

     | TOK_DAYNAME '(' value_expression ')'
        {
	  $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_DAYNAME, $3);
	}  

     | TOK_FIRSTDAYOFYEAR '(' value_expression ')'
        {
	  $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_FIRSTDAYOFYEAR, $3);
	}  

     | TOK_DAYOFMONTH '(' value_expression ')'
        {
          $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_DAYOFMONTH, $3);
        }
     | TOK_MONTHNAME '(' value_expression ')'
        {
	  $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_MONTHNAME, $3);
	}  
     | TOK_QUARTER '(' value_expression ')'
        {
	  $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_QUARTER, $3);
	}  
     | TOK_WEEK '(' value_expression ')'
        {
	  $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_WEEK, $3);
	}  
 
     | TOK_JULIANTIMESTAMP '(' value_expression ')'
				{
				  $$ = new (PARSERHEAP())
				    JulianTimestamp($3);
				}

     | TOK_YEAR '(' value_expression ')'
                                {
				  $$ = new(PARSERHEAP())
				    ExtractOdbc(REC_DATE_YEAR, $3,
						TRUE);
				}
     | TOK_MONTH '(' value_expression ')'
                                {
				  $$ = new(PARSERHEAP())
				    ExtractOdbc(REC_DATE_MONTH, $3,
						TRUE);
				}
     | TOK_DAY '(' value_expression ')'
                                {
				  $$ = new(PARSERHEAP())
				    ExtractOdbc(REC_DATE_DAY, $3,
						TRUE);
                                }
      | TOK_HOUR '(' value_expression ')'
                                {
				  $$ = new(PARSERHEAP())
				    ExtractOdbc(REC_DATE_HOUR, $3, TRUE);
                                }
     | TOK_MINUTE '(' value_expression ')'
                                {
				  $$ = new(PARSERHEAP())
				    ExtractOdbc(REC_DATE_MINUTE, $3, TRUE);
                                }
     | TOK_SECOND '(' value_expression ')'
                                {
				  $$ = new(PARSERHEAP())
				    ExtractOdbc(REC_DATE_SECOND, $3, TRUE);
                                }
     | TOK_EXTEND '(' value_expression ',' datetime_qualifier ')'
                                {
                                DatetimeType *dt = 
                                        DatetimeType::constructSubtype( 
                                                TRUE,                           
                                                $5->getStartField(),
                                                $5->getEndField(),
                                                $5->getFractionPrecision(),
                                                PARSERHEAP()
                                                );
                                                if (dt == NULL) 
                                                { *SqlParser_Diags << DgSqlCode(-3158) <<  DgString0(""); // Error - invalid datetime
                                                        YYERROR;
                                                }

                                $$ = new (PARSERHEAP()) Cast ($3, dt);
                                }

     | TOK_EXTEND '(' value_expression ')'
                                {
                                DatetimeType *dt = new (PARSERHEAP())
                                                SQLTimestamp(PARSERHEAP(), TRUE, SQLTimestamp::DEFAULT_FRACTION_PRECISION);

                                $$ = new (PARSERHEAP()) Cast ($3, dt);
                                }
    | TOK_TO_BINARY '(' value_expression ',' unsigned_integer ')'
                               {
                                 ConstValue * cv = new (PARSERHEAP()) ConstValue($5);
                                 $$ = new (PARSERHEAP()) 
				   ZZZBinderFunction(ITM_TO_BINARY, $3, cv);
			       }
    | TOK_TO_BINARY '(' value_expression ')'
                               {
                                 $$ = new (PARSERHEAP()) 
				   ZZZBinderFunction(ITM_TO_BINARY, $3);
			       }
    | TOK_TO_CHAR '(' value_expression ')'
                               {
                                 $$ = new (PARSERHEAP()) 
                                   ZZZBinderFunction(ITM_TO_CHAR, $3);
			       }
    | TOK_TO_DATE '(' value_expression ',' character_string_literal ')'
                               {
                                 $$ = new (PARSERHEAP()) 
                                   DateFormat($3, *$5, DateFormat::FORMAT_TO_DATE);
			       }
   | TOK_TO_DATE '(' value_expression  ')'
                               {
				 $$ = new (PARSERHEAP()) 
				   DateFormat($3, "YYYY-MM-DD", DateFormat::FORMAT_TO_DATE);
			       }
    | TOK_TO_NUMBER '(' value_expression ')'
                               {
				 $$ = new (PARSERHEAP()) 
				   ZZZBinderFunction(ITM_TO_NUMBER, $3);
			       }
    | TOK_TO_TIME '(' value_expression ',' character_string_literal ')'
                               {
                                 $$ = new (PARSERHEAP()) 
                                   DateFormat($3, *$5, DateFormat::FORMAT_TO_TIME);
			       }
    | TOK_TO_TIMESTAMP '(' value_expression ')'
                               {
				 $$ = new (PARSERHEAP()) 
				   ZZZBinderFunction(ITM_TO_TIMESTAMP, $3);
			       }
    | TOK_SLEEP '(' numeric_literal_exact ')'
				{
				 $$ = new (PARSERHEAP()) 
				   SleepFunction( $3);
				}

CHAR_FUNC_optional_character_set : ',' CHAR_FUNC_character_set
	  {
	    $$ = $2;
	  }
      |   empty
	  {
	    $$ = CharInfo::ISO88591;
	  }

optional_character_set : ',' character_set
	  {
	    $$ = $2;
	  }
      |   empty
	  {
	    if ( SqlParser_DEFAULT_CHARSET == CharInfo::ISO88591 )
	       $$ = CharInfo::ISO88591;
	    else {
	       if (CmpCommon::getDefault(ALLOW_IMPLICIT_CHAR_CASTING) == DF_ON)
	          $$ = CharInfo::ISO88591; // Try to eliminate Translate nodes
	       else
	          $$ = CharInfo::UCS2;
	    }
	  }



/* type item */
string_function : 
      TOK_ASCII '(' value_expression ')'
	  {
	    /* ODBC extension: ASCII */
	    $$ = new (PARSERHEAP()) CodeVal(ITM_ASCII, $3);
	  }
     | TOK_CODE_VALUE '(' value_expression ')'
	  {
            // assume $3 is ASCII. CodeVal::synthesizeType() decides the type
            // based on the true type of $3. 
	    $$ = new (PARSERHEAP()) CodeVal(NO_OPERATOR_TYPE, $3);
	  }
     | TOK_CHAR '(' value_expression CHAR_FUNC_optional_character_set ')' 
	  {
	    if ( ($4 != CharInfo::ISO88591) && ($4 != CharInfo::UTF8) &&
                 ($4 != CharInfo::UCS2)     && ($4 != CharInfo::SJIS) )
	    {
	      *SqlParser_Diags << DgSqlCode(-3217) << DgString0(CharInfo::getCharSetName($4)) << DgString1("CHAR");
	      YYABORT;
	    }
	    $$ = new (PARSERHEAP()) CharFunc($4, $3);
	  }
     | TOK_CHR '(' value_expression CHAR_FUNC_optional_character_set ')' 
	  {
	    if (!(($4 == CharInfo::ISO88591) || ( CharInfo::maxBytesPerChar($4) == 2))){
	      *SqlParser_Diags << DgSqlCode(-3217) << DgString0(CharInfo::getCharSetName($4)) << DgString1("CHAR");
	      YYABORT;
	    }
	    $$ = new (PARSERHEAP()) CharFunc($4, $3);
	  }
     | TOK_CHAR_LENGTH '(' value_expression ')'
	 {
	    $$ = new (PARSERHEAP()) CharLength($3);
	 }

     | TOK_COALESCE '(' value_expression_list ')'
        {
	  $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_COALESCE,
						    $3);

	}  

     | TOK_CONVERTFROMHEX '('   value_expression   ')'
        {
           $$ = new (PARSERHEAP()) ConvertHex(ITM_CONVERTFROMHEX, $3);
        } 

     | TOK_UNHEX '('   value_expression   ')'
        {
           $$ = new (PARSERHEAP()) ConvertHex(ITM_CONVERTFROMHEX, $3);
        } 
     | TOK_FROM_HEX '('   value_expression   ')'
        {
           $$ = new (PARSERHEAP()) ConvertHex(ITM_CONVERTFROMHEX, $3);
        } 

     | TOK_CONVERTTOHEX   '('   value_expression   ')'
        {
          if ( (SqlParser_DEFAULT_CHARSET == CharInfo::ISO88591) ||
               (CmpCommon::getDefault(ALLOW_IMPLICIT_CHAR_CASTING) == DF_ON) )
          {
            $$ = new (PARSERHEAP()) ConvertHex(ITM_CONVERTTOHEX, $3);
          }
          else
          {
              $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_CONVERTTOHX, $3);
          }
        }
     | TOK_TO_HEX   '('   value_expression   ')'
        {
          $$ = new (PARSERHEAP()) ConvertHex(ITM_CONVERTTOHEX, $3);
        }
     | TOK_HEX   '('   value_expression   ')'
        {
          $$ = new (PARSERHEAP()) ConvertHex(ITM_CONVERTTOHEX, $3);
        }
     | TOK_CONVERTTOHX_INTN  '('   value_expression   ')'
        {
           $$ = new (PARSERHEAP()) ConvertHex(ITM_CONVERTTOHEX, $3);
        } 

	| TOK_DECODE '(' value_expression_list ')'
        {

	  $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_DECODE,$3);
        }

     | TOK_INSERT '(' value_expression ',' value_expression ',' 
		      value_expression ',' value_expression ')'
        {
	  $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_INSERT_STR,
						    $3, $5, $7, $9, NULL);
         SqlParser_CurrentParser->setIsHQCCacheable(FALSE);
	}  

     /* added ODBC extension: map LEFT(str,count) in ODBC to  */
     /* SUBSTRING(str FROM 1 FOR count) in SQL/MX             */
     | TOK_LEFT '(' value_expression ',' value_expression ')' 
        {
	  $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_LEFT,
						    $3, $5);
	}  

     /* ODBC extension: map LOCATE(str-exp1, str-exp2) to */
     /* POSITION(str-exp1 IN str-exp2)                    */
     | TOK_LOCATE '(' value_expression ',' value_expression ')'
        {
          $$ = new (PARSERHEAP()) PositionFunc($3,$5,NULL,NULL);
        }

     /* ODBC extension: map LOCATE(str-exp1, str-exp2, START) to */
     /* POSITION(str-exp1 IN str-exp2)                    */
    | TOK_LOCATE '(' value_expression ',' value_expression ',' value_expression ')'
 	   {
 	     $$ = new (PARSERHEAP()) PositionFunc($3,$5,$7,NULL); 
 	   }

     | TOK_LPAD '(' value_expression ',' value_expression ')'
                  {
		    $$ = 
		      new (PARSERHEAP()) ZZZBinderFunction(ITM_LPAD, $3, $5);
                  }
           
     | TOK_LPAD '(' value_expression ',' value_expression ',' value_expression ')'
                  {
		    $$ = 
		      new (PARSERHEAP()) ZZZBinderFunction(ITM_LPAD, $3, $5, $7);
                  }
           
     | TOK_RPAD '(' value_expression ',' value_expression ')'
                  {
		    $$ = 
		      new (PARSERHEAP()) ZZZBinderFunction(ITM_RPAD, $3, $5);
                  }
           
     | TOK_RPAD '(' value_expression ',' value_expression ',' value_expression ')'
                  {
		    $$ = 
		      new (PARSERHEAP()) ZZZBinderFunction(ITM_RPAD, $3, $5, $7);
                  }
           
     /* ODBC extension: map LTRIM(str) to TRIM(LEADING FROM str) */
     | TOK_LTRIM '(' value_expression ')'
	     { 
		$$ = new (PARSERHEAP()) Trim
                  ((Int32)Trim::LEADING,
                   NULL, 
                   $3); 
	     }

     | TOK_OCTET_LENGTH '(' value_expression ')'
                 {
                    $$ = new (PARSERHEAP()) OctetLength($3);
                 }

     | TOK_POSITION '(' value_expression TOK_IN value_expression ')'
                  {
                    $$ = new (PARSERHEAP()) PositionFunc($3,$5,NULL,NULL);
                  }

     | TOK_INSTR '(' value_expression TOK_IN value_expression ')'
                  {
                    $$ = new (PARSERHEAP()) PositionFunc($3,$5,NULL,NULL);
                  }

     | TOK_INSTR '(' value_expression ',' value_expression ')'
                  {
                    $$ = new (PARSERHEAP()) PositionFunc($5,$3,NULL,NULL);
                  }
     | TOK_INSTR '(' value_expression ',' value_expression ',' value_expression ')'
                  {
                    $$ = new (PARSERHEAP()) PositionFunc($5,$3,$7,NULL);
                  }
     | TOK_INSTR '(' value_expression ',' value_expression ',' value_expression ',' value_expression ')'
                  {
                    $$ = new (PARSERHEAP()) PositionFunc($5,$3,$7,$9);
                  }

     /* ODBC extension */
     | TOK_CONCAT '(' value_expression ',' value_expression ')'
                  {
                     $$ = new (PARSERHEAP()) Concat( $3, $5);
                  }

     | TOK_REPEAT '(' value_expression ',' value_expression ')'
                  {
		    $$ = new (PARSERHEAP()) Repeat ($3, $5);
		  }

     | TOK_REPEAT '(' value_expression ',' value_expression ',' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
                  {
                    Int64 value = atoInt64($7->data()); 
                    if (value == 0)
                      value = -1; 
		    $$ = new (PARSERHEAP()) Repeat 
                      ($3, $5, (Int32)value);
		  }

     | TOK_REPLACE '(' value_expression ',' value_expression ',' value_expression ')'
                  {
		    $$ = new (PARSERHEAP()) Replace ($3, $5, $7);
		  }

     | TOK_RIGHT '(' value_expression ',' value_expression ')'
                  {
		    $$ = 
		      new (PARSERHEAP()) ZZZBinderFunction(ITM_RIGHT, $3, $5);
                  }
     /* ODBC extension: RTRIM(str) is the same as TRIM(TRAILING FROM str) */
     | TOK_RTRIM '(' value_expression ')'
	{ 
            $$ = new (PARSERHEAP()) Trim
              ((Int32)Trim::TRAILING,
               NULL, 
               $3); 
        }

     | TOK_RTRIM '(' value_expression ',' value_expression ')'
	{ 
            $$ = new (PARSERHEAP()) Trim((Int32)Trim::TRAILING,
                                         $5, $3);
        }

     | TOK_SPACE '(' value_expression optional_character_set ')'
     	  {
                  switch ($4) {
		    case CharInfo::ISO88591:
		    case CharInfo::UTF8:
		    case CharInfo::SJIS:
		       $$ = new (PARSERHEAP()) ZZZBinderFunction( ITM_SPACE,
			    new (PARSERHEAP()) SystemLiteral(" ", CharInfo::ISO88591), $3);
                       break;

		    case CharInfo::KANJI_MP:
		    case CharInfo::KSC5601_MP:
		       $$ = new (PARSERHEAP()) ZZZBinderFunction( ITM_SPACE,
			    new (PARSERHEAP()) SystemLiteral("  ", CharInfo::ISO88591), $3);
                       break;
		    case CharInfo::UNICODE:
		       $$ = new (PARSERHEAP()) ZZZBinderFunction( ITM_SPACE, 
			    new (PARSERHEAP()) SystemLiteral(WIDE_(" "), CharInfo::UNICODE), $3);
                       break;

                    default:

                     if ( $4 == CharInfo::UnknownCharSet &&
                          Get_SqlParser_Flags(ALLOW_UNKNOWN_CHARSET)) {
		       $$ = new (PARSERHEAP()) ZZZBinderFunction( ITM_SPACE, 
			    new (PARSERHEAP()) SystemLiteral(" ", WIDE_(" ")), $3);
                     } else {
               // 3403: Function $0 does not take an operand with character set $4.
		    	*SqlParser_Diags << DgSqlCode(-3403) << 
                             DgString0("SPACE") <<
                             DgString1(CharInfo::getCharSetName($4));
		    	YYABORT;
		     }
		  }
         } 
     | TOK_SUBSTRING '(' value_expression TOK_FROM value_expression ')'
                                {
                                  $$ = new (PARSERHEAP())
				    Substring($3, $5);
                                }
     | TOK_SUBSTRING '(' value_expression TOK_FROM value_expression TOK_FOR value_expression ')'
                                {
                                  $$ = new (PARSERHEAP())
				    Substring($3, $5, $7);
                               }
     | TOK_SUBSTRING '(' value_expression TOK_FOR value_expression ')'
                     {
                       // Causes mxcmp to crash, so use ZZZBinderFunction for now.
                       // $$ = new (PARSERHEAP()) Substring($3,
                       //                         new (PARSERHEAP()) ConstValue(1),
                       //                         $7);
                       $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_SUBSTR, $3, $5);
                     }
     /* ODBC extension, SUBSTRING(string_exp,start,lenth) */
     | TOK_SUBSTRING '(' value_expression ',' value_expression ',' value_expression ')'
                                {
                                  $$ = new (PARSERHEAP())
				    Substring($3, $5, $7);
                               }
     | TOK_SUBSTRING '(' value_expression ',' value_expression ')'
                     {
                       $$ = new (PARSERHEAP()) Substring($3, $5);
                     }

     | TOK_SUBSTRING TOK_LPAREN_BEFORE_DATE_AND_LPAREN value_expression ',' value_expression ',' value_expression ')'
                                {
                                  $$ = new (PARSERHEAP())
				    Substring($3, $5, $7);
                               }

     /* ODBC extension, map UCASE(str) to UPPER(str) */
     | TOK_UCASE    '('   value_expression   ')'
        {
           $$ = new (PARSERHEAP()) Upper($3);
        }

     | TOK_UPPER    '('   value_expression   ')'
        {
           $$ = new (PARSERHEAP()) Upper($3);
        }
     | TOK_UPSHIFT    '('   value_expression   ')'
        {
           $$ = new (PARSERHEAP()) Upper($3);
        } 

     /* ODBC extension, map LCASE(str) to LOWER(str) */
     | TOK_LCASE    '('   value_expression   ')'
        {
           $$ = new (PARSERHEAP()) Lower($3);
        }

     | TOK_LOWER    '('   value_expression   ')'
        {
           $$ = new (PARSERHEAP()) Lower($3);
        }

     | TOK_TRIM '(' trim_operands ')'
                                {
                                  $$ = $3;
                                }

     | TOK_EXTRACT '(' datetime_field TOK_FROM value_expression ')'
				{
				  $$ = new (PARSERHEAP())
				    Extract($3, $5, FALSE);
				}
     | TOK_CONVERTTOBITS    '('   value_expression   ')'
        {
	  $$ = new (PARSERHEAP()) 
	    BuiltinFunction(ITM_CONVERTTOBITS, CmpCommon::statementHeap(), 1, $3);
        } 

     | TOK_TOKENSTR    '('   QUOTED_STRING ',' value_expression  ')'
        {
	  NAString nas = *$3;
//	  nas.toUpper();
	  nas = nas.strip(NAString::both);
	  if (nas.length() == 0)
	    YYERROR;
	  if (NOT nas.contains(":"))
	    {
	      nas.append(":");
	    }
	  nas.append(" ");

	  ConstValue * cv = new (PARSERHEAP()) ConstValue((char*)nas.data());

	  $$ = new (PARSERHEAP()) 
	    BuiltinFunction(ITM_TOKENSTR, CmpCommon::statementHeap(), 2, cv, $5);
        } 

     | TOK_REVERSE    '('   value_expression   ')'
        {
	  $$ = new (PARSERHEAP()) 
	    BuiltinFunction(ITM_REVERSE, CmpCommon::statementHeap(), 1, $3);
        } 

     | TOK_OVERLAY '(' value_expression TOK_PLACING value_expression TOK_FROM value_expression TOK_FOR value_expression ')'
                  {
		    $$ = 
		      new (PARSERHEAP()) ZZZBinderFunction(ITM_OVERLAY, $3, $5, $7, $9);
                  }

     | TOK_OVERLAY '(' value_expression TOK_PLACING value_expression TOK_FROM value_expression ')'
                  {
		    $$ = 
		      new (PARSERHEAP()) ZZZBinderFunction(ITM_OVERLAY, $3, $5, $7);
                  }
     | TOK_STUFF '(' value_expression ',' value_expression ',' value_expression ',' value_expression ')'
                  {
		    $$ = 
		      new (PARSERHEAP()) ZZZBinderFunction(ITM_OVERLAY, $3, $9, $5, $7);
                    ((ZZZBinderFunction*)$$)->setOverlayFuncWasStuff(TRUE);
                  }
     | TOK_SPLIT_PART '(' value_expression ',' value_expression ',' value_expression ')'
        {                     
               $$ = new (PARSERHEAP()) SplitPart($3, $5, $7);
        }


/* type item */
builtin_function_user : TOK_USER
				{
                                  if ( (SqlParser_DEFAULT_CHARSET == CharInfo::ISO88591) ||
                                       (CmpCommon::getDefault(ALLOW_IMPLICIT_CHAR_CASTING) == DF_ON) )
                                  {
				     $$ = new (PARSERHEAP())
				       AnsiUSERFunction(ITM_CURRENT_USER);
                                  }
                                  else
                                  {
	                            $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_CURRNT_USER);
                                  }
				}
                        | TOK_USER '(' ')'
				{
                                  if ( (SqlParser_DEFAULT_CHARSET == CharInfo::ISO88591) ||
                                       (CmpCommon::getDefault(ALLOW_IMPLICIT_CHAR_CASTING) == DF_ON) )
                                  {
				     $$ = new (PARSERHEAP())
				       AnsiUSERFunction(ITM_CURRENT_USER);
                                  }
                                  else
                                  {
	                            $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_CURRNT_USER);
                                  }
				}
                        | TOK_CURRENT_USER
                                {
                                  if ( (SqlParser_DEFAULT_CHARSET == CharInfo::ISO88591) ||
                                       (CmpCommon::getDefault(ALLOW_IMPLICIT_CHAR_CASTING) == DF_ON) )
                                  {
				     $$ = new (PARSERHEAP()) AnsiUSERFunction(ITM_CURRENT_USER);
                                  }
                                  else
                                  {
	                            $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_CURRNT_USER);
                                  }
                                }
                        | TOK_CURRNT_USR_INTN
				{
				  $$ = new (PARSERHEAP())
				    AnsiUSERFunction(ITM_CURRENT_USER);
				}
                        | TOK_SESSION_USER
                                {
                                  if ( (SqlParser_DEFAULT_CHARSET == CharInfo::ISO88591) ||
                                       (CmpCommon::getDefault(ALLOW_IMPLICIT_CHAR_CASTING) == DF_ON) )
                                  {
				     $$ = new (PARSERHEAP()) AnsiUSERFunction(ITM_SESSION_USER);
                                  }
                                  else
	                            $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_SESSN_USER);
                                }
                        | TOK_SESSN_USR_INTN
				{
				  $$ = new (PARSERHEAP())
				    AnsiUSERFunction(ITM_SESSION_USER);
				}

 /* type pElemDDL */
sg_identity_function : 
                  TOK_IDENTITY
                  {
                        $$ = new (PARSERHEAP()) ElemDDLSGOptions(
		                       1, /* SG_INTERNAL */
                                       NULL);
	          } 

                  |TOK_INTERNAL
                  {
                        $$ = new (PARSERHEAP()) ElemDDLSGOptions(
		                       3, /* SG_INTERNAL_COMPUTED */
                                       NULL);
	          } 
 	          
	          |TOK_IDENTITY '(' sequence_generator_options ')'
                    {
                    
		        $$ = new (PARSERHEAP()) ElemDDLSGOptions(
		                       1, /* SG_INTERNAL */
                                       $3 /*sequence_generator_option_list*/);
                                     
		    }  
	
/* type pElemDDL */
all_sequence_generator_options : empty
                                {
                                  $$ = NULL;
                                }
                      | sequence_generator_option_list
                      | reset_option
	                   
/* type pElemDDL */
sequence_generator_options : empty
                                {
                                  $$ = NULL;
                                }
                      | sequence_generator_option_list

/* type pElemDDL */
sequence_generator_option_list :   sequence_generator_option
		      | sequence_generator_option_list sequence_generator_option
                        {
                          $$ = new (PARSERHEAP())
                            ElemDDLOptionList(
                                              $1 /*sequence_generator_option_list*/,
                                              $2 /*sequence_generator_option*/);
                        }

/* type pElemDDL */
sequence_generator_option : start_with_option
                      | increment_option
		      | max_value_option
                      | min_value_option
                      | cycle_option
                      | cache_option
                      | datatype_option

/* type pElemDDL */
start_with_option : TOK_START TOK_WITH sg_sign NUMERIC_LITERAL_EXACT_NO_SCALE
    {
      // Validate that the value is not larger than
      // the maximum allowed for a LARGEINT. 

      NABoolean result = validateSGOption(TRUE, FALSE,(char *)$4->data(), "START WITH", "SEQUENCE");
      
      if (result == FALSE)
        YYERROR;

      Int64 value = atoInt64($4->data()); 
     if (NOT $3)
        value = -value;
       
      $$ = new (PARSERHEAP())
	ElemDDLSGOptionStartValue(value); 

    }
                                
/* type pElemDDL */                                
max_value_option : TOK_MAXVALUE sg_sign NUMERIC_LITERAL_EXACT_NO_SCALE
    {
      // Validate that the value is not larger than
      // the maximum allowed for a LARGEINT. 
      NABoolean result = validateSGOption(TRUE, FALSE, (char *)$3->data(), "MAXVALUE", "SEQUENCE");
      
      if (result == FALSE)
        YYERROR;

      Int64 value = atoInt64($3->data()); 
      if (NOT $2)
        value = -value;
      $$ = new (PARSERHEAP())
	ElemDDLSGOptionMaxValue(value /*Int64*/); 
    }
    
    | TOK_NO TOK_MAXVALUE               
     {
 
     $$ = new (PARSERHEAP())
            ElemDDLSGOptionMaxValue(TRUE);
  
     }
                                  
 /* type pElemDDL */
 min_value_option : TOK_MINVALUE sg_sign NUMERIC_LITERAL_EXACT_NO_SCALE
    {
      // Validate that the value is not larger than
      // the maximum allowed for a LARGEINT. 
         
      NABoolean result = validateSGOption(TRUE, FALSE, (char *)$3->data(), "MINVALUE", "SEQUENCE");
      
      if (result == FALSE)
        YYERROR;

      Int64 value = atoInt64($3->data()); 
      if (NOT $2)
        value = -value;
      $$ = new (PARSERHEAP())
	ElemDDLSGOptionMinValue(value /*Int64*/); 
     }
                                                                      
    | TOK_NO TOK_MINVALUE               
     {
 
     $$ = new (PARSERHEAP())
            ElemDDLSGOptionMinValue(TRUE);
  
     }
                                
 /* type pElemDDL */                             
 increment_option : TOK_INCREMENT TOK_BY sg_sign NUMERIC_LITERAL_EXACT_NO_SCALE
     {
      // Validate that the value is not larger than
      // the maximum allowed for a LARGEINT. 
         
       NABoolean result = validateSGOption(TRUE, TRUE, (char *)$4->data(), "INCREMENT BY", "SEQUENCE");
      
      if (result == FALSE)
        YYERROR;

      Int64 value = atoInt64($4->data()); 
      if (NOT $3)
	value = -value;

      $$ = new (PARSERHEAP())
	ElemDDLSGOptionIncrement(value /*Int64*/); 
     }
                                           
/* type pElemDDL */
cycle_option : TOK_CYCLE 
     {
        // CYCLE Option
        $$ = new (PARSERHEAP())
        ElemDDLSGOptionCycleOption(TRUE);
  
     } 
                                          
   | TOK_NO TOK_CYCLE               
     {
        // NO CYCLE Option
        $$ = new (PARSERHEAP())
        ElemDDLSGOptionCycleOption(FALSE);
  
     }

/* type pElemDDL */
reset_option : TOK_RESET
     {
        // RESET Option
        $$ = new (PARSERHEAP())
          ElemDDLSGOptionResetOption();
  
     } 
                                          
/* type pElemDDL */
cache_option : TOK_CACHE NUMERIC_LITERAL_EXACT_NO_SCALE
     {
       Int64 value = atoInt64($2->data()); 

        // CACHE Option
        $$ = new (PARSERHEAP())
	  ElemDDLSGOptionCacheOption(TRUE, value);
  
     } 
                                          
   | TOK_NO TOK_CACHE               
     {
        // NO CACHE Option
        $$ = new (PARSERHEAP())
	  ElemDDLSGOptionCacheOption(FALSE, 0);
  
     }
 
/* type pElemDDL */
datatype_option : int_type
     {
       NumericType * type = (NumericType*)$1;
       if (NOT DFS2REC::isBinaryNumeric(type->getFSDatatype()))
         YYERROR;

        // CACHE Option
        $$ = new (PARSERHEAP())
	  ElemDDLSGOptionDatatype((ComFSDataType)type->getFSDatatype());
     } 
                                          
     
/* type boolean */
sg_sign : empty { $$ = TRUE; }  // sequence generator option value sign
        | '+' { $$ = TRUE; }   
        | '-' { $$ = FALSE; }    
                                                                                                                                           
optional_round_scale : empty
  {
    $$ = NULL;
  }
  | ',' value_expression
  {
    $$ = $2;
  }
  
/* type item */
math_function :
         TOK_ABS '(' value_expression ')'
	 {
	   $$ = new (PARSERHEAP()) Abs($3);
	 }

       | TOK_MOD '(' value_expression ',' value_expression ')'
	 {
	   $$ = new (PARSERHEAP()) Modulus($3, $5);
	 }

       | TOK_RAND '(' ')'
	 {
       if (allowRandFunction()) {
         $$ = new (PARSERHEAP()) RandomNum(/* NULL */);
       } else {
         *SqlParser_Diags << DgSqlCode(-4313); 
         yyerror(""); YYABORT;
       }
	 }

       | TOK_RANDOM '(' ')'
	 {
       if (allowRandFunction()) {
         $$ = new (PARSERHEAP()) RandomNum(NULL, TRUE);
       } else {
         *SqlParser_Diags << DgSqlCode(-4313); 
         yyerror(""); YYABORT;
       }
	 }

       | TOK_RAND '(' value_expression ')'
	 {
       if (allowRandFunction()) {
         $$ = new (PARSERHEAP()) RandomNum($3);
       } else {
         *SqlParser_Diags << DgSqlCode(-4313); 
         yyerror(""); YYABORT;
       }
	 }

       | TOK_SIGN '(' value_expression ')'
         {
	   $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_SIGN, $3);
	 }

       | TOK_TRANSLATE '(' value_expression TOK_USING regular_identifier ')'
				{
				  $$ = new (PARSERHEAP()) Translate($3, $5);
				}
       | TOK_ROUND '(' value_expression optional_round_scale ')'
         {
            $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_ROUND, $3, $4);
         }

       | TOK_ROUND '(' value_expression ',' value_expression ',' value_expression ')'
         {
            $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_ROUND, $3, $5, $7);
         }

       | TOK_BITNOT '(' value_expression ')'
         {
	   $$ = new (PARSERHEAP()) BitOperFunc(ITM_BITNOT, $3);
	 }

       | TOK_BITAND '(' value_expression ',' value_expression ')'
         {
	   $$ = new (PARSERHEAP()) BitOperFunc(ITM_BITAND, $3, $5);
	 }

       | TOK_BITOR '(' value_expression ',' value_expression ')'
         {
	   $$ = new (PARSERHEAP()) BitOperFunc(ITM_BITOR, $3, $5);
	 }

       | TOK_BITXOR '(' value_expression ',' value_expression ')'
         {
	   $$ = new (PARSERHEAP()) BitOperFunc(ITM_BITXOR, $3, $5);
	 }

       | TOK_BITEXTRACT '(' value_expression ',' value_expression ',' value_expression ')'
         {
	   $$ = new (PARSERHEAP()) BitOperFunc(ITM_BITEXTRACT, $3, $5, $7);
	 }

       | TOK_LOG '(' value_expression ')'
         {
	   $$ = new (PARSERHEAP()) MathFunc(ITM_LOG, $3);
	 }

       | TOK_LOG '(' value_expression ',' value_expression ')'
         {
	   $$ = new (PARSERHEAP()) MathFunc(ITM_LOG, $3, $5);
	 }

       | math_func_0_operand '(' ')'
         {
	   $$ = new (PARSERHEAP()) MathFunc($1);
	 }

       | math_func_1_operand '(' value_expression ')'
         {
	   $$ = new (PARSERHEAP()) MathFunc($1, $3);
	 }

       | math_func_2_operands '(' value_expression ',' value_expression ')'
         {
	   $$ = new (PARSERHEAP()) MathFunc($1, $3, $5);
	 }

/* type operator_type */
math_func_0_operand :
              TOK_PI {$$ = ITM_PI;}

/* type operator_type */
math_func_1_operand :
              TOK_ACOS {$$ = ITM_ACOS;}
           |  TOK_ASIN {$$ = ITM_ASIN;}
           |  TOK_ATAN {$$ = ITM_ATAN;}
           |  TOK_CEIL {$$ = ITM_CEIL;}
           |  TOK_CEILING {$$ = ITM_CEIL;}
           |  TOK_COS {$$ = ITM_COS;}
           |  TOK_COSH {$$ = ITM_COSH;}
           |  TOK_DEGREES {$$ = ITM_DEGREES;}
           |  TOK_EXP {$$ = ITM_EXP;}
           |  TOK_FLOOR {$$ = ITM_FLOOR;}
           |  TOK_LOG10 {$$ = ITM_LOG10;}
           |  TOK_LOG2 {$$ = ITM_LOG2;}
           |  TOK_RADIANS {$$ = ITM_RADIANS;}
           |  TOK_SIN {$$ = ITM_SIN;}
           |  TOK_SINH {$$ = ITM_SINH;}
           |  TOK_SQRT {$$ = ITM_SQRT;}
           |  TOK_TAN {$$ = ITM_TAN;}
           |  TOK_TANH {$$ = ITM_TANH;}


/* type operator_type */
math_func_2_operands :
              TOK_ATAN2 {$$ = ITM_ATAN2;}
           |  TOK_POWER {$$ = ITM_POWER;}
//           |  TOK_TRUNCATE {$$ = ITM_SCALE_TRUNC;}


/* type item */
misc_function :
     TOK_OS_USERID '(' value_expression ')'
                                {
                                  $$ = new (PARSERHEAP())
				    MonadicUSERIDFunction($3);
                                }

     | TOK_USER '(' value_expression ')'
                                {
                                  $$ = new (PARSERHEAP())
				    ZZZBinderFunction(ITM_USER, $3);
                                }

     | TOK_AUTHNAME '(' value_expression ')'
                  {
                    $$ = new (PARSERHEAP())
                              ZZZBinderFunction(ITM_AUTHNAME, $3);
                  }

     | TOK_AUTHTYPE '(' value_expression ')'
                  {
                    $$ = new (PARSERHEAP())
                              ZZZBinderFunction(ITM_AUTHTYPE, $3);
                  }

     | TOK_CASE case_expression TOK_END
				{
				  $$ = $2;
				}

     | TOK_SHA  '(' value_expression ')'
                {
                    $$ = new (PARSERHEAP())
                    BuiltinFunction(ITM_SHA1,
                            CmpCommon::statementHeap(),
                            1, $3);
                }
     | TOK_SHA1  '(' value_expression ')'
                {
                    $$ = new (PARSERHEAP())
                    BuiltinFunction(ITM_SHA1,
                            CmpCommon::statementHeap(),
                            1, $3);
                }

     | TOK_SHA2 '(' value_expression ',' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
                {
                    int mode = atoInt64($5->data());
                    switch (mode) {
                    case 0:
                    case 256:
                        $$ = new (PARSERHEAP())
                        BuiltinFunction(ITM_SHA2_256,
                                        CmpCommon::statementHeap(),
                                        1, $3);
                        break;

                    case 224:
                        $$ = new (PARSERHEAP())
                        BuiltinFunction(ITM_SHA2_224,
                                        CmpCommon::statementHeap(),
                                        1, $3);
                        break;

                    case 384:
                        $$ = new (PARSERHEAP())
                        BuiltinFunction(ITM_SHA2_384,
                                        CmpCommon::statementHeap(),
                                        1, $3);
                        break;

                    case 512:
                        $$ = new (PARSERHEAP())
                        BuiltinFunction(ITM_SHA2_512,
                                        CmpCommon::statementHeap(),
                                        1, $3);
                        break;

                    default:
                        yyerror("The second operand expects 0, 224, 256, 384 or 512");
                        YYERROR;
                        break;
                    }

                }

     | TOK_MD5 '(' value_expression ')'
                {
                    $$ = new (PARSERHEAP())
                    BuiltinFunction(ITM_MD5,
                            CmpCommon::statementHeap(),
                            1, $3);
                }

     | TOK_CRC32 '(' value_expression ')'
                {
                    $$ = new (PARSERHEAP())
                    BuiltinFunction(ITM_CRC32,
                            CmpCommon::statementHeap(),
                            1, $3);
                }


     | TOK_GREATEST '(' value_expression ',' value_expression ')'
                  {
                    $$ = new (PARSERHEAP())
                      ZZZBinderFunction(ITM_GREATEST, $3, $5);
                  }

     | TOK_LEAST '(' value_expression ',' value_expression ')'
                  {
                    $$ = new (PARSERHEAP())
                      ZZZBinderFunction(ITM_LEAST, $3, $5);
                  }

     | TOK_NULLIFZERO '(' value_expression ')'
                                {
                  $$ = new (PARSERHEAP()) 
                    BuiltinFunction(ITM_NULLIFZERO, 
                            CmpCommon::statementHeap(), 
                            1, $3);
                }
     | TOK_ISIPV4 '(' value_expression ')'
                {
                    $$ = new (PARSERHEAP())
                    BuiltinFunction(ITM_ISIPV4,
                            CmpCommon::statementHeap(),
                            1, $3);
                }
     | TOK_ISIPV6 '(' value_expression ')'
                {
                    $$ = new (PARSERHEAP())
                    BuiltinFunction(ITM_ISIPV6,
                            CmpCommon::statementHeap(),
                            1, $3);
                }
     | TOK_INET_ATON '(' value_expression ')'
                {
                    $$ = new (PARSERHEAP())
                    BuiltinFunction(ITM_INET_ATON,
                            CmpCommon::statementHeap(),
                            1, $3);
                }
     | TOK_INET_NTOA '(' value_expression ')'
                {
                    $$ = new (PARSERHEAP())
                    BuiltinFunction(ITM_INET_NTOA,
                            CmpCommon::statementHeap(),
                            1, $3);
                }
     | TOK_ISNULL '(' value_expression ',' value_expression ')'
                  {
                    $$ = new (PARSERHEAP())
                              BuiltinFunction(ITM_NVL,
                                 CmpCommon::statementHeap(),
                                 2, $3, $5);
                  }

     | TOK_NVL '(' value_expression ',' value_expression ')'
                                {
				  $$ = new (PARSERHEAP()) 
				    BuiltinFunction(ITM_NVL, 
                                                    CmpCommon::statementHeap(),
						    2, $3, $5);
				}

    | TOK_JSONOBJECTFIELDTEXT '(' value_expression ',' value_expression ')'
    {
        $$ = new (PARSERHEAP()) 
        BuiltinFunction(ITM_JSONOBJECTFIELDTEXT, CmpCommon::statementHeap(), 2, $3, $5);
    }
     | TOK_NULLIF '(' value_expression ',' value_expression ')'
              {
                $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_NULLIF, $3, $5);
              }

     | TOK_QUERYID_EXTRACT '(' value_expression ',' value_expression ')'
                                {
				  $$ = new (PARSERHEAP()) 
				    BuiltinFunction(ITM_QUERYID_EXTRACT, 
                                                    CmpCommon::statementHeap(), 
						    2, $3, $5);
				}

     | TOK_ZEROIFNULL'(' value_expression ')'
                         {
			   $$ = new (PARSERHEAP()) 
			     ZZZBinderFunction(ITM_ZEROIFNULL, $3);
                         }

     | TOK_ENCODE_KEY '(' encode_key_cast_spec
       optional_encode_key_ordering_spec ')'
                                {
                                  $$ = new (PARSERHEAP())
                                    CompEncode ( $3, NOT $4 );
                                }
     | TOK_SOUNDEX '(' value_expression ')'
                {
                    $$ = new (PARSERHEAP())
                    BuiltinFunction(ITM_SOUNDEX,
                            CmpCommon::statementHeap(),
                            1, $3);
                }
     | TOK_SORT_KEY '(' value_expression optional_Collation_type optional_sort_direction ')'
                                {
                                  if ($5 != CollationInfo::DefaultDir  && $4 != CollationInfo::Sort)
                                  {
					                  yyerror(""); 
					                  YYERROR;
                                  }
                                  $$ = new (PARSERHEAP())
                                    CompEncode ( $3,  ($5 == CollationInfo::Descending)? TRUE : FALSE  , -1 ,$4);
                                  //((CompEncode *)$$)->setCollationEncode( TRUE);
                                }
                                
     | TOK_HASHPARTFUNC '(' value_expression_list TOK_FOR value_expression ')'
                                {
                                  $$ = new (PARSERHEAP())
                                    ProgDistrib(new (PARSERHEAP())
                                                HashDistPartHash($3),
                                                new (PARSERHEAP())
                                                Cast($5, new (PARSERHEAP())
                                                     SQLInt(PARSERHEAP(), FALSE, FALSE)));
                                }
     | TOK_HASH2PARTFUNC '(' value_expression_list TOK_FOR value_expression ')'
                                {
                                  $$ = new (PARSERHEAP())
                                    Hash2Distrib(new (PARSERHEAP())
                                                 HashDistPartHash($3),
                                                 new (PARSERHEAP())
                                                 Cast($5, new (PARSERHEAP())
                                                      SQLInt(PARSERHEAP(), FALSE, FALSE)));
                                }
     | TOK_RRPARTFUNC '(' value_expression TOK_FOR value_expression ')'
                                {
                             /*   $$ = new (PARSERHEAP())
                                    ProgDistrib(new (PARSERHEAP()) 
                                                Cast(new (PARSERHEAP()) 
                                                     Shift(ITM_SHIFT_RIGHT,
                                                           $3,
                                                           new (PARSERHEAP()) 
                                                           ConstValue(32)),
                                                     new (PARSERHEAP())
                                                     SQLInt(PARSERHEAP(), FALSE,FALSE)),
                                                new (PARSERHEAP())
                                                Cast($5, new (PARSERHEAP())
                                                     SQLInt(PARSERHEAP(), FALSE, FALSE))); */
                                }

     | TOK_DATE_PART '(' QUOTED_STRING ',' value_expression  ')'
                   {
                     // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                     rec_datetime_field         CmpOper = REC_DATE_UNKNOWN;

                     $3->toUpper();
                     if      ( *$3 == "YEAR"   ) CmpOper = REC_DATE_YEAR;
                     else if ( *$3 == "MONTH"  ) CmpOper = REC_DATE_MONTH;
                     else if ( *$3 == "DAY"    ) CmpOper = REC_DATE_DAY;
                     else if ( *$3 == "HOUR"   ) CmpOper = REC_DATE_HOUR;
                     else if ( *$3 == "MINUTE" ) CmpOper = REC_DATE_MINUTE;
                     else if ( *$3 == "SECOND" ) CmpOper = REC_DATE_SECOND;
                     else if ( *$3 == "YEARQUARTER" )  CmpOper = REC_DATE_YEARQUARTER_EXTRACT;
                     else if ( *$3 == "YEARMONTH" )    CmpOper = REC_DATE_YEARMONTH_EXTRACT;
                     else if ( *$3 == "YEARWEEK" )     CmpOper = REC_DATE_YEARWEEK_EXTRACT;
                     else if ( *$3 == "YEARQUARTERD" ) CmpOper = REC_DATE_YEARQUARTER_D_EXTRACT;
                     else if ( *$3 == "YEARMONTHD" )   CmpOper = REC_DATE_YEARMONTH_D_EXTRACT;
                     else if ( *$3 == "YEARWEEKD" )    CmpOper = REC_DATE_YEARWEEK_D_EXTRACT;

                     if (CmpOper == REC_DATE_UNKNOWN) {
                          *SqlParser_Diags << DgSqlCode(-3415)
                                           << DgString0("DATE_PART");
                          YYERROR;
                     }
                     else if (CmpOper == REC_DATE_YEARWEEK_EXTRACT)
                       $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_YEARWEEK, $5);
                     else if (CmpOper == REC_DATE_YEARWEEK_D_EXTRACT)
                       $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_YEARWEEKD, $5);
                     else $$ = new (PARSERHEAP()) Extract(CmpOper, $5, FALSE);
                   }

     | TOK_DATE_TRUNC '(' QUOTED_STRING ',' value_expression ')'
                      {
                        // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                        OperatorTypeEnum            OperTyp = INVALID_OPERATOR_TYPE;

                        $3->toUpper();
                        if      ( *$3 == "YEAR"   ) OperTyp = ITM_DATE_TRUNC_YEAR;
                        else if ( *$3 == "MONTH"  ) OperTyp = ITM_DATE_TRUNC_MONTH;
                        else if ( *$3 == "DAY"    ) OperTyp = ITM_DATE_TRUNC_DAY;
                        else if ( *$3 == "HOUR"   ) OperTyp = ITM_DATE_TRUNC_HOUR;
                        else if ( *$3 == "MINUTE" ) OperTyp = ITM_DATE_TRUNC_MINUTE;
                        else if ( *$3 == "SECOND" ) OperTyp = ITM_DATE_TRUNC_SECOND;
                        else if ( *$3 == "CENTURY" ) OperTyp =ITM_DATE_TRUNC_CENTURY;
                        else if ( *$3 == "DECADE" ) OperTyp = ITM_DATE_TRUNC_DECADE;

                        if (OperTyp == INVALID_OPERATOR_TYPE) {
                             *SqlParser_Diags << DgSqlCode(-3415)
                                              << DgString0("DATE_TRUNC");
                             YYERROR;
                        }
                        $$ = new (PARSERHEAP()) ZZZBinderFunction(OperTyp, $5);
                      }

     | TOK_TRUNC '(' value_expression ',' QUOTED_STRING ')'
                      {
                        // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                        OperatorTypeEnum            OperTyp = INVALID_OPERATOR_TYPE;

                        $5->toUpper();
                        if      ( *$5 == "YEAR"   ) OperTyp = ITM_DATE_TRUNC_YEAR;
                        else if ( *$5 == "MONTH"  ) OperTyp = ITM_DATE_TRUNC_MONTH;
                        else if ( *$5 == "DAY"    ) OperTyp = ITM_DATE_TRUNC_DAY;
                        else if ( *$5 == "D"    ) OperTyp = ITM_DATE_TRUNC_DAY;
                        else if ( *$5 == "HOUR"   ) OperTyp = ITM_DATE_TRUNC_HOUR;
                        else if ( *$5 == "MINUTE" ) OperTyp = ITM_DATE_TRUNC_MINUTE;
                        else if ( *$5 == "SECOND" ) OperTyp = ITM_DATE_TRUNC_SECOND;
                        else if ( *$5 == "CENTURY" ) OperTyp =ITM_DATE_TRUNC_CENTURY;
                        else if ( *$5 == "DECADE" ) OperTyp = ITM_DATE_TRUNC_DECADE;

                        if (OperTyp == INVALID_OPERATOR_TYPE) {
                             *SqlParser_Diags << DgSqlCode(-3415)
                                              << DgString0("DATE_TRUNC");
                             YYERROR;
                        }
                        $$ = new (PARSERHEAP()) ZZZBinderFunction(OperTyp, $3);
                      }

     | TOK_DATEDIFF '(' date_time_operand ',' value_expression ',' value_expression ')'
                      {
                        $$ = new (PARSERHEAP())
                             ZZZBinderFunction($3, $5, $7);
                      }

    | TOK_MONTHS_BETWEEN '(' value_expression ',' value_expression ')'
                      {
                        $$ = new (PARSERHEAP())
                             ZZZBinderFunction(ITM_MONTHS_BETWEEN, $3, $5);
		      }

     | TOK_TIMESTAMPDIFF '(' IDENTIFIER ',' value_expression ',' value_expression ')'
        {
          OperatorTypeEnum op = NO_OPERATOR_TYPE;
          $3->toUpper();
          if      ( *$3 == "SQL_TSI_YEAR"  )    op = ITM_TSI_YEAR;
          else if ( *$3 == "SQL_TSI_MONTH"  )   op = ITM_TSI_MONTH;
          else if ( *$3 == "SQL_TSI_DAY"  )     op = ITM_TSI_DAY;
          else if ( *$3 == "SQL_TSI_HOUR"  )    op = ITM_TSI_HOUR;
          else if ( *$3 == "SQL_TSI_MINUTE"  )  op = ITM_TSI_MINUTE;
          else if ( *$3 == "SQL_TSI_SECOND"  )  op = ITM_TSI_SECOND;
          else if ( *$3 == "SQL_TSI_QUARTER"  ) op = ITM_TSI_QUARTER;
          else if ( *$3 == "SQL_TSI_WEEK"  )    op = ITM_TSI_WEEK;
          else {
            *SqlParser_Diags << DgSqlCode(-3415)
                             << DgString0("TIMESTAMPDIFF");
            YYERROR;
          }
          $$ = new (PARSERHEAP()) ZZZBinderFunction(op, $5, $7);
        }

     | TOK_ADD_MONTHS '(' value_expression ',' value_expression ')'
                      {
                         NABoolean maybeNullable = TRUE;

                         if ($5 ->getOperatorType() == ITM_CONSTANT)
                           {
                            NABoolean dummyNegate = FALSE;
                            ConstValue *cv = $5->castToConstValue(dummyNegate);

                            if (cv->isNull())
                              { 
                               *SqlParser_Diags << DgSqlCode(-4097) << DgString0("Add_Months");
                               YYERROR;                        
                              } 
                            maybeNullable = FALSE;
                           }

                         SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), maybeNullable, REC_DATE_MONTH, 6, REC_DATE_MONTH, 1);
                         ItemExpr *iq2 =	new (PARSERHEAP()) Cast($5, iq);
                         $$ = new (PARSERHEAP())  BiArith(ITM_PLUS, $3,iq2);
						 ((BiArith*) $$)->setStandardNormalization();
                      }
	 | TOK_ADD_MONTHS '(' value_expression ',' value_expression ',' unsigned_integer ')'
                      {
                         NABoolean maybeNullable = TRUE;

                         if ($5 ->getOperatorType() == ITM_CONSTANT)
                           {
                            NABoolean dummyNegate = FALSE;
                            ConstValue *cv = $5->castToConstValue(dummyNegate);

                            if (cv->isNull())
                              { 
                               *SqlParser_Diags << DgSqlCode(-4097) << DgString0("Add_Months");
                               YYERROR;                        
                              }
                            maybeNullable = FALSE;
                           }

                         SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), maybeNullable, REC_DATE_MONTH, 6, REC_DATE_MONTH, 1);
                         ItemExpr *iq2 =	new (PARSERHEAP()) Cast($5, iq);
                         $$ = new (PARSERHEAP())  BiArith(ITM_PLUS, $3,iq2);
						 UInt32 value = $7;
					  	 if      ( value == 0 )
					  	   ((BiArith*) $$)->setStandardNormalization();
						 else if  ( value == 1 )
					  	   ((BiArith*) $$)->setKeepLastDay();
						 else {
                           yyerror("");   // emits syntax error 15001
                           YYERROR;
                         }
                      }
	 | TOK_DATE_ADD '(' value_expression ',' value_expression  ')'
                                {
                  $$ = new (PARSERHEAP()) 	BiArith(ITM_PLUS, $3, $5);
				  ((BiArith*) $$)->setStandardNormalization();
                }
	 | TOK_DATEADD '(' datetime_keywords ',' value_expression ')'		
                                {
                  $$ = new (PARSERHEAP())  BiArith(ITM_PLUS, $5, $3);
				  ((BiArith*) $$)->setStandardNormalization();
                }
	 | TOK_TIMESTAMPADD '(' timestamp_keywords ',' value_expression ')'		
      {
        $$ = new (PARSERHEAP())  BiArith(ITM_PLUS, $5, $3);
        ((BiArith*) $$)->setStandardNormalization();
      }
	 | TOK_DATE_SUB '(' value_expression ',' value_expression ')'
                                {
                  $$ = new (PARSERHEAP())  BiArith(ITM_MINUS, $3, $5);
				  ((BiArith*) $$)->setStandardNormalization();
                }

         | TOK_LAST_DAY '(' value_expression ')'
             {
	       $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_LAST_DAY, $3);
	     }

         | TOK_NEXT_DAY '(' value_expression ',' value_expression ')'
             {

	       $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_NEXT_DAY, $3, $5);
	     }

         | TOK_TRUNC '(' value_expression ',' unsigned_integer ')'
             {

	       ConstValue * cv = new (PARSERHEAP()) ConstValue($5);

	       $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_SCALE_TRUNC, $3, cv);
	     }
         | TOK_TRUNC '(' value_expression ')'
             {	       

	       ConstValue * cv = new (PARSERHEAP()) ConstValue(0);

	       $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_SCALE_TRUNC, $3, cv);
	     }
         | TOK_TRUNCATE '(' value_expression ',' unsigned_integer ')'
             {
	       ConstValue * cv = new (PARSERHEAP())ConstValue($5);

	       $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_SCALE_TRUNC, $3, cv);
	     }
         | TOK_UNIQUE_ID '(' ')'
                                {
				  $$ = new (PARSERHEAP()) 
				    BuiltinFunction(ITM_UNIQUE_ID, 
                                                    CmpCommon::statementHeap());
				}
         | TOK_COLUMN_LOOKUP '(' dml_column_reference ',' QUOTED_STRING ')'
                              {
				NAType * type = new(PARSERHEAP()) SQLVarChar(PARSERHEAP(), 100000);
				$$ = new (PARSERHEAP()) 
				    HbaseColumnLookup($3, *$5, type);
			      }
        | TOK_COLUMN_LOOKUP '(' dml_column_reference ',' QUOTED_STRING ',' TOK_CAST TOK_AS Set_Cast_Global_False_and_data_type ')'
                              {
				  HbaseColumnLookup * hcl = new (PARSERHEAP()) 
				    HbaseColumnLookup($3, *$5);

				  $$ = new (PARSERHEAP()) Cast(hcl, $9);
			      }
        | TOK_COLUMN_LOOKUP '(' dml_column_reference ',' QUOTED_STRING ',' TOK_TYPE TOK_AS Set_Cast_Global_False_and_data_type ')'
                              {
				  HbaseColumnLookup * hcl = new (PARSERHEAP()) 
				    HbaseColumnLookup($3, *$5, $9);
				  //				  $$ = hcl;
				  $$ = new (PARSERHEAP()) CastType(hcl, $9);
			      }

        | TOK_COLUMN_CREATE '(' hbase_column_create_list ')'
                              {

				// validate that all created cols use the same CAST/TYPE type,
				// or none.
				NAList<HbaseColumnCreate::HbaseColumnCreateOptions *> 
				  * hccol = $3;
				HbaseColumnCreate::HbaseColumnCreateOptions * hcco0 =
				  (*hccol)[0];

				HbaseColumnCreate * hcl = new (PARSERHEAP()) 
				    HbaseColumnCreate($3);

				if (hcco0->convType() == HbaseColumnCreate::HbaseColumnCreateOptions::CAST_AS)
				  $$ = new (PARSERHEAP()) Cast(hcl, hcco0->naType());
				else if (hcco0->convType() == HbaseColumnCreate::HbaseColumnCreateOptions::TYPE_AS)
				  $$ = new (PARSERHEAP()) CastType(hcl, hcco0->naType());
				else
				  $$ = hcl;
			      }
        | TOK_COLUMN_DISPLAY '(' dml_column_reference  ')'
                              {
				  $$ = new (PARSERHEAP()) 
				    HbaseColumnsDisplay($3);
			      }
        | TOK_COLUMN_DISPLAY '(' dml_column_reference ',' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
	                      {
				Int64 longIntVal = atoInt64($5->data());

				  $$ = new (PARSERHEAP()) 
				    HbaseColumnsDisplay($3, NULL, longIntVal);
			      }
       | TOK_COLUMN_DISPLAY '(' dml_column_reference ',' '(' quoted_string_list ')'  ')'
                              {
				  $$ = new (PARSERHEAP()) 
				    HbaseColumnsDisplay($3, $6);
			      }
        | TOK_COLUMN_DISPLAY '(' dml_column_reference ',' '(' quoted_string_list ')'  ',' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
	                      {
				Int64 longIntVal = atoInt64($9->data());

				  $$ = new (PARSERHEAP()) 
				    HbaseColumnsDisplay($3, $6, longIntVal);
			      }
        | TOK_SEQNUM '(' ddl_qualified_name  ')'
	                      {
				CorrName cn(*$3);
				cn.setSpecialType(ExtendedQualName::SG_TABLE);

				$$ = new(PARSERHEAP()) SequenceValue(cn);
			      }
        | TOK_SEQNUM '(' ddl_qualified_name ',' TOK_CURRENT ')'
	                      {
				CorrName cn(*$3);
				cn.setSpecialType(ExtendedQualName::SG_TABLE);

				$$ = new(PARSERHEAP()) SequenceValue(cn, TRUE, FALSE);
			      }
        | TOK_SEQNUM '(' ddl_qualified_name ',' TOK_NEXT ')'
	                      {
				CorrName cn(*$3);
				cn.setSpecialType(ExtendedQualName::SG_TABLE);

				$$ = new(PARSERHEAP()) SequenceValue(cn, FALSE, TRUE);
			      }

       | TOK_ROWNUM '(' ')'
                                {
                                  $$ = new (PARSERHEAP()) RowNumFunc();
                                }

       | TOK_HBASE_VERSION '(' dml_column_reference  ')'
                              {
                                $$ = new (PARSERHEAP()) HbaseVersionRef($3);
			      }

       | TOK_HBASE_TIMESTAMP '(' dml_column_reference  ')'
                              {
                                $$ = new (PARSERHEAP()) HbaseTimestampRef($3);
			      }
       | TOK_GROUPING_ID '(' value_expression_list ')'
             {
               $$ = new (PARSERHEAP()) ZZZBinderFunction(ITM_GROUPING_ID, $3);
             }
       | TOK_AES_ENCRYPT '(' value_expression ',' value_expression ',' value_expression ')'
             {
               $$ = new (PARSERHEAP()) BuiltinFunction(ITM_AES_ENCRYPT, CmpCommon::statementHeap(),
                                                       3, $3, $5, $7);
             }
       | TOK_AES_ENCRYPT '(' value_expression ',' value_expression ')'
             {
               $$ = new (PARSERHEAP()) BuiltinFunction(ITM_AES_ENCRYPT, CmpCommon::statementHeap(),
                                                       2, $3, $5);
             }
       | TOK_AES_DECRYPT '(' value_expression ',' value_expression ',' value_expression ')'
             {
               $$ = new (PARSERHEAP()) BuiltinFunction(ITM_AES_DECRYPT, CmpCommon::statementHeap(),
                                                       3, $3, $5, $7);
             }
       | TOK_AES_DECRYPT '(' value_expression ',' value_expression ')'
             {
               $$ = new (PARSERHEAP()) BuiltinFunction(ITM_AES_DECRYPT, CmpCommon::statementHeap(),
                                                       2, $3, $5);
             }
       | TOK_ENCODE_BASE64 '(' value_expression ')'
             {
               $$ = new (PARSERHEAP()) BuiltinFunction(ITM_ENCODE_BASE64, 
                                                       CmpCommon::statementHeap(),
                                                       1, $3);
             }
       | TOK_DECODE_BASE64 '(' value_expression ')'
             {
               $$ = new (PARSERHEAP()) BuiltinFunction(ITM_DECODE_BASE64, 
                                                       CmpCommon::statementHeap(),
                                                       1, $3);
             }

hbase_column_create_list : '(' hbase_column_create_value ')'
                                   {
				     NAList<HbaseColumnCreate::HbaseColumnCreateOptions *> * hccol =
				       new (PARSERHEAP()) 
				       NAList<HbaseColumnCreate::HbaseColumnCreateOptions *>(PARSERHEAP ());
				     hccol->insert($2);
				     $$ = hccol;
				   }
                               | hbase_column_create_value 
                                   {
				     NAList<HbaseColumnCreate::HbaseColumnCreateOptions *> * hccol =
				       new (PARSERHEAP()) 
				       NAList<HbaseColumnCreate::HbaseColumnCreateOptions *>(PARSERHEAP ());
				     hccol->insert($1);
				     $$ = hccol;
				   }
                              | '(' hbase_column_create_value ')' ',' hbase_column_create_list
                                 {
				   $5->insert($2);
				   $$ = $5;
				 }
hbase_column_create_value : value_expression ',' value_expression ',' TOK_TYPE TOK_AS Set_Cast_Global_False_and_data_type
                                {
				  HbaseColumnCreate::HbaseColumnCreateOptions * hcco =
				    new (PARSERHEAP()) HbaseColumnCreate::HbaseColumnCreateOptions
				    ($1, $3, $7, HbaseColumnCreate::HbaseColumnCreateOptions::TYPE_AS);
				  $$ = hcco;
				}
                             | value_expression ',' value_expression ',' TOK_CAST TOK_AS data_type
                                {
				  HbaseColumnCreate::HbaseColumnCreateOptions * hcco =
				    new (PARSERHEAP()) HbaseColumnCreate::HbaseColumnCreateOptions
				    ($1, $3, $7, HbaseColumnCreate::HbaseColumnCreateOptions::CAST_AS);
				  $$ = hcco;
				}
 
                            | value_expression ',' value_expression 
                                {
				  HbaseColumnCreate::HbaseColumnCreateOptions * hcco =
				    new (PARSERHEAP()) HbaseColumnCreate::HbaseColumnCreateOptions
				    ($1, $3, NULL, HbaseColumnCreate::HbaseColumnCreateOptions::NONE);
				  $$ = hcco;
				}

/* type operator_type */
date_time_operand : TOK_YEAR    { $$ = ITM_DATEDIFF_YEAR   ;}
                  | TOK_MONTH   { $$ = ITM_DATEDIFF_MONTH  ;}
                  | TOK_M       { $$ = ITM_DATEDIFF_MONTH  ;}
                  | TOK_DAY     { $$ = ITM_DATEDIFF_DAY    ;}
                  | TOK_D       { $$ = ITM_DATEDIFF_DAY    ;}
                  | TOK_HOUR    { $$ = ITM_DATEDIFF_HOUR   ;}
                  | TOK_MINUTE  { $$ = ITM_DATEDIFF_MINUTE ;}
                  | TOK_SECOND  { $$ = ITM_DATEDIFF_SECOND ;}
                  | TOK_QUARTER { $$ = ITM_DATEDIFF_QUARTER;}
                  | TOK_WEEK    { $$ = ITM_DATEDIFF_WEEK   ;}
                  | IDENTIFIER
                    {
                      $1->toUpper();
                      if      ( *$1 == "YYYY") $$ = ITM_DATEDIFF_YEAR;
                      else if ( *$1 == "YY"  ) $$ = ITM_DATEDIFF_YEAR;
                      else if ( *$1 == "MM"  ) $$ = ITM_DATEDIFF_MONTH;
                      else if ( *$1 == "DD"  ) $$ = ITM_DATEDIFF_DAY;
                      else if ( *$1 == "HH"  ) $$ = ITM_DATEDIFF_HOUR;
                      else if ( *$1 == "MI"  ) $$ = ITM_DATEDIFF_MINUTE;
                      else if ( *$1 == "N"   ) $$ = ITM_DATEDIFF_MINUTE;
                      else if ( *$1 == "SS"  ) $$ = ITM_DATEDIFF_SECOND;
                      else if ( *$1 == "S"   ) $$ = ITM_DATEDIFF_SECOND;
                      else if ( *$1 == "QQ"  ) $$ = ITM_DATEDIFF_QUARTER;
                      else if ( *$1 == "Q"   ) $$ = ITM_DATEDIFF_QUARTER;
                      else if ( *$1 == "WK"  ) $$ = ITM_DATEDIFF_WEEK;
                      else if ( *$1 == "WW"  ) $$ = ITM_DATEDIFF_WEEK;
                      else {
                           *SqlParser_Diags << DgSqlCode(-3415)
                                            << DgString0("DATEDIFF");
                           YYERROR;
                      }
                    }

// The value_expression must be cast to the Token Type
/* type token */
datetime_keywords : TOK_QUARTER  ',' value_expression 		  // 3 months	Cast 3*num_expr to months
                   	{
					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_MONTH, 6, REC_DATE_MONTH, 1);
					$$ = new (PARSERHEAP()) 
					       Cast(new (PARSERHEAP())BiArith(ITM_TIMES, $3,  new (PARSERHEAP()) ConstValue(3)), iq);
					}                    
                   | TOK_WEEK   ',' value_expression 		  // 7 days	  Cast 7*num_expr to days
                    {
					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_DAY, 6, REC_DATE_DAY, 1);
					$$ = new (PARSERHEAP()) 
					       Cast(new (PARSERHEAP())BiArith(ITM_TIMES, $3,  new (PARSERHEAP()) ConstValue(7)), iq);
					}
                   | TOK_YEAR   ',' value_expression
				    {
					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_YEAR, 6, REC_DATE_YEAR, 1);
					$$ = new (PARSERHEAP()) Cast($3, iq);
					}
                   | TOK_MONTH  ',' value_expression 
				    {
					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_MONTH, 6, REC_DATE_MONTH, 1);
					$$ = new (PARSERHEAP()) Cast($3, iq);
					}
				   | TOK_DAY    ',' value_expression 
                   	{
					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_DAY, 6, REC_DATE_DAY, 1);
					$$ = new (PARSERHEAP()) Cast($3, iq);
					}
                   | TOK_M  ',' value_expression 
				    {
					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_MONTH, 6, REC_DATE_MONTH, 1);
					$$ = new (PARSERHEAP()) Cast($3, iq);
					}
				   | TOK_D    ',' value_expression 
                   	{
					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_DAY, 6, REC_DATE_DAY, 1);
					$$ = new (PARSERHEAP()) Cast($3, iq);
					}                   
                   | TOK_HOUR   ',' value_expression
                    {
					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_HOUR, 8, REC_DATE_HOUR, 1);
					$$ = new (PARSERHEAP()) Cast($3, iq);
					}                    
                   | TOK_MINUTE ',' value_expression
				    {
					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_MINUTE, 10, REC_DATE_MINUTE, 1);
					$$ = new (PARSERHEAP()) Cast($3, iq);
					}                    
                   | TOK_SECOND ',' value_expression 
				    {
					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_SECOND, 12, REC_DATE_SECOND, 1);
					$$ = new (PARSERHEAP()) Cast($3, iq);
					}
				   | IDENTIFIER ',' value_expression
                    {
                      $1->toUpper();
                      if      ( *$1 == "YYYY" | *$1 == "YY" )
					    {
					      SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_YEAR, 6, REC_DATE_YEAR, 1);
					      $$ = new (PARSERHEAP()) Cast($3, iq);
					    }
                      else if ( *$1 == "MM" ) 
				        {
					      SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_MONTH, 6, REC_DATE_MONTH, 1);
					      $$ = new (PARSERHEAP()) Cast($3, iq);
					    }                       
                      else if ( *$1 == "DD" ) 
                   	    {
					       SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_DAY, 6, REC_DATE_DAY, 1);
					       $$ = new (PARSERHEAP()) Cast($3, iq);
					    }                       
                      else if ( *$1 == "HH"  ) 
                        {
        					SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_HOUR, 8, REC_DATE_HOUR, 1);
		        			$$ = new (PARSERHEAP()) Cast($3, iq);
					    }
                      else if ( *$1 == "MI" | *$1 == "N" ) 
				        {
				       	   SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_MINUTE, 10, REC_DATE_MINUTE, 1);
				       	   $$ = new (PARSERHEAP()) Cast($3, iq);
					    }                       
                      else if ( *$1 == "SS" | *$1 == "S" ) 
				        {
					      SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_SECOND, 12, REC_DATE_SECOND, 1);
					      $$ = new (PARSERHEAP()) Cast($3, iq);
					    }                        
                      else if ( *$1 == "QQ" | *$1 == "Q" ) 
                        {
					      SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_MONTH, 6, REC_DATE_MONTH, 1);
					      $$ = new (PARSERHEAP()) 
					             Cast(new (PARSERHEAP())BiArith(ITM_TIMES, $3,  new (PARSERHEAP()) ConstValue(3)), iq);
					    }                       
                      else if ( *$1 == "WK" | *$1 == "WW" ) 
                       	{
				         SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_DAY, 6, REC_DATE_DAY, 1);
					     $$ = new (PARSERHEAP()) 
					          Cast(new (PARSERHEAP())BiArith(ITM_TIMES, $3,  new (PARSERHEAP()) ConstValue(7)), iq);
				     	}
                      else {
                           *SqlParser_Diags << DgSqlCode(-3415)
                                            << DgString0("DATEADD");
                           YYERROR;
                      }
					}

timestamp_keywords : IDENTIFIER ',' value_expression
  {
    $1->toUpper();
    if ( *$1 == "SQL_TSI_YEAR" )
      {
        SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_YEAR, 6, REC_DATE_YEAR, 1);
        $$ = new (PARSERHEAP()) Cast($3, iq);
      }
    else if ( *$1 == "SQL_TSI_MONTH" )
      {
        SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_MONTH, 6, REC_DATE_MONTH, 1);
        $$ = new (PARSERHEAP()) Cast($3, iq);
      }
    else if ( *$1 == "SQL_TSI_DAY" )
      {
        SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_DAY, 6, REC_DATE_DAY, 1);
        $$ = new (PARSERHEAP()) Cast($3, iq);
      }
    else if ( *$1 == "SQL_TSI_HOUR" )
      {
        SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_HOUR, 8, REC_DATE_HOUR, 1);
        $$ = new (PARSERHEAP()) Cast($3, iq);
      }
    else if ( *$1 == "SQL_TSI_MINUTE" )
      {
        SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_MINUTE, 10, REC_DATE_MINUTE, 1);
        $$ = new (PARSERHEAP()) Cast($3, iq);
      }
    else if ( *$1 == "SQL_TSI_SECOND" )
      {
        SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_SECOND, 12, REC_DATE_SECOND, 1);
        $$ = new (PARSERHEAP()) Cast($3, iq);
      }
    else if ( *$1 == "SQL_TSI_QUARTER" )
      {
        SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_MONTH, 6, REC_DATE_MONTH, 1);
        $$ = new (PARSERHEAP()) 
              Cast(new (PARSERHEAP())BiArith(ITM_TIMES, $3,  new (PARSERHEAP()) ConstValue(3)), iq);
      }
    else if ( *$1 == "SQL_TSI_WEEK" )
      {
        SQLInterval *iq = new (PARSERHEAP()) SQLInterval(PARSERHEAP(), TRUE, REC_DATE_DAY, 6, REC_DATE_DAY, 1);
        $$ = new (PARSERHEAP()) 
        Cast(new (PARSERHEAP())BiArith(ITM_TIMES, $3,  new (PARSERHEAP()) ConstValue(7)), iq);
      }
    else 
      {
        *SqlParser_Diags << DgSqlCode(-3415)
                         << DgString0("TIMESTAMPADD");
        YYERROR;
      }
  }

/* type item */
encode_key_cast_spec : cast_specification

                   | TOK_LOW_VALUE '(' data_type
                     optional_cast_spec_not_null_spec ')'
				{
                                  if ($4) // NOT NULL phrase specified
                                  {
                                    $3->setNullable(FALSE);
                                  }
                                  $$ = new (PARSERHEAP())
                                    ConstValue($3,      // datatype
	                                       TRUE,    // wantMinValue
	                                       NOT $4); // allowNull
				}
                   | TOK_HIGH_VALUE '(' data_type
                      optional_cast_spec_not_null_spec ')'
				{
                                  if ($4) // NOT NULL phrase specified
                                  {
                                    $3->setNullable(FALSE);
                                  }
                                  $$ = new (PARSERHEAP())
                                    ConstValue($3,      // datatype
	                                       FALSE,   // wantMinValue
	                                       NOT $4); // allowNull
				}
                   | TOK_LOW_VALUE TOK_LPAREN_BEFORE_DATATYPE data_type
                     optional_cast_spec_not_null_spec ')'
				{
                                  if ($4) // NOT NULL phrase specified
                                  {
                                    $3->setNullable(FALSE);
                                  }
                                  $$ = new (PARSERHEAP())
                                    ConstValue($3,      // datatype
	                                       TRUE,    // wantMinValue
	                                       NOT $4); // allowNull
				}
                   | TOK_HIGH_VALUE TOK_LPAREN_BEFORE_DATATYPE data_type
                      optional_cast_spec_not_null_spec ')'
				{
                                  if ($4) // NOT NULL phrase specified
                                  {
                                    $3->setNullable(FALSE);
                                  }
                                  $$ = new (PARSERHEAP())
                                    ConstValue($3,      // datatype
	                                       FALSE,   // wantMinValue
	                                       NOT $4); // allowNull
				}

/* type boolean */
optional_encode_key_ordering_spec : empty
                                {
                                  $$ = TRUE; // default is ASC(ENDING)
                                }

     | TOK_ASC
                                {
                                  $$ = TRUE;
                                }

     | TOK_DESC
                                {
                                  $$ = FALSE;
                                }
/*type CollationType*/                                
optional_Collation_type:  empty
			  {
			    $$ = CollationInfo::Sort;
			  }
			| TOK_FOR TOK_SORT
			  {
			    $$ = CollationInfo::Sort;
			  }
			| TOK_FOR TOK_COMPARE
			  {
			    $$ = CollationInfo::Compare;
			  }
			| TOK_FOR TOK_STRING_SEARCH
			  {
			    $$ = CollationInfo::Search;
			  }
/*type SortDirection*/                                
optional_sort_direction:  empty
			  {
			    $$ = CollationInfo::DefaultDir;
			  }
			| TOK_ASC
			  {
			    $$ = CollationInfo::Ascending;
			  }
			|  TOK_DESC
			  {
			    $$ = CollationInfo::Descending;
			  }

			
/* type item */
trim_operands : value_expression
        { 
            $$ = new (PARSERHEAP()) Trim
              (Trim::BOTH,
               NULL,
               $1); 
        }
     | TOK_FROM value_expression
        { 
          $$ = new (PARSERHEAP()) Trim
            (Trim::BOTH,
             NULL,
             $2); 
        }
     | trim_spec TOK_FROM value_expression
        { 
          $$ = new (PARSERHEAP()) Trim
            ($1,
             NULL,
             $3); 
        }
     | value_expression TOK_FROM value_expression
        { $$ = new (PARSERHEAP()) Trim(Trim::BOTH, $1, $3); }
     | trim_spec value_expression TOK_FROM value_expression
        { $$ = new (PARSERHEAP()) Trim($1,$2,$4); }

/* type uint */
trim_spec : TOK_LEADING     {  $$ = (Int32) Trim::LEADING;  }
        | TOK_TRAILING      {  $$ = (Int32) Trim::TRAILING; }
        | TOK_BOTH          {  $$ = (Int32) Trim::BOTH;     }

/* type stringval */
date_format : TOK_DEFAULT   
    {  
      $$ = new (PARSERHEAP()) NAString(ExpDatetime::getDatetimeFormatStr(ExpDatetime::DATETIME_FORMAT_DEFAULT));
    }
	| TOK_EUROPEAN      
    {  
      $$ = new (PARSERHEAP()) NAString(ExpDatetime::getDatetimeFormatStr(ExpDatetime::DATETIME_FORMAT_EUROPEAN));
    }
	| TOK_USA           
    {  
      $$ = new (PARSERHEAP()) NAString(ExpDatetime::getDatetimeFormatStr(ExpDatetime::DATETIME_FORMAT_USA));
    }


/* type item */
case_expression : case_operand simple_when_then_list
				{
				  $$ = new (PARSERHEAP())
				    Case($1, $2);
				}
		| searched_when_then_list
				{
				  $$ = new (PARSERHEAP())
				    Case(NULL, $1);
				}

/* type item */
case_operand : value_expression
			{
			  $$ = $1;
			}

/* type item */
simple_when_then_list : simple_when_then else_clause
			{
			  ((IfThenElse *) $1)->setElse($2);
			  $$ = $1;
			}
		| simple_when_then simple_when_then_list
			{
			  ((IfThenElse *) $1)->setElse($2);
			  $$ = $1;
			}

/* type item */
simple_when_then : TOK_WHEN value_expression TOK_THEN result_expr
			{
			  $$ = new (PARSERHEAP())
			    IfThenElse($2, $4, NULL);
			}

/* type item */
searched_when_then_list : searched_when_then else_clause
			{
			  ((IfThenElse *) $1)->setElse($2);
			  $$ = $1;
			}
		| searched_when_then searched_when_then_list
			{
			  ((IfThenElse *) $1)->setElse($2);
			  $$ = $1;
			}

/* type item */
searched_when_then : TOK_WHEN search_condition TOK_THEN result_expr
			{
			  $$ = new (PARSERHEAP())
			    IfThenElse($2, $4, NULL);
			}

/* type item */
else_clause : TOK_ELSE result_expr
			{
			  $$ = $2;
			}
		| /* empty */
			{
			  // same as ELSE NULL
			  $$ = new (PARSERHEAP()) SystemLiteral();
			}

/* type item */
result_expr : value_expression
			{
			  $$ = $1;
			}

/* type boolean */
optional_cast_spec_not_null_spec : empty
                                {
                                  $$ = FALSE; // NOT NULL phrase not specified
                                }

     | TOK_NOT TOK_NULL
                                {
                                  $$ = TRUE;  // NOT NULL phrase specified
                                }

optional_nullable_pkey: empty
                                {
                                  if (CmpCommon::getDefault(ALLOW_NULLABLE_UNIQUE_KEY_CONSTRAINT) == DF_OFF)
                                    $$ = FALSE;
                                  else
                                    $$ = TRUE;
                                }
     | TOK_NULLABLE
                                {
                                  $$ = TRUE;
                                }

/* type item */
cast_specification : TOK_CAST '(' value_expression  TOK_AS  Set_Cast_Global_False_and_data_type
                                  optional_cast_spec_not_null_spec ')'
				{
				  $$ = new (PARSERHEAP()) Cast($3, $5);
                                  if ($6) // NOT NULL phrase specified
                                  {
                                    $5->setNullable(FALSE);
                                  }
                                  if ( cast_target_cs_specified )
                                  {
                                     ((Cast *)$$)->setTgtCSSpecified(TRUE);
                                     cast_target_cs_specified = FALSE ;
                                  }
				}

                   /* ODBC extension, map CONVERT(expression, data-type) to */
                   /* CAST( expression AS data-type)                        */ 
                   | TOK_CONVERT '(' value_expression ',' {empty_charlen_specifier_allowed =TRUE;} data_type ')'
                                {
                                  $$ = new (PARSERHEAP())
                                    CastConvert($3, $6);
                                  empty_charlen_specifier_allowed = FALSE;
                                }
                      // source is not converted. It is only interpreted as data_type.
                   | TOK_TYPECAST '(' value_expression ',' data_type ')'
                                {
                                  $$ = new (PARSERHEAP())
                                    CastType($3, $5);
                                  empty_charlen_specifier_allowed = FALSE;
                                }
                   | TOK_CAST '(' value_expression TOK_AS TOK_NULLABLE ')'
                                {
                                  $$ = new (PARSERHEAP())
                                    CastType($3, TRUE);
                                  empty_charlen_specifier_allowed = FALSE;
                                }

/* proc_arg_data_type are the types that are generated by the preprocessor
   as the arguments of a PROCEDURE statement. The tandem_float_type are the
   float types that represent the hostvars which are declared as tandem
   float datatype */
proc_arg_data_type : predefined_type
	    {
	      if ($1->isExternalType()) {
	        externalDataTypeCnt_++;
		size_t i = 0;
		NAString nam($1->getTypeSQLname(TRUE/*terse*/));
		if ($1->getTypeQualifier() == NA_CHARACTER_TYPE)
		  if (((CharType *)$1)->isNullTerminated())
		    if (nam[i] == 'C' || nam[i] == 'V')
		      nam = "ANSIVARCHAR";
		i = nam.index(' ');
		if (i != NA_NPOS && i > 0) nam.remove(i);
		i = nam.index('(');
		if (i != NA_NPOS && i > 0) nam.remove(i);
		nam.prepend(" ");
		nam.append(" ");
		if (!strstr(*externalDataTypeNames_, nam))
		  *externalDataTypeNames_ += nam;
	      }
	      
	      // bignum not allowed as proc arguments generated by preprocessor
	      if (($1->getTypeQualifier() == NA_NUMERIC_TYPE) &&
		  (((NumericType *)$1)->isBigNum()))
		{
		  *SqlParser_Diags << DgSqlCode(-3165) << DgString0("NUMERIC");
		  YYERROR;
		}
	    }
	  | proc_arg_rowset_type
          | proc_arg_float_type
            {
	      if ($1->isExternalType())
	        externalDataTypeCnt_++;
	    }

/* Note:
 * pic_type can be string or numeric and is syntactic sugar not representing
 * any distinct SQL data types. It is simply cobolesque type syntax. */

/* type na_type */
data_type : predef_type | rowset_type

/* type na_type */
predef_type : predefined_type
	    {
	      if ($1->isExternalType()) {
	        externalDataTypeCnt_++;
		size_t i = 0;
		NAString nam($1->getTypeSQLname(TRUE/*terse*/));
		if ($1->getTypeQualifier() == NA_CHARACTER_TYPE)
		  if (((CharType *)$1)->isNullTerminated())
		    if (nam[i] == 'C' || nam[i] == 'V')
		      nam = "ANSIVARCHAR";
		i = nam.index(' ');
		if (i != NA_NPOS && i > 0) nam.remove(i);
		i = nam.index('(');
		if (i != NA_NPOS && i > 0) nam.remove(i);
		nam.prepend(" ");
		nam.append(" ");
		if (!strstr(*externalDataTypeNames_, nam))
		  *externalDataTypeNames_ += nam;
	      }
	    }
          | float_type

/* type na_type */
predefined_type : date_time_type
		| interval_type
		| numeric_type
		| pic_type
		| string_type
                | blob_type
                | boolean_type


/* type na_type */
rowset_type : TOK_ROWSET unsigned_integer predefined_type
	      {
		$$ = new (PARSERHEAP()) SQLRowset(PARSERHEAP(), $3, $2, $2);
	      }
             | TOK_ROWSET unsigned_integer float_type
	      {
		$$ = new (PARSERHEAP()) SQLRowset(PARSERHEAP(), $3, $2, $2);
	      }

/* type na_type */
proc_arg_rowset_type : TOK_ROWSET unsigned_integer predefined_type
	      {
		$$ = new (PARSERHEAP()) SQLRowset(PARSERHEAP(), $3, $2, $2);
	      }
             | TOK_ROWSET unsigned_integer proc_arg_float_type
	      {
		$$ = new (PARSERHEAP()) SQLRowset(PARSERHEAP(), $3, $2, $2);
	      }

/* type na_type */
numeric_type : non_int_type
	     | int_type

/* na type for the numeric */
int_type : TOK_INTEGER signed_option
             {
		$$ = new (PARSERHEAP()) SQLInt(PARSERHEAP(),  $2, TRUE);
             }
	 | TOK_SMALLINT signed_option
             {
		$$ = new (PARSERHEAP()) SQLSmall( PARSERHEAP(), $2, TRUE);
             }
	 | TOK_LARGEINT signed_option
             {
               $$ = new (PARSERHEAP()) SQLLargeInt(PARSERHEAP(),  $2, TRUE);
             }
         | TOK_BIGINT signed_option
             {
                if (!$2) {
                  // UNSIGNED specified. Error. Largeint must be signed. 
                  *SqlParser_Diags << DgSqlCode(-3130);
                  // YYABORT;
                  yyerror(""); 
                  YYERROR;
                }
                $$ = new (PARSERHEAP()) SQLLargeInt (PARSERHEAP(), $2,TRUE);
                // ((SQLLargeInt *)$$)->setDisplayDataType("BIGINT");
	     }
	 | TOK_BIT TOK_PRECISION TOK_INTEGER left_unsigned_right signed_option
             {
		if ($5 == TRUE) {
		  // ParserError: UNSIGNED expected
                   *SqlParser_Diags << DgSqlCode(-3125);
		   YYABORT;
		}
		if ($4 < 1 || $4 > 15) {
		  // Parser Error: An unsigned integer between 1 and 15 expected
                   *SqlParser_Diags << DgSqlCode(-3126);
		   YYABORT;
		}
		$$ = new (PARSERHEAP()) SQLBPInt (PARSERHEAP(), $4, TRUE, FALSE);
	     }
	 | TOK_BIT
       { 
         // odbc SQL_BIT is single bit binary data
         $$ = new (PARSERHEAP()) SQLChar(PARSERHEAP(), 1);
         // ((SQLChar *)$$)->setDisplayDataType("BIT");
       }
	 | TOK_TINYINT signed_option
       {
         // odbc SQL_TINYINT is exact numeric value with precision 3 &
         // scale 0. signed: -128<=n<=127, unsigned: 0<=n<=255.
         if (CmpCommon::getDefault(TRAF_TINYINT_SUPPORT) == DF_OFF)
           $$ = new (PARSERHEAP()) SQLSmall(PARSERHEAP(),  $2, TRUE);
         else
           $$ = new (PARSERHEAP()) SQLTiny(PARSERHEAP(),  $2, TRUE);
       }
	 | TOK_BYTEINT signed_option
       {
         // For TD compatibility, we map BYTEINT to TINYINT/SMALLINT
         // BYTEINT is supposed to be exact numeric value with precision 3 &
         // scale 0. signed: -128<=n<=127, unsigned: 0<=n<=255.
         if (CmpCommon::getDefault(TRAF_TINYINT_SUPPORT) == DF_OFF)
           $$ = new (PARSERHEAP()) SQLSmall(PARSERHEAP(),  $2, TRUE);
         else
           $$ = new (PARSERHEAP()) SQLTiny(PARSERHEAP(),  $2, TRUE);
       }

numeric_type_token :    TOK_NUMERIC
			//			          | TOK_NUMBER

/* na type for the numeric */
non_int_type : numeric_type_token left_uint_uint_right signed_option
             {

	       if (! ($2->left() > 0 ))  {
		 // Precision must be > 0.
		 *SqlParser_Diags << DgSqlCode(-3003) << DgInt0($2->left());
		 
		 delete $2;
		 yyerror("");
		 YYABORT;
	       }
	       
	       /////////////////////////////////////////////////////////////
	       //
	       // CQD MAX_NUMERIC_PRECISION_ALLOWED has a range of 18-128,
	       // it is set to 128 by default. This range is validated when
	       // the default is set.
	       //
	       //  MAX_HARDWARE_SUPPORTED_SIGNED_NUMERIC_PRECISION = 18
	       //  MAX_HARDWARE_SUPPORTED_UNSIGNED_NUMERIC_PRECISION = 9
	       //     (these 2 are defined in common/ComSmallDefs.h)
	       //
	       // If cqd MAX_NUMERIC_PRECISION_ALLOWED is set to 18, then
	       // old behavior is triggered (max numeric precision allowed, 
	       // both signed and unsigned, will be limited to what is 
	       // supported by hardware (18 and 9, resp.).
	       //
	       ////////////////////////////////////////////////////////////
	       if (($2->left() > MAX_HARDWARE_SUPPORTED_SIGNED_NUMERIC_PRECISION) &&
		   (CmpCommon::getDefaultNumeric(MAX_NUMERIC_PRECISION_ALLOWED)
		    == MAX_HARDWARE_SUPPORTED_SIGNED_NUMERIC_PRECISION))
		 {
		   // Precision of a Numeric may not exceed 18.
		   *SqlParser_Diags << DgSqlCode(-3014) << DgInt0($2->left())
				    << DgInt1(MAX_HARDWARE_SUPPORTED_SIGNED_NUMERIC_PRECISION);
		   delete $2;
		   YYABORT;
		 }
	       
	       // Precision of a Numeric cannot exceed max allowed
	       if ($2->left() > (UInt32)CmpCommon::getDefaultNumeric(MAX_NUMERIC_PRECISION_ALLOWED))
		 {
		   *SqlParser_Diags << DgSqlCode(-3014) << DgInt0($2->left())
				    << DgInt1((Int32)CmpCommon::getDefaultNumeric(MAX_NUMERIC_PRECISION_ALLOWED));
		   delete $2;
		   YYABORT;
		 }
	       
	       if ($2->right() > $2->left()) {
		 // Scale, $2->right()  cannot exceed 
		 // precision,  $2->left(). 
		 *SqlParser_Diags << DgSqlCode(-3015) << DgInt0($2->right()) << DgInt1($2->left()); 
		 delete $2;
		 YYABORT;
	       }

	       if (($2->left() > MAX_HARDWARE_SUPPORTED_SIGNED_NUMERIC_PRECISION) ||
		   (($2->left() > MAX_HARDWARE_SUPPORTED_UNSIGNED_NUMERIC_PRECISION) AND NOT $3))
		 $$ = new (PARSERHEAP())
		   SQLBigNum(PARSERHEAP(), $2->left(), $2->right(), TRUE, $3, TRUE);
	       else {
		 const Int16 DisAmbiguate = 0; // added for 64bit project
		 $$ = new (PARSERHEAP())
		   SQLNumeric(PARSERHEAP(), $3,$2->left(), $2->right(), DisAmbiguate );
	       }
	       delete $2;
             }
         | TOK_NUMERIC signed_option
	     {
	       // Default (precision,scale) for NUMERIC is (9,0)
               // But in MS4, it is 18.
               Lng32 prec = 9;
               if (CmpCommon::getDefault(MODE_SPECIAL_4) == DF_ON) 
                 prec = 18; 

	       const Int16 DisAmbiguate = 0; // added for 64bit project
	       $$ = new (PARSERHEAP()) SQLNumeric(PARSERHEAP(), $2, prec, 0, DisAmbiguate);
	     }
	 | TOK_LSDECIMAL left_uint_uint_right signed_option
             {
                if ($2->left() > 18) {
		  // Precision of a Decimal, " << $2->left()
                  // may not exceed 18.
                    *SqlParser_Diags << DgSqlCode(-3016) << DgInt0($2->left());
                    delete $2;
                    YYABORT;
                }
                if (! ($2->left() > 0 ))  {
		  // Precision must be > 0.
                    *SqlParser_Diags << DgSqlCode(-3003) << DgInt0($2->left());
                    delete $2;
                    yyerror("");
                    YYABORT;
                   }
                if ($2->right() > $2->left()) {
		  // Scale, $2->right(), cannot exceed precision, $2->left() 
                    *SqlParser_Diags << DgSqlCode(-3015)
		      << DgInt0($2->right()) << DgInt1($2->left()); 
                    delete $2;
                    YYABORT;
                }
                if ($2->left() > 9 AND NOT $3/*unsigned*/) {
                    // Precision of $0~string0 UNSIGNED data type,
                    // $1~int0, cannot exceed 9. 
                    *SqlParser_Diags << DgSqlCode(-3008)
                                     << DgString0("LSDECIMAL")
                                     << DgInt0($2->left())
				     << DgInt1(9);
                    delete $2;
                    YYABORT;
                }
		$$ = new (PARSERHEAP())
		  LSDecimal(PARSERHEAP(), $2->left(), $2->right(), $3);
                delete $2;
             }
	 | TOK_LSDECIMAL signed_option 
             {
	       // Default (precision,scale) for DECIMAL is (9,0)
	       $$ = new (PARSERHEAP()) LSDecimal(PARSERHEAP(),9, 0, $2);
	     }
	 | TOK_DECIMAL left_uint_uint_right signed_option
             {
                if ($2->left() > 18) {
		  // Precision of a Decimal, " << $2->left()
                  // may not exceed 18.
		  *SqlParser_Diags << DgSqlCode(-3016) << DgInt0($2->left());
		  delete $2;
		  YYABORT;
		}
                if (! ($2->left() > 0 ))  {
		  // Precision must be > 0.
                    *SqlParser_Diags << DgSqlCode(-3003) << DgInt0($2->left());
                    delete $2;
                    yyerror("");
                    YYABORT;
                   }
                if ($2->right() > $2->left()) {
		  // Scale, $2->right()  cannot exceed 
		  // precision, $2->left() 
                    *SqlParser_Diags << DgSqlCode(-3015) << DgInt0($2->right()) << DgInt1($2->left()); 
                    delete $2;
                    YYABORT;
                }
                if ($2->left() > 9 AND NOT $3/*unsigned*/) {
                    // Precision of $0~string0 UNSIGNED data type,
                    // $1~int0, cannot exceed 9. 
                    *SqlParser_Diags << DgSqlCode(-3008)
                                     << DgString0("DECIMAL")
                                     << DgInt0($2->left())
				     << DgInt1(9);
                    delete $2;
                    YYABORT;
                }
		$$ = new (PARSERHEAP())
		  SQLDecimal(PARSERHEAP(), $2->left(), $2->right(), $3);
                delete $2;
             }
	 | TOK_DECIMAL signed_option
             {
	       // Default (precision,scale) for DECIMAL is (9,0)
	       $$ = new (PARSERHEAP()) SQLDecimal(PARSERHEAP(),9, 0, $2);
	     }
float_type : TOK_FLOAT
             {
               //               $$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE, SQL_DOUBLE_PRECISION, TRUE);
               $$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE, 0, TRUE);
             }
	 | TOK_FLOAT left_unsigned_right
             {
               $$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE, $2, TRUE);

               if (CmpCommon::getDefault(MODE_SPECIAL_4) == DF_OFF)
                 {
                   if (! ((SQLDoublePrecision *)$$)->checkValid(SqlParser_Diags))
                     YYERROR;
                 }
             }
	 | TOK_REAL
             {
		$$ = new (PARSERHEAP()) SQLReal(PARSERHEAP(), TRUE); 
             }
	 | TOK_DOUBLE TOK_PRECISION
             {
		$$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE, 0);
             }
	 | TOK_SQL_DOUBLE
             {
		$$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE, 0);
             }

/* na type for the ieee or tandem floats as PROCEDURE argument in mdf.
   In here, REAL, FLOAT and DOUBLE PRECISION become TANDEM floats and
   not IEEE floats. This is for upward compatibility from pre R2 releases */
proc_arg_float_type : TOK_FLOAT_IEEE
             {
		$$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE, 0);
             }
	 | TOK_FLOAT_IEEE left_unsigned_right
             {
		$$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE, $2);
                if (! ((SQLDoublePrecision *)$$)->checkValid(SqlParser_Diags))
                   YYERROR;
             }
	 | TOK_REAL_IEEE
             {
		$$ = new (PARSERHEAP()) SQLReal(PARSERHEAP(), TRUE, 0);
             }
	 | TOK_DOUBLE_IEEE
             {
		$$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE, 0);
             }
	 | TOK_FLOAT
             {
		$$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE, 0);
             }
	 | TOK_FLOAT left_unsigned_right
             {
		$$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE, $2);
                if (! ((SQLDoublePrecision *)$$)->checkValid(SqlParser_Diags))
                   YYERROR;
             }
	 | TOK_REAL
             {
	       // For upward compatability, 
	       // REAL is IEEE real on NT, tandem real on NSK.
		$$ = new (PARSERHEAP()) SQLReal(PARSERHEAP(), TRUE, 0);
             }
	 | TOK_DOUBLE TOK_PRECISION
             {
	       // For upward compatability, 
	       // DOUBLE is IEEE double on NT, tandem double on NSK.
		$$ = new (PARSERHEAP()) SQLDoublePrecision(PARSERHEAP(), TRUE);
             }

/* na_type */
pic_type : TOK_PICTURE char_set collation_option pic_tail pic_notcasespecific_option
             {
                NABoolean    isStringType;
                UInt32     precision;  // for string, means "length"
                UInt32     scale;      // for string, meaningless
                NABoolean    hasSign;    // for string, meaningless

                NABoolean result =
                  parsePicClause($1,&isStringType,&precision,&scale,&hasSign);

		if(result == FALSE)
                { 
		  *SqlParser_Diags << DgSqlCode(-EXE_NUMERIC_OVERFLOW);
                  yyerror("");
                  YYABORT;
                }
                  /* We cast to DISPLAY_STYLE so as to let type of $2 be
                   * longint, so as not to expose DISPLAY_STYLE to the world
                   * as it would be were it in the "%union" declaration above.
                   */
                if (! (precision > 0 ))  {
		  // Precision must be > 0.
                    *SqlParser_Diags << DgSqlCode(-3003) << DgInt0(precision);
                    yyerror("");
                    YYABORT;
                   }

		if ((NOT isStringType) && ($5))
		  {
                    yyerror("");
                    YYABORT;
		  }

		if ((NOT isStringType) &&
		    (precision > 9) &&
		    (NOT hasSign))
		  {
                    // $1~int0, cannot exceed 9. 
                    *SqlParser_Diags << DgSqlCode(-3008)
                                     << DgString0("DECIMAL")
                                     << DgInt0(precision)
				     << DgInt1(9);
                    yyerror("");
                    YYABORT;
		  }

		NABoolean caseInsensitive = $5;
		if ((isStringType) &&
		    (SqlParser_CurrentParser->modeSpecial1()))
		  caseInsensitive = TRUE;

                // picNAType assert fails if precision is 0
                $$ = picNAType(isStringType, (DISPLAY_STYLE)$4,
                               precision, scale, hasSign,
			       $2, $3.collation_, $3.coercibility_,
                               *$1/*picClauseBuffer*/, caseInsensitive);
                delete $1;
                if ($$ == NULL) YYABORT;
	        if (checkError3179($$)) YYERROR;
             }

/* longint */
pic_tail :    { /* default case */ $$ = STYLE_DISPLAY; }
         | TOK_DISPLAY
              { $$ = STYLE_DISPLAY; }
         | TOK_DISPLAY TOK_SIGN TOK_IS TOK_LEADING
              { $$ = STYLE_LEADING_SIGN; }
         | TOK_DISPLAY TOK_UPSHIFT
              { $$ = STYLE_UPSHIFT; }
         | TOK_UPSHIFT
              { $$ = STYLE_UPSHIFT; }
         | TOK_COMP
              { $$ = STYLE_COMP; }


/* type boolean */
signed_option :   { $$ = TRUE; // default is SIGNED
		  }
     | TOK_SIGNED  { $$ = TRUE; }
     | TOK_UNSIGNED { $$ = FALSE; }

/* type na_type */
string_type : tok_char_or_character_or_byte new_optional_left_charlen_right char_set collation_option upshift_flag notcasespecific_option
            {
              CharInfo::CharSet eCharSet = $3; // char_set
              if ((NOT $2/*new_optional_left_charlen_right*/->isCharLenUnitSpecified()) &&
                  (eCharSet EQU CharInfo::UTF8) &&
                  (in_col_defn) &&
                  (CmpCommon::getDefault(TRAF_COL_LENGTH_IS_CHAR) == DF_OFF))
                {
                  $2->setCharLenUnit(ParAuxCharLenSpec::eBYTES);
                }

               ParAuxCharLenSpec::ECharLenUnit parCLU = $2/*new_optional_left_charlen_right*/->getCharLenUnit();

               if (( $2/*new_optional_left_charlen_right*/->isCharLenUnitSpecified() AND
                     $1/*tok_char_or_character_or_byte*/ EQU TOK_BYTE )  OR
                   ( eCharSet EQU CharInfo::UCS2 AND parCLU EQU ParAuxCharLenSpec::eBYTES ) )
                 {
                   emitError3435( $1, eCharSet, parCLU ); // BYTE[S] not allowed with UCS2 or type BYTE
                   YYERROR;
                 }
               Int32 specifiedLength = $2/*new_optional_left_charlen_right*/->getCharLen();
               if (parCLU EQU ParAuxCharLenSpec::eBYTES OR eCharSet EQU CharInfo::UTF8 /* OR eCharSet EQU CharInfo::SJIS */)
               { // SeaQuest Unicode
                 if ( $1/*tok_char_or_character_or_byte*/ EQU TOK_BYTE )
                 {
                   emitError3435( $1, eCharSet, parCLU ); // BYTE type not allowed with UTF8 or SJIS
                   YYERROR;
                 }
                 else if ( eCharSet EQU CharInfo::ISO88591 AND parCLU EQU ParAuxCharLenSpec::eBYTES )
                   parCLU = ParAuxCharLenSpec::eCHAR_LEN_UNIT_NOT_SPECIFIED; // Ignore BYTES specifier!
                 if (eCharSet EQU CharInfo::SJIS) // not yet supported
                 {
	           *SqlParser_Diags << DgSqlCode(-3010) << DgString0("SJIS");
                   YYERROR;
                 }
                 CharInfo::CharSet eEncodingCharSet = eCharSet;
                 Int32 maxLenInBytes = specifiedLength;
                 Int32 characterLimit = specifiedLength;
                 Int32 maxBytesPerChar = CharInfo::maxBytesPerChar(eEncodingCharSet);
                 if ( parCLU NEQ ParAuxCharLenSpec::eBYTES )
                 {
                   maxLenInBytes = characterLimit * maxBytesPerChar;
                 }
                 $$ = new (PARSERHEAP()) SQLChar ( PARSERHEAP(), CharLenInfo(characterLimit, maxLenInBytes), TRUE,
                                                   $5, $6, FALSE, eCharSet, $4.collation_,
                                                   $4.coercibility_, eEncodingCharSet );
                 NAString ddt("CHAR", PARSERHEAP());
                 ((SQLChar *)$$)->generateTextThenSetDisplayDataType ( eCharSet , ddt );
               }
               else // keep the old behavior
               $$ = new (PARSERHEAP()) SQLChar
			(PARSERHEAP(), specifiedLength, TRUE, $5, $6, FALSE, 
			 eCharSet, $4.collation_, $4.coercibility_);
	       if (checkError3179($$)) YYERROR;

            }
     | TOK_ANSIVARCHAR left_charlen_right char_set collation_option upshift_flag notcasespecific_option
            {
               $$ = new (PARSERHEAP()) ANSIChar
	       		(PARSERHEAP(), $2, TRUE, $5, TRUE,
			 $3, $4.collation_, $4.coercibility_);
	       if (checkError3179($$)) YYERROR;
            }
     | tok_char_or_character_or_byte TOK_VARYING toggled_optional_left_charlen_right char_set 
       collation_option upshift_flag notcasespecific_option
            {
              CharInfo::CharSet eCharSet = $4; // char_set
              if ((NOT $3/*new_optional_left_charlen_right*/->isCharLenUnitSpecified()) &&
                  (eCharSet EQU CharInfo::UTF8) &&
                  (in_col_defn) &&
                  (CmpCommon::getDefault(TRAF_COL_LENGTH_IS_CHAR) == DF_OFF))
                {
                  $3->setCharLenUnit(ParAuxCharLenSpec::eBYTES);
                }

               ParAuxCharLenSpec::ECharLenUnit parCLU = $3/*toggled_optional_left_charlen_right*/->getCharLenUnit();

               if ( $3/*toggled_optional_left_charlen_right*/->isCharLenUnitSpecified()  AND
                    $1/*tok_char_or_character_or_byte*/ EQU TOK_BYTE )
               {
                 emitError3435( $1, eCharSet, parCLU ); // BYTES/CHARS not allowed with BYTE VARYING
                 YYERROR;
               }
               if ( eCharSet EQU CharInfo::UCS2 AND parCLU EQU ParAuxCharLenSpec::eBYTES )
               {
                 emitError3435( $1, eCharSet, parCLU ); // BYTE[S] not allowed with UCS2
                 YYERROR;
               }
               Int32 specifiedLength = $3/*toggled_optional_left_charlen_right*/->getCharLen();
               if (eCharSet EQU CharInfo::UTF8 OR eCharSet EQU CharInfo::SJIS)
               { // SeaQuest Unicode
                 if ( $1/*tok_char_or_character_or_byte*/ EQU TOK_BYTE )
                   YYERROR;
                 if (eCharSet EQU CharInfo::SJIS) // not support in SeaQuest M4
                 {
	           *SqlParser_Diags << DgSqlCode(-3010) << DgString0("SJIS");
                   YYERROR;
                 }
                 CharInfo::CharSet eEncodingCharSet = eCharSet;
                 Int32 maxLenInBytes  = specifiedLength;
                 Int32 characterLimit = specifiedLength;
                 Int32 maxBytesPerChar   = CharInfo::maxBytesPerChar(eEncodingCharSet);
                 if ( parCLU NEQ ParAuxCharLenSpec::eBYTES )
                 {
                   maxLenInBytes = characterLimit * maxBytesPerChar; 
                 }
                 $$ = new (PARSERHEAP()) SQLVarChar ( PARSERHEAP(), CharLenInfo(characterLimit, maxLenInBytes),
                                                      TRUE, $6, $7, eCharSet, $5.collation_,
                                                      $5.coercibility_, eEncodingCharSet );
                 NAString ddt("VARCHAR", PARSERHEAP());
                 ((SQLVarChar *)$$)->generateTextThenSetDisplayDataType ( eCharSet , ddt );
               }
               else // keep the old behavior
               $$ = new (PARSERHEAP()) SQLVarChar
			(PARSERHEAP(), specifiedLength, TRUE, $6, $7,
			 eCharSet, $5.collation_, $5.coercibility_);
	       if (checkError3179($$)) YYERROR;
 
            }
     | TOK_VARCHAR toggled_optional_left_charlen_right char_set collation_option upshift_flag notcasespecific_option
            {
              CharInfo::CharSet eCharSet = $3; // char_set
              if ((NOT $2/*new_optional_left_charlen_right*/->isCharLenUnitSpecified()) &&
                  (eCharSet EQU CharInfo::UTF8) &&
                  (in_col_defn) &&
                  (CmpCommon::getDefault(TRAF_COL_LENGTH_IS_CHAR) == DF_OFF))
                {
                  $2->setCharLenUnit(ParAuxCharLenSpec::eBYTES);
                }

               ParAuxCharLenSpec::ECharLenUnit parCLU = $2/*toggled_optional_left_charlen_right*/->getCharLenUnit();

               if ( eCharSet EQU CharInfo::UCS2 AND parCLU EQU ParAuxCharLenSpec::eBYTES )
               {
                 emitError3435( TOK_VARCHAR, eCharSet, parCLU ); // BYTE[S] not allowed with UCS2
                 YYERROR;
               }
               Int32 specifiedLength = $2/*toggled_optional_left_charlen_right*/->getCharLen();
               if (eCharSet EQU CharInfo::UTF8 OR eCharSet EQU CharInfo::SJIS)
               { // Seaquest Unicode
                 if (eCharSet EQU CharInfo::SJIS) // not yet supported
                 {
	           *SqlParser_Diags << DgSqlCode(-3010) << DgString0("SJIS");
                   YYERROR;
                 }
                 CharInfo::CharSet eEncodingCharSet = eCharSet;
                 Int32 maxLenInBytes  = specifiedLength;
                 Int32 characterLimit = specifiedLength;
                 Int32 maxBytesPerChar   = CharInfo::maxBytesPerChar(eEncodingCharSet);
                 if ( parCLU NEQ ParAuxCharLenSpec::eBYTES )
                 {
                   maxLenInBytes = characterLimit * maxBytesPerChar;
                 }
                 $$ = new (PARSERHEAP()) SQLVarChar (PARSERHEAP(),  CharLenInfo(characterLimit, maxLenInBytes), TRUE,
                                                      $5, $6, eCharSet, $4.collation_,
                                                      $4.coercibility_, eEncodingCharSet );
                 NAString ddt("VARCHAR", PARSERHEAP());
                 ((SQLVarChar *)$$)->generateTextThenSetDisplayDataType ( eEncodingCharSet , ddt );
               }
               else // keep the old behavior
               $$ = new (PARSERHEAP()) SQLVarChar
			(PARSERHEAP(), specifiedLength, TRUE, $5, $6,
			 eCharSet, $4.collation_, $4.coercibility_);
	       if (checkError3179($$)) YYERROR;

            }
     | TOK_LONG TOK_VARCHAR char_set collation_option upshift_flag notcasespecific_option
       {
         // odbc SQL_LONGVARCHAR is LONG VARCHAR: variable length character
         // data. Maximum length is data source-dependent (can be specified
         // by control query default MAX_LONG_VARCHAR_DEFAULT_SIZE).
         //
         // 2010/6/6  Assume that the specified maximum length is in bytes
         //           (until the Seaquest Unicode ES says otherwise).

         CharInfo::CharSet eCharSet = $3; // char_set
         Int32 maxLenInBytes = getDefaultMaxLengthForLongVarChar(eCharSet);

         if (eCharSet EQU CharInfo::UTF8 OR eCharSet EQU CharInfo::SJIS)
         { // SeaQuest
           if (eCharSet EQU CharInfo::SJIS) // not support in SeaQuest M4
           {
	     *SqlParser_Diags << DgSqlCode(-3010) << DgString0("SJIS");
             YYERROR;
           }
           CharInfo::CharSet eEncodingCharSet = eCharSet;
           Int32 maxBytesPerChar = CharInfo::maxBytesPerChar(eCharSet);
           // compute the length in UCS4 characters for the worse case scenarios
           Int32 characterLimit = maxLenInBytes ;
           $$ = new (PARSERHEAP()) SQLLongVarChar ( PARSERHEAP(), (characterLimit, maxLenInBytes),
                                                    FALSE, TRUE,
                                                    $5, $6, eCharSet, $4.collation_,
                                                    $4.coercibility_, eEncodingCharSet );
           
           NAString ddt("LONG VARCHAR", PARSERHEAP());
           ((CharType *)$$)->generateTextThenSetDisplayDataType ( eCharSet , ddt );
         }
         else // keep the old behavior
         $$ = new (PARSERHEAP()) SQLLongVarChar
           (PARSERHEAP(), maxLenInBytes, FALSE, TRUE, $5, $6,
            eCharSet, $4.collation_, $4.coercibility_);
         if (checkError3179($$)) YYERROR;

       }

     | TOK_LONG TOK_VARCHAR new_left_charlen_right char_set collation_option upshift_flag notcasespecific_option
       {
         CharInfo::CharSet eCharSet = $4; // char_set
         if ((NOT $3/*new_optional_left_charlen_right*/->isCharLenUnitSpecified()) &&
             (eCharSet EQU CharInfo::UTF8) &&
             (in_col_defn) &&
             (CmpCommon::getDefault(TRAF_COL_LENGTH_IS_CHAR) == DF_OFF))
           {
             $3->setCharLenUnit(ParAuxCharLenSpec::eBYTES);
           }

         Int32 maxLenInBytes = $3/*new_left_charlen_right*/->getCharLen();
         ParAuxCharLenSpec::ECharLenUnit parCLU = $3/*new_left_charlen_right*/->getCharLenUnit();

         Int32 maxSize = getDefaultMaxLengthForLongVarChar(eCharSet);
         if (maxLenInBytes > maxSize) {
           *SqlParser_Diags << DgSqlCode(-3213) << DgInt0(maxSize);
           YYABORT;
         }
         Int32 minSize = getDefaultMinLengthForLongVarChar(eCharSet);
         if (maxLenInBytes < minSize) {
           *SqlParser_Diags << DgSqlCode(-3214) << DgInt0(minSize);
           YYABORT;
         }

         if (eCharSet EQU CharInfo::UTF8 OR eCharSet EQU CharInfo::SJIS)
         { // SeaQuest
           if (eCharSet EQU CharInfo::SJIS) // not yet support
           {
	     *SqlParser_Diags << DgSqlCode(-3010) << DgString0("SJIS");
             YYERROR;
           }
           if (parCLU EQU ParAuxCharLenSpec::eCHARACTERS)
           {
             emitError3435( TOK_LONG, eCharSet, parCLU ); // CHAR[S] not allowed with LONG VARCHAR
             YYERROR;
           }
           CharInfo::CharSet eEncodingCharSet = eCharSet;
           Int32 maxBytesPerChar = CharInfo::maxBytesPerChar(eCharSet);
           // compute the length in UCS4 characters for the worse case scenarios
           Int32 characterLimit = maxLenInBytes ;
           $$ = new (PARSERHEAP()) SQLVarChar ( PARSERHEAP(), CharLenInfo ( characterLimit , maxLenInBytes)
                                              , TRUE // allowSQLnull
                                              , $6   // isUpShifted
                                              , $7   // isCaseInsensitive
                                              , eCharSet
                                              , $5.collation_
                                              , $5.coercibility_
                                              , eEncodingCharSet
                                              );
           NAString ddt("LONG VARCHAR", PARSERHEAP());
           ((CharType *)$$)->generateTextThenSetDisplayDataType ( eEncodingCharSet , ddt );
         }
         else // keep the old behavior
         // KLUDGE begin: fix cases 10-040511-5169, 10-040610-2860, 
         // soln 10-040610-6863 by temporarily mapping
         //   "create table t(c long varchar, w longwvarchar)" into
         //   "create table t(c varchar(n),   w varwchar(m))".
         $$ = new (PARSERHEAP()) SQLVarChar
           (PARSERHEAP(), maxLenInBytes, TRUE, $6, $7, eCharSet, $5.collation_, $5.coercibility_);
         // end KLUDGE.
	       if (checkError3179($$)) YYERROR;

       }
     | nchar optional_left_charlen_right collation_option upshift_flag notcasespecific_option
            {
               $$ = new (PARSERHEAP()) SQLChar
		 	(PARSERHEAP(), $2, TRUE, $4, $5, FALSE,
			 SqlParser_NATIONAL_CHARSET,
			 $3.collation_, $3.coercibility_);
	       if (checkError3179($$)) YYERROR;
            }
     | nchar_varying left_charlen_right collation_option upshift_flag notcasespecific_option
            {
               $$ = new (PARSERHEAP()) SQLVarChar
		 	(PARSERHEAP(), $2, TRUE, $4, $5,
			 SqlParser_NATIONAL_CHARSET,
			 $3.collation_, $3.coercibility_);
	       if (checkError3179($$)) YYERROR;
            }
     | TOK_WCHAR left_unsigned_right collation_option upshift_flag notcasespecific_option
       {
         // odbc SQL_WCHAR is WCHAR(n): Unicode character string
         // of fixed string length n.
         $$ = new (PARSERHEAP()) SQLChar
           (PARSERHEAP(), $2, TRUE, $4, $5, FALSE, CharInfo::UNICODE, 
            $3.collation_, $3.coercibility_);
         if (checkError3179($$)) YYERROR;
       }
     | TOK_VARWCHAR left_unsigned_right collation_option upshift_flag notcasespecific_option
       {
         // odbc SQL_WVARCHAR is VARWCHAR(n): Unicode variable-length
         // character string with a maximum string length n.
         $$ = new (PARSERHEAP()) SQLVarChar
           (PARSERHEAP(), $2, TRUE, $4, $5, CharInfo::UNICODE, 
            $3.collation_, $3.coercibility_);
         if (checkError3179($$)) YYERROR;
       }
     | TOK_LONGWVARCHAR collation_option upshift_flag notcasespecific_option
       {
         // odbc SQL_WLONGVARCHAR is LONGWVARCHAR: Unicode variable-length
         // character data. Maximum length is data source-dependent (can be
         // set by control query default MAX_LONG_WVARCHAR_DEFAULT_SIZE).
         $$ = new (PARSERHEAP()) SQLLongVarChar
           (PARSERHEAP(), getDefaultMaxLengthForLongVarChar(CharInfo::UNICODE), 
            FALSE, TRUE, $3, $4, CharInfo::UNICODE, 
            $2.collation_, $2.coercibility_);
         if (checkError3179($$)) YYERROR;
       }
     | TOK_LONGWVARCHAR left_unsigned_right collation_option upshift_flag notcasespecific_option
       {
         Lng32 maxSize = getDefaultMaxLengthForLongVarChar(CharInfo::UNICODE);

         if ($2 > maxSize) {
           *SqlParser_Diags << DgSqlCode(-3209) << DgInt0(maxSize);
           YYABORT;
         }
         Lng32 minSize = getDefaultMinLengthForLongVarChar(CharInfo::UNICODE);

         if ($2 < minSize) {
           *SqlParser_Diags << DgSqlCode(-3210) << DgInt0(minSize);
           YYABORT;
         }
         $$ = new (PARSERHEAP()) SQLLongVarChar
           (PARSERHEAP(), $2, TRUE, TRUE, $4, $5, CharInfo::UNICODE, 
            $3.collation_, $3.coercibility_);
         if (checkError3179($$)) YYERROR;
       }
     | TOK_BINARY 
       {
         if (CmpCommon::getDefault(TRAF_BINARY_SUPPORT) == DF_OFF)
           $$ = new (PARSERHEAP()) SQLChar(PARSERHEAP(),
                                           DEFAULT_STRING_SIZE, TRUE, FALSE, FALSE);
         else
           $$ = new (PARSERHEAP()) SQLBinaryString(PARSERHEAP(),
                                                   DEFAULT_STRING_SIZE, TRUE, FALSE);
         if (checkError3179($$)) 
           YYERROR;
       }
     | TOK_BINARY left_unsigned_right
       {
         // odbc SQL_BINARY is BINARY(n). Binary data of fixed length n.
         if (CmpCommon::getDefault(TRAF_BINARY_SUPPORT) == DF_OFF)
           $$ = new (PARSERHEAP()) SQLChar(PARSERHEAP(), $2, TRUE, FALSE, FALSE);
         else
           $$ = new (PARSERHEAP()) SQLBinaryString(PARSERHEAP(), $2, TRUE, FALSE);
         if (checkError3179($$)) YYERROR;
       }
     | TOK_VARBINARY
       {
         if (CmpCommon::getDefault(TRAF_BINARY_SUPPORT) == DF_OFF)
           $$ = new (PARSERHEAP()) SQLVarChar(PARSERHEAP(), DEFAULT_STRING_SIZE);
         else
           {
             $$ = new (PARSERHEAP()) SQLBinaryString(PARSERHEAP(), DEFAULT_STRING_SIZE, TRUE, TRUE);
           }
         if (checkError3179($$)) YYERROR;
       }
     | TOK_VARBINARY left_unsigned_right
       {
         if (CmpCommon::getDefault(TRAF_BINARY_SUPPORT) == DF_OFF)
           $$ = new (PARSERHEAP()) SQLVarChar(PARSERHEAP(), $2);
         else
           $$ = new (PARSERHEAP()) SQLBinaryString(PARSERHEAP(), $2, TRUE, TRUE);
         if (checkError3179($$)) YYERROR;
       }
     | TOK_BINARY TOK_VARYING left_unsigned_right
       {
         if (CmpCommon::getDefault(TRAF_BINARY_SUPPORT) == DF_OFF)
           $$ = new (PARSERHEAP()) SQLVarChar(PARSERHEAP(), $3);
         else
           $$ = new (PARSERHEAP()) SQLBinaryString(PARSERHEAP(), $3, TRUE, TRUE);
         if (checkError3179($$)) YYERROR;
       }
     | TOK_LONG TOK_VARBINARY
       {
         // odbc SQL_LONGVARBINARY is LONG VARBINARY(n). Variable length 
         // binary data. Maximum length is data source-dependent.
         $$ = new (PARSERHEAP()) SQLLongVarChar(PARSERHEAP(), 0, FALSE);
         if (checkError3179($$)) YYERROR;
       }
     | TOK_LONG TOK_VARBINARY left_unsigned_right
       {
         Lng32 maxSize = getDefaultMaxLengthForLongVarChar(CharInfo::ISO88591);
         if ($3 > maxSize) {
           *SqlParser_Diags << DgSqlCode(-3211) << DgInt0(maxSize);
           YYABORT;
         }
         Lng32 minSize = getDefaultMinLengthForLongVarChar(CharInfo::ISO88591);
         if ($3 < minSize) {
           *SqlParser_Diags << DgSqlCode(-3212) << DgInt0(minSize);
           YYABORT;
         }
         // KLUDGE begin: fix cases 10-040511-5169, 10-040610-2860, 
         // soln 10-040610-6863 by temporarily mapping
         //   "create table t(b long varbinary(n))" into
         //   "create table t(b varchar(n))".
         $$ = new (PARSERHEAP()) SQLVarChar(PARSERHEAP(), $3);
         // end KLUDGE.
         if (checkError3179($$)) YYERROR;
       }

tok_char_or_character : TOK_CHAR | TOK_CHARACTER

/* For TD compatibility - we map BYTE to CHAR */
tok_char_or_character_or_byte : TOK_CHAR | TOK_CHARACTER
                              | TOK_BYTE
                                {
                                  CheckModeSpecial1();
                                }

/* type na_type */
blob_type : TOK_BLOB blob_optional_left_len_right 
            {
	      if (CmpCommon::getDefault(TRAF_BLOB_AS_VARCHAR) == DF_ON)
		{
		  $$ = new (PARSERHEAP()) SQLVarChar(PARSERHEAP(), $2);
                  ((SQLVarChar*)$$)->setClientDataType("BLOB");
		}
	      else
		{
    		  $$ = new (PARSERHEAP()) SQLBlob (PARSERHEAP(),  $2 );
		}
            }
          | TOK_CLOB clob_optional_left_len_right
            {
	      if (CmpCommon::getDefault(TRAF_CLOB_AS_VARCHAR) == DF_ON)
		{
		  $$ = new (PARSERHEAP()) SQLVarChar(PARSERHEAP(), $2);
                  ((SQLVarChar*)$$)->setClientDataType("CLOB");
		}
	      else
		{
                  $$ = new (PARSERHEAP()) SQLClob (PARSERHEAP(),  $2 );
		}
            }
 

blob_optional_left_len_right: '(' NUMERIC_LITERAL_EXACT_NO_SCALE optional_lob_unit ')'
        {
	 
	  Int64 longIntVal = atoInt64($2->data());
	  if (longIntVal < 0)
	  {
	    // Error: Expected an unsigned integer
	    *SqlParser_Diags << DgSqlCode(-3017) 
			     << DgString0(*$2);
	  }
	  
	  longIntVal = longIntVal * $3;

	  $$ = (Int64)longIntVal;
	  delete $2;
	 
	}

	| empty
	{ 

	  if (CmpCommon::getDefault(TRAF_BLOB_AS_VARCHAR) == DF_ON)
	    {
	      $$ = (Int64)CmpCommon::getDefaultNumeric(TRAF_MAX_CHARACTER_COL_LENGTH );
	    }
	  else
	    {
	 
	      $$ = (Int64)CmpCommon::getDefaultNumeric(LOB_MAX_SIZE)*1024*1024;

	    }
        }

/* type int64 */
optional_lob_unit :   TOK_K {$$ = 1024;}
                     | TOK_M {$$ = 1024*1024;}
                     | TOK_G {$$ = 1024*1024*1024;}
                     | empty {$$ = 1;}

clob_optional_left_len_right: '(' NUMERIC_LITERAL_EXACT_NO_SCALE optional_lob_unit ')'
        {
	  Int64 longIntVal = atoInt64($2->data());
	  if (longIntVal < 0)
	  {
	    // Error: Expected an unsigned integer
	    *SqlParser_Diags << DgSqlCode(-3017)
			     << DgString0(*$2);
	  }
	  longIntVal = longIntVal * $3;

	  $$ = (Int64)longIntVal;
	  delete $2;
	}

	| empty
	{

	  if (CmpCommon::getDefault(TRAF_CLOB_AS_VARCHAR) == DF_ON)
	    {
	      $$ = (Int64)CmpCommon::getDefaultNumeric(TRAF_MAX_CHARACTER_COL_LENGTH );
	    }
	  else
	    {
	      $$ = (Int64)CmpCommon::getDefaultNumeric(LOB_MAX_SIZE)*1024*1024;

	    }
        }

/* type na_type */
boolean_type : TOK_BOOLEAN
            {
              $$ = new (PARSERHEAP()) SQLBooleanNative (PARSERHEAP(), TRUE);
            }

/* type pCharLenSpec */
toggled_optional_left_charlen_right: new_left_charlen_right
	| empty
	{ 
          if ( empty_charlen_specifier_allowed == FALSE ) { 
            YYERROR; 
          } else
            $$ = new(PARSERHEAP()) ParAuxCharLenSpec ( DEFAULT_STRING_SIZE
                                                     , ParAuxCharLenSpec::eCHAR_LEN_UNIT_NOT_SPECIFIED
                                                     );
        }

optional_left_charlen_right: left_charlen_right
	| empty
	{ 
          $$ = DEFAULT_STRING_SIZE; 
        }

/* type pCharLenSpec */
new_optional_left_charlen_right: new_left_charlen_right
        | empty
        {
          $$ = new(PARSERHEAP()) ParAuxCharLenSpec ( DEFAULT_STRING_SIZE
                                                   , ParAuxCharLenSpec::eCHAR_LEN_UNIT_NOT_SPECIFIED
                                                   );
        }

nchar: TOK_NATIONAL tok_char_or_character { cast_target_cs_specified = TRUE; }
       | TOK_NCHAR                        { cast_target_cs_specified = TRUE; }

nchar_varying: TOK_NATIONAL tok_char_or_character TOK_VARYING { cast_target_cs_specified = TRUE; }
               | TOK_NCHAR TOK_VARYING                        { cast_target_cs_specified = TRUE; }

/* type charSetVal */
char_set :	
           { 
             if ((in_col_defn) &&
                 (SqlParser_CurrentParser->defaultColCharset() != CharInfo::UnknownCharSet))
               $$ = SqlParser_CurrentParser->defaultColCharset();
             else
               $$ = SqlParser_DEFAULT_CHARSET; 
           }
      | TOK_CHARACTER TOK_SET character_set 
	  	{
	  	  $$ = $3;
	  	  cast_target_cs_specified = TRUE;
	  	}

/* type charSetVal */
CHAR_FUNC_character_set : IDENTIFIER 
        { 
	  $1->toUpper();
	  $$ = CharInfo::getCharSetEnum(*$1);
	  if (!CharInfo::isCharSetFullySupported($$)) {
	    // 3010 Character set $0~string0 is not yet supported.
	    if ($$ != CharInfo::UnknownCharSet) {
	      *SqlParser_Diags << DgSqlCode(-3010) << DgString0(*$1);
	       YYERROR;
	    } else {
              if (!Get_SqlParser_Flags(ALLOW_UNKNOWN_CHARSET)) {
	        yyerror("");
	        YYERROR;
              }
            }
	  }
          delete $1;
        } 

/* type charSetVal */
character_set : IDENTIFIER 
        { 
	  $1->toUpper();
	  $$ = CharInfo::getCharSetEnum(*$1);
	  if (!CharInfo::isCharSetFullySupported($$)) {
	    // 3010 Character set $0~string0 is not yet supported.
	    if ($$ != CharInfo::UnknownCharSet) {
	      *SqlParser_Diags << DgSqlCode(-3010) << DgString0(*$1);
	       YYERROR;
	    } else {
              if (!Get_SqlParser_Flags(ALLOW_UNKNOWN_CHARSET)) {
	        yyerror("");
	        YYERROR;
              }
            }
	  }
          delete $1;
        } 

/* type boolean */
upshift_flag :	    { $$ = FALSE; }
      | TOK_UPSHIFT { $$ = TRUE; }
      | TOK_UPPERCASE { $$ = TRUE; }

/* type boolean */
notcasespecific_option : empty 
                           { 
			     if (SqlParser_CurrentParser->modeSpecial1())
			       $$ = TRUE;
			     else
			       $$ = FALSE; 
			   }
      | TOK_NOT_CASESPECIFIC   
                           { 
			     $$ = TRUE; 
			   }
      | TOK_CASESPECIFIC   
                           { 
			     $$ = FALSE; 
			   }

/* type boolean */
pic_notcasespecific_option : empty 
                           { 
			     $$ = FALSE; 
			   }
      | TOK_NOT_CASESPECIFIC   
                           { 
			     $$ = TRUE; 
			   }

/* type uint */
unsigned_integer : NUMERIC_LITERAL_EXACT_NO_SCALE
    {
      Lng32 longIntVal = atol(*$1);
      if (longIntVal < 0)
      {
        // Error: Expected an unsigned integer
        // *$1.
         *SqlParser_Diags << DgSqlCode(-3017) << DgString0(*$1);
      }
      delete $1;
      $$ = (UInt32)longIntVal;
    }

/* type usmallint */
unsigned_smallint : NUMERIC_LITERAL_EXACT_NO_SCALE
    {
      Lng32 longIntVal = atol(*$1);
      if (longIntVal < 0 AND longIntVal > USHRT_MAX)
      {
	// *** Error *** Expected an unsigned smallint
        // $1.
        *SqlParser_Diags << DgSqlCode(-3018) << DgString0(*$1);
      }
      delete $1;
      $$ = (UInt16)longIntVal;
    }

/* type Int64 */
left_largeint_right : '(' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
    {
      NAString *theValue = new (PARSERHEAP()) NAString($2->data(), PARSERHEAP());
      ItemExpr *returnValue = literalOfNumericNoScale(theValue);
      if (!returnValue) YYERROR;
      $$ = returnValue;
      assert( $$ == returnValue );
      SqlParser_CurrentParser->collectItem4HQC($$);
      delete $2;
    }

/* type uint */
ts_left_unsigned_right : '(' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
    {
      Lng32  theValue = atol($2->data());
      if (theValue < 0)
      { // time_precision can be 0
        // Parse Error: Expected an unsigned number
        // between the pair of parentheses --.

        *SqlParser_Diags << DgSqlCode(-3017) << DgString0(*$2);
        yyerror("");
        YYABORT;
      }
      $$ = (UInt32) theValue;
      assert($$ == (UInt32) theValue);
      delete $2;
    }

/* type uint */
left_charlen_right : left_unsigned optional_charlen_unit ')'
	{ $$ = $1; }

/* type tokval */
optional_charlen_unit : TOK_CHARACTERS
	| TOK_CHAR      { $$ =  TOK_CHARACTERS ; }
	| TOK_CHARS     { $$ =  TOK_CHARACTERS ; }
	| TOK_CHARACTER { $$ =  TOK_CHARACTERS ; } 
	|
	empty;

/* type pCharLenSpec */
new_left_charlen_right : left_unsigned new_optional_charlen_unit ')'
    {
      ParAuxCharLenSpec::ECharLenUnit eUnit = 
        ParAuxCharLenSpec::eCHAR_LEN_UNIT_NOT_SPECIFIED;
      switch ( $2 /*new_optional_charlen_unit */ )
      {
      case 0:
        eUnit = ParAuxCharLenSpec::eCHAR_LEN_UNIT_NOT_SPECIFIED;
        break;
      case TOK_CHAR: case TOK_CHARS: case TOK_CHARACTER: case TOK_CHARACTERS:
        eUnit = ParAuxCharLenSpec::eCHARACTERS;
        break;
      case TOK_BYTE: case TOK_BYTES:
        eUnit = ParAuxCharLenSpec::eBYTES;
        break;
      default:
        YYERROR;
        break;
      }
      $$ = new(PARSERHEAP()) ParAuxCharLenSpec ( $1 // left_unsigned
                                               , eUnit
                                               );
    }

/* type tokval */
new_optional_charlen_unit : TOK_CHAR | TOK_CHARS | TOK_CHARACTER | TOK_CHARACTERS
	| TOK_BYTE | TOK_BYTES
	| empty

/* type uint */
left_unsigned_right : left_unsigned ')'
	{ $$ = $1; }

/* type uint */
left_unsigned: '(' NUMERIC_LITERAL_EXACT_NO_SCALE 
    {
      const char *numStr = $2->data();
      Lng32 strLen = (Lng32)($2->length());
      Lng32  theValue;
      Lng32 convErrFlag = ex_conv_clause::CONV_RESULT_OK;      

      /* for char(n), we limit the value of n to be no more than
         2^31-1, so convert it to 32bit signed first, then check 
	 to make sure the converted value is not negative. */

      ex_expr::exp_return_type result = 
         convDoIt((char *)numStr,       /*source*/
	          strLen,               /*sourceLen*/
		  REC_BYTE_F_ASCII,     /*sourceType*/
		  0,                    /*sourcePrecision*/
		  0,                    /*sourceScale*/
	          (char *)&theValue,    /*target*/
	          sizeof(theValue),     /*targetLen*/
	          REC_BIN32_SIGNED,     /*targetType*/
	          0,                    /*targetPrecision*/
	          0,                    /*targetScale*/
                  NULL,                 /*varCharLen*/
                  0,                    /*varCharLenSize*/
	          PARSERHEAP(),         /*heap*/
	          &SqlParser_Diags,     /*diagsArea*/
		  CONV_ASCII_BIN32S,    /*index*/
                  &convErrFlag,         /*dataConversionErrorFlag*/
	          0                     /*flags*/);

      switch(convErrFlag){
      case ex_conv_clause::CONV_RESULT_ROUNDED_DOWN:
      case ex_conv_clause::CONV_RESULT_ROUNDED_DOWN_TO_MAX:
      case ex_conv_clause::CONV_RESULT_ROUNDED_UP:
      case ex_conv_clause::CONV_RESULT_ROUNDED_UP_TO_MIN:
      case ex_conv_clause::CONV_RESULT_ROUNDED:
        *SqlParser_Diags << DgSqlCode(-EXE_NUMERIC_OVERFLOW);
	break;
      default:
        break;
      }

      if( (result != ex_expr::EXPR_OK) ||
          (convErrFlag != ex_conv_clause::CONV_RESULT_OK) ) 
      {
        yyerror("");
        YYABORT;
      }

      if (! (theValue > 0))
        // Normally, we come here to parse unsigned positive numbers
        // used for precision and length values in SQL statements. 
        //
        // We have now encountered a precision or length value
        // that is zero or negative.
        //
        // We do allow a length value of 0 for character data types
        // for columns in UDR Result Set proxy statements to support
        // returning empty strings as part of Result Set columns.
        //
        // All other scenarios are errors. 
        //

         if (! ((theValue == 0) && inRSProxyStmt))
         { 
           *SqlParser_Diags << DgSqlCode(-3003) << DgString0(*$2);
           // Parse Error 3003: Length or precision must be greater than zero.
           yyerror("");
           YYABORT;
         }
      $$ = (UInt32) theValue;
      assert($$ == (UInt32) theValue);
      delete $2;
    }

/* type pairPtr */
left_uint_uint_right: '(' NUMERIC_LITERAL_EXACT_NO_SCALE ',' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
    {
      UInt32  theLeftValue,theRightValue;
      Lng32  theValue = atol($2->data());
      if (theValue < 0)
      {
        // Parse Error: Expected an unsigned number 
        // as the first number within the parentheses --  $2 
        *SqlParser_Diags << DgSqlCode(-3020) << DgString0(*$2);
      }
      theLeftValue = (UInt32) theValue;
      assert(theLeftValue == (UInt32)theValue);

      theValue = atol($4->data());
      if (theValue < 0)
      {
        // Parse Error: Expected an unsigned number 
        // as the second number within the parentheses -- $4;
        *SqlParser_Diags << DgSqlCode(-3021) << DgString0(*$4);
      }
      theRightValue = (UInt32) theValue;
      assert(theRightValue == (UInt32)theValue);

      $$ = new (PARSERHEAP())
	PairOfUnsigned(theLeftValue,theRightValue);
      assert($$);
    }
   | left_unsigned_right
      { $$ = new (PARSERHEAP()) PairOfUnsigned($1,0);
        assert($$);
      }


/* type na_type */
date_time_type : TOK_DATE disableCharsetInference format_attributes
                          {
                            $$ = new (PARSERHEAP()) SQLDate(PARSERHEAP(), TRUE);
                            SQLDate *pDate = (SQLDate *)$$;
                            // Leave the field blank if FORMAT clause not
                            // specified to leave SHOWDDL output remain
                            // unchanged so we don't need to update
                            // expected results in regression test suites
                            if ($3 /*format_attributes*/ != NULL) 
                              {
                                NAString format (*$3 /*format_attributes*/, PARSERHEAP());
                                NAStringUpshiftASCII(format);
                                pDate->setDisplayFormat(format);
                                delete $3 /*format_attributes*/;
                              }
                            restoreInferCharsetState();
                          }
               | TOK_TIME
                          {
                              $$ = new (PARSERHEAP()) SQLTime(PARSERHEAP(), TRUE, 
                                                              SQLTime::DEFAULT_FRACTION_PRECISION);
                          }
               | TOK_TIME ts_left_unsigned_right
                          {
                              $$ = new (PARSERHEAP()) SQLTime(PARSERHEAP(), TRUE,
                                                              $2);

                              if (! ((SQLTime *)$$)->checkValid(SqlParser_Diags)) YYERROR;
                          }
	       | TOK_TIMESTAMP disableCharsetInference  format_attributes
                          {
                              $$ = new (PARSERHEAP()) 
                                SQLTimestamp(PARSERHEAP(), TRUE, 
                                             SQLTimestamp::DEFAULT_FRACTION_PRECISION); 
                              restoreInferCharsetState();
                          }
	       | TOK_TIMESTAMP ts_left_unsigned_right disableCharsetInference format_attributes
                          {
                              $$ = new (PARSERHEAP()) SQLTimestamp(PARSERHEAP(), TRUE, $2);
                              if (! ((SQLTimestamp *)$$)->checkValid(SqlParser_Diags)) YYERROR;
                              restoreInferCharsetState();
                          }

               | TOK_DATETIME  datetime_qualifier
                          {
                              $$ = DatetimeType::constructSubtype(  // This call is necessary to insure that we return
                               TRUE,                                // a standard DateTime, if possible.
                               $2->getStartField(),
                               $2->getEndField(),
                               $2->getFractionPrecision(),
                               PARSERHEAP()
                               );
                              delete $2;
                              if ($$ == NULL) 
                              {
                               *SqlParser_Diags << DgSqlCode(-3158) << DgString0(""); // Error - invalid datetime
                               YYERROR;
                              } 
			      // Create table with data type DATETIME not supported
			      ((DatetimeType *)$$)->setDTIFlag(DatetimeType::UNSUPPORTED_DDL_DATA_TYPE);
                              if (! ((DatetimeType *)$$)->checkValid(SqlParser_Diags)) YYERROR;
                          }

datetime_qualifier : datetime_start_field
                          {
                             $$ = $1;
                          } 
                | datetime_start_field TOK_TO datetime_end_field
                          {
                             $$ = new (PARSERHEAP())
                                DatetimeQualifier($1->getStartField(),
                                                $3->getEndField(),
                                                $3->getFractionPrecision());
                           delete $1;
                           delete $3;
                          }
                | fraction_only_datetime
                          {
                             $$ = $1;
                          } 

/* type datetimeField */
datetime_start_field : non_second_datetime_field
                {
                        $$ = new (PARSERHEAP()) DatetimeQualifier($1);
                }
                | TOK_SECOND
                {
                        $$ = new (PARSERHEAP()) DatetimeQualifier(REC_DATE_SECOND);
                }

datetime_end_field : non_second_datetime_field
                {
                        $$ = new (PARSERHEAP()) DatetimeQualifier($1);
                }
                | TOK_SECOND
                {
                        $$ = new (PARSERHEAP()) DatetimeQualifier(REC_DATE_SECOND);
                }
                | datetime_fraction_field
                {                                  
                        $$ = $1;
                }
fraction_only_datetime : datetime_fraction_field
                {                                  
                   $$ = new (PARSERHEAP())
                        DatetimeQualifier(REC_DATE_FRACTION_MP,
                                          REC_DATE_FRACTION_MP,
                                         $1->getFractionPrecision());
                    delete $1;
                }
                | TOK_FRACTION TOK_TO datetime_fraction_field
                {
                   $$ = new (PARSERHEAP())
                      DatetimeQualifier(REC_DATE_FRACTION_MP,
                                      REC_DATE_FRACTION_MP,
                                      $3->getFractionPrecision());
                 delete $3;
                }
datetime_fraction_field  : TOK_FRACTION                            // returned in MP mode only
                {                                  
                   $$ = new (PARSERHEAP()) DatetimeQualifier(REC_DATE_SECOND, SQLTimestamp::MAX_FRACTION_PRECISION );
                }
                | TOK_FRACTION ts_left_unsigned_right     // returned in MP mode only
                {                                  
                   $$ = new (PARSERHEAP()) DatetimeQualifier(REC_DATE_SECOND, $2);
                }

/* type na_type */
interval_type : TOK_INTERVAL interval_qualifier
              {
                $$ = new (PARSERHEAP())
		  SQLInterval(PARSERHEAP(), TRUE,
			      $2->getStartField(),
			      $2->getLeadingPrecision(),
			      $2->getEndField(),
			      $2->getFractionPrecision());

		// Check to see if FRACTION used, pass along to new object
		if($2->getDTIFlag(IntervalType::UNSUPPORTED_DDL_DATA_TYPE))
		{
		  ((SQLInterval *)$$)->setDTIFlag(IntervalType::UNSUPPORTED_DDL_DATA_TYPE);
		}
                delete $2;
                if (! ((SQLInterval *)$$)->checkValid(SqlParser_Diags)) YYERROR;
              }

/* type intervalQualifier */
interval_qualifier : start_field TOK_TO end_field
                   {
                      $$ = new (PARSERHEAP())
	              IntervalQualifier(PARSERHEAP(), $1->getStartField(),
                                        $1->getLeadingPrecision(),
					$3->getEndField(),
				        $3->getFractionPrecision());

		      // Check to see if FRACTION used, pass along to new object
		      if($3->getDTIFlag(IntervalType::UNSUPPORTED_DDL_DATA_TYPE))
		      {
		      $$->setDTIFlag(IntervalType::UNSUPPORTED_DDL_DATA_TYPE);
		      }

                      delete $1;
                      delete $3;
                      if (! $$->checkValid(SqlParser_Diags)) YYERROR;
                   }
                   | single_datetime_field
                   {
                     $$ = $1;
                   }
                   | TOK_SECOND TOK_TO interval_fraction_field
                   {
                       $$ = new (PARSERHEAP()) 
                           IntervalQualifier(PARSERHEAP(), REC_DATE_SECOND,
                                     SQLInterval::DEFAULT_LEADING_PRECISION,
                                     REC_DATE_SECOND,
                                     $3);

                      if (! $$->checkValid(SqlParser_Diags)) YYERROR;

	              // Create table with data type INTERVAL FRACTION not supported
		      $$->setDTIFlag(IntervalType::UNSUPPORTED_DDL_DATA_TYPE);
                   }
                   | TOK_SECOND ts_left_unsigned_right TOK_TO interval_fraction_field
                   {
                        $$ = new (PARSERHEAP())
                          IntervalQualifier(PARSERHEAP(), REC_DATE_SECOND,
                                    $2,
                                    REC_DATE_SECOND,
                                    $4);

                        if (! $$->checkValid(SqlParser_Diags)) YYERROR;
			
			// Create table with data type INTERVAL FRACTION not supported
			$$->setDTIFlag(IntervalType::UNSUPPORTED_DDL_DATA_TYPE);
                    }
                   | TOK_SECOND TOK_TO TOK_SECOND
                   {
                        $$ = new (PARSERHEAP()) 
                            IntervalQualifier(PARSERHEAP(), REC_DATE_SECOND,
                                              IntervalQualifier::DEFAULT_LEADING_PRECISION);
                   }

                   | TOK_SECOND ts_left_unsigned_right TOK_TO TOK_SECOND
                   {
                        $$ = new (PARSERHEAP())
                          IntervalQualifier(PARSERHEAP(), REC_DATE_SECOND,
                                   $2,
                                   REC_DATE_SECOND,
                                   0);
                        if (! $$->checkValid(SqlParser_Diags)) YYERROR;
                    }
                    | fraction_only_interval
                    {
                      $$ = $1;

		      // Create table with data type INTERVAL FRACTION not supported
		      $$->setDTIFlag(IntervalType::UNSUPPORTED_DDL_DATA_TYPE);

                    }
/* type intervalQualifier */
start_field : non_second_datetime_field
            {
              $$ = new (PARSERHEAP()) IntervalQualifier(PARSERHEAP(), $1, IntervalQualifier::DEFAULT_LEADING_PRECISION);
            }
            | non_second_datetime_field ts_left_unsigned_right
            {
              $$ = new (PARSERHEAP()) IntervalQualifier(PARSERHEAP(), $1, $2);
            }

fraction_only_interval :  TOK_FRACTION                           // returned in MP mode only
                {                                  
                   $$ = new (PARSERHEAP())
                        IntervalQualifier(PARSERHEAP(), REC_DATE_FRACTION_MP,
                                      SQLInterval::DEFAULT_LEADING_PRECISION,
                                      REC_DATE_FRACTION_MP,
                                      SQLInterval::MAX_FRACTION_PRECISION);
                }
                | TOK_FRACTION ts_left_unsigned_right   
                {                                  
                   $$ = new (PARSERHEAP())
                        IntervalQualifier(PARSERHEAP(), REC_DATE_FRACTION_MP,
                                      $2,
                                      REC_DATE_FRACTION_MP,
                                      SQLInterval::MAX_FRACTION_PRECISION);
                   if (! $$->checkValid(SqlParser_Diags)) YYERROR;
                }
                | TOK_FRACTION TOK_TO interval_fraction_field
                {
                   $$ = new (PARSERHEAP())
                        IntervalQualifier(PARSERHEAP(), REC_DATE_FRACTION_MP,
                                      SQLInterval::DEFAULT_LEADING_PRECISION,
                                      REC_DATE_FRACTION_MP,
                                      $3);

                   if (! $$->checkValid(SqlParser_Diags)) YYERROR;
                }
                | TOK_FRACTION ts_left_unsigned_right  TOK_TO interval_fraction_field
                {
                   $$ = new (PARSERHEAP())
                        IntervalQualifier(PARSERHEAP(), REC_DATE_FRACTION_MP,
                                      $2,
                                      REC_DATE_FRACTION_MP,
                                      $4);

                   if (! $$->checkValid(SqlParser_Diags)) YYERROR;
                }
interval_fraction_field  : TOK_FRACTION                            // returned in MP mode only
                {                                  
                   $$ = SQLInterval::MAX_FRACTION_PRECISION ; 
                }
                | TOK_FRACTION ts_left_unsigned_right     
                {                                  
                   $$ = $2;
                }

/* type intervalQualifier */
end_field : non_second_datetime_field
          {
            $$ = new (PARSERHEAP()) IntervalQualifier(PARSERHEAP(), $1, IntervalQualifier::DEFAULT_LEADING_PRECISION);
          }
          | TOK_SECOND
          {
            $$ = new (PARSERHEAP()) IntervalQualifier(PARSERHEAP(), REC_DATE_SECOND, IntervalQualifier::DEFAULT_LEADING_PRECISION);
          }
          | TOK_SECOND ts_left_unsigned_right
          {
             $$ = new (PARSERHEAP())
	       IntervalQualifier(PARSERHEAP(), REC_DATE_SECOND,
                            SQLInterval::DEFAULT_LEADING_PRECISION,
                            REC_DATE_SECOND,
                            $2);

             if (! $$->checkValid(SqlParser_Diags)) YYERROR;
          }
          | interval_fraction_field
            {
             $$ = new (PARSERHEAP())
	       IntervalQualifier(PARSERHEAP(), REC_DATE_SECOND,
                            SQLInterval::DEFAULT_LEADING_PRECISION,
                            REC_DATE_SECOND,
                            $1);

             if (! $$->checkValid(SqlParser_Diags)) YYERROR;

	     // Create table with data type INTERVAL FRACTION not supported
	     $$->setDTIFlag(IntervalType::UNSUPPORTED_DDL_DATA_TYPE);
            }

/* type intervalQualifier */
single_datetime_field : start_field
                      {
                        $$ = $1;
                      }
                      | TOK_SECOND
                      {
                        $$ = new (PARSERHEAP())
			  IntervalQualifier(PARSERHEAP(), REC_DATE_SECOND,
                                            IntervalQualifier::DEFAULT_LEADING_PRECISION);
                      }
                      | TOK_SECOND ts_left_unsigned_right
                      {
                        $$ = new (PARSERHEAP())
			  IntervalQualifier(PARSERHEAP(), REC_DATE_SECOND, $2);
                        if (! $$->checkValid(SqlParser_Diags)) YYERROR;
                      }
                      | TOK_SECOND '(' unsigned_integer ',' unsigned_integer ')'
                      {
                        //
                        // Don't use the left_uint_uint_right production here.
                        // In that production, the second uint defaults to 0
                        // if omitted.  We want the default fraction precision
                        // to be 6.
                        //
                        $$ = new (PARSERHEAP())
			  IntervalQualifier(PARSERHEAP(), REC_DATE_SECOND,
					    $3,
					    REC_DATE_SECOND,
					    $5);
                        if (! $$->checkValid(SqlParser_Diags)) YYERROR;
                      }

/* type datetimeField */
non_second_datetime_field : TOK_YEAR
                          {
                            $$ = REC_DATE_YEAR;
                          }
                          | TOK_MONTH
                          {
                            $$ = REC_DATE_MONTH;
                          }
                          | TOK_DAY
                          {
                            $$ = REC_DATE_DAY;
                          }
                          | TOK_HOUR
                          {
                            $$ = REC_DATE_HOUR;
                          }
                          | TOK_MINUTE
                          {
                            $$ = REC_DATE_MINUTE;
                          }
new_non_second_datetime_field:
                          TOK_CENTURY
                          {
                            $$ = REC_DATE_CENTURY;
                          }
                          | TOK_DECADE
                          {
                            $$ = REC_DATE_DECADE;
                          }
                          | TOK_WEEK
                          {
                            $$ = REC_DATE_WEEK;
                          }
                          | TOK_QUARTER
                          {
                            $$ = REC_DATE_QUARTER;
                          }
                          | TOK_EPOCH
                          {
                            $$ = REC_DATE_EPOCH;
                          }
                          | TOK_DOW
                          {
                            $$ = REC_DATE_DOW;
                          }
                          | TOK_DOY
                          {
                            $$ = REC_DATE_DOY;
                          }
                          | TOK_WOM
                          {
                            $$ = REC_DATE_WOM;
                          }

/* type datetimeField */
datetime_field : non_second_datetime_field
               {
                 $$ = $1;
               }
               | new_non_second_datetime_field
               {
                 $$ = $1;
               }
               | TOK_SECOND
               {
                 $$ = REC_DATE_SECOND;
               }

/* type item */
dynamic_parameter : PARAMETER
		      {
			if (CmpCommon::context()->GetMode() == STMT_STATIC)
			  {
			    // 3048 Dyn params not allowed in static compile.
			    // CR 10-010608-3272 			    
			    if (*$1 == "") 
			      {
				*SqlParser_Diags << DgSqlCode(-3048) << DgString0("?");
			      }
			    else 
			      {
				*SqlParser_Diags << DgSqlCode(-3048) << DgString0(*$1);
			      }
			    YYERROR;
			  }
			else
			  {
			    $$ = new (PARSERHEAP()) DynamicParam(*$1, PARSERHEAP());
			    TheHostVarRoles->addARole(HV_IS_DYNPARAM);
			    AllHostVars->insert($$);
			    setHVorDPvarIndex ( $$, $1 );
			    delete $1;
			    $1 = NULL;
                            SqlParser_CurrentParser->collectItem4HQC($$);
			  }
		      }

/******************************** ## implement later (ANSI 6.15 SR2)
                  | PARAMETER interval_qualifier
		      {
		      }
********************************/

dynamic_parameter_array : PARAMETER '[' unsigned_integer ']' 
			    {
				if (CmpCommon::context()->GetMode() == STMT_STATIC)
				{
				    // 3048 Dyn params not allowed in static compile.
				    // CR 10-010608-3272 			    
				    if (*$1 == "") 
				    {
					*SqlParser_Diags << DgSqlCode(-3048) << DgString0("?");
				    }
				    else 
				    {
					*SqlParser_Diags << DgSqlCode(-3048) << DgString0(*$1);
				    }
				    YYERROR;
				}
				else
				{
				    if ($3 > 0) {
					$$ = new (PARSERHEAP()) DynamicParam(*$1, PARSERHEAP());
					((DynamicParam *) $$)->setRowsetSize($3);
					TheHostVarRoles->addARole(HV_IS_DYNPARAM);
					AllHostVars->insert($$);
					setHVorDPvarIndex ( $$, $1 );
                                       delete $1;
                                       $1 = NULL;
				    }
				    else {
					*SqlParser_Diags << DgSqlCode(-30016) ;
					YYERROR;
				    }

				}
			    }

// Host Variable Expression Formats
// --------------------------------
// Host variable expressions, in general, come in four varieties,
// depending on whether an indicator and/or prototype value is present
// (indicators may have a prototype value if the main host variable
// may have a prototype).  We denote these (), (I), (P), and (IP),
// which mean "no prototype, no indicator", "with indicator, but no
// prototype", and so on.
//
// Here are the uses of host variable expressions, then:
//   (P)   table names
//   (IP)  currently unused (candidate would for certain input host variables)
//   (I)   output host variables (which can't have prototype values)
//   ()    strings (i.e., prepare stmt), simple value spec, simple target
//           spec, and entity names (i.e., extended dynamic cursor)

// This non-terminal provides for host variable expressions of format "()"
// as given above.

/* item */
simple_host_variable : HOSTVAR
	{
          if (CmpCommon::getDefault(MODE_SPECIAL_4) == DF_ON) 
            {
              $$ = new (PARSERHEAP()) DynamicParam(*$1, PARSERHEAP());
              TheHostVarRoles->addARole(HV_IS_DYNPARAM);
              AllHostVars->insert($$);
              setHVorDPvarIndex ( $$, $1 );
              delete $1;
            }
          else
            {
              $$ = makeHostVar($1,NULL);
              delete $1;  // okay to delete, we made a copy in makeHostVar
              AllHostVars->insert($$);
              TheHostVarRoles->addUnassigned();
            }
	}

// This production is for a host variable, with a prototype required,
// and with no indicator.  This is according to format "(P)" given above.
// Such host variable expressions always supply input values.
//
// Prototype values disallow date, time, and interval literals
// for reasons of syntactic complexity.  If we were to allow such literals,
// then there would be a conflict at the INSERT statement.

/* item */
hostvar_and_prototype : HOSTVAR TOK_PROTOTYPE mvs_umd_option character_string_literal 
	{ 
          // DEFAULT_CHARSET has no effect on character_string_literal in this context
          HostVar *hv = makeHostVar($1,NULL);
          $$ = hv;
	  delete $1;  // okay to delete, we made a copy in makeHostVar

          hv->setPrototypeValue(*$4);
	  delete $4;  // okay to delete, we just made a copy

	  // Remove leading/trailing blanks from string literal --
	  // the token(s) within the literal is the real proto value
	  TrimNAStringSpace(hv->getPrototypeValue());
	  if (hv->getPrototypeValue().isNull())
	    {
	      yyerror("");	// emits syntax error 15001
	      YYERROR;
	    }

          if (TRUE == $3) //MVS
            hv->setSpecialType(ExtendedQualName::MVS_UMD);
	  
	  AllHostVars->insert($$);
          TheHostVarRoles->addARole(HV_IS_INPUT);
	}

param_and_prototype : PARAMETER TOK_PROTOTYPE character_string_literal 
	{ 
          // DEFAULT_CHARSET has no effect on character_string_literal in this context
	  if (CmpCommon::context()->GetMode() == STMT_STATIC)
	    {
	      // 3048 Dyn params not allowed in static compile.
	      if (*$1 == "") 
		{
		  *SqlParser_Diags << DgSqlCode(-3048) << DgString0("?");
		}
	      else 
		{
		  *SqlParser_Diags << DgSqlCode(-3048) << DgString0(*$1);
		}
	      YYERROR;
	    }

          HostVar *hv = makeHostVar($1,NULL, TRUE);
          $$ = hv;
	  delete $1;  // okay to delete, we made a copy in makeHostVar
	  
	  hv->setPrototypeValue(*$3);
	  delete $3;  // okay to delete, we just made a copy

	  // Remove leading/trailing blanks from string literal --
	  // the token(s) within the literal is the real proto value
	  TrimNAStringSpace(hv->getPrototypeValue());
	  if (hv->getPrototypeValue().isNull())
	    {
	      yyerror("");	// emits syntax error 15001
	      YYERROR;
	    }
	  
	  AllHostVars->insert($$);
          TheHostVarRoles->addARole(HV_IS_DYNPARAM);
	}


mvs_umd_option: empty 
				{
					$$ = FALSE;
				}
				| TOK_MVS_UMD
				{
					$$ = TRUE;
				}
	//////////////////////////////////////////////////////////////////////////
 /*
	|  HOSTVAR  TOK_PROTOTYPE TOK_MVS_UMD character_string_literal
	{ 
          // DEFAULT_CHARSET has no effect on character_string_literal in this context
          HostVar *hv = makeHostVar($1,NULL);
          $$ = hv;
	  delete $1;  // okay to delete, we made a copy in makeHostVar

	  if ((RecompLateNameInfoList *)CmpCommon::context()->recompLateNameInfoList())
	    {
	      char * newPtype = 
		getPrototypeFromLateNameInfoList
		((RecompLateNameInfoList *)CmpCommon::context()->recompLateNameInfoList(),
		 hv->getName(),
		 *$4);

	      hv->setPrototypeValue(NAString(newPtype));
	    }
	  else
	    {
	      hv->setPrototypeValue(*$4);
	    }

	  delete $4;  // okay to delete, we just made a copy
	  // Remove leading/trailing blanks from string literal --
	  // the token(s) within the literal is the real proto value
	  TrimNAStringSpace(hv->getPrototypeValue());
	  if (hv->getPrototypeValue().isNull())
	    {
	      yyerror("");	// emits syntax error 15001
	      YYERROR;
	    }

//      if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
      if (1) // XXXXXXXXMVSXXXXXXXXX
   		hv->setSpecialType(ExtendedQualName::MVS_UMD);
      else
      { 
		  yyerror(""); YYERROR; //internal syntax only!
	  }

	  AllHostVars->insert($$);
          TheHostVarRoles->addARole(HV_IS_INPUT);
	}
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
*/

// This non-terminal provides for host variable expressions of format
// "(IP)" as described above.

/* item */
input_hostvar_expression :  HOSTVAR
                 {
                   if (CmpCommon::getDefault(MODE_SPECIAL_4) == DF_ON) 
                     {
                       $$ = new (PARSERHEAP()) DynamicParam(*$1, PARSERHEAP());
                       TheHostVarRoles->addARole(HV_IS_DYNPARAM);
                       AllHostVars->insert($$);
                       setHVorDPvarIndex ( $$, $1 );
                       delete $1;
                     }
                   else
                     {
                       $$ = makeHostVar($1,NULL);
                       delete $1;
                       
                       AllHostVars->insert($$);
                       TheHostVarRoles->addUnassigned();
                       
                       // If we are in an Assignment statement of a 
                       //Compound Statement, and this
                       // is a host variable on the left-hand side of 
                       //the statement, we store it.
                       
                       if (InAssignmentSt) {
                         AssignmentHostVars->insert($$);  
                       }
                     }
		   }
                 
	      | HOSTVAR HOSTVAR
                 {
		   $$ = makeHostVar($1,$2);
		   delete $1;
		   delete $2;
		   AllHostVars->insert($$);
		   TheHostVarRoles->addUnassigned();
		   TheHostVarRoles->add_indicator();
		   if (InAssignmentSt) {
		     AssignmentHostVars->insert($$);  
		   }
          }
	      | HOSTVAR TOK_INDICATOR HOSTVAR
                 {
		   $$ = makeHostVar($1,$3);
		   delete $1;
		   delete $3;
		   AllHostVars->insert($$);
		   TheHostVarRoles->addUnassigned();
		   TheHostVarRoles->add_indicator();
		   if (InAssignmentSt) {
		     AssignmentHostVars->insert($$);  
		   }

           }

// This non-terminal exists strictly to eliminate some shift/reduce and reduce/reduce errors
// 
/* type na_type */
Set_Cast_Global_False_and_data_type: {cast_target_cs_specified=FALSE;} data_type
                         { $$ = $2; }

// This non-terminal provide for host variable expressions of format
// "(I)" as described above.

/* item */
hostvar_expression : input_hostvar_expression
              | TOK_CAST '(' HOSTVAR  TOK_AS  Set_Cast_Global_False_and_data_type ')'
                     {
                   $$ = makeHostVar($3,NULL);
                   delete $3;
                   AllHostVars->insert($$);
                   TheHostVarRoles->addUnassigned();
                   $$ = new (PARSERHEAP()) Cast($$, $5);
                   if ( cast_target_cs_specified )
                   {
                      ((Cast *)$$)->setTgtCSSpecified(TRUE);
                      cast_target_cs_specified = FALSE ;
                   }
				   if (InAssignmentSt) {
				     /* Syntax error */
				     *SqlParser_Diags << DgSqlCode(1000);
                     YYABORT;
				   } 
                 }
              | TOK_CAST '(' HOSTVAR  TOK_AS  Set_Cast_Global_False_and_data_type  ')'  HOSTVAR
                 {
                   $$ = makeHostVar($3,$7);
                   delete $3;
                   delete $7;
                   AllHostVars->insert($$);
                   TheHostVarRoles->addUnassigned();
                   TheHostVarRoles->add_indicator();
                   $$ = new (PARSERHEAP()) Cast($$, $5);
                   if ( cast_target_cs_specified )
                   {
                      ((Cast *)$$)->setTgtCSSpecified(TRUE);
                      cast_target_cs_specified = FALSE ;
                   }
				   if (InAssignmentSt) {
				     /* Syntax error */
				     *SqlParser_Diags << DgSqlCode(1000);
                     YYABORT;
				   } 

                 }
              | TOK_CAST '(' HOSTVAR  TOK_AS  Set_Cast_Global_False_and_data_type  ')'  TOK_INDICATOR  HOSTVAR
                 {
                   $$ = makeHostVar($3,$8);
                   delete $3;
                   delete $8;
                   AllHostVars->insert($$);
                   TheHostVarRoles->addUnassigned();
                   TheHostVarRoles->add_indicator();
                   $$ = new (PARSERHEAP()) Cast($$, $5);
                   if ( cast_target_cs_specified )
                   {
                      ((Cast *)$$)->setTgtCSSpecified(TRUE);
                      cast_target_cs_specified = FALSE ;
                   }
				   if (InAssignmentSt) {
				     /* Syntax error */
				     *SqlParser_Diags << DgSqlCode(1000);
                     YYABORT;
				   } 
                 }

/* type item */
internal_arith_placeholder : ARITH_PLACEHOLDER
				{
				  $$ = $1;
				}

/* type item */
internal_bool_placeholder : 
                            BOOL_PLACEHOLDER
				{
				  $$ = $1;
				}
                            | TOK_TRUE '(' value_expression ')'
                                {
                                  $$ =
				    new (PARSERHEAP()) 
				    BoolVal(ITM_RETURN_TRUE, $3);
				}
                            | TOK_FALSE '(' value_expression ')'
                                {
                                  $$ =
				    new (PARSERHEAP()) 
				    BoolVal(ITM_RETURN_FALSE, $3);
				}

// left recursion for insert statement values fix.
				  
insert_value_expression_list :	  insert_value_expression						
			  | insert_value_expression_list_comma	%prec ','
			  | insert_value_expression_list_paren	%prec ','
 	    				
insert_value_expression_list_comma : insert_value_expression ',' insert_value_expression
				{							  
					$$ = new (PARSERHEAP()) ItemList( $3, $1 );
				}	
		      	| insert_value_expression_list_comma ',' insert_value_expression  
				{
					$$ = new (PARSERHEAP()) ItemList( $3, $1 );
				}
							
insert_value_expression_list_paren : '(' insert_value_expression_list_comma ')'
				{
				    $$ = $2;
				}
			    | '(' insert_value_expression_list_paren ')'
				{
				    $$ = $2;
				}
				  		
insert_value_expression : value_expression 
                          | insert_obj_to_lob_function
                          | insert_empty_blob_clob

insert_obj_to_lob_function : 
			    TOK_STRINGTOLOB '(' value_expression ')'
			        {
				  $$ = new (PARSERHEAP()) LOBinsert( $3, NULL, LOBoper::STRING_, FALSE);
				}			       
			  | TOK_BUFFERTOLOB '(' TOK_LOCATION  value_expression',' TOK_SIZE value_expression')'
			        {
				  ItemExpr *bufAddr = $4;
				  ItemExpr *bufSize = $7;
				  bufAddr = new (PARSERHEAP())Cast(bufAddr, new (PARSERHEAP()) SQLLargeInt(PARSERHEAP(), TRUE,FALSE));
				  bufSize = new (PARSERHEAP())
				    Cast(bufSize, new (PARSERHEAP()) SQLLargeInt(PARSERHEAP(), TRUE, FALSE));
				  $$ = new (PARSERHEAP()) LOBinsert( bufAddr, bufSize, LOBoper::BUFFER_, FALSE);
				}
                          | TOK_FILETOLOB '(' character_literal_sbyte ')'
			        {
                                  
                                  $$ = new (PARSERHEAP()) LOBinsert( $3, NULL, LOBoper::FILE_, FALSE);
				}
			  | TOK_LOADTOLOB '(' literal ')'
			        {
                                  YYERROR;
                                  $$ = new (PARSERHEAP()) LOBinsert( $3, NULL, LOBoper::LOAD_);
				}
			  | TOK_EXTERNALTOLOB '(' literal ')'
			        {
                         
                                  $$ = new (PARSERHEAP()) LOBinsert( $3, NULL, LOBoper::EXTERNAL_);
				}
			  | TOK_EXTERNALTOLOB '(' literal ',' literal ')'
			        {
                                  
                                  $$ = new (PARSERHEAP()) LOBinsert( $3, $5, LOBoper::EXTERNAL_);
				}
insert_empty_blob_clob : TOK_EMPTY_BLOB '(' ')' 
                    {
                      $$ = new (PARSERHEAP()) LOBinsert(NULL,NULL,LOBoper::EMPTY_LOB_);
                    }
                 | TOK_EMPTY_CLOB '(' ')'
                    {
                      $$ = new (PARSERHEAP()) LOBinsert(NULL,NULL,LOBoper::EMPTY_LOB_);
                    }
update_obj_to_lob_function : 
			    TOK_STRINGTOLOB '(' value_expression ')'
			        {
				  $$ = new (PARSERHEAP()) LOBupdate( $3, NULL, NULL,LOBoper::STRING_, FALSE);
				}
			  | TOK_STRINGTOLOB '(' value_expression ',' TOK_APPEND ')'
			        {
				  $$ = new (PARSERHEAP()) LOBupdate( $3, NULL,NULL, LOBoper::STRING_, TRUE);
				}
                          | TOK_FILETOLOB '('character_literal_sbyte ')'
			        {
				 
				  $$ = new (PARSERHEAP()) LOBupdate( $3, NULL,NULL,LOBoper::FILE_, FALSE);
				}
                          | TOK_FILETOLOB '('character_literal_sbyte ',' TOK_APPEND ')'
			        {
				 
				  $$ = new (PARSERHEAP()) LOBupdate( $3,NULL, NULL,LOBoper::FILE_, TRUE);
				}
			  | TOK_BUFFERTOLOB '(' TOK_LOCATION  value_expression ',' TOK_SIZE value_expression ')'
			        {
				  ItemExpr *bufAddr = $4;
				  ItemExpr *bufSize = $7;
				  bufAddr = new (PARSERHEAP())Cast(bufAddr, new (PARSERHEAP()) SQLLargeInt(PARSERHEAP(), TRUE,FALSE));
				  bufSize = new (PARSERHEAP())
				    Cast(bufSize, new (PARSERHEAP()) SQLLargeInt(PARSERHEAP(), TRUE, FALSE));
				  $$ = new (PARSERHEAP()) LOBupdate( bufAddr, NULL,bufSize, LOBoper::BUFFER_, FALSE);
				}
			  | TOK_BUFFERTOLOB '(' TOK_LOCATION value_expression ',' TOK_SIZE value_expression ',' TOK_APPEND')'
			        {
				  ItemExpr *bufAddr = $4;
				  ItemExpr *bufSize = $7;
				  bufAddr = new (PARSERHEAP())Cast(bufAddr, new (PARSERHEAP()) SQLLargeInt(PARSERHEAP(), TRUE,FALSE));
				  bufSize = new (PARSERHEAP())
				    Cast(bufSize, new (PARSERHEAP()) SQLLargeInt(PARSERHEAP(), TRUE, FALSE));
				  $$ = new (PARSERHEAP()) LOBupdate( bufAddr, NULL,bufSize, LOBoper::BUFFER_, TRUE);
				}

			  | TOK_EXTERNALTOLOB '(' literal ')'
			        {
                                  
				  $$ = new (PARSERHEAP()) LOBupdate( $3, NULL, NULL,LOBoper::EXTERNAL_, FALSE);
                                }
                                  | TOK_EXTERNALTOLOB '(' literal ',' TOK_APPEND ')'
			        {
                                  YYERROR;
				  $$ = new (PARSERHEAP()) LOBupdate( $3, NULL, NULL,LOBoper::EXTERNAL_, TRUE);
				}
			  | TOK_EXTERNALTOLOB '(' literal ',' literal ')'
			        {
                                  YYERROR;
				  $$ = new (PARSERHEAP()) LOBupdate( $3, $5, NULL,LOBoper::EXTERNAL_, FALSE);
				}
			  | TOK_LOADTOLOB '(' literal ',' TOK_APPEND ')'
			        {
				  YYERROR;
				  $$ = new (PARSERHEAP()) LOBupdate( $3, NULL, NULL,LOBoper::LOAD_, TRUE);
				}
                          | TOK_EMPTY_BLOB '(' ')' 
                               {
                                 ItemExpr *dummy = new (PARSERHEAP())ConstValue(0);                              
                                  $$ = new (PARSERHEAP()) LOBupdate(dummy,NULL,NULL,LOBoper::EMPTY_LOB_,FALSE);
                               }
                          | TOK_EMPTY_CLOB '(' ')'
                              {
                                ItemExpr *dummy = new (PARSERHEAP())ConstValue(0);                                
                                 $$ = new (PARSERHEAP()) LOBupdate(dummy,NULL,NULL,LOBoper::EMPTY_LOB_,FALSE);
                               }
 
                                
select_lob_to_obj_function : TOK_LOBTOFILE '(' value_expression ',' literal ')'
			        {
				  
				  $$ = new (PARSERHEAP()) LOBselect( $3, $5, LOBoper::FILE_);
				  
				}
                         
			  | TOK_LOBTOSTRING '(' value_expression ')'
			        {
				  
				  $$ = new (PARSERHEAP()) LOBconvert( $3,LOBoper::STRING_);
				 
				}
			  | TOK_LOBTOSTRING '(' value_expression ',' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
			        {
				 
				  Int64 tgtSize = atoInt64($5->data());
				  $$ = new (PARSERHEAP()) LOBconvert( $3,  LOBoper::STRING_, (Lng32)tgtSize);
				  
				}
			  | TOK_LOBTOSTRING '(' value_expression ',' TOK_EXTRACT ',' TOK_OUTPUT TOK_ROW TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ')'
			        {
				  
				  Int64 rowSize = atoInt64($10->data());
				  $$ = new (PARSERHEAP()) LOBextract( $3, (Lng32)rowSize);
				  
				}
			  | TOK_LOBTOSTRING '(' value_expression ',' TOK_EXTRACT ')'
			        {
				  
				  Int64 rowSize = 1000;
				  $$ = new (PARSERHEAP()) LOBextract( $3, (Lng32)rowSize);
				  
				}
                           


table_value_constructor : TOK_VALUES '(' insert_value_expression_list ')' 
				{
					$$ = new (PARSERHEAP()) Tuple($3->reverseTree());
				}
                | TOK_VALUES '(' insert_value_expression_list ')' ',' list_of_values
				{
				  ItemList * il = new (PARSERHEAP()) 
				    ItemList(new(PARSERHEAP())Convert($3->reverseTree()), $6->reverseTree());
				  $$ = new (PARSERHEAP()) TupleList(il);
				}

// NB: Beware of using right recursive production here
//   list_of_values : '(' insert_value_expression_list ')' ',' list_of_values
// causes parser stack overflow when processing a long IN predicate
//   <col> IN (values(1),(2),...,(999))
// of 996 elements or longer. Trying to workaround the parser stack overflow
// by bumping bison's YYMAXDEPTH beyond 4,000 does NOT work on NSK.
// Right recursive productions are the root cause of the problems reported in
// solutions: 10-070627-5883, 10-100524-0557.
list_of_values : '(' insert_value_expression_list ')'
				{								
					$$ = new(PARSERHEAP()) Convert($2->reverseTree());
				}
               | list_of_values ',' '(' insert_value_expression_list ')'
				{					
					$$ = new (PARSERHEAP()) 
						 ItemList(new(PARSERHEAP()) Convert($4->reverseTree()), $1);
				}

// end of fix: left recursion for insert statement values.		  

		  
table_expression : from_clause where_clause sample_clause
                   cond_transpose_clause_list sequence_by_clause
                   group_by_clause_non_empty qualify_clause
                   {
		     $$ = 
		       getTableExpressionRelExpr($1, 
                                                 $2, 
                                                 $3, 
                                                 $4, 
                                                 $5, 
                                                 $6, 
                                                 NULL, 
                                                 $7,
                                                 SqlParser_CurrentParser->topHasTDFunctions(), 
                                                 SqlParser_CurrentParser->topHasOlapFunctions());
		                                 
                       if (SqlParser_CurrentParser->topHasTDFunctions() && $5)
                       {
                          SqlParser_CurrentParser->setTopHasTDFunctions(FALSE);
                       }
		       
		   }

                | from_clause where_clause sample_clause
                   cond_transpose_clause_list sequence_by_clause
                   having_clause_non_empty
                   {
		     $$ = 
		       getTableExpressionRelExpr($1, 
		                                 $2, 
		                                 $3, 
		                                 $4, 
		                                 $5, 
		                                 NULL, 
		                                 $6,
		                                 NULL,
		                                 FALSE, 
                                                 SqlParser_CurrentParser->topHasOlapFunctions());
                     SqlParser_CurrentParser->setTopHasTDFunctions(FALSE);
		   }
		   
                | from_clause where_clause sample_clause
                   cond_transpose_clause_list sequence_by_clause
                   qualify_clause
                   {
                     $$ = 
		        getTableExpressionRelExpr($1, 
                                                  $2, 
                                                  $3, 
                                                  $4, 
                                                  $5, 
                                                  NULL, 
                                                  NULL,
                                                  $6,
                                                  SqlParser_CurrentParser->topHasTDFunctions(), 
                                                  SqlParser_CurrentParser->topHasOlapFunctions() );
                                                  
                     if (SqlParser_CurrentParser->topHasTDFunctions() && $5)
                      {
                        SqlParser_CurrentParser->setTopHasTDFunctions(FALSE);
                      }
		   }


                | from_clause where_clause sample_clause
                   cond_transpose_clause_list sequence_by_clause
                   group_by_clause_non_empty having_clause_non_empty
                   {
		     $$ = 
		       getTableExpressionRelExpr($1, 
		                                 $2, 
		                                 $3, 
		                                 $4, 
		                                 $5, 
		                                 $6, 
		                                 $7,
		                                 NULL,
		                                 FALSE,
		                                 SqlParser_CurrentParser->topHasOlapFunctions());
                     SqlParser_CurrentParser->setTopHasTDFunctions(FALSE);
		   }

                 | from_clause where_clause sample_clause
                   cond_transpose_clause_list sequence_by_clause
                   having_clause_non_empty group_by_clause_non_empty
                   {
		     $$ = 
		       getTableExpressionRelExpr($1, 
		                                 $2, 
		                                 $3, 
		                                 $4, 
		                                 $5, 
		                                 $7, 
		                                 $6,
		                                 NULL,
		                                 FALSE,
		                                 SqlParser_CurrentParser->topHasOlapFunctions());
                     SqlParser_CurrentParser->setTopHasTDFunctions(FALSE);
		   }

/* type relx */
from_clause : TOK_FROM global_hint table_reference { $$ = $3; }
	    | from_clause ',' table_reference
			      {
				$$ = new (PARSERHEAP()) Join($1, $3, REL_JOIN);
			      }

/* type item */
join_specification : join_condition
	     // | named_columns_join  // TOK_USING '(' value_expression_list ')'

/* type item */
join_condition : TOK_ON search_condition
			      { $$ = $2; }

/* type item */
where_clause : { $$ = NULL; }
             | TOK_WHERE search_condition
			      { $$ = $2; }

group_by_clause_non_empty : TOK_GROUP TOK_BY value_expression_list 
			      { $$ = $3; }
                          | TOK_GROUP TOK_BY TOK_ROLLUP '(' value_expression_list ')'
			      { 
                                $5->setIsGroupByRollup(TRUE);
                                $$ = $5; 
                              }

/* type item */
having_clause_non_empty : TOK_HAVING search_condition
			      { $$ = $2; }
			      

qualify_clause : { $$ = NULL; }
               | TOK_QUALIFY search_condition
                  { 
                    if (SqlParser_CurrentParser->modeSpecial1()	|| 
                        CmpCommon::getDefault(COMP_BOOL_200) == DF_ON) 
                        $$ = $2;    
                    else
                        YYERROR;
                  }
					
/* item */
sort_by_value_expression : value_expression
            | value_expression ordering_spec
              {
                $$ = $1;
                if ($2 == TOK_DESC || $2 == TOK_DESCENDING)
                {
                  $$ = new (PARSERHEAP()) InverseOrder($$);
                }
                else
                {
                  //To that ASC sort order was specified explicitely we use insevreOrder of inversOrder
                  //this is needed to deal with the default order for TD rank which is by default descending
                   if (SqlParser_CurrentParser->modeSpecial1()	|| 
                        CmpCommon::getDefault(COMP_BOOL_200) == DF_ON) 
                        $$ =new (PARSERHEAP()) InverseOrder( new (PARSERHEAP()) InverseOrder($$));
                }
              }

/* item */
sort_by_value_expression_list : sort_by_value_expression
   | sort_by_value_expression ',' sort_by_value_expression_list
           {
              $$ = new (PARSERHEAP()) ItemList( $1, $3);
           }
			      

/* item */
sort_by_key : dml_column_reference
            | dml_column_reference ordering_spec
              {
		$$ = $1;
		if ($2 == TOK_DESC || $2 == TOK_DESCENDING)
		  {
		    $$ = new (PARSERHEAP()) InverseOrder($$);
		  }
              }

/* item */
sort_by_key_list : sort_by_key
   | sort_by_key ',' sort_by_key_list
           {
              $$ = new (PARSERHEAP()) ItemList( $1, $3);
           }

/* type item */
sort_by_clause : { $$ = NULL; }
               | TOK_SORT TOK_BY sort_by_key_list
			      { $$ = $3; }

/* type item */
sequence_by_clause : { $$ = NULL; }
                   | TOK_SEQUENCE_BY sort_by_key_list
                     { $$ = $2; }


/* type item */
transpose_value : value_expression
                | value_expression_list_paren

transpose_item_list : transpose_value
                    {
		      // Create a NULL terminated list,
		      // to make it easier to traverse in Transpose::bindNode()
		      //
		      $$ = new (PARSERHEAP()) ItemList($1,NULL);
		    }
                    | transpose_value ',' transpose_item_list
                    {
		      $$ = new (PARSERHEAP()) ItemList($1,$3);
		    }

transpose_col_list : identifier
                   {
		     $$ = new (PARSERHEAP())
		       ColReference(new (PARSERHEAP())
				    ColRefName(*$1, PARSERHEAP()));
		     delete $1;
		   }
                   | '(' column_list ')'
                   {
		     $$ = $2;
		   }

/* type item */
transpose_set : transpose_item_list TOK_AS transpose_col_list
              {
		$$ = new (PARSERHEAP()) ItemList($1, $3);
	      }

/* type item */
transpose_list : transpose_set
               {
		 // Create a NULL terminated list.
		 // This make it easier to traverse in Transpose::bindNode()
		 //
		 $$ = new (PARSERHEAP()) ItemList($1,NULL);
	       }
               | transpose_set transpose_list
               {
		 $$ = new (PARSERHEAP()) ItemList($1,$2);
	       }

/* type relx */
transpose_clause : TOK_TRANSPOSE transpose_list TOK_KEY TOK_BY identifier
                 {

		   ItemExpr *keyCol = new (PARSERHEAP()) 
		     ColReference (new (PARSERHEAP()) ColRefName(*$5, PARSERHEAP()));
		   delete $5;
				  
		   $$ = new (PARSERHEAP()) Transpose($2,keyCol);
                 }
                 | TOK_TRANSPOSE transpose_list
                 {
		   $$ = new (PARSERHEAP()) Transpose($2, (ItemExpr *)NULL);
                 }

/* type relx */
cond_transpose_clause_list : { $$ = NULL; }
                           | transpose_clause_list

/* type relx */
transpose_clause_list : transpose_clause
                      | transpose_clause_list transpose_clause
                      {
			$2->setChild(0,$1);
			$$ = $2;
		      }

/* type relx */
sample_clause : sample_clause_x
                  { if ($1 != NULL && Get_SqlParser_Flags(PARSING_IUS_WHERE_CLAUSE))
                      {
                        *SqlParser_Diags << DgSqlCode(-9237) << DgString0("SAMPLE");
                        YYERROR;
                      }
                    else
                      $$ = $1; 
                  }

/* type relx */
sample_clause_x : { $$ = NULL; }
            | TOK_SAMPLE_FIRST sample_size_expr sort_by_clause
              {
                $$ = new (PARSERHEAP()) RelSample ((RelExpr *)NULL,
                                                   RelSample::FIRSTN,
                                                   $2,
                                                   $3);
              }
            | TOK_SAMPLE_PERIODIC sample_size_expr TOK_EVERY
              sample_size_numeric sample_absolute_rows sort_by_clause
              {
                $2->setChild(3, $4);
                ((ItmBalance *)$2)->setSkipAbs($5);
                $$ = new (PARSERHEAP()) RelSample ((RelExpr *)NULL,
                                                   RelSample::PERIODIC,
                                                   $2,
                                                   $6);
              }
            | TOK_SAMPLE_RANDOM sample_size_expr
              {
                $$ = new (PARSERHEAP()) RelSample ((RelExpr *)NULL,
                                                RelSample::RANDOM, $2);
              }
            | TOK_SAMPLE_RANDOM sample_cluster_expr
              {
                $$ = new (PARSERHEAP()) RelSample ((RelExpr *)NULL,
                                                RelSample::CLUSTER, $2);
              }

/* type item */
sample_clusters : TOK_CLUSTERS TOK_OF NUMERIC_LITERAL_EXACT_NO_SCALE TOK_BLOCKS
               {
                 $$ = literalOfNumericNoScale($3);
                 if (! $$) YYERROR;
               }                

/* type boolean */
sample_absolute :  { $$ = TRUE; }
                | TOK_PERCENT { $$ = FALSE; }

/* type boolean */
sample_absolute_rows : TOK_ROWS    { $$ = TRUE; }
                     | TOK_PERCENT { $$ = FALSE; }
                     | TOK_PERCENT TOK_ROWS { $$ = FALSE; }

/* type item */
sample_size_numeric : NUMERIC_LITERAL_EXACT_NO_SCALE
                    {
                      $$ = literalOfNumericNoScale($1);
                      if (! $$) YYERROR;
                    }
                    | NUMERIC_LITERAL_EXACT_WITH_SCALE
                    {
                      $$ = literalOfNumericWithScale($1);
                      if (! $$) YYERROR;
                    }

/* type item */
sample_cluster_expr : sample_size_numeric sample_absolute sample_clusters
                {
                  $$ = new (PARSERHEAP()) 
                       ItmBalance(new (PARSERHEAP()) BoolVal(ITM_RETURN_TRUE),
                       $1,
                       NULL, 
                       $3, 
                       $2,
                       FALSE);
                }

/* type item */
sample_size_expr : sample_size_numeric sample_absolute_rows
                {
                  $$ = new (PARSERHEAP()) 
                       ItmBalance(new (PARSERHEAP()) BoolVal(ITM_RETURN_TRUE),
                       $1,
                       NULL, 
                       NULL,
                       $2,
                       FALSE);
                }
              | balance_expr

/* type item */
balance_expr : TOK_BALANCE balance_when_then_list TOK_END
                {
                  $$ = $2;
                }

/* NB: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *  Beware of adding clauses with a closing END like balance_expr above.
 *  They can mislead arkcmp/StaticCompiler.cpp's isEndOfStmt() and 
 *  sqlci/InputStmt.cpp's findBlockStmt() into finding the wrong END
 *  of a compound statement. For example:
 *     exec sql begin 
 *       insert into t values(7);
 *       select a into :h from m 
 *         sample first balance when a < 10 then 5 rows
 *                              when a >=10 then 7 rows
 *                      end sort by a;
 *     end;
 *  used to get a false syntax error due to a prematurely ENDed 
 *  compound statement. This is a consequence of SQLMX having 
 *  multiple parsers recognizing partially overlapping languages. To be
 *  more precise, both tdm_arkcmp and sqlci do only a partial scan of 
 *  their input looking for the beginning and ending of SQL statements 
 *  (among the input languages they recognize), ignore everything in
 *  between while buffering the statement, then passing it here 
 *  (sqlparser.y) for parsing. Therefore, the ending of SQLMX statements
 *  should be unambiguously distinguishable from the ending of compound
 *  statements. In case expressions "case .... end", we got away with it
 *  rather easily because "case" is an ANSI reserved word. But, for
 *  balance_expr, we had to solve the problem by considering "balance when" 
 *  as starting a new nesting level. But, "balance when" must be ignored 
 *  in "case balance when ... end" because "balance" here is an identifier
 *  and not a keyword. So, if you add any new clause with an "END" in it,
 *  please fix StaticCompiler.cpp and InputStmt.cpp also if your new 
 *  clause can appear inside a compound statement.
 */

/* type item */
balance_when_then_list : balance_when_then balance_when_then_list
                {
                  $1->setChild(2, $2);
                  $$ = $1;
                }
              | balance_when_then balance_else
                {
                  $1->setChild(2, $2);
                  $$ = $1;
                }

/* type item */
balance_when_then : TOK_WHEN search_condition TOK_THEN sample_size_numeric
                    sample_absolute_rows
                {
                  $$ = new (PARSERHEAP())
                       ItmBalance($2,
                       $4,
                       NULL, 
                       NULL, 
                       $5,
                       FALSE);
                }

/* type item */
balance_else : TOK_ELSE sample_size_numeric sample_absolute_rows
                {
                  $$ = new (PARSERHEAP())
                       ItmBalance(new (PARSERHEAP()) BoolVal(ITM_RETURN_TRUE),
                       $2,
                       NULL, 
                       NULL, 
                       $3, 
                       FALSE);
                }
              | /* empty */
                {
                  $$ = NULL;
                }

/* TD-style LOCKING <table> FOR ACCESS list -- ignore them! */
optional_locking_stmt_list : empty 
                               {$$ = NULL;}
                           | locking_stmt_list 
                               {$$ = NULL;}
locking_stmt_list : locking_stmt
                      {
			CheckModeSpecial1();
		      }

                    | locking_stmt_list locking_stmt

locking_stmt : TOK_LOCKING actual_table_name TOK_FOR TOK_ACCESS
                  { 
		    $$ = NULL; 
		  }
               | TOK_LOCKING TOK_TABLE actual_table_name TOK_FOR TOK_ACCESS
                  { 
		    $$ = NULL; 
		  }
               | TOK_LOCK actual_table_name TOK_FOR TOK_ACCESS
                  { 
		    $$ = NULL; 
		  }
               | TOK_LOCK TOK_TABLE actual_table_name TOK_FOR TOK_ACCESS
                  { 
		    $$ = NULL; 
		  }
               | TOK_LOCK_ROW TOK_FOR TOK_ACCESS
                  { 
		    $$ = NULL; 
		  }
               | TOK_LOCKING TOK_ROW TOK_FOR TOK_ACCESS
                  { 
		    $$ = NULL; 
		  }
               | TOK_LOCKING TOK_FOR TOK_ACCESS
                  { 
		    $$ = NULL; 
		  }

/* type tokval */
select_token : TOK_SELECT 
		{ 
		  SqlParser_CurrentParser->pushHasOlapFunctions (FALSE);
		  SqlParser_CurrentParser->pushHasTDFunctions (FALSE);
		}
               | TOK_SEL
                {
		  CheckModeSpecial1();
		  SqlParser_CurrentParser->pushHasOlapFunctions(FALSE);
		  SqlParser_CurrentParser->pushHasTDFunctions(FALSE);
		}
               | TOK_SELECT TOK_BEGIN_HINT ignore_ms4_hints TOK_END_HINT
                {
                  CheckModeSpecial4;

		  SqlParser_CurrentParser->pushHasOlapFunctions(FALSE);
		  SqlParser_CurrentParser->pushHasTDFunctions(FALSE);
		}

/* type hint */
ignore_ms4_hints : identifier '(' NUMERIC_LITERAL_EXACT_NO_SCALE  ')'
                              { $$ = NULL; }
                          | identifier 
                               { $$ = NULL; }

/* type relx */
query_specification :select_token set_quantifier query_spec_body 
    { 
       if ($2) {
         $$ = new (PARSERHEAP())
           RelRoot(new (PARSERHEAP())
                   GroupByAgg($3
                              ,REL_GROUPBY
                              ,new (PARSERHEAP())
                              ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP()))
                                        )
                         );
           assert($3->getOperatorType() == REL_ROOT);
           RelRoot *root1 = (RelRoot *) $$;
           RelRoot *root2 = (RelRoot *) $3;
           root1->assignmentStTree() = root2->assignmentStTree();
           root2->assignmentStTree() = NULL;
           }
       else
         $$ = $3;

       if (CmpCommon::getDefault(MVQR_LOG_QUERY_DESCRIPTORS) == DF_DUMP ||
           CmpCommon::getDefault(MVQR_LOG_QUERY_DESCRIPTORS) == DF_DUMP_MV)
         ((RelRoot*)$$)->setAnalyzeOnly();

    }

query_specification : exe_util_maintain_object 
                                {
				  RelRoot *root = new (PARSERHEAP())
				    RelRoot($1, REL_ROOT);
                                }

query_specification : exe_util_aqr
                                {
				  RelRoot *root = new (PARSERHEAP())
				    RelRoot($1, REL_ROOT);
                                }

query_specification : exe_util_get_qid
                                {
				  RelRoot *root = new (PARSERHEAP())
				    RelRoot($1, REL_ROOT);
                                }

query_specification : exe_util_get_lob_info
                                {
				  RelRoot *root = new (PARSERHEAP())
				    RelRoot($1, REL_ROOT);
                                }
/* type relx */
query_specification : select_token '[' firstn_sorted NUMERIC_LITERAL_EXACT_NO_SCALE ']' set_quantifier query_spec_body
	{
	  if ($6) {
	    $$ = new (PARSERHEAP())
	      RelRoot(new (PARSERHEAP())
		      GroupByAgg($7
				 ,REL_GROUPBY
				 ,new (PARSERHEAP())
				 ColReference(new (PARSERHEAP()) 
					      ColRefName(TRUE, PARSERHEAP())))
		      );
	   assert($7->getOperatorType() == REL_ROOT);
	   RelRoot *root1 = (RelRoot *) $$;
	   RelRoot *root2 = (RelRoot *) $7;
	   root1->assignmentStTree() = root2->assignmentStTree();
	   root2->assignmentStTree() = NULL;
	   }
	  else
	    $$ = $7;

	  assert($$->getOperatorType() == REL_ROOT);
	  
	  RelRoot * rootNode = (RelRoot *)$$;
	  Int64 numRows = atoInt64($4->data());
	  if (($3 == TOK_LAST) && 
	      ((numRows < 0) || (numRows > 1)))
	    {
	      yyerror("Number of rows must be 0 or 1 with LAST option. \n");
	      YYERROR;
	    }

	  if ($3 == TOK_LAST)
	    {
	      // last 0 is -2.  last 1 is -3.
	      rootNode->setFirstNRows((numRows == 0) ? -2 : -3);
	    }
	  else
	    {
	      rootNode->setFirstNRows(numRows);
	    }

	  rootNode->needFirstSortedRows() = (($3 == TOK_FIRST) ? TRUE : FALSE);
	  delete $4;
         
          if (CmpCommon::getDefault(MVQR_LOG_QUERY_DESCRIPTORS) == DF_DUMP ||
              CmpCommon::getDefault(MVQR_LOG_QUERY_DESCRIPTORS) == DF_DUMP_MV)
            ((RelRoot*)$$)->setAnalyzeOnly();
           } 

/* type tokval */
firstn_sorted : TOK_ANY    {$$ = TOK_ANY;}
              | TOK_FIRST  {$$ = TOK_FIRST;}
              | TOK_LAST   {$$ = TOK_LAST;}

/* For set_quantifier, the $$ value is TRUE if it is DISTINCT, and
 * FALSE for ALL, which is also the default value (ALL,FALSE = default).
 *
 * type boolean */
set_quantifier : { $$ = FALSE; /* by default, set quantifier is ALL */
		 }
          | TOK_ALL
             {
                $$ = FALSE;
             }
          | TOK_DISTINCT
             {
                $$ = TRUE;
             }
          | TOK_UNIQUE
             {
                $$ = TRUE;
             }

/* type relx */
query_spec_body : query_select_list table_expression access_type  optional_lock_mode
			{
			  // use a compute node to attach select list
			  RelRoot *temp=  new (PARSERHEAP())
                            RelRoot($2, $3, $4, REL_ROOT, $1);
			    // set relroot olap here
			    if (SqlParser_CurrentParser->topHasOlapFunctions()) {
			      temp->setHasOlapFunctions(TRUE);
			    }
			    //pop the last element which was pushed when we eneterd a new select  
			    SqlParser_CurrentParser->popHasOlapFunctions();
			    
			    // do the same for TD functions
			    if (SqlParser_CurrentParser->topHasTDFunctions()) {
			      temp->setHasTDFunctions(TRUE);
			    }
			    //pop the last element which was pushed when we eneterd a new select  
			    SqlParser_CurrentParser->popHasTDFunctions();			    
			    
			    $$=temp;			    
			}
		| query_select_list into_clause table_expression access_type optional_lock_mode
			{
			  // use a compute node to attach select list
  			  RelRoot *temp = new (PARSERHEAP())
			    RelRoot($3, $4, $5, REL_ROOT, $1);
			  
			  if (SqlParser_CurrentParser->topHasOlapFunctions()) {
			    temp->setHasOlapFunctions(TRUE);
			  }
			  //pop the last element which was pushed when we eneterd a new select  
			  SqlParser_CurrentParser->popHasOlapFunctions();
			  
			  if (SqlParser_CurrentParser->topHasTDFunctions()) {
			     temp->setHasTDFunctions(TRUE);
			  }
			  //pop the last element which was pushed when we eneterd a new select  
			  SqlParser_CurrentParser->popHasTDFunctions();
			  
			  // If we are in a compound statement,
			  // then the variables in an INTO clause
			  // should behave like those in an assignment stmt,
			  // so we store them in the area in the root
			  // reserved for such variables
			  CollIndex varcnt = AssignmentHostVars->entries();
			  for (CollIndex i = 0; i < varcnt; i++) {
			    temp->addAssignmentStTree((*AssignmentHostVars)[i]);
			  }

			  AssignmentHostVars->clear();
			  $$ = temp;
			}

//++ MV OZ
// type item 
query_select_list : select_list
{
  if(TRUE == WeAreInACreateMVStatement && TRUE == ThisIsTheFirstMVQuerySelect)
  {
    // Set a global variable to the (minimal) position
    // of the end of the "select column list" (For MV use !!)
    // we only want to mark the first SELECT in a 
    // "SELECT FROM (SELECT FROM (SELECT ..." structure
    ParSetEndOfSelectColumnListPos(ParNameLocListPtr);
    ThisIsTheFirstMVQuerySelect = FALSE;
  }
  

  $$ = $1;
}



/* type accesstype */
access_type:
	        TOK_REPEATABLE_READ TOK_ACCESS		
                {
                  *SqlParser_Diags << DgSqlCode(-1719)
                                   << DgString0("REPEATABLE READ");
                  YYERROR;
                  
                  $$ = TransMode::REPEATABLE_READ_ACCESS_;
                }
	      | TOK_SERIALIZABLE_ACCESS			
                {
                  *SqlParser_Diags << DgSqlCode(-1719)
                                   << DgString0("SERIALIZABLE");
                  YYERROR;

                  $$ = TransMode::REPEATABLE_READ_ACCESS_;
                }
	      | TOK_FOR_REPEATABLE TOK_READ TOK_ACCESS	
                {
                  *SqlParser_Diags << DgSqlCode(-1719)
                                   << DgString0("REPEATABLE READ");
                  YYERROR;

                  $$ = TransMode::REPEATABLE_READ_ACCESS_;
                }
	      | TOK_FOR_SERIALIZABLE TOK_ACCESS		
                {
                  *SqlParser_Diags << DgSqlCode(-1719)
                                   << DgString0("SERIALIZABLE");
                  YYERROR;

                  $$ = TransMode::REPEATABLE_READ_ACCESS_;
                }
              | TOK_READ TOK_UNCOMMITTED TOK_ACCESS	
                {
                  $$ = TransMode::READ_COMMITTED_ACCESS_;
                }
	      | TOK_READ TOK_COMMITTED TOK_ACCESS	
                {
                  $$ = TransMode::READ_COMMITTED_ACCESS_;
                }
	      | TOK_FOR_READ TOK_UNCOMMITTED TOK_ACCESS	
                {
                  $$ = TransMode::READ_COMMITTED_ACCESS_;
                }
	      | TOK_FOR_READ TOK_COMMITTED TOK_ACCESS	
                {
                  $$ = TransMode::READ_COMMITTED_ACCESS_;
                }
	      | TOK_FOR_SKIP TOK_CONFLICT TOK_ACCESS 	
                {
                  $$ = TransMode::SKIP_CONFLICT_ACCESS_;
                }
	      | TOK_SKIP_CONFLICT_ACCESS             	
                {
                  $$ = TransMode::SKIP_CONFLICT_ACCESS_;
                }

	      | /* empty */
		{
                  $$ = TransMode::ACCESS_TYPE_NOT_SPECIFIED_;
                }


/* The following production is an "okay"  way to do things
 * from a yacc point of view. But it would be better to have a left-recursive
 * production such as  select_list : select_list ',' select_list_item.
 * That way, yacc's stack wouldn't have to first fill up with each item
 * from the list.  However, we would also have to build our ItemList
 * trees to be "left heavy" instead of "right heavy."  This isn't such a
 * BAD situation anyway.  For a future upgrade if we ever so desire...
 */

// QSTUFF

                 
/* type item */
return_list : TOK_RETURN 
	      {
		Set_SqlParser_Flags(ALLOW_OLD_AND_NEW_KEYWORD);  
	      } 
              select_list
              {
		Reset_SqlParser_Flags(ALLOW_OLD_AND_NEW_KEYWORD); 
		$$ = $3;
	      } 
// QSTUFF

/* type item */
select_list :   select_list_item 
              | select_list_item ',' select_list
                           {
                             $$ = new (PARSERHEAP()) ItemList($1, $3);
                           } 
/* type item */
select_list_item :
                derived_column
              | '*'
                      {
                        ColRefName *starName
                          = new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP());
                        if (CmpCommon::getDefault(MV_ALLOW_SELECT_SYSTEM_ADDED_COLUMNS) == DF_ON) 
                        {
			  starName->setStarWithSystemAddedCols(); // ++MV
                        }
                        $$ = new (PARSERHEAP()) ColReference(starName);
                        ParInsertNameLocForStar(starName);
                      }
              | actual_table_name2 TOK_DOT_STAR
                      {
                        ColRefName *starName
                          = new (PARSERHEAP()) ColRefName(TRUE, CorrName(*$1, PARSERHEAP()), PARSERHEAP());
                        $$ = new (PARSERHEAP()) ColReference(starName);
                        ParUpdateNameLocForDotStar(starName);
                        delete $1;
                      }

/* type item */
derived_column : value_expression
	      | value_expression as_clause
                      {
                        $$ = new (PARSERHEAP())
                          RenameCol($1, new (PARSERHEAP()) ColRefName(*$2, PARSERHEAP()));
                        delete $2;
                      }

/* type stringval */
as_clause : TOK_AS correlation_name     { $$ = $2; }
            | correlation_name



/* type stmt_ptr */
starting_production:
		 // Anonymous rule: Initialize static variables for everyone.
		 //
		 // As a matter of convention, SqlParserGlobals.h globals aren't
		 // initialized here, but instead in caller (Parser::parseDML).
		 {
		   inJoinSpec->reset();
		 }
	       starting_production2 ';'
	       	      { 
			// 3178 External data type(s) $0 found in query.
			if (externalDataTypeCnt_) {
			  ComASSERT(externalDataTypeCnt_ > 0);
			  PrettifySqlText(*externalDataTypeNames_);
			  *SqlParser_Diags << DgSqlCode(-3178)
			    << DgString0(*externalDataTypeNames_);
			  YYERROR;
			}
		        TheParseTree = $2;	// $2 since anonymous rule is $1
		      }

/* type stmt_ptr */
starting_production2:
		 // This interpolated anonymous rule performs initialization
		 // of globals/statics for the sql_statement that follows.
		 //
		 // These inits are done here instead of in caller
		 // (Parser::parseDML) because it makes more sense here.
		 {
		   resetHostVars();
		   in3GL_ = 0;
		   externalDataTypeCnt_ = 0;
		   if ( externalDataTypeNames_ == NULL )
		        externalDataTypeNames_ = new NAString("");
		   else
		       *externalDataTypeNames_ = "";
		   inCallStmt = FALSE;
                   InIfCondition = FALSE;
		   inRSProxyStmt = FALSE;
                   empty_charlen_specifier_allowed = FALSE;
		   NumOfScalars = NumOfArrays = 0;
		   currVarIndex = 0;
		   ParBeginingOfMVQueryPos = 0;
		   ParBeginingOfFileOptionsListPos = 0;
		   disableMakeQuotedStringISO88591Mechanism();
                   NonISO88591LiteralEncountered = FALSE;
		   turnUnknownCharSetToISO88591 = FALSE;
		   HexStringLiteralNotAllowed = FALSE; 
		   WeAreInACreateMVStatement = FALSE;
		   WeAreInAnEmbeddedInsert = FALSE;
		   ParNameSavedLocListPtr = NULL;
		   ParEndOfCreateTableAsAttrList = 0;
		   ParEndOfSelectColumnListPos = 0 ;
		   ParEndOfOptionalColumnListPos = 0 ;
		   ParEndOfFileOptionsListPos = 0;
		   WeAreInALRUOperation = FALSE;
                   ParNameCTLocListPtr = NULL;

		   /* Reset Trigger parsing state globals */
		   RowOrTableClause1 = ParTRIG_SCOPE_NONE;
		   RowOrTableClause2 = ParTRIG_SCOPE_NONE;
	           InsideTriggerDefinition = FALSE;
		   CSInsideTriggerDefinition = FALSE;
                   SqlParser_CurrentParser->clearHasOlapFunctions();			
                   SqlParser_CurrentParser->clearHasTDFunctions();
		   cast_target_cs_specified = FALSE;

                   in_col_defn = FALSE;
		 }
	       sql_statement
	       	      { 
		        $$ = $2;		// $2 since anonymous rule is $1
		      }
	     | TOK_INTERNAL_EXPR any_expression
		      {
		        $$ = (StmtNode *)$2;	// fake out yacc; see caller
		      }
	     | TOK_INTERNAL_COLUMN_DEFINITION column_definition
		      {
		        $$ = (StmtNode *)$2;	// just to make yacc happy
		      }

/* type item */
any_expression : value_expression_list
	       | search_condition

/* type item */
rowset_input_size : TOK_INPUT TOK_SIZE rowset_size
           {
		if ($3->getOperatorType() == ITM_HOSTVAR) {
		    ((HostVar *) $3)->setHVRowsetForInputSize();
		}
		else if ($3->getOperatorType() == ITM_DYN_PARAM) {
		    ((DynamicParam *) $3)->setDPRowsetForInputSize();
		}	
		$$ = $3;
           }

/* type item */
rowset_output_size : TOK_OUTPUT TOK_SIZE rowset_size
           {
		if (CmpCommon::context()->GetMode() == STMT_DYNAMIC) {
		    *SqlParser_Diags << DgSqlCode(-30017);  // ROWSET FOR OUTPUT SIZE not supported for dynamic SQL
	            YYERROR;
		}
		else {
		    if ($3->getOperatorType() == ITM_HOSTVAR) {
			((HostVar *) $3)->setHVRowsetForOutputSize();
		    }
		    $$ = $3;
		}
           }

/* type item */
rowset_index : TOK_KEY TOK_BY identifier
          {
            $$ = new (PARSERHEAP())
                     ColReference (new (PARSERHEAP()) ColRefName(*$3));
            delete $3;
          }            	    

/* type relx */
rowset_for_output : TOK_ROWSET TOK_FOR rowset_input_size ',' rowset_output_size ',' rowset_index
	   {
		RelExpr *rowsetfor = new (PARSERHEAP()) 
		RowsetFor(NULL, $3, $5, $7);
		$$ = rowsetfor;
           }
	| TOK_ROWSET TOK_FOR rowset_input_size ',' rowset_output_size
           {
		RelExpr *rowsetfor = new (PARSERHEAP()) 
		RowsetFor(NULL, $3, $5);
		$$ = rowsetfor;
           }
	| TOK_ROWSET TOK_FOR rowset_output_size ',' rowset_index
           {
		RelExpr *rowsetfor = new (PARSERHEAP()) 
		RowsetFor(NULL, NULL, $3, $5);
		$$ = rowsetfor;
           }
	| TOK_ROWSET TOK_FOR rowset_output_size
           {
             RelExpr *rowsetfor = new (PARSERHEAP()) 
               RowsetFor(NULL, NULL, $3);
             $$ = rowsetfor;
           }

/* type relx */
rowset_for_input : TOK_ROWSET TOK_FOR rowset_input_size ',' rowset_index
	    {
		RelExpr *rowsetfor = new (PARSERHEAP()) 
		  RowsetFor(NULL, $3, NULL, $5);
		$$ = rowsetfor;
	   }
	| TOK_ROWSET TOK_FOR rowset_input_size
	   {
		RelExpr *rowsetfor = new (PARSERHEAP()) 
		  RowsetFor(NULL, $3);
		$$ = rowsetfor;
	   }
	| TOK_ROWSET TOK_FOR rowset_index
	   {
		RelExpr *rowsetfor = new (PARSERHEAP()) 
		  RowsetFor(NULL, NULL, NULL, $3);
		$$ = rowsetfor;
	   }

/* type relx */
rowset_for : rowset_for_input 
	   |  rowset_for_output

rowwise_rowset_info : '(' TOK_MAX TOK_ROWSET TOK_SIZE literal ','
                          TOK_INPUT TOK_ROWSET TOK_SIZE dynamic_parameter ','
                          TOK_INPUT TOK_ROW TOK_MAX TOK_LENGTH dynamic_parameter ','
                          TOK_ROWSET TOK_BUFFER dynamic_parameter
                      ')' 
                      {
			ItemExpr * mrs  = $5;
			ItemExpr * irs  = $10;
			ItemExpr * irml = $16;
			ItemExpr * rrb  = $20;

			// if input values are params, 
			// type them as 'long'.
			if (irs->getOperatorType() == ITM_DYN_PARAM)
			  {
			    ((DynamicParam*)irs)->setDPRowsetForInputSize();
			    irs = new (PARSERHEAP()) 
			      Cast(irs, new (PARSERHEAP()) SQLInt(PARSERHEAP(), TRUE, FALSE));
			  }
			else
			  YYERROR;

			if (irml->getOperatorType() == ITM_DYN_PARAM)
			  {
			    ((DynamicParam*)irml)->setRowwiseRowsetInputMaxRowlen();
			    irml = new (PARSERHEAP()) 
			      Cast(irml, new (PARSERHEAP()) SQLInt(PARSERHEAP(), TRUE, FALSE));
			  }
			else
			  YYERROR;

			if (rrb->getOperatorType() == ITM_DYN_PARAM)
			  {
			    ((DynamicParam *)rrb)->setRowwiseRowsetInputBuffer();
			    rrb = new (PARSERHEAP()) 
			      Cast(rrb, new (PARSERHEAP()) SQLLargeInt(PARSERHEAP(), TRUE, FALSE));
			  }
			else
			  YYERROR;

			RowsetFor *rowsetfor = new (PARSERHEAP()) 
			  RowsetFor(NULL, irs, NULL, NULL, mrs, irml, rrb, NULL);
			rowsetfor->rowwiseRowset() = TRUE;

			$$ = rowsetfor;
		      }

/* type stmt_ptr */
sql_statement : interactive_query_expression
		   {
		      $$ = new (PARSERHEAP()) StmtQuery($1);
		   }
	       | TOK_DISPLAY 
                 {
                   SqlParser_CurrentParser->hiveDDLInfo_->essd_ = Parser::HiveDDLInfo::DISPLAY_;                   
                 }
                 interactive_query_expression
		   {
		      ((RelRoot *)$3)->setDisplayTree(TRUE);
		      $$ = new (PARSERHEAP()) StmtQuery($3);
		   }
	       | TOK_BEGIN TOK_DECLARE TOK_SECTION
		   {
		      $$ = new (PARSERHEAP()) StmtNode(STM_BEGIN_DECLARE);
		   }
	       | TOK_END TOK_DECLARE TOK_SECTION
		   {
		      $$ = new (PARSERHEAP()) StmtNode(STM_END_DECLARE);
		   }
	       | alloc_desc_statement 
	       | alloc_static_desc_stmt
	       | close_statement
	       | dealloc_desc_statement
	       | dealloc_stmt_statement
	       | declare_dynamic_cursor
	       | declare_static_cursor
	       | describe_statement
	       | dynamic_prepare
	       | dynamic_execute
	       | execute_immediate
	       | fetch_cursor
	       | get_conddiags_statement
	       | get_desccount_statement
	       | get_rowsetsize_statement
	       | get_descitem_statement
	       | get_stmtdiags_statement
	       | module_statement
	       | source_file_statement
	       | module_timestamp
	       | open_cursor
	       | procedure_stmt
	       | set_desccount_statement
	       | set_rowsetsize_statement
	       | set_descitem_statement
	       | whenever_statement
               | explain_stmt_finalized

/* type stmt_ptr */
explain_stmt_finalized : exe_util_display_explain
                            {
                               RelExpr *temp = finalize($1);
                               $$ = new (PARSERHEAP()) StmtQuery(temp);
                            }

/* type stmt_ptr */

set_transaction_statement : TOK_SET TOK_TRANSACTION transaction_mode_list
                            {
                               $$ = new (PARSERHEAP()) StmtDMLSetTransaction($3);
                            }

transaction_mode_list :   transaction_mode
                          | transaction_mode_list ',' transaction_mode
                            {
                               $$ = new (PARSERHEAP()) ItemList($1,$3);
                            }

transaction_mode :   isolation_level
                   | transaction_access_mode
                   | diagnostics_size
		   | rollback_mode_on_off
		   | autoabort_interval_stmt
		   | multi_commit_mode

isolation_level :    TOK_ISOLATION TOK_LEVEL isolation_level_enum
                     {
                        $$ = new (PARSERHEAP()) TxnIsolationItem($3);
                     }

isolation_level_enum : TOK_READ TOK_UNCOMMITTED { $$ = TransMode::READ_UNCOMMITTED_; }
                     | TOK_READ TOK_COMMITTED	{ $$ = TransMode::READ_COMMITTED_; }
                     | TOK_REPEATABLE_READ	
                     { 
                       *SqlParser_Diags << DgSqlCode(-1720)
                                        << DgString0("REPEATABLE READ");
                       YYERROR;
                       
                       $$ = TransMode::REPEATABLE_READ_; 
                     }
                     | TOK_SERIALIZABLE		
                     { 
                       *SqlParser_Diags << DgSqlCode(-1720)
                                        << DgString0("SERIALIZABLE");
                       YYERROR;

                       $$ = TransMode::SERIALIZABLE_; 
                     }

transaction_access_mode : transaction_access
                          {
                            $$ = new (PARSERHEAP()) TxnAccessModeItem($1);
                          }

transaction_access :    TOK_READ TOK_ONLY	{ $$ = TransMode::READ_ONLY_SPECIFIED_BY_USER_; }
		   |    TOK_READ TOK_WRITE	{ $$ = TransMode::READ_WRITE_; }

diagnostics_size :    TOK_DIAGNOSTICS TOK_SIZE number_of_conditions
                      {
                         $$ = new (PARSERHEAP()) DiagnosticSizeItem ($3);
                      }

number_of_conditions :   literal
                       | simple_host_variable
			 { 
                           if (CmpCommon::getDefault(MODE_SPECIAL_4) == DF_OFF) 
                             {
                               TheHostVarRoles->setLastUnassignedTo(HV_IS_INPUT); 
                               $$ = $1 ;
                             }
                         }
                       | dynamic_parameter
		      
rollback_mode_on_off : TOK_NO TOK_ROLLBACK on_off
	      {
		if ($3)
		  $$ = new (PARSERHEAP()) TxnRollbackModeItem(TransMode::NO_ROLLBACK_);
		 else
		  $$ = new (PARSERHEAP()) TxnRollbackModeItem(TransMode::ROLLBACK_MODE_WAITED_);
	      }
autoabort_interval_stmt  : TOK_AUTOABORT autoabort_interval
              {
		$$ = new (PARSERHEAP()) TxnAutoabortIntervalItem($2);
              }
              
multi_commit_mode  : TOK_MULTI TOK_COMMIT on_or_empty TOK_EVERY unsigned_integer TOK_ROWS 
              {
		if($5 == 0)
		  *SqlParser_Diags << DgSqlCode(-3240); // commit size must be greater than zero.
		
		$$ = new (PARSERHEAP()) TxnMultiCommitItem($5, $3);
              }
              | TOK_MULTI TOK_COMMIT on_off
              {
	       $$ = new (PARSERHEAP()) TxnMultiCommitItem($3);
              }

sql_schema_statement_prologue :
                { HexStringLiteralNotAllowed = TRUE; 
                  turnUnknownCharSetToISO88591 = TRUE;
                  disableMakeQuotedStringISO88591Mechanism();
                } 

/* type pStmtDDL */
sql_schema_statement : sql_schema_statement_prologue
                    sql_schema_definition_statement
                         { 
                           $$ = $2; 
                           HexStringLiteralNotAllowed = FALSE; 
                           turnUnknownCharSetToISO88591 = FALSE ;
                           disableMakeQuotedStringISO88591Mechanism();
                         }

              |  sql_schema_statement_prologue sql_schema_manipulation_statement
                         { 
                           $$ = $2; 
                           HexStringLiteralNotAllowed = FALSE; 
                           turnUnknownCharSetToISO88591 = FALSE ;
                           disableMakeQuotedStringISO88591Mechanism();
                         }

/* type pStmtDDL */
sql_schema_definition_statement :

                schema_definition
				{
				}
              | create_synonym_stmt
                                {
                                }
                                
              | create_library_stmt
                                {
                                }
                                
	      | table_definition
				{
				}

              | view_definition
				{
				}

              | grant_statement
                                {
                                }
                           
              | grant_component_privilege_stmt
                                {
                                }
              | create_component_privilege_stmt
                                {
                                }
              | drop_component_privilege_stmt
                                {
                                }

              | register_component_statement
                                {
                                }
              | register_user_statement
                                {
                                }
              | unregister_component_statement
                                {
                                }
              | unregister_user_statement
                                {
                                }

              | catalog_definition
                                {
                                  // Tandem extension
                                }

	      | index_definition
				{
                                  // Tandem extension
                                }

	      | populate_index_definition
				{
                                  // Tandem extension
                                }

	      | initialize_sql_statement
				{
                                  // Tandem extension
                                }
	      | create_mvrgroup_statement
		  {
						// MV - RG
						// Tandem extension
		  }
	      | trigger_definition
				{
                                }
	      | mv_definition
				{
                                }
	      | routine_definition
                                {
                                }

	      | grant_schema_statement
                                {
                                }

	      | grant_role_statement
                                {
                                }

	      | create_role_statement
                                {
                                }
              | create_sequence_statement
	                        {
				}                        
              | alter_sequence_statement
	                        {
				}                        
              | cleanup_objects_statement
                                {
                                }
              | register_hive_statement
                                {
                                }
              | unregister_hive_statement
                                {
                                }
              | register_hbase_statement
                                {
                                }
              | unregister_hbase_statement
                                {
                                }
              | comment_on_statement
                                {
                                }
				
/* type pStmtDDL */
sql_schema_manipulation_statement :

                drop_schema_statement
				{
				}
                                
	      | alter_audit_config_statement
				{
				}
                                
	      | alter_catalog_statement
				{
				}

	      | alter_schema_statement
				{
				}

              | alter_index_statement
				{
				}

              | alter_function_statement
				{
				}

              | alter_library_statement
				{
				}

              | alter_table_statement
				{
				}
			  | alter_mv_refresh_group_statement
			  {
					// MV - RG
			  }
              | alter_synonym_statement
                                {
                                }
              | alter_trigger_statement
				{
				}

              | alter_mv_statement
				{
				}

              | alter_user_statement
				{
				}

              | alter_view_statement
				{
				}

              | drop_synonym_stmt
                                {
                                }
                                
              | drop_exception_stmt
                                {
                                }
                                
              | drop_all_exception_stmt
                                {
                                }
              | drop_sql
                                {
                                  // Tandem extension
                                }

              | drop_table_statement
				{
				}

	      |	drop_mvrgroup_statement
              | drop_trigger_statement
				{
				}

              | drop_mv_statement
				{
				}

              | drop_index_statement
                                {
                                   // Tandem extension
                                }

              | drop_library_statement
				{
				}

              | drop_routine_statement
				{
				}

              | drop_view_statement
				{
				}

              | give_statement
                {
                }

              | revoke_component_privilege_stmt
                                {
                                }
              | revoke_statement
				{
				}
	      
	      | revoke_schema_statement
                                {
                                }


	      | revoke_role_statement
                                {
                                }

              | drop_catalog_statement
                                {
                                   // Tandem extension
                                }

              | drop_module
                                {
                                   // Tandem extension
                                }

              | drop_role_statement
                                {
                                }
              | drop_sequence_statement
	                        {
				}                        

/* type item */
item_signal_statement : 
/*
     TOK_SIGNAL TOK_SQLSTATE QUOTED_STRING '(' QUOTED_STRING ')'
     {
     // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
       if (isInvalidSignalSqlstateValue($3)) 
	 {
	   *SqlParser_Diags << DgSqlCode(-3184) << DgString0(*$3);
	   YYERROR;
	 } 
       else 
	 {
	   $$ = new (PARSERHEAP()) RaiseError(ComDiags_SignalSQLCODE,*$3, *$5);
	 }
     }
    | 
*/
    TOK_SIGNAL TOK_SQLSTATE  QUOTED_STRING '(' value_expression ')'
     {
       // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
       if (isInvalidSignalSqlstateValue($3)) 
	 {
	   *SqlParser_Diags << DgSqlCode(-3184) << DgString0(*$3);
	   YYERROR;
	 } 
       else 
	 {
	   $$ = new (PARSERHEAP()) RaiseError(ComDiags_SignalSQLCODE, *$3, $5);
	 }
     }

/* type relx */
signal_statement : item_signal_statement
     {
       ItemExpr *fakeList = new (PARSERHEAP()) Convert($1); // convert error
       $$ = new (PARSERHEAP()) TupleList(fakeList);
     }

/* type relx */
interactive_query_expression:
                rowset_for dml_statement
				{
				    // Make sure the root is on top of the rowsetfor node
				    // the parse tree is root->rowsetfor->previous child of root
				    $1->setChild(0, $2->child(0));
				    $2->setChild(0, $1);
				  $$ = $2;
				}

	      | locking_stmt_list dml_statement
				{
				  $$ = $2;
				}
	      | dml_statement
				{
				  $$ = $1;
				}

              | front_of_insert no_check_log no_rollback TOK_INTO
                TOK_TABLE '(' TOK_EXTRACT_TARGET '(' extract_type ','
                unsigned_integer ')' ')' '(' dml_query ')'
                  {
		    if (CmpCommon::getDefault(IS_DB_TRANSPORTER) == DF_OFF)
		      YYERROR;

                    // Raise a parse error if the LOG or ROLLBACK
                    // clause is specified. It will not be a
                    // user-friendly error but this syntax is for
                    // internal use only, so for now that's OK.
                    if ($2 == TRUE || $3 == TRUE)
                      YYERROR;

                    // The number of streams cannot be 0 or 1. Let the
                    // binder catch this. Change a value of 0 to 1,
                    // otherwise the binder won't even know this is a
                    // parallel extract.
                    ComUInt32 numStreams = $11;
                    if (numStreams < 1)
                      numStreams = 1;

                    // The dml_query production returns a "finalized"
                    // RelRoot instance. All we need to do is mark
                    // that root for parallel extract and return it.
                    $$ = $15;
                    ((RelRoot*)$$)->setNumExtractStreams(numStreams);
                  } 
	      | control_statement
				{
				  $$ = finalize($1);
				}
              |  osim_statement
                                {
                                  $$ = finalize($1);
                                }
              | set_statement
				{ 
				  $$ = finalize($1);
				}
	      | transaction_statement
				{
				  $$ = finalize($1);
				}
	      | lock_unlock_statement
				{
				  $$ = finalize($1);
				}
	      | sql_schema_statement
                {
		  CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		  NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
		                                  , PARSERHEAP() // in  - NAMemory * heapUsedForOutputBuffers
		                                  );
		  // If we can not get a variable-width multi-byte or single-byte string here, report error 
		  if ( stmt == NULL )
		  {
		    *SqlParser_Diags <<  DgSqlCode(-3406);
		    YYERROR;
		  }

		  if (($1->castToStmtDDLNode()) &&
		      ($1->castToStmtDDLCreateTable()) &&
		      ($1->castToStmtDDLCreateTable()->getQueryExpression()))
		    {
		      // CREATE TABLE AS query.
		      // Use ExeUtil to implement this.
		      ExeUtilCreateTableAs * eue = 
			new(PARSERHEAP()) ExeUtilCreateTableAs
			(CorrName($1->castToStmtDDLCreateTable()->getTableNameAsQualifiedName(), 
				  PARSERHEAP()),
			 $1,
			 (char*)stmt->data(),
			 stmtCharSet,
			 PARSERHEAP());
		      $$ = finalize(eue);
		    }
		  else if (($1->castToStmtDDLNode()) &&
			   ($1->castToStmtDDLNode()->isVolatile()) &&
			   ($1->castToStmtDDLNode()->processAsExeUtil()))
		    {
		      // CREATE VOLATILE table
		      // Use ExeUtil to implement this.
		      ExeUtilProcessVolatileTable * eue = 
			new(PARSERHEAP()) ExeUtilProcessVolatileTable
			($1,
			 (char*)stmt->data(),
			 stmtCharSet,
			 PARSERHEAP());
		      $$ = finalize(eue);
		    }
		  else if (($1->castToStmtDDLNode()) &&
			   ($1->castToStmtDDLNode()->castToStmtDDLCreateExceptionTable()) &&
			   ($1->castToStmtDDLNode()->processAsExeUtil()))
		    {
		      // CREATE EXCEPTION table
		      // Use ExeUtil to implement this.
		      ExeUtilProcessExceptionTable * eue = 
			new(PARSERHEAP()) ExeUtilProcessExceptionTable
			($1,
			 (char*)stmt->data(),
			 stmtCharSet,
			 PARSERHEAP());
		      $$ = finalize(eue);
		    }
		  else if (($1->castToRelExpr()) &&
			   ($1->castToRelExpr()->getOperatorType() == REL_EXE_UTIL) &&
			   (((ExeUtilExpr*)$1->castToRelExpr())->getExeUtilType()
			    == ExeUtilExpr::HBASE_DDL_))
		    {
		      $$ = finalize($1->castToRelExpr());		      
		    }
		  else
		    {
		      $$ = finalize(new (PARSERHEAP())
				    DDLExpr($1, (char*)stmt->data(), 
                                            stmtCharSet, PARSERHEAP()));
		    }

                  delete stmt;
                }
	      | psm_3gl_statement
				{
				  --in3GL_;
                                  if ( in3GL_ == 0 && $1 == NULL )
                                    $1 = getEmptyCSRelTree(); 

				  $$ = finalize($1);
				}
              | assignment_statement
				{
				  $$ = finalize($1);
				}
	      | show_statement
				{
				  $$ = finalize($1);
				}
              | TOK_EXIT
                                { 
				  if (in3GL_ <= 0) 
				    NAExit(0);
				  else {
				    *SqlParser_Diags << DgSqlCode(-3172);
				    $$ = NULL;
				  }
				}
              | signal_statement 
		  		{
				  $$ = finalize($1, FALSE);
		  		}
	      | internal_refresh_command
		  {
			$$ = finalize($1); 
		  }
	      | mvlog_command
		  {
			$$ = finalize($1);
		  }
              | standalone_call_statement
              | exe_util_statement
              | exe_util_cleanup_volatile_tables
                                {
				  $$ = finalize($1);
				}
              | exe_util_get_volatile_info
                                {
				  $$ = finalize($1);
				}
              | exe_util_get_error_info
                                {
				  $$ = finalize($1);
				}
              | exe_util_get_statistics
                                {
				  $$ = finalize($1);
				}
              | exe_util_get_metadata_info
                                {
				  $$ = finalize($1);
				}

              | exe_util_get_version_info
                                {
				  $$ = finalize($1);
				}
              | query_suspend_safe
                                {
				  $$ = finalize($1);
				}
              | query_suspend_forced
                                {
				  $$ = finalize($1);
				}
              | query_activate
                                {
				  $$ = finalize($1);
				}
              | query_cancel_optional_comment
                                {
				  $$ = finalize($1);
				}
              | truncate_table
                                {
				  $$ = finalize($1);
				}
              | exe_util_get_uid
                                {
				  $$ = finalize($1);
				}
              | exe_util_populate_in_memory_statistics
                                {
				  $$ = finalize($1);
				}
              | exe_util_lob_extract
                                {
				  $$ = finalize($1);
				}
              | unload_statement 
                                {
				  $$ = finalize($1);
				}
              | exe_util_lob_update
                                {
                                  $$ = finalize($1);
                                }
              | exe_util_init_hbase
                                {
				  $$ = finalize($1);
				}
              | exe_util_get_region_access_stats
                                {
				  $$ = finalize($1);
				}
              | exe_util_hive_query
                                {
				  $$ = finalize($1);
				}

dml_query : query_expression order_by_clause access_type
            optional_lock_mode for_update_spec optional_limit_spec
              {
#ifndef NDEBUG	// To test packing.
                char* env = getenv("PACKING_FACTOR");
                if ($2 == NULL && // no ORDER BY specified
                    $3 == TransMode::ACCESS_TYPE_NOT_SPECIFIED_ &&
                    $4 == LOCK_MODE_NOT_SPECIFIED_ &&
                    env && atol(env) > 0)
                {
                  Pack* pack =
                    new(PARSERHEAP()) Pack(atol(env),$1);
                  $$ = finalize(pack);
                }
                else
#endif
                {
                  $$ = finalize($1);

                  ((RelRoot *)$$)->addOrderByTree($2);
                  if (!finalizeAccessOptions($$, $3, $4))
                    YYERROR;
                  $5->finalizeUpdatability($$);

		  if ($6)
		    {
		      // limit clause was specified. 
		      RelRoot * rr = (RelRoot*)$$;
		      if (rr->getFirstNRows() >= 0)
			{
			  // cannot specify LIMIT and FIRST N clauses together.
			  YYERROR;
			}
		      else
			{
                          NABoolean negate;
                          if ($6->castToConstValue(negate))
                            {
                              ConstValue * limit = (ConstValue*)$6;
                              Lng32 scale = 0;
                              rr->setFirstNRows(limit->getExactNumericValue(scale));
                              rr->setFirstNRowsParam(NULL);
                            }
                          else
                            {
                              rr->setFirstNRowsParam($6);
                              rr->setFirstNRows(-1);
                            }

                          if ($2 != NULL) // ORDER BY specified
                            rr->needFirstSortedRows() = TRUE;
			}
		    } // LIMIT clause was specified
                }
              }
          | query_expression order_by_clause_non_empty
            group_by_clause_non_empty access_type optional_lock_mode
            for_update_spec optional_limit_spec
              {
                CheckModeSpecial1();
                
                ItemExpr * compExpr = NULL;
                RelExpr * childNode = NULL;
                if ($1->getOperatorType() == REL_ROOT)
                {
                  compExpr = 
                    ((RelRoot*)($1->castToRelExpr()))->
                    getCompExprTree();
                  childNode = 
                    $1->child(0)->castToRelExpr();
                }
                else
                {
                  childNode = $1;
                }
                
                RelExpr * gbyPtr =
                  getTableExpressionRelExpr
                  (childNode,
                   NULL, NULL, NULL, NULL,
                   $3, // group by
                   NULL);

                // save FIRST N settings 
                NABoolean needFirstSortedRows = ((RelRoot *)$$)->needFirstSortedRows();
                Int64 firstNRows = ((RelRoot *)$$)->getFirstNRows();
                
                $$ = finalize(gbyPtr);
                
                // restore FIRST N settings 
                ((RelRoot *)$$)->needFirstSortedRows() = needFirstSortedRows;
                ((RelRoot *)$$)->setFirstNRows(firstNRows);
                
                ((RelRoot *)$$)->addOrderByTree($2);
                if (compExpr)
                  ((RelRoot*)$$)->addCompExprTree(compExpr);
                if (!finalizeAccessOptions($$, $4, $5))
                  YYERROR;
                $6->finalizeUpdatability($$);
              }

optional_limit_spec : TOK_LIMIT NUMERIC_LITERAL_EXACT_NO_SCALE
                   {
		     Int64 rows = atoInt64($2->data());

                     ConstValue * limit = new(PARSERHEAP()) ConstValue(rows);

		     $$ = limit;
		   }
                 | TOK_LIMIT dynamic_parameter
                 {
                   $$ = $2;
                 }
                 | /* empty */
                   {
		     $$ = NULL;
		   }

dml_statement : dml_query { $$ = $1; }

               | with_clause dml_query
                 {
                   $$ = $2;  
                 }

	       | front_of_insert_with_rwrs   rowwise_rowset_info Rest_Of_insert_statement 
		    {
                      if ($1 != Insert::UPSERT_INSERT)
                        YYERROR;
                      
                      Insert * ie = (Insert *)$3;
                      if ((ie->child(0) == NULL) ||
                          (ie->child(0)->getOperatorType() != REL_TUPLE))
                        YYERROR;
                      
                      ie->setInsertType($1);
                      
                      $2->child(0) = ie;
                      $$ = finalize($2);
                    }

	      |	front_of_insert Rest_Of_insert_statement 
				{
				  ((Insert *)$2)->setInsertType($1);
				  $$ = finalize($2);
				}

	      |	front_of_insert Rest_Of_insert_wo_INTO_statement 
				{
				  ((Insert*)$2)->setInsertType($1);
				  $$ = finalize($2);
				}

	      | update_statement_searched access_type
				{
				  $$ = finalize($1);
	       			  if (!finalizeAccessOptions($$, $2)) YYERROR;
				}
	      | merge_statement
				{
				  $$ = finalize($1);
				}
	      | delete_statement access_type
				{
				  $$ = finalize($1);
	       			  if (!finalizeAccessOptions($$, $2)) YYERROR;
				}
	      | load_statement
                  {
                    $$ = finalize($1);
                  }

exe_util_statement: TOK_INSERT TOK_USING TOK_ALTER TOK_INTO table_name query_expression
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
		                                 , PARSERHEAP() // in  - NAMemory * heapUsedForOutputBuffers
		                                 );
		 // If we can not get a variable-width multi-byte or single-byte string here, report error 
		 if ( stmt == NULL )
		 {
		   *SqlParser_Diags <<  DgSqlCode(-3406);
		   YYERROR;
		 }

		 UInt32 pos = 
		   stmt->index(" into ", 0, NAString::ignoreCase);
		 pos = pos + strlen(" into ");
		 // skip blanks to reach start of tablename
		 while (stmt->data()[pos] == ' ')
		   pos++;
		 
		 // skip tablename
		 while (stmt->data()[pos] != ' ')
		   pos++;

		 ExeUtilCreateTableAs * eue = 
		   new(PARSERHEAP()) ExeUtilCreateTableAs
		   (CorrName(*$5, PARSERHEAP()),
		    NULL,
		    (char*)&(stmt->data()[pos]),
		    stmtCharSet,
		    PARSERHEAP());
		
		 $$ = finalize(eue);
 
		 delete $5 /*ddl_qualified_name*/;


	       }

exe_util_cleanup_volatile_tables : TOK_CLEANUP_OBSOLETE TOK_VOLATILE TOK_TABLES
               {
		 ExeUtilCleanupVolatileTables * volSch =
		    new (PARSERHEAP ()) ExeUtilCleanupVolatileTables
		   (ExeUtilCleanupVolatileTables::OBSOLETE_TABLES_IN_DEFAULT_CAT,
		    "",
		    PARSERHEAP ());

		 // xn will be started, if needed, when the exeutilstmt stmt
		 // is processed.
		 volSch->xnNeeded() = FALSE;

		 $$ = volSch;
	       }
              | TOK_CLEANUP_OBSOLETE TOK_VOLATILE TOK_TABLES TOK_IN TOK_ALL TOK_CATALOGS
               {
		 ExeUtilCleanupVolatileTables * volSch =
		    new (PARSERHEAP ()) ExeUtilCleanupVolatileTables
		   (ExeUtilCleanupVolatileTables::OBSOLETE_TABLES_IN_ALL_CATS,
		    "",
		    PARSERHEAP ());

		 // xn will be started, if needed, when the exeutilstmt stmt
		 // is processed.
		 volSch->xnNeeded() = FALSE;

		 $$ = volSch;
	       }
              | TOK_CLEANUP_OBSOLETE TOK_VOLATILE TOK_TABLES TOK_IN TOK_CATALOG character_string_literal
               {
                 // DEFAULT_CHARSET has no effect on character_string_literal in this context
		 ExeUtilCleanupVolatileTables * volSch =
		    new (PARSERHEAP ()) ExeUtilCleanupVolatileTables
		   (ExeUtilCleanupVolatileTables::OBSOLETE_TABLES_IN_SPECIFIED_CAT,
		    *$6,
		    PARSERHEAP ());

		 // xn will be started, if needed, when the exeutilstmt stmt
		 // is processed.
		 volSch->xnNeeded() = FALSE;

		 $$ = volSch;
	       }

/* type relx */
exe_util_get_error_info : TOK_GET TOK_TEXT TOK_FOR TOK_ERROR NUMERIC_LITERAL_EXACT_NO_SCALE 
               {
		 ExeUtilGetErrorInfo * errInfo =
		    new (PARSERHEAP ()) ExeUtilGetErrorInfo
		   (atol($5->data()),
		    PARSERHEAP ());

		 $$ = errInfo;
	       }

/* type relx */
exe_util_get_volatile_info : TOK_GET TOK_ALL TOK_VOLATILE TOK_SCHEMAS
               {
		 ExeUtilGetVolatileInfo * volSch =
		    new (PARSERHEAP ()) ExeUtilGetVolatileInfo
		   (ExeUtilGetVolatileInfo::ALL_SCHEMAS,
		    "",
		    PARSERHEAP ());

		 $$ = volSch;
	       }
             | TOK_GET TOK_ALL TOK_VOLATILE TOK_TABLES
               {
		 ExeUtilGetVolatileInfo * volSch =
		    new (PARSERHEAP ()) ExeUtilGetVolatileInfo
		   (ExeUtilGetVolatileInfo::ALL_TABLES,
		    "",
		    PARSERHEAP ());

		 $$ = volSch;
	       }
             | TOK_GET TOK_VOLATILE TOK_TABLES TOK_FOR TOK_SESSION QUOTED_STRING
               {
                 // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		 ExeUtilGetVolatileInfo * volSch =
		    new (PARSERHEAP ()) ExeUtilGetVolatileInfo
		   (ExeUtilGetVolatileInfo::ALL_TABLES_IN_A_SESSION,
		    *$6,
		    PARSERHEAP ());

		 $$ = volSch;
	       }

explain_starting_tokens : TOK_EXPLAIN optional_options
                                {
                                  ParNameLocListPtr = new (PARSERHEAP()) 
                                    ParNameLocList ( SQLTEXT()
                                                   , (CharInfo::CharSet)SQLTEXTCHARSET()
                                                   , SQLTEXTW()
                                                   , PARSERHEAP()
                                                   );
                                  ParSetTextStartPosForDisplayExplain(
                                        ParNameLocListPtr);
				  $$ = $2;

                                  SqlParser_CurrentParser->hiveDDLInfo_->essd_ = Parser::HiveDDLInfo::EXPLAIN_;	
                                  if ($2)
                                    SqlParser_CurrentParser->hiveDDLInfo_->essdOptions_ = *$2;
                                  StringPos start;
                                  StringPos end;
                                  ParGetTextStartEndPosForDisplayExplain(
                                       ParNameLocListPtr, start, end);
                                  SqlParser_CurrentParser->hiveDDLInfo_->essdQueryStartPos_ = start;
                                }

/* type relx */
exe_util_get_statistics : TOK_GET TOK_STATISTICS stats_merge_clause get_statistics_optional_options
               {
		 ExeUtilGetStatistics * stats =
		    new (PARSERHEAP ()) ExeUtilGetStatistics
		   ("", ($4 ? (char*)$4->data() : NULL),
		    PARSERHEAP (), SQLCLI_STATS_REQ_STMT, (short)$3);

		 $$ = stats;
	       }
              | TOK_GET TOK_STATISTICS TOK_FOR TOK_STATEMENT identifier stats_merge_clause get_statistics_optional_options
               {
		 ExeUtilGetStatistics * stats =
		    new (PARSERHEAP ()) ExeUtilGetStatistics
		   (*$5, ($7 ? (char*)$7->data() : NULL),
		    PARSERHEAP (), SQLCLI_STATS_REQ_STMT, (short)$6);

		 $$ = stats;
	       }
              | TOK_GET TOK_STATISTICS TOK_FOR TOK_QID qid_identifier stats_merge_clause get_statistics_optional_options
                {
                  ExeUtilGetStatistics *stats = NULL;
                  if (*$5 == "CURRENT")
                  {
                     stats =
                      new (PARSERHEAP ()) ExeUtilGetStatistics
                    (*$5, ($7 ? (char*)$7->data() : NULL),
                      PARSERHEAP (), SQLCLI_STATS_REQ_QID_CURRENT, (short)$6, -1); /*RtsQueryId::ANY_QUERY_*/
                  }
                  else
                  {
                    stats =
                      new (PARSERHEAP ()) ExeUtilGetStatistics
                    (*$5, ($7 ? (char*)$7->data() : NULL),
                      PARSERHEAP (), SQLCLI_STATS_REQ_QID, (short)$6, -1); /*RtsQueryId::ANY_QUERY_*/
                  }
                  $$ = stats;
                }
              | TOK_GET TOK_STATISTICS TOK_FOR TOK_QID_INTERNAL qid_internal_identifier qid_internal_stats_merge_clause
                {
                  ExeUtilGetStatistics *stats =
                     new (PARSERHEAP ()) ExeUtilGetStatistics
                     (*$5, NULL,
                       PARSERHEAP (), SQLCLI_STATS_REQ_QID_INTERNAL, (short)$6, -1); /*RtsQueryId::ANY_QUERY_*/
                  $$ = stats;
                }
              | TOK_GET TOK_STATISTICS TOK_FOR TOK_PID pid_identifier stats_active_clause stats_merge_clause
                {
                  ExeUtilGetStatistics * stats =
                      new (PARSERHEAP ()) ExeUtilGetStatistics
                    (*$5, NULL,
                      PARSERHEAP (), SQLCLI_STATS_REQ_PID, (short)$7, (short)$6);
                  $$ = stats;
                }
              | TOK_GET TOK_PROCESS TOK_STATISTICS TOK_FOR pid_identifier
                {
                  ExeUtilGetProcessStatistics * stats =
                      new (PARSERHEAP ()) ExeUtilGetProcessStatistics
                    (*$5, NULL,
                      PARSERHEAP ());
                  $$ = stats;
                }
              | TOK_GET TOK_STATISTICS TOK_FOR TOK_CPU cpu_identifier stats_active_clause stats_merge_clause
                {
                  ExeUtilGetStatistics * stats =
                      new (PARSERHEAP ()) ExeUtilGetStatistics
                    (*$5, NULL,
                      PARSERHEAP (), SQLCLI_STATS_REQ_CPU, (short)$7, (short)$6);

                  $$ = stats;
                }
              | TOK_GET TOK_STATISTICS TOK_FOR TOK_RMS cpu_identifier_with_all reset_clause
                {
                  ExeUtilGetStatistics * stats =
                      new (PARSERHEAP ()) ExeUtilGetStatistics
                    (*$5, NULL,
                      PARSERHEAP (), SQLCLI_STATS_REQ_RMS_INFO, SQLCLI_SAME_STATS, (short)($6*-1));
                  $$ = stats;
                }
                
get_statistics_optional_options : /* empty */
                                  { $$ = NULL; }
                                | ',' TOK_OPTIONS QUOTED_STRING
                                  /* DEFAULT_CHARSET has no effect on QUOTED_STRING in this context */
                                  { $$ = $3; }
procedure_or_function : TOK_PROCEDURES 
                        | TOK_FUNCTIONS 
                        | TOK_TABLE_MAPPING TOK_FUNCTIONS {$$ = $1; }

exe_util_get_metadata_info : 
          TOK_GET get_info_aus_clause objects_identifier 
                  get_info_io_clause object_identifier table_name 
                  optional_no_header_and_match_pattern_clause
          {
            NABoolean getVersion = FALSE;
            NAString aus(*$2);
            if (*$2 == "VERSION_USER")
            {
              getVersion = TRUE;
              aus = "USER";
            }
            else if (*$2 == "VERSION_ALL")
            {
              getVersion = TRUE;
              aus = "ALL";
            }
            else if (*$2 == "VERSION_SYSTEM")
            {
              getVersion = TRUE;
              aus = "SYSTEM";
            }
            else if (*$2 == "NONE")
              aus = "USER";

            PtrPlaceHolder * pph = $7;
            NAString * noHeader       = (NAString *)pph->ptr1_;
            NAString * pattern        = (NAString *)pph->ptr2_;
            NAString * fullyQualNames = (NAString *)pph->ptr3_;

            ExeUtilGetMetadataInfo * gmi = new (PARSERHEAP ()) ExeUtilGetMetadataInfo
                   (aus, *$3, *$4, *$5, *$6, pattern, (fullyQualNames ? TRUE : FALSE),
                    getVersion, NULL, PARSERHEAP ());

            if (noHeader)
              gmi->setNoHeader(TRUE);
            else if (NOT ((CmpCommon::getDefault(IS_SQLCI) == DF_ON) ||
                          (CmpCommon::getDefault(NVCI_PROCESS) == DF_ON)))
            {
              gmi->setNoHeader(TRUE);
            }

            $$ = gmi;
          }
        | TOK_GET get_info_aus_clause objects_identifier 
                  optional_no_header_and_match_pattern_clause
          {
            NABoolean getVersion = FALSE;
            NAString aus(*$2);
            if (*$2 == "VERSION_ALL")
            {
              getVersion = TRUE;
              aus = "ALL";
            }
            else if (*$2 == "VERSION_USER")
            {
              getVersion = TRUE;
              aus = "USER";
            }
            else if (*$2 == "VERSION_SYSTEM")
            {
              getVersion = TRUE;
             aus = "SYSTEM";
            }
            else if (*$2 == "NONE")
              aus = "USER";

            PtrPlaceHolder * pph = $4;
            NAString * noHeader = (NAString *)pph->ptr1_;
            NAString * pattern = (NAString *)pph->ptr2_;
            NAString * fullyQualNames = (NAString *)pph->ptr3_;
            CorrName cn("DUMMY");
            NAString nas("");
            ExeUtilGetMetadataInfo * gmi = new (PARSERHEAP ()) ExeUtilGetMetadataInfo
                    (aus, *$3, nas, nas, cn, pattern, (fullyQualNames ? TRUE : FALSE), 
                     getVersion, NULL, PARSERHEAP());

            if (noHeader)
              gmi->setNoHeader(TRUE);

            $$ = gmi;
          }
        | TOK_GET get_info_aus_clause procedure_or_function TOK_FOR_LIBRARY table_name
                  optional_no_header_and_match_pattern_clause
        {
           NAString aus("ALL");    
           NAString infoType;
           NAString iof("FOR");
           NAString objType("LIBRARY"); 
           CorrName cn("");

           // we want an empty get_info_aus_clause;  it is just there to make the
           // production symetric with other GET statements and please the parser
           if (*$2 != "NONE")
             YYERROR;
           if ($3 == TOK_PROCEDURES)
             infoType = "PROCEDURES" ;
           else if ($3 == TOK_FUNCTIONS)
             infoType = "FUNCTIONS" ;
           else
             infoType = "TABLE_FUNCTIONS" ;

           PtrPlaceHolder * pph = $6;
           NAString * noHeader = (NAString *)pph->ptr1_;
           NAString * pattern = (NAString *)pph->ptr2_;
           NAString * fullyQualNames = (NAString *)pph->ptr3_;

           ExeUtilGetMetadataInfo * gmi = new (PARSERHEAP ()) 
                    ExeUtilGetMetadataInfo(
                             aus,            // NAString &
                             infoType,       // NAString & 
                             iof,            // NAString & 
                             objType,        // NAString & objectType
                             *($5),          // CorrName &
                             NULL,           // NAString * pattern
                             TRUE,           // return fully qualified names
                             FALSE,          // getVersion 
                             NULL,             // param1 -- the library name
                             PARSERHEAP ()); // ColHeap  * oHeap 
                     
           if (noHeader)
             gmi->setNoHeader(TRUE);
           else if (NOT ((CmpCommon::getDefault(IS_SQLCI) == DF_ON) ||
                         (CmpCommon::getDefault(NVCI_PROCESS) == DF_ON)))
             gmi->setNoHeader(TRUE);

           $$ = gmi;          
        } 
        | TOK_GET get_info_aus_clause obj_priv_identifier 
          for_user_or_role authorization_identifier  
          optional_no_header_and_match_pattern_clause
          {
            NAString aus(*$2);
            if (aus == "CURRENT_USER") YYERROR;
            if (aus == "NONE")
              aus = "USER";

            NAString infoType(*$3);

            NAString iof("FOR");

            NAString objType("USER");
            if ($4 == TOK_FOR_ROLE)
              objType = "ROLE";
  
            PtrPlaceHolder * pph      = $6;
            NAString * noHeader       = (NAString *)pph->ptr1_;
            NAString * pattern        = (NAString *)pph->ptr2_;
            NABoolean  fullyQualNames = (pph->ptr3_) ? TRUE : FALSE; 

            NABoolean getVersion = FALSE;

            CorrName cnm("");

            ExeUtilGetMetadataInfo * gmi = new (PARSERHEAP ()) ExeUtilGetMetadataInfo
                    (aus, infoType, iof, objType, cnm, pattern, fullyQualNames, 
                     getVersion, $5,  PARSERHEAP ());

            if (noHeader ||
                (NOT ((CmpCommon::getDefault(IS_SQLCI) == DF_ON) ||
                      (CmpCommon::getDefault(NVCI_PROCESS) == DF_ON))))
              gmi->setNoHeader(TRUE);

            $$ = gmi;
          }

        | TOK_GET get_info_aus_clause TOK_PRIVILEGES TOK_ON object_identifier 
          table_name optional_for_user_clause 
          optional_no_header_and_match_pattern_clause
          {
            NAString aus("ALL");

            NAString infoType("PRIVILEGES");
            NABoolean getVersion = FALSE;
            PtrPlaceHolder * pph = $8;
            NAString * noHeader = (NAString *)pph->ptr1_;
            NAString * pattern = (NAString *)pph->ptr2_;
            NAString * fullyQualNames = (NAString *)pph->ptr3_;

            NAString iof("ON");
            NAString nas("");
            ExeUtilGetMetadataInfo * gmi =
              new (PARSERHEAP ()) ExeUtilGetMetadataInfo
              (aus, infoType, iof, *$5, 
               *$6, pattern,
               (fullyQualNames ? TRUE : FALSE),
               getVersion,
               $7,
               PARSERHEAP ());
		 
            if (noHeader)
              gmi->setNoHeader(TRUE);
            else if (NOT ((CmpCommon::getDefault(IS_SQLCI) == DF_ON) ||
                 (CmpCommon::getDefault(NVCI_PROCESS) == DF_ON)))
              {
               gmi->setNoHeader(TRUE);
              }

            $$ = gmi;
          }
    
      // Created a special production for getting privileges on procedures
      // TOK_PROCEDURE as an object_identifier causes lots of parser conflicts
      | TOK_GET get_info_aus_clause TOK_PRIVILEGES TOK_ON TOK_PROCEDURE
        table_name optional_for_user_clause
        optional_no_header_and_match_pattern_clause
        {
          NAString aus("ALL");
          NAString infoType("PRIVILEGES");
          NABoolean getVersion = FALSE;
          PtrPlaceHolder * pph = $8;
          NAString * noHeader = (NAString *)pph->ptr1_;
          NAString * pattern = (NAString *)pph->ptr2_;
          NAString * fullyQualNames = (NAString *)pph->ptr3_;

          NAString iof("ON");
          NAString nas("");
          NAString ptype("PROCEDURE");
          ExeUtilGetMetadataInfo * gmi =
            new (PARSERHEAP ()) ExeUtilGetMetadataInfo
            (aus, infoType, iof, ptype,
             *$6, pattern,
             (fullyQualNames ? TRUE : FALSE),
             getVersion,
             $7,
             PARSERHEAP ());

          if (noHeader)
            gmi->setNoHeader(TRUE);
          else if (NOT ((CmpCommon::getDefault(IS_SQLCI) == DF_ON) ||
                        (CmpCommon::getDefault(NVCI_PROCESS) == DF_ON)))
            {
              gmi->setNoHeader(TRUE);
            }

          $$ = gmi;
        }

      | TOK_GET get_info_aus_clause TOK_COMPONENTS 
          optional_no_header_and_match_pattern_clause
          // GET COMPONENTS
          {
            NAString aus(*$2);
            if (*$2 == "ALL")
              aus = "ALL";
            else if (*$2 == "USER")
              aus = "USER";
            else if (*$2 == "CURRENT_USER")
              aus = "USER";
            else if (*$2 == "NONE")
              aus = "ALL";
            else
              YYERROR;

            NAString infoType("COMPONENTS");  // COMPONENT TBD
            NAString iof;
            NAString objectType;
            CorrName objectName;
            ExeUtilGetMetadataInfo * gmi = new (PARSERHEAP())
              ExeUtilGetMetadataInfo
              ( aus          // NAString &
              , infoType     // NAString &
              , iof          // NAString &
              , objectType   // NAString & objectType
              , objectName   // CorrName &
              , NULL         // NAString * pattern
              , FALSE        // NABoolean returnFullyQualNames
              , FALSE        // NABoolean getVersion
              , NULL         // NAString * param1
              , PARSERHEAP() // CollHeap * oHeap
              );

            PtrPlaceHolder * pph      = $4;
            NAString * noHeader       = (NAString *)pph->ptr1_;
            if (noHeader)
              gmi->setNoHeader(TRUE);

            $$ = gmi;
          }
  
        | TOK_GET get_info_aus_clause TOK_COMPONENT TOK_PRIVILEGES 
          TOK_ON component_name optional_authid_clause 
          optional_drop_behavior optional_no_header_and_match_pattern_clause 
          {
            NAString aus(*$2);
            if (*$2 == "ALL")
              aus = "ALL";
            else if (*$2 == "USER")
              aus = "USER";
            else if (*$2 == "CURRENT_USER")
              aus = "USER";
            else if (*$2 = "NONE")
              aus = "ALL";
            else
              YYERROR;

            NAString infoType("PRIVILEGES");
            NAString iof("ON");       
            NAString objectType("COMPONENT");
            CorrName objectName(*$6);

            PtrPlaceHolder * pph = $9;
            NAString * noHeader = (NAString *)pph->ptr1_;
            NAString * pattern = (NAString *)pph->ptr2_;
            NAString * fullyQualNames = (NAString *)pph->ptr3_;

            ExeUtilGetMetadataInfo * gmi = new (PARSERHEAP())
              ExeUtilGetMetadataInfo
              ( aus          // NAString & 
              , infoType     // NAString &
              , iof          // NAString &
              , objectType   // NAString &
              , objectName   // CorrName &
              , pattern         // NAString * pattern
              , (fullyQualNames ? TRUE : FALSE)  // NABoolean returnFullyQualNames
              , FALSE        // NABoolean getVersion
              , $7           // NAString * param1
              , PARSERHEAP() // CollHeap * oHeap
              );

            if (noHeader)
              gmi->setNoHeader(TRUE);
            
            if ($8 == COM_CASCADE_DROP_BEHAVIOR)
               gmi->setCascade(TRUE);

            $$ = gmi;
            delete $6; // component_name
            delete $7; // user_name
          }

        | TOK_GET get_info_aus_clause TOK_PRIVILEGES
          TOK_ON TOK_COMPONENT component_name optional_authid_clause
          optional_drop_behavior optional_no_header_and_match_pattern_clause

          // GET [CURRENT_USER] PRIVILEGES ON COMPONENT <name> or
          // GET [CURRENT_USER] PRIVILEGES ON COMPONENT <name> FOR <authid>
          {
            NAString aus(*$2);
            if (*$2 == "ALL")
              aus = "ALL";
            else if (*$2 == "USER")
              aus = "USER";
            else if (*$2 == "CURRENT_USER")
              aus = "USER";
            else if (*$2 == "NONE")
              aus = "ALL";
            else
              YYERROR;

            NAString infoType("PRIVILEGES");
            NAString iof("ON");
            NAString objectType("COMPONENT");
            CorrName objectName(*$6);

            PtrPlaceHolder * pph = $9;
            NAString * noHeader = (NAString *)pph->ptr1_;
            NAString * pattern = (NAString *)pph->ptr2_;
            NAString * fullyQualNames = (NAString *)pph->ptr3_;

            ExeUtilGetMetadataInfo * gmi = new (PARSERHEAP())
              ExeUtilGetMetadataInfo
              ( aus          // NAString & 
              , infoType     // NAString &
              , iof          // NAString &
              , objectType   // NAString &
              , objectName   // CorrName &
              , pattern         // NAString * pattern
              , (fullyQualNames ? TRUE : FALSE)  // NABoolean returnFullyQualNames
              , FALSE        // NABoolean getVersion
              , $7           // NAString * param1
              , PARSERHEAP() // CollHeap * oHeap
              );

            if (noHeader)
              gmi->setNoHeader(TRUE);

            if ($8 == COM_CASCADE_DROP_BEHAVIOR)
               gmi->setCascade(TRUE);

            $$ = gmi;
            delete $6; // component_name
            delete $7; // user_name
          }
       | TOK_GET get_info_aus_clause TOK_HBASE TOK_OBJECTS
         {
           NAString ausStr(*$2);
           if (*$2 == "NONE")
             ausStr = "USER";

           NAString infoType("HBASE_OBJECTS");
           NAString iofStr;
           NAString objectType;
           CorrName objectName("DUMMY");
           NAString pattern;

           ExeUtilGetMetadataInfo * gmi = new (PARSERHEAP())
             ExeUtilGetMetadataInfo
             ( ausStr          // NAString & 
               , infoType      // NAString &
               , iofStr          // NAString &
               , objectType   // NAString &
               , objectName   // CorrName &
               , NULL         // NAString * pattern
               , FALSE  // NABoolean returnFullyQualNames
               , FALSE        // NABoolean getVersion
               , NULL           // NAString * param1
               , PARSERHEAP() // CollHeap * oHeap
               );

           $$ = gmi;
         }
       | TOK_GET get_info_aus_clause TOK_HBASE TOK_OBJECTS ',' TOK_MATCH QUOTED_STRING
         {
           NAString ausStr(*$2);
           if (*$2 == "NONE")
             ausStr = "USER";

           NAString infoType("HBASE_OBJECTS");
           NAString iofStr;
           NAString objectType;
           CorrName objectName("DUMMY");
           NAString pattern(*$7);

           ExeUtilGetMetadataInfo * gmi = new (PARSERHEAP())
             ExeUtilGetMetadataInfo
             ( ausStr          // NAString & 
               , infoType      // NAString &
               , iofStr          // NAString &
               , objectType   // NAString &
               , objectName   // CorrName &
               , &pattern         // NAString * pattern
               , FALSE  // NABoolean returnFullyQualNames
               , FALSE        // NABoolean getVersion
               , NULL           // NAString * param1
               , PARSERHEAP() // CollHeap * oHeap
               );

           $$ = gmi;
         }

for_user_or_role : TOK_FOR_USER | TOK_FOR_ROLE

optional_for_user_clause : empty { $$ = NULL; }
                         | TOK_FOR authorization_identifier
                         {
                           $$ = new(PARSERHEAP()) NAString(*$2);
                         }
                         | TOK_FOR_USER authorization_identifier
                         {
                           $$ = new(PARSERHEAP()) NAString(*$2);
                         }

optional_authid_clause : empty { $$ = NULL; }
                       | TOK_FOR authorization_identifier
                       {
                           $$ = new(PARSERHEAP()) NAString(*$2);
                       }

get_info_aus_clause :  empty { $$ = new (PARSERHEAP()) NAString("NONE"); }
                     | TOK_ALL { $$ = new (PARSERHEAP()) NAString("ALL"); }
                     | TOK_USER { $$ = new (PARSERHEAP()) NAString("USER"); }
                     | TOK_CURRENT_USER { $$ = new (PARSERHEAP()) NAString("CURRENT_USER"); }
                     | TOK_IUDLOG   { $$ = new (PARSERHEAP()) NAString("IUDLOG");}
                     | TOK_RANGELOG   { $$ = new (PARSERHEAP()) NAString("RANGELOG");}
                     | TOK_TEMP_TABLE   { $$ = new (PARSERHEAP()) NAString("TRIGTEMP");}
                     | TOK_SYSTEM { $$ = new (PARSERHEAP()) NAString("SYSTEM"); }
                     | TOK_EXTERNAL { $$ = new (PARSERHEAP()) NAString("EXTERNAL"); }

object_identifier : 
                    TOK_CATALOG  { $$ = new (PARSERHEAP()) NAString("CATALOG"); }
                  | TOK_CONSTRAINT{ $$ = new (PARSERHEAP()) NAString("CONSTRAINT"); }
                  | TOK_INDEX    { $$ = new (PARSERHEAP()) NAString("INDEX"); }
                  | TOK_LIBRARY  { $$ = new (PARSERHEAP()) NAString("LIBRARY"); }
                  | TOK_TABLE_MAPPING TOK_FUNCTION  { $$ = new (PARSERHEAP()) NAString("ROUTINE"); }
                  | TOK_FUNCTION  { $$ = new (PARSERHEAP()) NAString("ROUTINE"); }
                  | TOK_MV       { $$ = new (PARSERHEAP()) NAString("MV"); }
                  | TOK_SCHEMA   { $$ = new (PARSERHEAP()) NAString("SCHEMA"); }
                  | TOK_SYNONYM  { $$ = new (PARSERHEAP()) NAString("SYNONYM"); }
                  | TOK_TABLE    { $$ = new (PARSERHEAP()) NAString("TABLE"); }
                  | TOK_TRIGGER  { $$ = new (PARSERHEAP()) NAString("TRIGGER"); }
                  | TOK_VIEW     { $$ = new (PARSERHEAP()) NAString("VIEW"); }
                  | TOK_SEQUENCE     { $$ = new (PARSERHEAP()) NAString("SEQUENCE"); }

objects_identifier : 
                    TOK_CATALOGS { $$ = new (PARSERHEAP()) NAString("CATALOGS"); }
                  | TOK_CONSTRAINTS{ $$ = new (PARSERHEAP()) NAString("CONSTRAINTS"); }
                  | TOK_INDEXES  { $$ = new (PARSERHEAP()) NAString("INDEXES"); }
                  | TOK_LIBRARIES { $$ = new (PARSERHEAP()) NAString("LIBRARIES"); }
                  | TOK_MVS      { $$ = new (PARSERHEAP()) NAString("MVS"); }
                  | TOK_MVGROUPS { $$ = new (PARSERHEAP()) NAString("MVGROUPS"); }
                  | TOK_OBJECTS  { $$ = new (PARSERHEAP()) NAString("OBJECTS"); }
                  | TOK_PARTITIONS { $$ = new (PARSERHEAP()) NAString("PARTITIONS"); }
                  | TOK_PROCEDURES { $$ = new (PARSERHEAP()) NAString("PROCEDURES"); }
                  | TOK_ROLES    { $$ = new (PARSERHEAP()) NAString("ROLES"); }  // get roles
                  | TOK_SCHEMAS  { $$ = new (PARSERHEAP()) NAString("SCHEMAS"); }
                  | TOK_SEQUENCES  { $$ = new (PARSERHEAP()) NAString("SEQUENCES"); }
                  | TOK_SYNONYMS { $$ = new (PARSERHEAP()) NAString("SYNONYMS"); }
                  | TOK_TABLES   { $$ = new (PARSERHEAP()) NAString("TABLES"); }
                  | TOK_TRIGGERS { $$ = new (PARSERHEAP()) NAString("TRIGGERS"); }
                  | TOK_USERS    { $$ = new (PARSERHEAP()) NAString("USERS"); }  // get users
                  | TOK_VIEWS    { $$ = new (PARSERHEAP()) NAString("VIEWS"); }
                  | TOK_INVALID TOK_VIEWS { $$ = new (PARSERHEAP()) NAString("INVALID_VIEWS"); }
                  | TOK_FUNCTIONS { $$ = new (PARSERHEAP()) NAString("FUNCTIONS"); }
                  | TOK_TABLE_MAPPING TOK_FUNCTIONS { $$ = new (PARSERHEAP()) NAString("TABLE_FUNCTIONS"); }
                  | TOK_HIVE TOK_REGISTERED TOK_TABLES { $$ = new (PARSERHEAP()) NAString("HIVE_REG_TABLES"); }
                  | TOK_HIVE TOK_REGISTERED TOK_VIEWS { $$ = new (PARSERHEAP()) NAString("HIVE_REG_VIEWS"); }
                  | TOK_HIVE TOK_REGISTERED TOK_SCHEMAS { $$ = new (PARSERHEAP()) NAString("HIVE_REG_SCHEMAS"); }
                  | TOK_HIVE TOK_REGISTERED TOK_OBJECTS { $$ = new (PARSERHEAP()) NAString("HIVE_REG_OBJECTS"); }
                  | TOK_HIVE TOK_EXTERNAL TOK_TABLES { $$ = new (PARSERHEAP()) NAString("HIVE_EXT_TABLES"); }
                  | TOK_HBASE TOK_REGISTERED TOK_TABLES { $$ = new (PARSERHEAP()) NAString("HBASE_REG_TABLES"); }


privileges_identifier :
                    TOK_PRIVILEGES { $$ = new (PARSERHEAP()) NAString("PRIVILEGES"); }

obj_priv_identifier :
                    objects_identifier | privileges_identifier

/* type stringval */
get_info_io_clause : TOK_IN  { $$ = new (PARSERHEAP()) NAString("IN"); }
                   | TOK_ON  { $$ = new (PARSERHEAP()) NAString("ON"); }

optional_no_header_and_match_pattern_clause : 
                           empty 
                            { 
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder(
				     NULL, NULL, NULL);
			    }
                          | ',' TOK_NO TOK_HEADER 
                            { 
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder(
				     (new(PARSERHEAP()) NAString()), NULL, NULL);
			    }
                          | ',' TOK_MATCH QUOTED_STRING 
                            { 
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder(
				     NULL, $3, NULL);
			    }
                          | ',' TOK_RETURN TOK_FULL TOK_NAMES
                            { 
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder(
				     NULL, NULL, (new(PARSERHEAP()) NAString()));
			    }
                          | ',' TOK_NO TOK_HEADER ',' TOK_MATCH QUOTED_STRING 
                            { 
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder(
				     (new(PARSERHEAP()) NAString()), $6, NULL);
			    }
                          | ',' TOK_NO TOK_HEADER ',' TOK_RETURN TOK_FULL TOK_NAMES
                            { 
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder(
				     (new(PARSERHEAP()) NAString()), NULL, (new(PARSERHEAP()) NAString()) );
			    }
                          | ',' TOK_NO TOK_HEADER ',' TOK_RETURN TOK_FULL TOK_NAMES ',' TOK_MATCH QUOTED_STRING 
                            { 
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder(
				     (new(PARSERHEAP()) NAString()), $10, (new(PARSERHEAP()) NAString()) );
			    }

/* type relx */
exe_util_get_version_info :   TOK_GET TOK_VERSION TOK_OF TOK_METADATA
                               {
				 ExeUtilMetadataUpgrade * mu =
				   new(PARSERHEAP()) ExeUtilMetadataUpgrade(PARSERHEAP());
				 mu->setGetMDVersion(TRUE);

				 $$ = mu;
			       }
                         | TOK_GET TOK_VERSION TOK_OF TOK_SOFTWARE
                               {
				 ExeUtilMetadataUpgrade * mu =
				   new(PARSERHEAP()) ExeUtilMetadataUpgrade(PARSERHEAP());
				 mu->setGetSWVersion(TRUE);

				 $$ = mu;
			       }
                          | TOK_GET TOK_VPROC TOK_OF TOK_SYSTEM TOK_MODULES
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_VPROC TOK_OF TOK_MODULE QUOTED_STRING
                               {
		 YYERROR;
			       }

                            | TOK_GET TOK_VERSION TOK_OF TOK_PROCEDURE '(' QUOTED_STRING ',' QUOTED_STRING ')'
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_VERSION TOK_OF TOK_STATEMENT explain_identifier
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_VERSION TOK_OF TOK_SYSTEM
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_VERSION TOK_OF TOK_SYSTEM nsk_node_name
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_VERSION TOK_OF TOK_MODULE QUOTED_STRING
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_VERSION TOK_OF TOK_SYSTEM TOK_SCHEMA
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_VERSION TOK_OF TOK_SYSTEM TOK_SCHEMA nsk_node_name
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_VERSION TOK_OF TOK_PROCEDURE actual_routine_name
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_VERSION TOK_OF TOK_STORED TOK_PROCEDURE actual_routine_name
                               {
		 YYERROR;
			       }
                           | TOK_GET TOK_VERSION TOK_OF object_identifier table_name 
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_NAMES TOK_OF TOK_RELATED objects_identifier TOK_FOR table_name 
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_NAMES TOK_OF TOK_RELATED TOK_NODES TOK_FOR nsk_node_name
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_NAMES TOK_OF TOK_RELATED TOK_NODES 
                               {
		 YYERROR;
			       }
                            | TOK_GET TOK_SYSTEM TOK_NAME
                               {
		 YYERROR;
			       }
/* type relx */
exe_util_get_uid : TOK_GET TOK_UID TOK_OF maintain_object_token table_name
               {
                 YYERROR;
	       }

/* type relx */
exe_util_get_qid : TOK_GET TOK_QID TOK_FOR TOK_STATEMENT IDENTIFIER
               {
                 if ( ($5==NULL) || transformIdentifier(*$5)) 
                   YYERROR;

                 $$ = new(PARSERHEAP()) ExeUtilGetQID(*$5, PARSERHEAP());
	       }

/* type relx */
exe_util_populate_in_memory_statistics : TOK_GENERATE TOK_STATISTICS TOK_FOR TOK_TABLE table_name TOK_LIKE table_name optional_from_schema
               {
		 YYERROR;
	       }

/* type relx */
exe_util_lob_extract : TOK_EXTRACT TOK_LOBLENGTH '(' TOK_LOB QUOTED_STRING  ')' TOK_LOCATION NUMERIC_LITERAL_EXACT_NO_SCALE
               {
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);
		 Int64 returnLengthAddr = atoInt64($8->data());
		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::RETRIEVE_LENGTH_,
		    returnLengthAddr, 0, 0, 0);

		 $$ = lle;
	       }
/* type relx */
exe_util_lob_extract : TOK_EXTRACT TOK_LOBLENGTH '(' TOK_LOB QUOTED_STRING  ')' 
               {
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);
		
		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::RETRIEVE_LENGTH_,
		    -1, 0, 0, 0);

		 $$ = lle;
	       }
/* type relx */
exe_util_lob_extract : TOK_EXTRACT TOK_NAME '(' TOK_LOB QUOTED_STRING  ')' TOK_LOCATION NUMERIC_LITERAL_EXACT_NO_SCALE
               {
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);
		 Int64 returnFilenameAddr = atoInt64($8->data());
		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::RETRIEVE_HDFSFILENAME_,
		    returnFilenameAddr, 0, 0, 0);

		 $$ = lle;
	       }
/* type relx */
exe_util_lob_extract : TOK_EXTRACT TOK_NAME '(' TOK_LOB QUOTED_STRING  ')' 
               {
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);
		
		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::RETRIEVE_HDFSFILENAME_,
		    -1, 0, 0, 0);

		 $$ = lle;
	       }
/* type relx */
exe_util_lob_extract : TOK_EXTRACT TOK_OFFSET'(' TOK_LOB QUOTED_STRING  ')' TOK_LOCATION NUMERIC_LITERAL_EXACT_NO_SCALE
               {
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);
		 Int64 returnOffsetAddr = atoInt64($8->data());
		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::RETRIEVE_OFFSET_,
		    returnOffsetAddr, 0, 0, 0);

		 $$ = lle;
	       }
/* type relx */
exe_util_lob_extract : TOK_EXTRACT TOK_OFFSET '(' TOK_LOB QUOTED_STRING  ')' 
               {
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);
		
		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::RETRIEVE_OFFSET_,
		    -1, 0, 0, 0);

		 $$ = lle;
	       }


               | TOK_EXTRACT TOK_LOBTOSTRING '(' TOK_LOB QUOTED_STRING ',' TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ')'
               {
		 YYERROR;
		 /*
		  Int64 rowSize = atoInt64($8->data());

		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::TO_STRING_,
		    0, 0, rowSize, 0);

		 $$ = lle;
		 */
	       }

              | TOK_EXTRACT TOK_LOBTOBUFFER '(' TOK_LOB QUOTED_STRING ',' TOK_LOCATION NUMERIC_LITERAL_EXACT_NO_SCALE ',' TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ')'
               {
		 /* TOK_LOCATION points to a user allocated data buffer ehich needs to be enough to hold alreast TOK_SIZE worth of data .
TOK_SIZE points to the address of an Int64 container This size is the input specified by user for length to extract. One return, it will give the caller the size that was extracted */

		 Int64 bufAddr = atoInt64($8->data());
		 Int64 sizeAddr = atoInt64($11->data());
		 
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::TO_BUFFER_,
		    bufAddr, sizeAddr, 0, 0);

		 $$ = lle;
	       }

              
            | TOK_EXTRACT TOK_LOBTOFILE '(' TOK_LOB QUOTED_STRING  ','  QUOTED_STRING ')'
               {
                 // if file exists, error . if file doesn't exist, create
                 // extract lobtofile (lob 'abc',  'file');

		  ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::TO_FILE_,
		    0, 0, 
		    0, 
		    0,
		    (char*)$7->data());

		 $$ = lle;
	       }
              | TOK_EXTRACT TOK_LOBTOFILE '(' TOK_LOB QUOTED_STRING ',' QUOTED_STRING ',' TOK_TRUNCATE  ')'
               {
                 // if file exists, truncate and replace contents. if file doesn't exist error
                 // extract lobtofile (lob 'abc',  'file', truncate);

		  ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::TO_FILE_,
		    0, 0, 
		    ExeUtilLobExtract::ERROR_IF_NOT_EXISTS, 
		    ExeUtilLobExtract::TRUNCATE_EXISTING,
		    (char*)$7->data());

		 $$ = lle;
	       }
| TOK_EXTRACT TOK_LOBTOFILE '(' TOK_LOB QUOTED_STRING ',' QUOTED_STRING ',' TOK_CREATE ',' TOK_TRUNCATE  ')'
               {
                 // if file exists, truncate and replace contents. if file doesn't exist, create
                 // extract lobtofile (lob 'abc',  'file', create);

		  ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::TO_FILE_,
		    0, 0, 
		    0, 
		    ExeUtilLobExtract::TRUNCATE_EXISTING ,
		    (char*)$7->data());

		 $$ = lle;
	       }
               | TOK_EXTRACT TOK_LOBTOFILE '(' TOK_LOB QUOTED_STRING ','  QUOTED_STRING ',' TOK_CREATE ',' TOK_APPEND  ')'
               {
                 // if file exists, append. if file doesn't exist, create
                 // extract lobtofile (lob 'abc',  'file', create);

		  ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::TO_FILE_,
		    0, 0, 
		    0,
		    ExeUtilLobExtract::APPEND_OR_CREATE,
		    (char*)$7->data());

		 $$ = lle;
	       }

              | TOK_EXTRACT TOK_LOBTOFILE '(' TOK_LOB QUOTED_STRING ',' QUOTED_STRING ',' TOK_APPEND ')'
               {
                 // if file exists, append. if file doesn't exist, error
                 // extract lobtofile (lob 'abc',  'file', append);

		  ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, 
		    ExeUtilLobExtract::TO_FILE_,
		    0, 0, 
		    ExeUtilLobExtract::ERROR_IF_NOT_EXISTS, 
		    0,
		    (char*)$7->data(),FALSE);

		 $$ = lle;
	       }

               | TOK_EXTRACT TOK_LOBTOSTRING '(' TOK_LOB QUOTED_STRING ',' TOK_OUTPUT TOK_ROW TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ',' TOK_LOB TOK_BUFFER TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ')'
               {
                 YYERROR;
                 /*
		 Int64 rowSize = atoInt64($10->data());
		 Int64 bufSize = atoInt64($15->data());

		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$5);

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (handle, //(char*)$5->data(), 
		    ExeUtilLobExtract::TO_STRING_,
		    0, 0, rowSize, bufSize); 
                    $$ = lle;
                 */
	       }

           | TOK_EXTRACT TOK_EXTERNALTOSTRING '(' QUOTED_STRING ',' TOK_OUTPUT TOK_ROW TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ')'
               {
                 YYERROR;
                 /*
		 Int64 rowSize = atoInt64($9->data());

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (NULL,
		    ExeUtilLobExtract::TO_STRING_,
		    0, 0, rowSize, 0,
		    (char*)$4->data());

		 $$ = lle;
                 */
	       }

          | TOK_EXTRACT TOK_EXTERNALTOSTRING '(' QUOTED_STRING ',' QUOTED_STRING ',' TOK_OUTPUT TOK_ROW TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ')'
               {
                 YYERROR;
                 /*
		  Int64 rowSize = atoInt64($11->data());

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (NULL,
		    ExeUtilLobExtract::TO_STRING_,
		    0, 0, rowSize, 0,
		    (char*)$4->data(), (char*)$6->data());

		 $$ = lle; 
                 */
	       }

          | TOK_EXTRACT TOK_EXTERNALTOSTRING '(' QUOTED_STRING ',' QUOTED_STRING ',' TOK_BUFFER TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ',' TOK_OUTPUT TOK_ROW TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ')'
               {
                 YYERROR;
                 /*
		 Int64 rowSize = atoInt64($15->data());
		 Int64 bufSize = atoInt64($10->data());

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (NULL,
		    ExeUtilLobExtract::TO_STRING_,
		    0, 0, rowSize, bufSize,
		    (char*)$4->data(), (char*)$6->data());

		 $$ = lle;
                 */
	       }

          | TOK_EXTRACT TOK_EXTERNALTOSTRING '(' QUOTED_STRING ',' QUOTED_STRING ',' QUOTED_STRING ',' TOK_OUTPUT TOK_ROW TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ')'
               {
                 YYERROR;
                 /*
		 Int64 rowSize = atoInt64($13->data());

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (NULL,
		    ExeUtilLobExtract::TO_STRING_,
		    0, 0, rowSize, 0,
		    (char*)$4->data(), (char*)$6->data(), (char*)$8->data());

		 $$ = lle;
                 */
	       }

          | TOK_LOAD TOK_STRINGTOEXTERNAL '(' QUOTED_STRING ',' QUOTED_STRING ',' QUOTED_STRING  ',' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
               {
                 YYERROR;
                 /*
		 Int64 offset = atoInt64($10->data());

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (NULL,
		    ExeUtilLobExtract::TO_EXTERNAL_FROM_STRING_,
		    0, 0, offset, 0,
		    (char*)$4->data(), (char*)$6->data(), (char*)$8->data());

		 $$ = lle;
                 */
	       }

         | TOK_LOAD TOK_STRINGTOEXTERNAL '(' QUOTED_STRING ',' QUOTED_STRING ',' QUOTED_STRING  ',' NUMERIC_LITERAL_EXACT_NO_SCALE ',' TOK_WITH TOK_CREATE ')'
               {
                 YYERROR;
                 /*
		  Int64 offset = atoInt64($10->data());

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (NULL,
		    ExeUtilLobExtract::TO_EXTERNAL_FROM_STRING_,
		    0, 0, offset, 0,
		    (char*)$4->data(), (char*)$6->data(), (char*)$8->data());

		 lle->withCreate() = TRUE;

		 $$ = lle;
                 */
	       }

          | TOK_LOAD TOK_FILETOEXTERNAL '(' QUOTED_STRING ',' QUOTED_STRING ',' QUOTED_STRING  ',' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
               {
                 YYERROR;
                 /*
		 Int64 offset = atoInt64($10->data());

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (NULL,
		    ExeUtilLobExtract::TO_EXTERNAL_FROM_FILE_,
		    0, 0, offset, 0,
		    (char*)$4->data(), (char*)$6->data(), (char*)$8->data());

		 $$ = lle;
                 */
	       }

         | TOK_LOAD TOK_FILETOEXTERNAL '(' QUOTED_STRING ',' QUOTED_STRING ',' QUOTED_STRING  ',' NUMERIC_LITERAL_EXACT_NO_SCALE ',' TOK_WITH  TOK_CREATE ')'
               {
                 YYERROR;
                 /*
		  Int64 offset = atoInt64($10->data());

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (NULL,
		    ExeUtilLobExtract::TO_EXTERNAL_FROM_FILE_,
		    0, 0, offset, 0,
		    (char*)$4->data(), (char*)$6->data(), (char*)$8->data());

		 lle->withCreate() = TRUE;

		 $$ = lle;
                 */
	       }
          | TOK_LOAD TOK_FILETOEXTERNAL '(' QUOTED_STRING ',' QUOTED_STRING ',' QUOTED_STRING  ',' NUMERIC_LITERAL_EXACT_NO_SCALE ',' NUMERIC_LITERAL_EXACT_NO_SCALE ')'
               {
                 YYERROR;
                 /*
		 Int64 offset = atoInt64($10->data());
		 Int64 bufSize = atoInt64($12->data());

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (NULL,
		    ExeUtilLobExtract::TO_EXTERNAL_FROM_FILE_,
		    0, 0, offset, bufSize,
		    (char*)$4->data(), (char*)$6->data(), (char*)$8->data());

		 $$ = lle;
                 */
	       }

         | TOK_LOAD TOK_FILETOEXTERNAL '(' QUOTED_STRING ',' QUOTED_STRING ',' QUOTED_STRING  ',' NUMERIC_LITERAL_EXACT_NO_SCALE ',' NUMERIC_LITERAL_EXACT_NO_SCALE ',' TOK_WITH  TOK_CREATE ')'
               {
                 YYERROR;
                 /*
		  Int64 offset = atoInt64($10->data());
		 Int64 bufSize = atoInt64($12->data());

		 ExeUtilLobExtract * lle =
		   new (PARSERHEAP ()) ExeUtilLobExtract
		   (NULL,
		    ExeUtilLobExtract::TO_EXTERNAL_FROM_FILE_,
		    0, 0, offset, bufSize,
		    (char*)$4->data(), (char*)$6->data(), (char*)$8->data());

		 lle->withCreate() = TRUE;

		 $$ = lle;
                 */
	       }

exe_util_lob_update :   TOK_UPDATE_LOB '(' TOK_LOB QUOTED_STRING ',' TOK_LOCATION NUMERIC_LITERAL_EXACT_NO_SCALE ',' TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE  ')' 
               {
                 /* TOK_LOCATION points to a caller allocated data buffer with 
                 LOB data . TOK_SIZE is the  size is the input specified by 
                 user for length to update. On return, it will give the caller 
                 the size that was updated */
                 Int64 bufAddr = atoInt64($7->data());
		 Int64 size = atoInt64($10->data());
		 
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$4);
                 ExeUtilLobUpdate *llu =  
                   new (PARSERHEAP ()) ExeUtilLobUpdate
		   (handle, 
		    ExeUtilLobUpdate::FROM_BUFFER_,
		    bufAddr, size, ExeUtilLobUpdate::REPLACE_,0);

		 $$ = llu;
               } 
              |  TOK_UPDATE_LOB '(' TOK_LOB QUOTED_STRING ',' TOK_LOCATION NUMERIC_LITERAL_EXACT_NO_SCALE ',' TOK_SIZE NUMERIC_LITERAL_EXACT_NO_SCALE ',' TOK_APPEND')'    
               {
                 /* TOK_LOCATION points to a caller allocated data buffer with 
                 LOB data . TOK_SIZE is the  size is the input specified by 
                 user for length to update. On return, it will give the caller 
                 the size that was updated */
                 Int64 bufAddr = atoInt64($7->data());
		 Int64 size = atoInt64($10->data());
		 
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$4);
                 ExeUtilLobUpdate *llu =  
                   new (PARSERHEAP ()) ExeUtilLobUpdate
		   (handle, 
		    ExeUtilLobUpdate::FROM_BUFFER_,
		    bufAddr, size, ExeUtilLobUpdate::APPEND_,0);

		 $$ = llu;
               }
              | TOK_UPDATE_LOB '(' TOK_LOB QUOTED_STRING ',' TOK_EMPTY_BLOB '(' ')'')' 
               {
                 /* Truncate and insert empty_blob */
                 
		 
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$4);
                 ExeUtilLobUpdate *llu =  
                   new (PARSERHEAP ()) ExeUtilLobUpdate
		   (handle, 
		    ExeUtilLobUpdate::FROM_BUFFER_,
		    0, 0, ExeUtilLobUpdate::TRUNCATE_EXISTING_,0);

		 $$ = llu;
               }
          | TOK_UPDATE_LOB '(' TOK_LOB QUOTED_STRING ',' TOK_EMPTY_CLOB '(' ')' ')' 
               {
                 /* Truncate and insert empty_blob */
                 
		 
		 ConstValue * handle = new(PARSERHEAP()) ConstValue(*$4);
                 ExeUtilLobUpdate *llu =  
                   new (PARSERHEAP ()) ExeUtilLobUpdate
		   (handle, 
		    ExeUtilLobUpdate::FROM_BUFFER_,
		    0, 0, ExeUtilLobUpdate::TRUNCATE_EXISTING_,0);

		 $$ = llu;
               }
             

/* type pSchema */
optional_from_schema : /* empty */
               {
		 $$ = NULL;
	       }
               | TOK_FROM TOK_SCHEMA schema_name
               {
		 $$ = $3;
	       }

/* type relx */
exe_util_init_hbase :TOK_INITIALIZE TOK_TRAFODION 
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr
                   (NULL,
                    (char*)stmt->data(), 
                    stmtCharSet,
                    PARSERHEAP());

                 de->setInitHbase(TRUE);
                 de->setCreateMDViews(TRUE);
                 de->setReturnStatus(TRUE);

		 $$ = de;
	       }

           | TOK_INITIALIZE TOK_TRAFODION ',' TOK_MINIMAL
               {
 		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr
                   (NULL,
                    (char*)stmt->data(), 
                    stmtCharSet,
                    PARSERHEAP());

                 de->setInitHbase(TRUE);
                 de->setCreateMDViews(TRUE);
                 de->setMinimal(TRUE);
                 de->setReturnStatus(TRUE);

		 $$ = de;                
               }

          | TOK_INITIALIZE TOK_TRAFODION ',' TOK_NO TOK_RETURN TOK_STATUS
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr
                   (NULL,
                    (char*)stmt->data(), 
                    stmtCharSet,
                    PARSERHEAP());

                 de->setInitHbase(TRUE);
                 de->setCreateMDViews(TRUE);

		 $$ = de;
	       }
          | TOK_INITIALIZE TOK_TRAFODION ',' TOK_MINIMAL ',' TOK_NO TOK_RETURN TOK_STATUS
               {
 		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr
                   (NULL,
                    (char*)stmt->data(), 
                    stmtCharSet,
                    PARSERHEAP());

                 de->setInitHbase(TRUE);
                 de->setCreateMDViews(TRUE);
                 de->setMinimal(TRUE);

		 $$ = de;                
               }


             | TOK_INITIALIZE TOK_TRAFODION ',' TOK_DROP
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr
                   (NULL,
                    (char*)stmt->data(), 
                    stmtCharSet,
                    PARSERHEAP());

                 de->setDropHbase(TRUE);
                 de->setDropMDViews(TRUE);

		 $$ = de;
	       }

           | TOK_INITIALIZE TOK_TRAFODION ',' TOK_CREATE TOK_METADATA TOK_VIEWS
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr
                   (NULL,
                    (char*)stmt->data(), 
                    stmtCharSet,
                    PARSERHEAP());

                 de->setCreateMDViews(TRUE);

		 $$ = de;
	       }

           | TOK_INITIALIZE TOK_TRAFODION ',' TOK_DROP TOK_METADATA TOK_VIEWS
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr
                   (NULL,
                    (char*)stmt->data(), 
                    stmtCharSet,
                    PARSERHEAP());

                 de->setDropMDViews(TRUE);

		 $$ = de;
	       }

             | TOK_INITIALIZE TOK_TRAFODION ',' TOK_UPGRADE
               {
		 ExeUtilMetadataUpgrade * mu =
		   new(PARSERHEAP()) ExeUtilMetadataUpgrade(PARSERHEAP());
		 $$ = mu;
	       }

             | TOK_INITIALIZE TOK_TRAFODION ',' TOK_CREATE TOK_SCHEMA TOK_OBJECTS
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr
                   (NULL,
                    (char*)stmt->data(), 
                    stmtCharSet,
                    PARSERHEAP());

                 de->setAddSchemaObjects(TRUE);

                 $$ = de;

               }

             | TOK_INITIALIZE TOK_TRAFODION ',' TOK_CREATE TOK_LIBRARY TOK_MANAGEMENT
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
					         , PARSERHEAP() 
	                                         );

		 DDLExpr * de = new(PARSERHEAP()) DDLExpr(NULL,
                                                          (char*)stmt->data(),
                                                          stmtCharSet,
                                                          PARSERHEAP());
                 de->setCreateLibmgr(TRUE);

                 $$ = de;

               }

             | TOK_INITIALIZE TOK_TRAFODION ',' TOK_DROP TOK_LIBRARY TOK_MANAGEMENT
               {
                 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
                 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
                                                 , PARSERHEAP()
                                                 );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr(NULL,
                                                          (char*)stmt->data(),
                                                          stmtCharSet,
                                                          PARSERHEAP());

                 de->setDropLibmgr(TRUE);

                 $$ = de;

               }

             | TOK_INITIALIZE TOK_TRAFODION ',' TOK_UPGRADE TOK_LIBRARY TOK_MANAGEMENT
               {
                 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
                 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
                                                 , PARSERHEAP()
                                                 );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr(NULL,
                                                          (char*)stmt->data(),
                                                          stmtCharSet,
                                                          PARSERHEAP());

                 de->setUpgradeLibmgr(TRUE);

                 $$ = de;

               }

            | TOK_INITIALIZE TOK_TRAFODION ',' TOK_CREATE TOK_REPOSITORY
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

		 DDLExpr * de = new(PARSERHEAP()) DDLExpr(NULL,
							  (char*)stmt->data(),
							  stmtCharSet,
                                                          PARSERHEAP());

                 de->setCreateRepos(TRUE);

                 $$ = de;
               }

           | TOK_INITIALIZE TOK_TRAFODION ',' TOK_DROP TOK_REPOSITORY
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

		 DDLExpr * de = new(PARSERHEAP()) DDLExpr(NULL,
							  (char*)stmt->data(),
							  stmtCharSet,
                                                          PARSERHEAP());

                 de->setDropRepos(TRUE);

                 $$ = de;
               }

           | TOK_INITIALIZE TOK_TRAFODION ',' TOK_UPGRADE TOK_REPOSITORY
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

		 DDLExpr * de = new(PARSERHEAP()) DDLExpr(NULL,
							  (char*)stmt->data(),
							  stmtCharSet,
                                                          PARSERHEAP());

                 de->setUpgradeRepos(TRUE);

                 $$ = de;
               }

             | TOK_INITIALIZE TOK_AUTHORIZATION
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

                 DDLExpr * de = new(PARSERHEAP()) DDLExpr
                   (NULL,
                    (char*)stmt->data(), 
                    stmtCharSet,
                    PARSERHEAP());

                 de->setInitAuth(TRUE);

                 $$ = de;

               }

             | TOK_INITIALIZE TOK_AUTHORIZATION ',' TOK_CLEANUP
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

		 DDLExpr * de = new(PARSERHEAP()) DDLExpr(NULL,
							  (char*)stmt->data(),
							  stmtCharSet,
                                                          PARSERHEAP());

                 de->setCleanupAuth(TRUE);
                 $$ = de;

               }

             | TOK_INITIALIZE TOK_AUTHORIZATION ',' TOK_DROP
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

		 DDLExpr * de = new(PARSERHEAP()) DDLExpr(NULL,
							  (char*)stmt->data(),
							  stmtCharSet,
                                                          PARSERHEAP());
                 de->setDropAuth(TRUE);

                 $$ = de;

               }

             | TOK_INITIALIZE TOK_TRAFODION ',' TOK_UPDATE TOK_SOFTWARE TOK_VERSION
               {
		 CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		 NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						   , PARSERHEAP() 
	                                       );

		 DDLExpr * de = new(PARSERHEAP()) DDLExpr(NULL,
							  (char*)stmt->data(),
							  stmtCharSet,
                                                          PARSERHEAP());
                 de->setUpdateVersion(TRUE);

		 $$ = de;
	       }

/* type relx */
exe_util_get_region_access_stats : TOK_GET TOK_REGION stats_or_statistics TOK_FOR TOK_TABLE table_name
               {
                 $$ = new (PARSERHEAP()) 
                   ExeUtilRegionStats(*$6, FALSE, FALSE, TRUE, FALSE, NULL, PARSERHEAP());
	       } 
             | TOK_GET TOK_REGION stats_or_statistics TOK_FOR TOK_INDEX table_name
               {
                 $6->setSpecialType(ExtendedQualName::INDEX_TABLE);

                 $$ = new (PARSERHEAP()) 
                   ExeUtilRegionStats(*$6, FALSE, TRUE, TRUE, FALSE, NULL, PARSERHEAP());
	       } 
             | TOK_GET TOK_REGION stats_or_statistics TOK_FOR rel_subquery 
               {
                 $$ = new (PARSERHEAP()) 
                   ExeUtilRegionStats(
                        CorrName("DUMMY"), FALSE, TRUE, TRUE, FALSE, $5, PARSERHEAP());
	       } 
             | TOK_GET TOK_REGION stats_or_statistics TOK_FOR TOK_TABLE table_name ',' TOK_SUMMARY
               {
                 $$ = new (PARSERHEAP()) 
                   ExeUtilRegionStats(*$6, TRUE, FALSE, TRUE, FALSE, NULL, PARSERHEAP());
	       } 
             | TOK_GET TOK_REGION stats_or_statistics TOK_FOR TOK_INDEX table_name ',' TOK_SUMMARY
               {
                 $6->setSpecialType(ExtendedQualName::INDEX_TABLE);

                 $$ = new (PARSERHEAP()) 
                   ExeUtilRegionStats(*$6, TRUE, TRUE, TRUE, FALSE, NULL, PARSERHEAP());
	       } 
             | TOK_GET TOK_REGION stats_or_statistics TOK_FOR rel_subquery ',' TOK_SUMMARY
               {
                 $$ = new (PARSERHEAP()) 
                   ExeUtilRegionStats(
                        CorrName("DUMMY"), TRUE, TRUE, TRUE, FALSE, $5, PARSERHEAP());
	       } 

stats_or_statistics : TOK_STATS
                      {
                        $$ = TRUE;
                      }
                    | TOK_STATISTICS
                      {
                        $$ = TRUE;
                      }
 
exe_util_get_lob_info : TOK_GET TOK_LOB stats_or_statistics TOK_FOR TOK_TABLE table_name
               {
                 $$ = new (PARSERHEAP()) 
                   ExeUtilLobInfo(*$6, FALSE,NULL,  PARSERHEAP());
	       } 

exe_util_hive_query : TOK_PROCESS TOK_HIVE TOK_STATEMENT QUOTED_STRING
                      {
                        $$ = new (PARSERHEAP()) 
                          ExeUtilHiveQuery(*$4, ExeUtilHiveQuery::FROM_STRING,
                                           PARSERHEAP());
                      } 
                    | TOK_PROCESS TOK_HIVE TOK_DDL QUOTED_STRING
                      {
                        SqlParser_CurrentParser->hiveDDLInfo_->
                          setValues(TRUE, StmtDDLonHiveObjects::PASSTHRU_DDL_, StmtDDLonHiveObjects::UNKNOWN_TYPE_);

                        SqlParser_CurrentParser->hiveDDLInfo_->userSpecifiedStmt_ = *$4;
                        SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_ = TRUE;

                        // error out. Caller will handle this stmt.
                        YYERROR;
                        $$ = NULL;
                    }
                    | TOK_PROCESS TOK_HIVE TOK_STATEMENT TOK_FROM TOK_FILE QUOTED_STRING
                      {
                        $$ = new (PARSERHEAP()) 
                          ExeUtilHiveQuery(*$6, ExeUtilHiveQuery::FROM_FILE,
                                           PARSERHEAP());
                      } 
/*
 * The purpose of dummy_token_lookahead is to force the lexer to look
 * one token ahead.  This may be necessary in cases where the parser
 * has reduced before reaching a trailing semicolon.  In those cases,
 * ParGetTextStartEndPosForDisplayExplain() will not work correctly so
 * we force an extra token to be evaluated.  The intention of
 * dummy_token_lookahead is not to affect the grammar, but just
 * modify how bison works so more of the statement will be parsed when
 * ParGetTextStartEndPosForDisplayExplain() is called.  TOK_EXIT is not
 * expected to be seen in this location.  It was chosen because the
 * user probably won't accidentally place it at the end of an explain
 * command.
 */
dummy_token_lookahead: empty | TOK_EXIT
               ;

exe_util_display_explain: explain_starting_tokens explain_identifier
               {
		 ExeUtilDisplayExplain * eue = 
		   new (PARSERHEAP ()) ExeUtilDisplayExplain
		   (ExeUtilExpr::DISPLAY_EXPLAIN_,
		    (char*)NULL, CharInfo::UnknownCharSet,
		    NULL,
		    (char*)$2->data(),
		    ($1 ? (char*)$1->data() : NULL),
		    NULL,
		    PARSERHEAP());
		 //$$ = finalize(eue);
		 
		 // xn will be started, if needed, when the exeutilstmt stmt
		 // is processed.
		 eue->xnNeeded() = FALSE;
		 
                 $$ = eue;
	       }

/* type stringval */
explain_identifier : IDENTIFIER
                       {
			 if ( ($1==NULL) || transformIdentifier(*$1)) 
			   YYERROR;
			 $$ = $1;
		       }
                     | DELIMITED_IDENTIFIER
                       {
			 if ( ($1==NULL) || transformIdentifier(*$1)) 
			   YYERROR;
			 $$ = $1;
		       }
                     | nonreserved_word_for_explain
                       {
                         NAString temp = *(unicodeToChar
                                          (ToTokvalPlusYYText(&$1)->yytext,
                                           ToTokvalPlusYYText(&$1)->yyleng,
                                           (CharInfo::CharSet) (
                                                                ComGetNameInterfaceCharSet()
                                                                ),
                                           PARSERHEAP()) );
                         temp.toUpper();
                         $$ = new (PARSERHEAP())NAString(temp);
                       }


exe_util_display_explain: explain_starting_tokens TOK_PROCEDURE '(' QUOTED_STRING ',' QUOTED_STRING ')'
               {
                 // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		 ExeUtilDisplayExplain * eue = 
		   new (PARSERHEAP ()) ExeUtilDisplayExplain
		   (ExeUtilExpr::DISPLAY_EXPLAIN_,
		    (char*)NULL, CharInfo::UnknownCharSet,
		    (char*)$4->data(),
		    (char*)$6->data(),
		    ($1 ? (char*)$1->data() : NULL),
		    NULL,
		    PARSERHEAP());
		 //$$ = finalize(eue);
		 
		 // xn will be started, if needed, when the exeutilstmt stmt
		 // is processed.
		 eue->xnNeeded() = FALSE;
		 
                 $$ = eue;
	       }
exe_util_display_explain: explain_starting_tokens TOK_FOR TOK_QID qid_identifier
              {
                char * tmpString =
                          new (PARSERHEAP()) char[$4->length() + 5];
                strcpy(tmpString, "QID=");
                strncpy(tmpString+4, $4->data(), $4->length());
                tmpString[$4->length()+4] = '\0';
                ExeUtilDisplayExplain * eue =
                   new (PARSERHEAP ()) ExeUtilDisplayExplain
                   (ExeUtilExpr::DISPLAY_EXPLAIN_,
                    (char*)NULL, CharInfo::UnknownCharSet,
                    NULL,
                    tmpString,
                    ($1 ? (char*)$1->data() : NULL),
                    NULL,
                    PARSERHEAP());
                 //$$ = finalize(eue);

                 // xn will be started, if needed, when the exeutilstmt stmt
                 // is processed.
                 eue->xnNeeded() = FALSE;

                 $$ = eue;
              }
exe_util_display_explain: explain_starting_tokens TOK_QID qid_identifier TOK_FROM TOK_RMS
              {
                char * tmpString = 
			  new (PARSERHEAP()) char[$3->length() + 5];
	        strcpy(tmpString, "QID=");
	        strncpy(tmpString+4, $3->data(), $3->length());
	        tmpString[$3->length()+4] = '\0';
                ExeUtilDisplayExplain * eue = 
		   new (PARSERHEAP ()) ExeUtilDisplayExplain
		   (ExeUtilExpr::DISPLAY_EXPLAIN_,
		    (char*)NULL, CharInfo::UnknownCharSet,
		    NULL,
		    tmpString,
		    ($1 ? (char*)$1->data() : NULL),
		    NULL,
		    PARSERHEAP());
		 //$$ = finalize(eue);
		 
		 // xn will be started, if needed, when the exeutilstmt stmt
		 // is processed.
		 eue->xnNeeded() = FALSE;
		 
                 $$ = eue;
              }
exe_util_display_explain: explain_starting_tokens TOK_QID qid_identifier TOK_FROM TOK_REPOSITORY
              {
                Int32 prefixLen = strlen("EXPLAIN_QID=");
                char * tmpString = 
			  new (PARSERHEAP()) char[$3->length() + prefixLen + 1];
	        strcpy(tmpString, "EXPLAIN_QID=");
	        strncpy(tmpString+prefixLen, $3->data(), $3->length());
	        tmpString[$3->length()+prefixLen] = '\0';
                ExeUtilDisplayExplain * eue = 
		   new (PARSERHEAP ()) ExeUtilDisplayExplain
		   (ExeUtilExpr::DISPLAY_EXPLAIN_,
		    (char*)NULL, CharInfo::UnknownCharSet,
		    NULL,
		    tmpString,
		    ($1 ? (char*)$1->data() : NULL),
		    NULL,
		    PARSERHEAP());

		 eue->xnNeeded() = FALSE;
		 
                 $$ = eue;
              }
exe_util_display_explain: explain_starting_tokens interactive_query_expression dummy_token_lookahead
                {
		  StringPos start;
		  StringPos end;
		  if (ParGetTextStartEndPosForDisplayExplain(
		       ParNameLocListPtr,start, end))
		    { yyerror(""); YYERROR; }
		  
		  char *inputStr = SQLTEXT();
		  CharInfo::CharSet inputStrCharSet = (CharInfo::CharSet)SQLTEXTCHARSET();

		  NAString * stmt = new(PARSERHEAP ()) NAString(PARSERHEAP ());
		  stmt->append(&inputStr[start], (end-start));
		  
		  NABoolean complexExplain = FALSE;
		  ExprNode * nodeToExplainComplex = NULL;

		  // Find out if a DDL or complex ExeUtil is being explained.
		  // A 'complex' statement requires multiple explains on each
		  // of the statements executed on behalf of the user query.
		  // For example: explain create table as select ...
		  // will require 2 explains to be issued internally. 
		  // One, to explain the
		  // 'create' and the other to explain the 'insert...select'.
		  // If it is, then create DisplayExplainComplex node. This node will
		  // cause multiple explains to be issued at runtime.
		  
		  
		  // Find out if this is a supported DDL explain.
		  if (($2->getOperatorType() == REL_DDL) ||
		      (($2->getOperatorType() == REL_ROOT) &&
		       ($2->castToRelExpr()->child(0)) && 
		       ($2->castToRelExpr()->child(0)->getOperatorType() == REL_DDL)))
		    {
		      DDLExpr * ddlExpr = NULL;
		      if ($2->getOperatorType() == REL_DDL)
			ddlExpr = (DDLExpr*)$2;
		      else
			ddlExpr = (DDLExpr*)($2->castToRelExpr()->child(0)->castToRelExpr());
		      if ((ddlExpr->showddlExplain()) &&
			  (NOT ddlExpr->showddlExplainInt()))
			{
			  complexExplain = TRUE;
			  nodeToExplainComplex = ddlExpr;
			}
		      else if (ddlExpr->getDDLNode() && ddlExpr->getDDLNode()->castToStmtDDLNode())
			{
			  complexExplain = ddlExpr->getDDLNode()->castToStmtDDLNode()->explainSupported();
			  if (complexExplain)
			    nodeToExplainComplex = ddlExpr;
			}
		    }
		  
		  // ExeUtil where explain is supported.
		  if (($2->getOperatorType() == REL_EXE_UTIL) ||
		      (($2->getOperatorType() == REL_ROOT) &&
		       ($2->castToRelExpr()->child(0)) && 
		       ($2->castToRelExpr()->child(0)->getOperatorType() == REL_EXE_UTIL)))
		    {
		      ExeUtilExpr * exeUtilExpr = NULL;
		      if ($2->getOperatorType() == REL_EXE_UTIL)
			exeUtilExpr = (ExeUtilExpr*)$2;
		      else
			exeUtilExpr = (ExeUtilExpr*)($2->castToRelExpr()->child(0)->castToRelExpr());

		      if (exeUtilExpr->explainSupported())
			{
			  complexExplain = TRUE;
			  nodeToExplainComplex = exeUtilExpr;
			}
		    }

		  ExeUtilDisplayExplain * eue = NULL;
		  if ((complexExplain) &&
		      (CmpCommon::getDefault(DDL_EXPLAIN) == DF_ON))
		    {
		      eue =
			new (PARSERHEAP ()) ExeUtilDisplayExplainComplex
			((char*)stmt->data(), inputStrCharSet,
			 ($1 ? (char*)$1->data() : NULL),
			 nodeToExplainComplex,
			 PARSERHEAP());
		    }
		  else
		    {
		      eue = 
			new (PARSERHEAP ()) ExeUtilDisplayExplain
			(ExeUtilExpr::DISPLAY_EXPLAIN_,
			 (char*)stmt->data(), inputStrCharSet,
			 NULL, NULL,
			 ($1 ? (char*)$1->data() : NULL),
			 $2,
			 PARSERHEAP());
		    }

		  // xn will be started, if needed, when the exeutilstmt stmt
		  // is processed.
		  eue->xnNeeded() = FALSE;

		  $$ = eue;
		  
		  delete stmt;
		}

/* type stringval */
optional_options : /* empty */
             { $$ = NULL; }
         | TOK_OPTION QUOTED_STRING
           /* DEFAULT_CHARSET has no effect on QUOTED_STRING in this context */
             { $$ = $2; }
         | TOK_OPTIONS QUOTED_STRING
           /* DEFAULT_CHARSET has no effect on QUOTED_STRING in this context */
             { $$ = $2; }

quoted_string_list : QUOTED_STRING
		 {
		  $$ = new (PARSERHEAP()) ConstStringList(PARSERHEAP ());
		  $$->insert($1);
		 }
		 | quoted_string_list ',' QUOTED_STRING
		 {
		  $1->insert($3);
		  $$ = $1;
		 }

col_fam_quoted_string_list : TOK_COLUMN TOK_FAMILY QUOTED_STRING
		 {
		  $$ = new (PARSERHEAP()) ConstStringList(PARSERHEAP ());
		  $$->insert($3);
		 }
		 | col_fam_quoted_string_list ',' TOK_COLUMN TOK_FAMILY QUOTED_STRING
		 {
		  $1->insert($5);
		  $$ = $1;
		 }

exe_util_maintain_object : TOK_MAINTAIN maintain_object_token table_name maintain_object_options
             {
	       ExeUtilMaintainObject::MaintainObjectType ot;
	       if ($2 == 1)
		 ot = ExeUtilMaintainObject::TABLE_;
	       else if ($2 == 2)
		 ot = ExeUtilMaintainObject::INDEX_;
	       else if ($2 == 3)
		 ot = ExeUtilMaintainObject::MV_;
	       else if ($2 == 4)
		 ot = ExeUtilMaintainObject::MVGROUP_;
	       else if ($2 == 5)
		 ot = ExeUtilMaintainObject::SCHEMA_;
	       else if ($2 == 6)
		 ot = ExeUtilMaintainObject::CATALOG_;
	       else  
		 ot = ExeUtilMaintainObject::MV_INDEX_;
	           
	       CorrName cn;
	       if (ot == ExeUtilMaintainObject::SCHEMA_)
		 {
		   if (NOT $3->getQualifiedNameObj().getCatalogName().isNull())
		     YYERROR;

		   cn = CorrName("DUMMY_OBJECT", PARSERHEAP(),
				 $3->getQualifiedNameObj().getObjectName(),
				 $3->getQualifiedNameObj().getSchemaName());
		 }
	       else if (ot == ExeUtilMaintainObject::CATALOG_)
		 {
		   if ((NOT $3->getQualifiedNameObj().getCatalogName().isNull()) ||
		       (NOT $3->getQualifiedNameObj().getSchemaName().isNull()))
		     YYERROR;

		   cn = CorrName("DUMMY_OBJECT", PARSERHEAP(),
				 "DUMMY_SCHEMA",
				 $3->getQualifiedNameObj().getObjectName());
		 }
	       else
		 cn = CorrName(*$3, PARSERHEAP());

	       ExeUtilMaintainObject * eue = 
		 new (PARSERHEAP ()) ExeUtilMaintainObject(
		      ot,
		      cn, //CorrName(*$3, PARSERHEAP()),
		      NULL,
		      $4,
		      PARSERHEAP());
	       
	       // xn will be started, if needed, when the exeutilstmt stmt
	       // is processed.
	       eue->xnNeeded() = FALSE;
	       
	       $$ = eue;
	       
	       delete $4;
	     }
            | TOK_MAINTAIN TOK_DATABASE maintain_object_options
             {
	       ExeUtilMaintainObject::MaintainObjectType ot;
	       ot = ExeUtilMaintainObject::DATABASE_;
	           
	       CorrName cn;
	       cn = CorrName("DUMMY_OBJECT", PARSERHEAP(),
			     "DUMMY_SCHEMA", "DUMMY_CATALOG");

	       ExeUtilMaintainObject * eue = 
		 new (PARSERHEAP ()) ExeUtilMaintainObject(
		      ot,
		      cn, 
		      NULL,
		      $3,
		      PARSERHEAP());
	       
	       // xn will be started, if needed, when the exeutilstmt stmt
	       // is processed.
	       eue->xnNeeded() = FALSE;
	       
	       $$ = eue;
	     }
            | TOK_MAINTAIN TOK_TABLES '(' pipeline_mv_name_list ')' maintain_object_options
             {
	       ExeUtilMaintainObject::MaintainObjectType ot;
	       ot = ExeUtilMaintainObject::TABLES_;
	           
	       CorrName cn;
	       cn = CorrName("DUMMY_OBJECT", PARSERHEAP(),
			     "DUMMY_SCHEMA", "DUMMY_CATALOG");

	       ExeUtilMaintainObject * eue = 
		 new (PARSERHEAP ()) ExeUtilMaintainObject(
		      ot,
		      cn,
		      $4,
		      $6,
		      PARSERHEAP());
	       
	       // xn will be started, if needed, when the exeutilstmt stmt
	       // is processed.
	       eue->xnNeeded() = FALSE;
	       
	       $$ = eue;
	     }
             | TOK_INITIALIZE_MAINTAIN
             {
	       NAList<ExeUtilMaintainObject::MaintainObjectOption*> * mtol =
		 new (PARSERHEAP ()) NAList<ExeUtilMaintainObject::MaintainObjectOption*>(PARSERHEAP ());

	       ExeUtilMaintainObject::MaintainObjectOption * mto = 
		 new (PARSERHEAP ()) 
		 ExeUtilMaintainObject::MaintainObjectOption
		 (ExeUtilMaintainObject::INITIALIZE_,
		  0, NULL);
			    
	       mtol->insert(mto);

	       ExeUtilMaintainObject * eue = 
		 new (PARSERHEAP ()) ExeUtilMaintainObject(
		      ExeUtilMaintainObject::NOOP_,    // no-op
		      CorrName("DUMMY", PARSERHEAP()), // no-op
		      NULL,
		      mtol,
		      PARSERHEAP());
	       
	       eue->xnNeeded() = FALSE;

	       $$ = eue;
	     }
             | TOK_REINITIALIZE_MAINTAIN
             {
	       NAList<ExeUtilMaintainObject::MaintainObjectOption*> * mtol =
		 new (PARSERHEAP ()) NAList<ExeUtilMaintainObject::MaintainObjectOption*>(PARSERHEAP ());

	       ExeUtilMaintainObject::MaintainObjectOption * mto = 
		 new (PARSERHEAP ()) 
		 ExeUtilMaintainObject::MaintainObjectOption
		 (ExeUtilMaintainObject::REINITIALIZE_,
		  0, NULL);
			    
	       mtol->insert(mto);

	       ExeUtilMaintainObject * eue = 
		 new (PARSERHEAP ()) ExeUtilMaintainObject(
		      ExeUtilMaintainObject::NOOP_,    // no-op
		      CorrName("DUMMY", PARSERHEAP()), // no-op
		      NULL,
		      mtol,
		      PARSERHEAP());
	       
	       eue->xnNeeded() = FALSE;

	       $$ = eue;
	     }
             | TOK_REINITIALIZE_MAINTAIN ',' TOK_DROP TOK_ONLY
             {
	       NAList<ExeUtilMaintainObject::MaintainObjectOption*> * mtol =
		 new (PARSERHEAP ()) NAList<ExeUtilMaintainObject::MaintainObjectOption*>(PARSERHEAP ());

	       ExeUtilMaintainObject::MaintainObjectOption * mto = 
		 new (PARSERHEAP ()) 
		 ExeUtilMaintainObject::MaintainObjectOption
		 (ExeUtilMaintainObject::DROP_,
		  0, NULL);
			    
	       mtol->insert(mto);

	       ExeUtilMaintainObject * eue = 
		 new (PARSERHEAP ()) ExeUtilMaintainObject(
		      ExeUtilMaintainObject::NOOP_,    // no-op
		      CorrName("DUMMY", PARSERHEAP()), // no-op
		      NULL,
		      mtol,
		      PARSERHEAP());
	       
	       eue->xnNeeded() = FALSE;

	       $$ = eue;
	     }
             | TOK_REINITIALIZE_MAINTAIN ',' TOK_CREATE TOK_VIEW
             {
	       NAList<ExeUtilMaintainObject::MaintainObjectOption*> * mtol =
		 new (PARSERHEAP ()) NAList<ExeUtilMaintainObject::MaintainObjectOption*>(PARSERHEAP ());

	       ExeUtilMaintainObject::MaintainObjectOption * mto = 
		 new (PARSERHEAP ()) 
		 ExeUtilMaintainObject::MaintainObjectOption
		 (ExeUtilMaintainObject::CREATE_VIEW_,
		  0, NULL);
			    
	       mtol->insert(mto);

	       ExeUtilMaintainObject * eue = 
		 new (PARSERHEAP ()) ExeUtilMaintainObject(
		      ExeUtilMaintainObject::NOOP_,    // no-op
		      CorrName("DUMMY", PARSERHEAP()), // no-op
		      NULL,
		      mtol,
		      PARSERHEAP());
	       
	       eue->xnNeeded() = FALSE;

	       $$ = eue;
	     }
             | TOK_REINITIALIZE_MAINTAIN ',' TOK_DROP TOK_VIEW
             {
	       NAList<ExeUtilMaintainObject::MaintainObjectOption*> * mtol =
		 new (PARSERHEAP ()) NAList<ExeUtilMaintainObject::MaintainObjectOption*>(PARSERHEAP ());

	       ExeUtilMaintainObject::MaintainObjectOption * mto = 
		 new (PARSERHEAP ()) 
		 ExeUtilMaintainObject::MaintainObjectOption
		 (ExeUtilMaintainObject::DROP_VIEW_,
		  0, NULL);
			    
	       mtol->insert(mto);

	       ExeUtilMaintainObject * eue = 
		 new (PARSERHEAP ()) ExeUtilMaintainObject(
		      ExeUtilMaintainObject::NOOP_,    // no-op
		      CorrName("DUMMY", PARSERHEAP()), // no-op
		      NULL,
		      mtol,
		      PARSERHEAP());
	       
	       eue->xnNeeded() = FALSE;

	       $$ = eue;
	     }
	     | TOK_MAINTAIN TOK_CLEAN maintain_object_options
             {
	       ExeUtilMaintainObject::MaintainObjectType ot;
	       
		   ot = ExeUtilMaintainObject::CLEAN_MAINTAIN_;
           
	       ExeUtilMaintainObject * eue = 
		     new (PARSERHEAP ()) ExeUtilMaintainObject(
		      ot,
		      CorrName("DUMMY", PARSERHEAP()), // information only
		      NULL,
		      $3,
		      PARSERHEAP());
	       
	       // xn will be started, if needed, when the exeutilstmt stmt
	       // is processed.
	       eue->xnNeeded() = FALSE;
	       
	       $$ = eue;
	       
	       delete $3;
	     }

maintain_object_token :  TOK_TABLE
                           {
			     $$ = 1;
			   }
                         | TOK_INDEX
                           {
			     $$ = 2;
			   }
                         | TOK_MV
                           {
			     $$ = 3;
			   }
                         | TOK_MVGROUP
                           {
			     $$ = 4;
			   }
                         | TOK_SCHEMA
                           {
			     $$ = 5;
			   }
                         | TOK_CATALOG
                           {
			     $$ = 6;
			   }

maintain_object_options : empty
             {
	       $$ = NULL;
	     }
        | ',' maintain_object_options_list
             {
	       $$ = $2;
	     }
;

maintain_object_options_list : maintain_object_option
             {
	       NAList<ExeUtilMaintainObject::MaintainObjectOption*> * mtol =
		 new (PARSERHEAP ()) NAList<ExeUtilMaintainObject::MaintainObjectOption*>(PARSERHEAP ());
	       mtol->insert($1);
	       $$ = mtol;
	     }
        | maintain_object_option ',' maintain_object_options_list
             {
	       $3->insert($1);
	       $$ = $3;
	     }
;

maintain_object_option : TOK_ALL 
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::ALL_,
			       0, NULL);
			    
			    $$ = mto;
			  }

                      | TOK_UPDATE TOK_STATISTICS optional_mt_options
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::UPD_STATS_TABLE_,
			       0, ($3 ? (char*)$3->data() : NULL));
			    
			    $$ = mto;
			  }

                      | TOK_REFRESH optional_mt_options
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::REFRESH_,
			       0, ($2 ? (char*)$2->data() : NULL));
			    
			    $$ = mto;
			  }

                      | TOK_REFRESH TOK_ALL TOK_MVS optional_mt_options
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::REFRESH_ALL_MVS_,
			       0, ($4 ? (char*)$4->data() : NULL));
			    
			    $$ = mto;
			  }

// Next maintain task options are not externalized.
                      | TOK_UPDATE TOK_MVLOG TOK_STATISTICS optional_mt_options
                          {
			    if (CmpCommon::getDefault(ALLOW_UNEXTERNALIZED_MAINTAIN_OPTIONS) == DF_OFF)
			      {
				YYERROR;
			      }

			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::UPD_STATS_MVLOG_,
			       0, ($4 ? (char*)$4->data() : NULL));
			    
			    $$ = mto;
			  }

                      | TOK_REFRESH TOK_MVGROUPS TOK_ONLY optional_mt_options
                          {
			    if (CmpCommon::getDefault(ALLOW_UNEXTERNALIZED_MAINTAIN_OPTIONS) == DF_OFF)
			      {
				YYERROR;
			      }

			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::REFRESH_MVGROUP_,
			       0, ($4 ? (char*)$4->data() : NULL));
			    
			    $$ = mto;
			  }

                      | TOK_REFRESH TOK_MVS TOK_ONLY optional_mt_options
                          {
			    if (CmpCommon::getDefault(ALLOW_UNEXTERNALIZED_MAINTAIN_OPTIONS) == DF_OFF)
			      {
				YYERROR;
			      }

			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::REFRESH_MVS_,
			       0, ($4 ? (char*)$4->data() : NULL));
			    
			    $$ = mto;
			  }
			  
	   	      | TOK_UPDATE TOK_STATISTICS TOK_ALL TOK_MVS optional_mt_options
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::UPD_STATS_ALL_MVS_,
			       0, ($5 ? (char*)$5->data() : NULL));
			    
			    $$ = mto;
			  }

// end unexternalized maintain task options

                       | TOK_GET TOK_DETAILS
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::GET_DETAILS_,
			       0, "sf");
			    
			    $$ = mto;
			  }

                      | TOK_GET TOK_DETAILS TOK_OPTIONS QUOTED_STRING
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::GET_DETAILS_,
			       0, (char*)$4->data());
			    
			    $$ = mto;
			  }

                      | TOK_GET TOK_STATUS
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::GET_STATUS_,
			       0, "sf");
			    
			    $$ = mto;
			  }

                      | TOK_GET TOK_STATUS TOK_OPTIONS QUOTED_STRING
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::GET_STATUS_,
			       0, (char*)$4->data());
			    
			    $$ = mto;
			  }
                      | TOK_GET TOK_LABEL TOK_STATISTICS 
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::GET_LABEL_STATS_,
			       0, NULL);
			    
			    $$ = mto;
			  }
			  
                      | TOK_GET TOK_LABEL TOK_STATISTICS TOK_ALL TOK_INDEXES
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::GET_LABELSTATS_INC_INDEXES_,
			       0, NULL);
			    
			    $$ = mto;
			  }

                      | TOK_GET TOK_LABEL TOK_STATISTICS TOK_ALL TOK_INTERNAL
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::GET_LABELSTATS_INC_INTERNAL_,
			       0, NULL);
			    
			    $$ = mto;
			  }
                      | TOK_GET TOK_LABEL TOK_STATISTICS TOK_ALL TOK_RELATED
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::GET_LABELSTATS_INC_RELATED_,
			       0, NULL);
			    
			    $$ = mto;
			  }
                     
                      | TOK_RUN run_from run_to run_for
                          {
			    char * fromStr = (char*)($2 ? $2->data() : NULL);
			    char * toStr = (char*)($3 ? $3->data() : NULL);

			    UInt32 fractionPrec1;
			    UInt32 fractionPrec2;
			    DatetimeValue * from = NULL;
			    DatetimeValue * to = NULL;
			    Int64 * fromJTS = NULL;
			    Int64 * toJTS = NULL;
			    Int64 forVal = $4;

			    if (fromStr)
			      {
				from = 
				  new (PARSERHEAP()) DatetimeValue(fromStr, REC_DATE_YEAR, REC_DATE_SECOND, fractionPrec1, FALSE);
			      }

			    if (toStr && (forVal > 0))
			      YYERROR;

			    if (toStr)
			      {
				to = 
				  new (PARSERHEAP()) DatetimeValue(toStr, REC_DATE_YEAR, REC_DATE_SECOND, fractionPrec2, FALSE);
			      }

			    if ((from && (! from->isValid())) ||
				(to && (! to->isValid())))
			      YYERROR;

			    if (from)
			      {
				fromJTS = (Int64 *)(new (PARSERHEAP()) char[sizeof(Int64)]);
				*fromJTS = DatetimeType::julianTimestampValue
				  ((char*)from->getValue(), from->getValueLen(), fractionPrec1);
				if (*fromJTS <= 0)
				  YYERROR;
			      }

			    toJTS = (Int64 *)(new (PARSERHEAP()) char [sizeof(Int64)]);
			    if (to)
			      {
				*toJTS = DatetimeType::julianTimestampValue
				  ((char*)to->getValue(), to->getValueLen(), fractionPrec2);

				if (*toJTS <= 0)
				  YYERROR;
			      }
				
			    if (forVal > 0)
			      {
				if (! from)
				  {
				    *toJTS = CONVERTTIMESTAMP(JULIANTIMESTAMP(0,0,0,-1),0,-1,0);
				  }
				*toJTS = *toJTS + forVal * 1000000;
			      }

			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::RUN_,
			       (fromJTS ? sizeof(Int64) : 0),
			       (fromJTS ? (char*)fromJTS : NULL),
			       (toJTS ? sizeof(Int64) : 0),
			       (toJTS ? (char*)toJTS : NULL));
			    
			    $$ = mto;
			  }

                      | TOK_IF TOK_NEEDED
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::IF_NEEDED_,
			       0, NULL, 0, NULL);

			    $$ = mto;
			  }

                      | TOK_MAX NUMERIC_LITERAL_EXACT_NO_SCALE TOK_TABLES
                        {
			  ExeUtilMaintainObject::MaintainObjectOption * mto = 
			    new (PARSERHEAP ()) 
			    ExeUtilMaintainObject::MaintainObjectOption
			    (ExeUtilMaintainObject::MAX_TABLES_,
			     atol($2->data()), NULL);
			  
			  $$ = mto;
			}

                      | TOK_ENABLE
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::ENABLE_,
			       0, NULL);
			    
			    $$ = mto;
			  }

                      | TOK_DISABLE
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::DISABLE_,
			       0, NULL);
			    
			    $$ = mto;
			  }

                      | TOK_RESET
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::RESET_,
			       0, NULL);
			    
			    $$ = mto;
			  }

                      | TOK_CONTINUE TOK_ON TOK_ERROR
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::CONTINUE_ON_ERROR_,
			       1, NULL);
			    
			    $$ = mto;
			  }
                      | TOK_STOP TOK_ON TOK_ERROR
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::CONTINUE_ON_ERROR_,
			       0, NULL);
			    
			    $$ = mto;
			  }
                      | TOK_RETURN TOK_SUMMARY
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::RETURN_SUMMARY_,
			       0, NULL);
			    
			    $$ = mto;
			  }
                      | TOK_RETURN TOK_SUMMARY TOK_OPTIONS QUOTED_STRING
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::RETURN_SUMMARY_,
			       0, (char*)$4->data());
			    
			    $$ = mto;
			  }
                      | TOK_RETURN TOK_DETAIL TOK_OUTPUT
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::RETURN_DETAIL_OUTPUT_,
			       0, NULL);
			    
			    $$ = mto;
			  }
                      | TOK_DISPLAY
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::DISPLAY_,
			       0, NULL);
			    
			    $$ = mto;
			  }
                      | TOK_DISPLAY TOK_DETAIL
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::DISPLAY_DETAIL_,
			       0, NULL);
			    
			    $$ = mto;
			  }
                      | TOK_NO TOK_OUTPUT
                          {
			    ExeUtilMaintainObject::MaintainObjectOption * mto = 
			      new (PARSERHEAP ()) 
			      ExeUtilMaintainObject::MaintainObjectOption
			      (ExeUtilMaintainObject::NO_OUTPUT_,
			       0, NULL);
			    
			    $$ = mto;
			  }

/* type stringval */
run_from    :  TOK_FROM TOK_TIMESTAMP QUOTED_STRING 
                      {
			$$ = $3;
		      }
                   | /* empty */
                     {
		       $$ = NULL;
		     }

/* type stringval */
run_to      :  TOK_TO TOK_TIMESTAMP QUOTED_STRING 
                      {
			$$ = $3;
		      }
                   | /* empty */
                     {
		       $$ = NULL;
		     }

/* type longint */
run_for :  TOK_FOR_MAXRUNTIME maxruntime_interval
                      {
			$$ = $2;
		      }
                | /* empty */
                     {
		       $$ = 0;
		     }

/* stringval */
optional_mt_options :   QUOTED_STRING
                     {
                       // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		       $$ = $1;
		     }
                   | /* empty */
                     {
		       $$ = NULL;
		     }

/* type corrName */
truncate_table_name : TOK_PURGEDATA optional_if_exists_clause table_name 
                        {
                          $$ = new(PARSERHEAP()) 
                            PtrPlaceHolder($3, 
                                           ($2 ? new(PARSERHEAP()) NAString() 
                                            : NULL));
                        }
                        | TOK_TRUNCATE optional_if_exists_clause 
                        {
                          SqlParser_CurrentParser->hiveDDLInfo_->
                            setValues(TRUE, StmtDDLonHiveObjects::TRUNCATE_, StmtDDLonHiveObjects::TABLE_, $2);
                        }
                        ddl_qualified_name
                        {
                          CorrName * cn = new(PARSERHEAP()) CorrName(*$4, PARSERHEAP());
                          $$ = new(PARSERHEAP()) 
                            PtrPlaceHolder(cn, 
                                           ($2 ? new(PARSERHEAP()) NAString() 
                                            : NULL));
                        }
                        | TOK_TRUNCATE TOK_TABLE optional_if_exists_clause 
                        {
                          SqlParser_CurrentParser->hiveDDLInfo_->
                            setValues(TRUE, StmtDDLonHiveObjects::TRUNCATE_, StmtDDLonHiveObjects::TABLE_, $3);
                        }
                        ddl_qualified_name
                        {
                          CorrName * cn = new(PARSERHEAP()) CorrName(*$5, PARSERHEAP());
                          $$ = new(PARSERHEAP()) 
                            PtrPlaceHolder(cn, 
                                           ($3 ? new(PARSERHEAP()) NAString() 
                                            : NULL));
                        }

truncate_table :  truncate_table_name 
		     {
                       PtrPlaceHolder *pph = $1;

		       CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
		       NAString * stmt = getSqlStmtStr ( stmtCharSet
		                                       , PARSERHEAP()
		                                       );
		       if ( stmt == NULL )
		       {
		         *SqlParser_Diags <<  DgSqlCode(-3406);
		         YYERROR;
		       }
                       CorrName *cn = (CorrName*) pph->ptr1_;
                       NABoolean ifExists = (pph->ptr2_ != NULL);

                       DDLExpr * ddlExpr = new(PARSERHEAP()) 
                         DDLExpr(NULL,
                                 (char*)stmt->data(),
                                 CharInfo::UnknownCharSet,
                                 CmpCommon::statementHeap());
                       ddlExpr->setPurgedata(TRUE);
                       ddlExpr->setPurgedataTableName(*cn);
                       ddlExpr->setPurgedataIfExists(ifExists);
                       
                       $$ = ddlExpr;
                     }

exe_util_aqr: TOK_GET TOK_ALL TOK_AQR TOK_ENTRIES
               {
		 ExeUtilAQR * eua = 
		   new (PARSERHEAP ()) ExeUtilAQR(
			ExeUtilAQR::GET_,
			NULL,
			PARSERHEAP());
		 
		 $$ = eua;
	       }

exe_util_aqr: TOK_SET TOK_AQR TOK_CLEAR TOK_ALL TOK_ENTRIES
               {
		 ExeUtilAQR * eua = 
		   new (PARSERHEAP ()) ExeUtilAQR(
			ExeUtilAQR::CLEAR_,
			NULL,
			PARSERHEAP());
		 
		 $$ = eua;
	       }

exe_util_aqr: TOK_SET TOK_AQR TOK_RESET TOK_ALL TOK_ENTRIES
               {
		 ExeUtilAQR * eua = 
		   new (PARSERHEAP ()) ExeUtilAQR(
			ExeUtilAQR::RESET_,
			NULL,
			PARSERHEAP());
		 
		 $$ = eua;
	       }

exe_util_aqr: TOK_SET TOK_AQR TOK_ENTRY aqr_task aqr_options_list
               {
		 ExeUtilAQR::AQRTask task;
		 if ($4 == 1)
		   task = ExeUtilAQR::ADD_;
		 else if ($4 == 2)
		   task = ExeUtilAQR::DELETE_;
		 else if ($4 == 3)
		   task = ExeUtilAQR::UPDATE_;
		 else
		   task = ExeUtilAQR::NONE_;

		 ExeUtilAQR * eua = 
		   new (PARSERHEAP ()) ExeUtilAQR(
			task,
			$5,
			PARSERHEAP());
		 
		 $$ = eua;
		 
		 delete $5;
	       }

aqr_task :   TOK_ADD { $$ = 1; }
           | TOK_DELETE { $$ = 2; }
           | TOK_UPDATE { $$ = 3; }

aqr_options_list : aqr_option
                      {
			NAList<ExeUtilAQR::AQROption*> * o =
			  new (PARSERHEAP ()) NAList<ExeUtilAQR::AQROption*>(PARSERHEAP ());
			o->insert($1);
			$$ = o;
		      }
                  | aqr_option ',' aqr_options_list
                      {
			$3->insert($1);
			$$ = $3;
		      }
;

aqr_option : TOK_SQLCODE '=' NUMERIC_LITERAL_EXACT_NO_SCALE
                      {
		 Lng32 longIntVal = atol(*$3);
			if (longIntVal < 0)
			  {
			    // Error: Expected an unsigned integer
			    *SqlParser_Diags << DgSqlCode(-3017) 
					     << DgString0(*$3);
			  }
			
			ExeUtilAQR::AQROption * o = 
			  new (PARSERHEAP ()) ExeUtilAQR::AQROption
			  (ExeUtilAQR::SQLCODE_,
			   longIntVal, NULL);
			
			$$ = o;
		      }
             | TOK_NSK_CODE '=' NUMERIC_LITERAL_EXACT_NO_SCALE
                      {
		 Lng32 longIntVal = atol(*$3);
			if (longIntVal < 0)
			  {
			    // Error: Expected an unsigned integer
			    *SqlParser_Diags << DgSqlCode(-3017) 
					     << DgString0(*$3);
			  }
			
			ExeUtilAQR::AQROption * o = 
			  new (PARSERHEAP ()) ExeUtilAQR::AQROption
			  (ExeUtilAQR::NSKCODE_,
			   longIntVal, NULL);
			
			$$ = o;
		      }
             | TOK_NUMBER TOK_OF TOK_RETRIES '=' NUMERIC_LITERAL_EXACT_NO_SCALE
                      {
		 Lng32 longIntVal = atol(*$5);
			if (longIntVal < 0)
			  {
			    // Error: Expected an unsigned integer
			    *SqlParser_Diags << DgSqlCode(-3017) 
					     << DgString0(*$5);
			  }
			
			ExeUtilAQR::AQROption * o = 
			  new (PARSERHEAP ()) ExeUtilAQR::AQROption
			  (ExeUtilAQR::RETRIES_,
			   longIntVal, NULL);
			
			$$ = o;
		      }
             | TOK_DELAY '=' NUMERIC_LITERAL_EXACT_NO_SCALE
                      {
		 Lng32 longIntVal = atol(*$3);
			if (longIntVal < 0)
			  {
			    // Error: Expected an unsigned integer
			    *SqlParser_Diags << DgSqlCode(-3017) 
					     << DgString0(*$3);
			  }
			
			ExeUtilAQR::AQROption * o = 
			  new (PARSERHEAP ()) ExeUtilAQR::AQROption
			  (ExeUtilAQR::DELAY_,
			   longIntVal, NULL);
			
			$$ = o;
		      }
             | TOK_TYPE '=' NUMERIC_LITERAL_EXACT_NO_SCALE
                      {
		 Lng32 longIntVal = atol(*$3);
			if (longIntVal < 0)
			  {
			    // Error: Expected an unsigned integer
			    *SqlParser_Diags << DgSqlCode(-3017) 
					     << DgString0(*$3);
			  }
			
			ExeUtilAQR::AQROption * o = 
			  new (PARSERHEAP ()) ExeUtilAQR::AQROption
			  (ExeUtilAQR::TYPE_,
			   longIntVal, NULL);
			
			$$ = o;
		      }

/* type relx */
//HBASE LOAD 
load_statement : TOK_LOAD TOK_TRANSFORM load_sample_option TOK_INTO table_name query_expression optional_limit_spec
                  {
                    //disabled by default in 0.8.0 release 
                    if (CmpCommon::getDefault(COMP_BOOL_226) != DF_ON)
                      YYERROR; 

                    //limit clause
                    if ($7)
                    {
                      RelExpr *query = $6;
          
                      if (query->getFirstNRows() >= 0)
                        {
                          // cannot specify LIMIT and FIRST N clauses together.
                          YYERROR;
                        }
                      else
                        {
                          NABoolean negate;
                          if ($7->castToConstValue(negate))
                            {
                              ConstValue * limit = (ConstValue*)$7;
                              Lng32 scale = 0;
                              query->setFirstNRows(limit->getExactNumericValue(scale));
                            }
                        }
                    }

                    $$ = new (PARSERHEAP())
                          HBaseBulkLoadPrep(CorrName(*$5, PARSERHEAP()),
                                            NULL,
                                            REL_HBASE_BULK_LOAD,
                                            $6,
                                            $3//,
                                            //NULL
                                            );  
                    }
                   | TOK_LOAD optional_hbbload_options TOK_INTO table_name query_expression optional_limit_spec
                    {
                      CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
                      NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
                                                      , PARSERHEAP() // in  - NAMemory * 
                                                      );

                      // If we can not get a variable-width multi-byte or single-byte string here, report error 
                      if ( stmt == NULL )
                      {
                        *SqlParser_Diags <<  DgSqlCode(-3406);
                        YYERROR;
                      }
                      UInt32 pos = 
                          stmt->index(" into ", 0, NAString::ignoreCase);
                       
                      RelRoot *top = finalize($5);
                      //limit clause
                      if ($6)
                      {
                        if (top->getFirstNRows() >= 0)
                          {
                            // cannot specify LIMIT and FIRST N clauses together.
                            YYERROR;
                          }
                        else
                          {
                            NABoolean negate;
                            if ($6->castToConstValue(negate))
                              {
                                ConstValue * limit = (ConstValue*)$6;
                                Lng32 scale = 0;
                                top->setFirstNRows(limit->getExactNumericValue(scale));
                                top->setFirstNRowsParam(NULL);
                              }
                          }
                      }

                      ExeUtilHBaseBulkLoad * eubl = new (PARSERHEAP()) 
                                        ExeUtilHBaseBulkLoad(CorrName(*$4, PARSERHEAP()),
                                        NULL,
                                        NULL,
                                        stmtCharSet,
                                        top,
                                        PARSERHEAP());
                      if (eubl->setOptions($2, SqlParser_Diags))
                             YYERROR; 

                      NAString stmt1;
                      if (eubl->getUpsertUsingLoad())
                      {
                        stmt1 = "UPSERT USING LOAD ";
                        stmt1.append((char*)&(stmt->data()[pos])); 
                        eubl->setStmtText((char*)stmt1.data(), stmtCharSet);
                      }
                      else
                      {
                        stmt1 = "LOAD TRANSFORM ";
                        if (eubl->getUpdateStats())
                          stmt1.append("WITH SAMPLE ");
                        stmt1.append((char*)&(stmt->data()[pos])); 
                        eubl->setStmtText((char*)stmt1.data(), stmtCharSet);
                      }
                      $$ = finalize(eubl);
                    
                    }
                                            
                    //delete $3;
                    //delete $4;
                  //}

                    |   TOK_LOAD  TOK_COMPLETE TOK_FOR TOK_TABLE table_name
                      {
                        //disabled by default in 0.8.0 release 
                        if (CmpCommon::getDefault(COMP_BOOL_226) != DF_ON)
                          YYERROR; 
                          
                          ExeUtilHBaseBulkLoadTask::TaskType tt = ExeUtilHBaseBulkLoadTask::COMPLETE_BULK_LOAD_;
                          if (CmpCommon::getDefault(TRAF_LOAD_PREP_KEEP_HFILES) == DF_ON)
                            tt = ExeUtilHBaseBulkLoadTask::COMPLETE_BULK_LOAD_N_KEEP_HFILES_;
                            
                          ExeUtilHBaseBulkLoadTask * hblt = new (PARSERHEAP())   
                                              ExeUtilHBaseBulkLoadTask(CorrName(*$5, PARSERHEAP()),
                                              NULL,
                                              NULL,
                                              CharInfo::UnknownCharSet,
                                              tt,
                                              PARSERHEAP());
                          $$ = finalize(hblt);         
                          
                      }
                    |   TOK_LOAD  TOK_CLEANUP TOK_FOR TOK_TABLE table_name
                      {
                        //disabled by default in 0.8.0 release 
                        if (CmpCommon::getDefault(COMP_BOOL_226) != DF_ON)
                          YYERROR; 
                          
                          ExeUtilHBaseBulkLoadTask::TaskType tt = ExeUtilHBaseBulkLoadTask::PRE_LOAD_CLEANUP_;
                            
                          ExeUtilHBaseBulkLoadTask * hblt = new (PARSERHEAP())   
                                              ExeUtilHBaseBulkLoadTask(CorrName(*$5, PARSERHEAP()),
                                              NULL,
                                              NULL,
                                              CharInfo::UnknownCharSet,
                                              tt,
                                              PARSERHEAP());
                          $$ = finalize(hblt);         
                          
                      }   

load_sample_option : TOK_WITH TOK_SAMPLE
                            {
                              if (! Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
                              {
                                yyerror("");
                                YYERROR;     /*internal syntax only!*/
                              }
                              $$ = TRUE;
                            }
                            | empty
                            {
                              $$ = FALSE;
                            }

optional_hbbload_options : TOK_WITH hbbload_option_list
                            {
                               $$ = $2;
                            }
                            | empty /* empty */
                            {
                                $$ = NULL;
                            }
                            
hbbload_option_list : hbbload_option
                      {
                        NAList<ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*> * hbol =
			  new (PARSERHEAP ()) NAList<ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*>(PARSERHEAP ());
                        hbol->insert($1);
                        $$ = hbol;
                      }
                      | hbbload_option ',' hbbload_option_list
                      {
                          $3->insert($1);
                          $$ = $3;
                      }
                      | hbbload_option  hbbload_option_list
                      {
                          $2->insert($1);
                          $$ = $2;
                      }

hbbload_option :  hbb_no_recovery_option
                | hbb_truncate_option
                | hbb_update_stats_option
                | hbb_continue_on_error
                | hbb_stop_after_n_error_rows
                | hbb_log_error_rows
                | hbb_no_duplicate_check
                | hbb_no_output
                | hbb_rebuild_indexes
                | hbb_constraints
                | hbb_index_table_only
                | hbb_upsert_using_load
                
              
hbb_no_recovery_option : TOK_NO TOK_RECOVERY
                    {
                    //NO ROLLBACK
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::NO_ROLLBACK_,
                                          0,
                                          NULL);
                      $$ = op;
                    }
hbb_truncate_option : TOK_TRUNCATE TOK_TABLE
                    {
                      //TRUNCATE
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::TRUNCATE_TABLE_,
                                          0,
                                          NULL);
                      $$ = op;
                    }
hbb_update_stats_option : TOK_UPDATE TOK_STATISTICS
                    {
                      //UPDATE STATISTICS
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::UPDATE_STATS_,
                                          0,
                                          NULL);
                      $$ = op;
                    }
hbb_index_table_only :   TOK_INDEX TOK_TABLE TOK_ONLY
                    {
                      if (!Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                        YYERROR;
                      //the target table is index table in this case
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::INDEX_TABLE_ONLY_,
                                          0,
                                          NULL);
                      $$ = op;
                    }                   
hbb_no_duplicate_check   : TOK_NO TOK_DUPLICATE TOK_CHECK
                    { //NO DUPLICATES
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::NO_DUPLICATE_CHECK_, 
                                          0, 
                                          NULL);
                      $$ = op;
                    }
hbb_continue_on_error : TOK_CONTINUE TOK_ON TOK_ERROR
                    { //LOG_ERRORS
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::CONTINUE_ON_ERROR_, 0, NULL);
                      $$ = op;
                    }
hbb_log_error_rows : TOK_LOG TOK_ERROR TOK_ROWS
                    { //LOG_ERRORS
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::LOG_ERROR_ROWS_, 0, NULL);
                      $$ = op;
                    }                    
                    | TOK_LOG TOK_ERROR TOK_ROWS  TOK_TO QUOTED_STRING
                    { //LOG_ERRORS
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::LOG_ERROR_ROWS_, 0, (char*)$5->data());
                      $$ = op;
                    }                    
hbb_stop_after_n_error_rows: TOK_STOP TOK_AFTER unsigned_integer TOK_ERROR TOK_ROWS                
                    { //LOG_ERRORS
                    
                    // need to give error if unsigned_integer ==0
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::STOP_AFTER_N_ERROR_ROWS_, $3, NULL);
                      $$ = op;
                    }      
hbb_no_output :  TOK_NO TOK_OUTPUT
                    { //INDEXES
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::NO_OUTPUT_, 
                                           0, 
                                           NULL);
                      $$ = op;
                    }                     
hbb_rebuild_indexes   : TOK_REBUILD TOK_INDEXES
                    { //INDEXES
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::REBUILD_INDEXES_,
                                           0, 
                                           NULL);
                      $$ = op;
                    } 
hbb_constraints   : TOK_CONSTRAINTS
                    {//CONSTRAINTS
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::CONSTRAINTS_,
                                           0,
                                           NULL);
                      $$ = op;
                    }    

hbb_upsert_using_load : TOK_UPSERT TOK_USING TOK_LOAD 
                    {//CONSTRAINTS
                      ExeUtilHBaseBulkLoad::HBaseBulkLoadOption*op = 
                              new (PARSERHEAP ()) ExeUtilHBaseBulkLoad::HBaseBulkLoadOption
                                          (ExeUtilHBaseBulkLoad::UPSERT_USING_LOAD_,
                                           0,
                                           NULL);
                      $$ = op;
                    }    

//url_string : QUOTED_STRING

 unload_statement : TOK_UNLOAD optional_hbb_unload_options TOK_INTO std_char_string_literal query_expression 
                {
                  CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
                  NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
                                                  , PARSERHEAP() // in  - NAMemory * 
                                                  );
                  // If we can not get a variable-width multi-byte or single-byte string here, report error 
                  if ( stmt == NULL )
                  {
                    *SqlParser_Diags <<  DgSqlCode(-3406);
                    YYERROR;
                  }
               
                  RelRoot *top = finalize($5);

                  ExeUtilHBaseBulkUnLoad * eubl = new (PARSERHEAP()) 
                                    ExeUtilHBaseBulkUnLoad(CorrName("DUMMY", PARSERHEAP()),
                                    NULL,
                                    (char*)stmt->data(),
                                    $4,
                                    stmtCharSet,
                                    top,
                                    PARSERHEAP());
                  if (eubl->setOptions($2, SqlParser_Diags))
                    YYERROR; 
                  $$ = finalize(eubl);    
                
                }
                | TOK_UNLOAD TOK_EXTRACT optional_hbb_unload_options TOK_TO std_char_string_literal  query_expression 
                {
                  if (CmpCommon::getDefault(COMP_BOOL_226) != DF_ON)
                    YYERROR;
                  FastExtract* fastExt = 
                    new (PARSERHEAP()) FastExtract($6, $5, 
                                      FastExtract::FILE, 
                                      PARSERHEAP());
                  if (fastExt->setOptions($3, SqlParser_Diags))
                  YYERROR;
                  $$ = fastExt;
                  delete $5;
                  delete $3;
                }

optional_hbb_unload_options : TOK_WITH hbb_unload_option_list
                {
                    $$ = $2;
                }
                | empty
                {
                    $$ = NULL;
                }
                            
hbb_unload_option_list : hbb_unload_option
                {
                   NAList<UnloadOption*> * hbol =
		     new (PARSERHEAP ()) NAList<UnloadOption*>(PARSERHEAP ());
                   hbol->insert($1);
                   $$ = hbol;
                }
                | hbb_unload_option  hbb_unload_option_list
                {
                   $2->insert($1);
                   $$ = $2;
                }

hbb_unload_option:   hbb_unload_empty_target
                | hbb_unload_compress
                | hbb_unload_one_file
                | hbb_unload_no_output
                | hbb_unload_delimiter
                | hbb_unload_record_separator
                | hbb_unload_null_string
                | hbb_unload_header
                | hbb_unload_append
                | hbb_unload_snapshot


 hbb_unload_empty_target: TOK_PURGEDATA TOK_FROM TOK_TARGET
                {
                //purge target folder
                  UnloadOption *op = 
                        new (PARSERHEAP ()) UnloadOption(UnloadOption::EMPTY_TARGET_,0,NULL);
                  $$ = op;
                }
                | TOK_TRUNCATE TOK_FROM TOK_TARGET
                {
                //purge target folder
                  UnloadOption *op = 
                        new (PARSERHEAP ()) UnloadOption(UnloadOption::EMPTY_TARGET_,0,NULL);
                  $$ = op;
                }
                
 hbb_unload_compress: TOK_COMPRESSION TOK_GZIP
                {
                  //COMPRESSION
                  UnloadOption *op = 
                        new (PARSERHEAP ()) UnloadOption(UnloadOption::COMPRESS_,1,NULL);
                  $$ = op;
                }

 hbb_unload_one_file: TOK_MERGE TOK_FILE std_char_string_literal hbb_unload_optional_overwrite
                {
                //merge files
                  UnloadOption *op = 
                      new (PARSERHEAP ()) UnloadOption(UnloadOption::ONE_FILE_, $4 ? 1 : 0 ,(char *)$3->data());
                  $$ = op;
                }
 hbb_unload_no_output: TOK_NO TOK_OUTPUT
                {
                  //NO OUTPUT
                   UnloadOption *op = 
                        new (PARSERHEAP ()) UnloadOption(UnloadOption::NO_OUTPUT_,0,NULL);
                  $$ = op;
                }
                                  
 hbb_unload_delimiter : TOK_DELIMITER std_char_string_literal
                {
                   UnloadOption *op = 
                          new (PARSERHEAP ()) UnloadOption(UnloadOption::DELIMITER_,0,(char *)$2->data());
                   $$ = op;
                }
                | TOK_DELIMITER unsigned_smallint
                {
                //only 1-255 are supported
                  if ($2 > 0 && $2 < 256 )
                  {
                    char * charVal = new (PARSERHEAP()) char[2];
                    charVal[0] = (char)$2;
                    charVal[1] = 0;
                    UnloadOption *op = 
                              new (PARSERHEAP ()) UnloadOption(UnloadOption::DELIMITER_,1,charVal);
                    $$ = op;
                  }
                  else
                    YYERROR;
                }   
 hbb_unload_record_separator: TOK_RECORD_SEPARATOR  std_char_string_literal
                {
                  UnloadOption *op = 
                                  new (PARSERHEAP ()) UnloadOption(UnloadOption::RECORD_SEP_,0,(char *)$2->data());
                  $$ = op;
                }
                | TOK_RECORD_SEPARATOR unsigned_smallint
                {
                  //only 1-255 are supported
                  if ($2 > 0 && $2 < 256)
                  {
                    char * charVal = new (PARSERHEAP()) char[2];
                    charVal[0] = (char)$2;
                    charVal[1] = 0;
                    UnloadOption *op = 
                                  new (PARSERHEAP ()) UnloadOption(UnloadOption::RECORD_SEP_,1,charVal);
                    $$ = op;
                  }
                  else
                  YYERROR;
                }     
hbb_unload_null_string : TOK_NULL_STRING std_char_string_literal
                {
                  UnloadOption *op = 
                                  new (PARSERHEAP ()) UnloadOption(UnloadOption::NULL_STRING_,0,(char *)$2->data());
                  $$ = op;
                }      

hbb_unload_header: TOK_NO TOK_HEADER
                {
                  UnloadOption *op = 
                                  new (PARSERHEAP ()) UnloadOption(UnloadOption::HEADER_,0,NULL);
                  $$ = op;
                }
        
hbb_unload_append: TOK_APPEND
                {
                   UnloadOption*op = 
                                  new (PARSERHEAP ()) UnloadOption(UnloadOption::APPEND_,1,NULL);
                   $$ = op;
                } 
 hbb_unload_snapshot: hbb_unload_existing_snap TOK_SNAPSHOT  TOK_HAVING TOK_SUFFIX QUOTED_STRING 
                {
                   ExeUtilHBaseBulkUnLoad::ScanType scanType = ($1 == FALSE) ? ExeUtilHBaseBulkUnLoad::SNAPSHOT_SCAN_CREATE_ : 
                                                                                    ExeUtilHBaseBulkUnLoad::SNAPSHOT_SCAN_EXISTING_;
                   char * suffix = NULL;
                   if ($5 != NULL) 
                      suffix = (char *)$5->data();
                   UnloadOption*op = 
                                  new (PARSERHEAP ()) UnloadOption(UnloadOption::USE_SNAPSHOT_SCAN_,(int)scanType,suffix);
                   $$ = op;                
                }
hbb_unload_existing_snap: TOK_NEW 
                          { 
                           $$ = FALSE;
                          }
                        | TOK_EXISTING
                          {
                            $$ = TRUE;
                          }

hbb_unload_optional_overwrite : TOK_OVERWRITE
         {
            $$ = TRUE;
         }
         | empty
         {
             $$ = FALSE;
         }        

// Raj P - 7/2000
// CALL <proc-name>	
standalone_call_statement: TOK_CALL {beginCallStmtParsing();} routine_invocation
				{
				  $$ = finalize($3);
				}
			   | '{' TOK_CALL {beginCallStmtParsing();} routine_invocation '}'
				{
				  $$ = finalize($4);
			        }

// Raj P - 7/2000
// Type relx
// We only support CallSP for now, but it will be extended to support
// other types of UDR's in the future
routine_invocation: routine_name '(' routine_arg_list ')'
                                {
	CallSP	      *expr = NULL;
	QualifiedName *qualifiedProcName;

	if ( in3GL_ > 0 && InsideTriggerDefinition == FALSE )
	{
	  *SqlParser_Diags <<  DgSqlCode(-4306);
	  $$ = NULL;
	  return NULL;	  
	}
	
	// Support for C/COBOL preprocessor
        if (CmpCommon::context()->GetMode() == STMT_STATIC)
	  TheHostVarRoles->setAllAssignedInputTo (HV_IS_INPUT_OUTPUT);
	
	switch ( $1->numParts ())
	{
	    case 1:
	    case 2:
	    case 3:
                qualifiedProcName = qualifiedNameFromStrings($1);
		break;
	  default:
	  {
	    // Error
	    NAString errName;
	    errName.append($1->extract (0)->data ());
	    for (Int32 i=1; i < $1->numParts (); i++)
	    {
	      errName.append (".");
	      errName.append ($1->extract (i)->data ());
	    }
	    
            *SqlParser_Diags << DgSqlCode(-3011) << DgString0 (errName);
	    $$ = NULL;
            return NULL;
	  }
          break;
		
	}

	expr = new (PARSERHEAP ())CallSP ( *qualifiedProcName,
					   PARSERHEAP () );
	if ( $3 )
	{
	    // expr->setChild ( 0, paramTuple );
	  expr->setProcAllParamsTree ( $3 );
	}
	
        $$ = (RelExpr *) expr;
                                }

// Raj P - 7/2000
routine_name: qualified_name
              {
                 // helps with computing trigger text
                 //
                 ParInsertNameLoc($1->getPosition(), $1->getNameLength());
  	         $$ = $1;
              }

// Raj P - 7/2000
routine_arg_list: /* empty */
                {
		    $$ = NULL;
                }
                | value_expression_list
                {
		    $$ = $1;
                }

/* type relx */
query_expression : non_join_query_expression
/***             | joined_table			***/

/* type relx */
query_term	 : non_join_query_term
/***		 | joined_table			***/

query_primary	 : non_join_query_primary
/***		 | joined_table			***/

/* type relx */
non_join_query_expression : non_join_query_term

         | query_expression TOK_UNION query_term
         {
          Union *dUnion = new (PARSERHEAP()) Union($1, $3);
          dUnion->setDistinctUnion();	

          $$ = new (PARSERHEAP())
                RelRoot(new (PARSERHEAP())
                    GroupByAgg(new (PARSERHEAP()) RelRoot(dUnion),
                              REL_GROUPBY, new (PARSERHEAP()) 
							  ColReference(new (PARSERHEAP())
                              ColRefName(TRUE, PARSERHEAP()))));

          // Make sure that all variables associated with an assignment are in
          // the top root
          if ($1->getOperatorType() == REL_ROOT) {
            RelRoot *root1 = (RelRoot *) $1;
            if (root1->assignmentStTree()) {
              ((RelRoot *)$$)->assignmentStTree() = root1->removeAssignmentStTree();
            }
          }
           
          if ($3->getOperatorType() == REL_ROOT) {
            RelRoot *root3 = (RelRoot *) $3;
            if (root3->assignmentStTree()) {
              ((RelRoot *)$$)->assignmentStTree() = root3->removeAssignmentStTree();
            }
          }
        }
	| query_expression TOK_UNION TOK_ALL query_term
        {
	  Union *unionNode = new (PARSERHEAP()) Union($1, $4);
          $$ = new (PARSERHEAP()) RelRoot(unionNode);


          // Make sure that all variables associated with an assignment are in
          // the top root
          if ($1->getOperatorType() == REL_ROOT) {
            RelRoot *root1 = (RelRoot *) $1;
            if (root1->assignmentStTree()) {
              ((RelRoot *)$$)->assignmentStTree() = root1->removeAssignmentStTree();
            }
          }
           
          if ($4->getOperatorType() == REL_ROOT) {
            RelRoot *root4 = (RelRoot *) $4;
            if (root4->assignmentStTree()) {
              ((RelRoot *)$$)->assignmentStTree() = root4->removeAssignmentStTree();
            }
          }
        }

	      | query_expression TOK_EXCEPT query_term
		{
  	            $$ = new (PARSERHEAP())
  	                     RelRoot(new (PARSERHEAP())
  				  GroupByAgg(
  					     new (PARSERHEAP())
  					     Except($1,$3),
  					     REL_GROUPBY,
  					     new (PARSERHEAP())
  					     ColReference(new (PARSERHEAP())
  					       ColRefName(TRUE, PARSERHEAP())
  					     )));
		}
  
	      | query_expression TOK_EXCEPT TOK_ALL query_term
		{
		  // EXCEPT is not yet supported
		  *SqlParser_Diags << DgSqlCode(-3022) << DgString0("EXCEPT ALL");
		  YYERROR;
		}

/* type relx */
non_join_query_term : non_join_query_primary
  		    | query_term TOK_INTERSECT distinct_sugar query_primary
  		      {
  			$$ = new (PARSERHEAP())
  			  RelRoot(new (PARSERHEAP())
  				  GroupByAgg(
  					     new (PARSERHEAP())
  					     Intersect($1,$4),
  					     REL_GROUPBY,
  					     new (PARSERHEAP())
  					     ColReference(new (PARSERHEAP())
  					       ColRefName(TRUE, PARSERHEAP())
  					     )));
  		      }
  		    | query_term TOK_INTERSECT TOK_ALL query_primary
  				      {
					*SqlParser_Diags << DgSqlCode(-3022) << DgString0("INTERSECT ALL");
					YYERROR;
  				      }

distinct_sugar: TOK_DISTINCT
| 
/* type relx */
non_join_query_primary : simple_table
	      | rel_subquery				// ## this line ...
//	      | '(' non_join_query_expression ')'	// ## should be replaced
//				{			// ## with these lines,
//				  $$ = $2;		// ## per Ansi 7.10,
//				}			// ## but it's too hard!

/* type relx */
simple_table  : query_specification
              | table_value_constructor
              | TOK_TABLE table_name
		{
                     // same as "SELECT * FROM qualified_name"
		     $$ = new (PARSERHEAP())
		       RelRoot(new (PARSERHEAP())
			       Scan(*$2),
			       REL_ROOT,
			       new (PARSERHEAP())
			       ColReference(new (PARSERHEAP())
					    ColRefName(TRUE, PARSERHEAP())));
                     delete $2;
		}


/* type relx */
rel_subquery : '(' query_expression order_by_clause optional_limit_spec ')'
				{
                                  if (InIfCondition) {
                                     *SqlParser_Diags << DgSqlCode(-3176);
		                     yyerror("");
		                     YYERROR;
                                  }

                                  RelExpr *temp = $2;

                                  if ( temp->getOperatorType() != REL_ROOT )
                                    temp = new (PARSERHEAP()) RelRoot($2);

                                  if (CmpCommon::getDefault(ALLOW_ORDER_BY_IN_SUBQUERIES) == DF_OFF) 
                                    {
                                      if ($3)
                                        {
                                          yyerror("");	// emits syntax error 15001
                                          YYERROR;
                                        }
                                    }
                                  else
                                    {
                                      if ($3)
                                        ((RelRoot *)temp)->addOrderByTree($3);
                                    }

                                  $$ = temp;
                  if ($4)
                    {
                      RelExpr *query = $2;
                      if (query->getFirstNRows() >= 0)
                        {
                          YYERROR;
                        }
                      else
                        {
                          NABoolean negate;
                          if ($4->castToConstValue(negate))
                            {
                              ConstValue *limit = (ConstValue *)$4;
                              Lng32 scale = 0;
                              query->setFirstNRows(limit->getExactNumericValue(scale));
                            }
                        }
                    }
				}
/* type item */
predicate : directed_comparison_predicate
        | key_comparison_predicate
        | overlaps_predicate 
	  | between_predicate predicate_selectivity_hint 
          {
              if ($2)
              { 
                ((ItemExpr *)$1)->setSelectivityFactor($2);
                ((ItemExpr *)$1)->setSelectivitySetUsingHint();
              }
          }
	  | quantified_predicate predicate_selectivity_hint
          {
              if ($2)
              { 
                ((ItemExpr *)$1)->setSelectivityFactor($2);
                ((ItemExpr *)$1)->setSelectivitySetUsingHint();
              }
          }
	  | in_predicate predicate_selectivity_hint
          {
              if ($2)
              { 
                ((ItemExpr *)$1)->setSelectivityFactor($2);
                ((ItemExpr *)$1)->setSelectivitySetUsingHint();
              }
          }
	  | like_predicate predicate_selectivity_hint
          {
              if ($2)
              { 
                ((ItemExpr *)$1)->setSelectivityFactor($2);
                ((ItemExpr *)$1)->setSelectivitySetUsingHint();
              }
          }
	  | exists_predicate
	  | null_predicate predicate_selectivity_hint
          {
              if ($2)
              { 
                ((ItemExpr *)$1)->setSelectivityFactor($2);
                ((ItemExpr *)$1)->setSelectivitySetUsingHint();
              }
          }
	  | internal_bool_placeholder

predicate_selectivity_hint : empty { $$ = NULL; }
        | TOK_BEGIN_HINT TOK_SELECTIVITY selectivity_number TOK_END_HINT
          {
            $$ = $3;
          }

selectivity_number : number
         {
              // If selectivity is not between 0 and 1, we issue a warning 
              //  and disregard the user specified selectivity.
              if($1 < 0 || $1 > 1)
              {
                NAString wrnMsg = "Only values between 0 and 1 are acceptable for predicate selectivity hints. Specified selectivity hint has been ignored.";
                *SqlParser_Diags << DgSqlCode(3066) << DgString0(wrnMsg);
                $$ = NULL;
              }
              else
                $$ = $1;
         }
	  //
	  // Predicates still to be implemented:
	  //   UNIQUE, MATCH, OVERLAPS
	  //
	  // The former two will need to set their result type's canBeSQLUnknown
	  // to FALSE, as they (like IS [NOT] NULL and EXISTS) can only return
	  // Sql True or False but not Unknown.
	  //
	  // The latter two will need to satisfy Genesis 10-971028-7413
	  // (see checkForNULLchildren in BindItemExpr.cpp).


/* type item*/
null_predicate :
       value_expression_list TOK_IS TOK_NULL
                      { $$ = new (PARSERHEAP()) UnLogic(ITM_IS_NULL, $1); }
     | value_expression_list TOK_IS TOK_NOT TOK_NULL
                      { $$ = new (PARSERHEAP()) UnLogic(ITM_IS_NOT_NULL, $1); }

/* type operator_type */
comparison_operator :	'='		  { $$ = ITM_EQUAL; }
		    |	'<'		  { $$ = ITM_LESS; }
		    |	'>'		  { $$ = ITM_GREATER; }
		    |	TOK_NOT_EQUAL	  { $$ = ITM_NOT_EQUAL; }
		    |	TOK_LESS_EQUAL	  { $$ = ITM_LESS_EQ; }
		    |	TOK_GREATER_EQUAL { $$ = ITM_GREATER_EQ; }

/* type tokval */
between_operator    : TOK_BETWEEN
		    | TOK_NOT_BETWEEN

/* type tokval */
quantifier	    : TOK_ALL
	   	    | TOK_ANY
	   	    | TOK_SOME	{ $$ = TOK_ANY; }

//
// The fix for Genesis 10-971104-1441:
// each side of a comparison op must use the same syntax, i.e.
//	v1=v2		v1=(v2)		((v1))=v2	etc... [Ansi]
//	(j,k)=(m,n)	(j,k)=((m,n))	(((j,k)))=(m,n)	etc... [Ansi]
//	a,b=c,d    BUT NOT  a,b=(c,d)  or  (a,b)=c,d	[Tandem extension!]
//
// The latter cases still cause ambiguity parsing
//	select * from t1 join t2 on t1.a,t1.b = t2.aa,t2.bb, t3;
// but that is due to our non-Ansi extension; what we've fixed here is that
//	select * from t1 join t2 on t1.a = t2.aa, t3;
// will be parsed correctly per Ansi, as will
//	select * from t1 join t2 on (t1.a,t1.b) = (t2.aa,t2.bb), t3; -- Ansi
//	select * from t1 join t2 on (t1.a,t1.b = t2.aa,t2.bb), t3;   -- Tdm ext.
//
// The upshot in this set of rules is not to allow any bare
// <value_expression_list> on a RHS; instead, to clone each comparison operator
// rule with each of the three <value_expression, ve_list_comma, ve_list_paren>.
// Vive la balance!
//
// Do note that <row_subquery> is a <value_expression> of unknown degree, so we
// must allow it also wherever <ve_list_comma> or <ve_list_paren> may appear.
// 
// UDF added 1/8/10: Before UDF, only the first eight rules existed
// for this predicate.  Note that row_subquery is part of the
// value_expression rule, and the rule value_expression_list is made
// up of value_expression, value_expression_list_comma, and
// value_expression_list_paren.  Because of this you would think that
// only one rule would be needed:
//
//    value_expression_list comparison operator value_expression_list
//
// The beginning of this comment explains why this cannot be.  Since
// the first eight rules exist, and we cannot add rules like
//
//    value_expression comparison_operator value_expression_list_comma
//
// we must add explicit rules for multi-valued functions.  These are
// (co = comparison_operator):
//
//     value_expression_list_comma co '(' function ')'
//     value_expression_list_paren co '(' function ')'
//     '(' function ')' co value_expression_list_comma
//     '(' function ')' co value_expression_list_paren
//
// Unfortunately, we must also add the following as well:
//     value_expression co '(' function ')'
//     '(' function ')' co value_expression
//     row_subquery     co '(' function ')'

/* type pBiRelat */
comparison_predicate :  
       value_expression comparison_operator value_expression
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $3); }
     | row_subquery comparison_operator value_expression
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $3); }
     | value_expression_list_comma comparison_operator value_expression_list_comma
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $3); }
     | value_expression_list_comma comparison_operator row_subquery
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $3); }
     | row_subquery comparison_operator value_expression_list_comma
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $3); }
     | value_expression_list_paren comparison_operator value_expression_list_paren
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $3); }
     | value_expression_list_paren comparison_operator row_subquery
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $3); }
     | row_subquery comparison_operator value_expression_list_paren
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $3); }

     // BEGIN rules added for UDF
/* COMMENTED OUT FOR R2.5. CAUSES GRAMMAR CONFLICTS.
     | value_expression            comparison_operator '(' value_function ')'
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $4); }
     | row_subquery                comparison_operator '(' value_function ')'
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $4); }
     | value_expression_list_comma comparison_operator '(' value_function ')'
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $4); }
     | value_expression_list_paren comparison_operator '(' value_function ')'
		      { $$ = new (PARSERHEAP()) BiRelat($2, $1, $4); }
     | '(' value_function ')' comparison_operator value_expression
		      { $$ = new (PARSERHEAP()) BiRelat($4, $2, $5); }
     | '(' value_function ')'comparison_operator value_expression_list_comma
		      { $$ = new (PARSERHEAP()) BiRelat($4, $2, $5); }
     | '(' value_function ')' comparison_operator value_expression_list_paren
		      { $$ = new (PARSERHEAP()) BiRelat($4, $2, $5); }
*/
     // END rules added for UDF

/* type boolean */
scan_key_hint : empty { $$ = FALSE; }
    | TOK_BEGIN_HINT TOK_PREFER_FOR_SCAN_KEY TOK_END_HINT 
      { $$ = TRUE;}

/* type item */
key_comparison_predicate : TOK_KEY_RANGE_COMPARE '(' partitioning_key_type comparison_operator '(' value_expression_list ')' pkey_access_path ')'
{
  $$ = new (PARSERHEAP()) KeyRangeCompare(*$8,  
					  $4,  
					  $3, 
					  $6
					  );
			  delete $8;
}
  | TOK_KEY_RANGE_COMPARE '(' TOK_CLUSTERING TOK_KEY comparison_operator '(' value_expression_list ')' ckey_access_path ')'
{
  $$ = new (PARSERHEAP()) KeyRangeCompare(*$9,  
					  $5,  
					  NULL, // to indicate that there is no column_list
					  $7
					  );
			  delete $9;
}
/* item */
partitioning_key_type : TOK_PARTITIONING TOK_KEY '(' value_expression_list ')'
{
  $$ = $4;
}

/* corrName */
pkey_access_path : TOK_ON TOK_TABLE actual_table_name
{
  $$ = $3;
}
| TOK_ON TOK_INDEX_TABLE actual_table_name
{

  $3->setSpecialType(ExtendedQualName::INDEX_TABLE);
  $$ = $3;

}

/* corrName */
ckey_access_path : pkey_access_path
{
  $$ = $1;
}
| TOK_ON special_regular_table_name
{
  $$ = $2;
}
| TOK_ON special_index_table_name
{
  $$ = $2;
}
|
{
  $$ = new (PARSERHEAP()) CorrName(); // empty Corrname 
}

/* type item */
directed_comparison_predicate : 
      comparison_predicate scan_key_hint
      { 
	$$ = $1;
	if ($1->isARangePredicate() && $2 == TRUE) $1->setPreferForSubsetScanKey();
      }
      |
      comparison_predicate TOK_BEGIN_HINT TOK_SELECTIVITY selectivity_number TOK_END_HINT
      { 
        $$ = $1;

        if($4)
        { 
          ((ItemExpr *)$1)->setSelectivityFactor($4);
          ((ItemExpr *)$1)->setSelectivitySetUsingHint();
        }
      } 
      |
      comparison_predicate TOK_DIRECTEDBY direction_vector
      {
	if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
        {
	  $1->setDirectionVector($3);
	  $$ = $1;
	}
	else
	{ 
	  yyerror(""); YYERROR; /*internal syntax only!*/
	}
      }

/* type pIntegerList */
direction_vector : '(' direction_vector_comma_list ')'
      {
	$$ = $2;
      }

/* type pIntegerList */
direction_vector_comma_list: 
      direction_literal 
      {
	$$ = new (PARSERHEAP()) IntegerList();
	$$->insert($1);
      }
      |
      direction_vector_comma_list ',' direction_literal
      {
	$$ = $1;
	$$->insert($3);
      }

/* type tokval */
direction_literal : ddl_ordering_spec
      {
	if ($1 == COM_ASCENDING_ORDER)
	  $$ = 1;
	else
	  $$ = -1;
      }

/* type item */
//
// Although there is no "balancing" necessary here as was needed in
// the comparison_predicate rules for the Genesis 10-971104-1441 fix,
// since here we use the same operators ('=' '<' etc) as comparison_predicate,
// we are forced to clone subrules here just like there.
//
quantified_predicate :
	  value_expression comparison_operator quantifier rel_subquery
				      { $$ = makeQuantifiedComp($1,$2,$3,$4); }
	| row_subquery comparison_operator quantifier rel_subquery
				      { $$ = makeQuantifiedComp($1,$2,$3,$4); }
	| value_expression_list_comma comparison_operator quantifier rel_subquery
				      { $$ = makeQuantifiedComp($1,$2,$3,$4); }
	| value_expression_list_paren comparison_operator quantifier rel_subquery
				      { $$ = makeQuantifiedComp($1,$2,$3,$4); }

/* type item */
in_predicate :
	  value_expression_list TOK_IN rel_subquery
			  {
			    $$ = makeQuantifiedComp($1, ITM_EQUAL, TOK_ANY, $3);
			  }
	| value_expression_list TOK_NOT_IN rel_subquery
			  {
			    $$ = new (PARSERHEAP())
			      UnLogic(ITM_NOT,
				makeQuantifiedComp($1, ITM_EQUAL, TOK_ANY, $3));
			  }
	| value_expression_list TOK_IN '(' value_expression_list_lr ')'
              {
		$$ = processINlist($1, $4);
	      }
	| value_expression_list TOK_NOT_IN '(' value_expression_list_lr ')'
              {
		$$ = new (PARSERHEAP())
		  UnLogic(ITM_NOT, 
			  processINlist($1, $4));
              }
	| value_expression_list TOK_IN literal
	      {
		CheckModeSpecial1();
		
		// special1 mode extension
		$$ = processINlist($1, $3);
	      }

/* type item */
// See preceding remarks about Genesis 10-971104-1441 problem and solution.
between_predicate : 
       value_expression between_operator 
       value_expression TOK_AND
       value_expression
		      { $$ = makeBetween($1, $3, $5, $2); }
     | row_subquery between_operator 
       value_expression TOK_AND
       value_expression
		      { $$ = makeBetween($1, $3, $5, $2); }
     | row_subquery between_operator 
       row_subquery TOK_AND
       row_subquery
		      { $$ = makeBetween($1, $3, $5, $2); }

     | value_expression_list_comma between_operator 
       value_expression_list_comma TOK_AND
       value_expression_list_comma
		      { $$ = makeBetween($1, $3, $5, $2); }
     | value_expression_list_comma between_operator 
       value_expression_list_comma TOK_AND
       row_subquery
		      { $$ = makeBetween($1, $3, $5, $2); }
     | value_expression_list_comma between_operator 
       row_subquery TOK_AND
       value_expression_list_comma
		      { $$ = makeBetween($1, $3, $5, $2); }
     | value_expression_list_comma between_operator 
       row_subquery TOK_AND
       row_subquery
		      { $$ = makeBetween($1, $3, $5, $2); }
     | row_subquery between_operator 
       value_expression_list_comma TOK_AND
       value_expression_list_comma
		      { $$ = makeBetween($1, $3, $5, $2); }
     | row_subquery between_operator 
       value_expression_list_comma TOK_AND
       row_subquery
		      { $$ = makeBetween($1, $3, $5, $2); }
     | row_subquery between_operator 
       row_subquery TOK_AND
       value_expression_list_comma
		      { $$ = makeBetween($1, $3, $5, $2); }

     | value_expression_list_paren between_operator 
       value_expression_list_paren TOK_AND
       value_expression_list_paren
		      { $$ = makeBetween($1, $3, $5, $2); }
     | value_expression_list_paren between_operator 
       value_expression_list_paren TOK_AND
       row_subquery
		      { $$ = makeBetween($1, $3, $5, $2); }
     | value_expression_list_paren between_operator 
       row_subquery TOK_AND
       value_expression_list_paren
		      { $$ = makeBetween($1, $3, $5, $2); }
     | value_expression_list_paren between_operator 
       row_subquery TOK_AND
       row_subquery
		      { $$ = makeBetween($1, $3, $5, $2); }
     | row_subquery between_operator 
       value_expression_list_paren TOK_AND
       value_expression_list_paren
		      { $$ = makeBetween($1, $3, $5, $2); }
     | row_subquery between_operator 
       value_expression_list_paren TOK_AND
       row_subquery
		      { $$ = makeBetween($1, $3, $5, $2); }
     | row_subquery between_operator 
       row_subquery TOK_AND
       value_expression_list_paren
		      { $$ = makeBetween($1, $3, $5, $2); }

/* type tokval */
not_like   : TOK_LIKE
	   | TOK_NOT TOK_LIKE

/* type item */
like_predicate : value_expression not_like value_expression
				{
				  $$ = new (PARSERHEAP()) Like($1, $3);
				  if ($2 == TOK_NOT)
				    $$ = new (PARSERHEAP()) UnLogic(ITM_NOT,$$);
				}
	      | value_expression not_like value_expression TOK_ESCAPE value_expression
				{
				  $$ = new (PARSERHEAP()) Like($1, $3, $5);
				  if ($2 == TOK_NOT)
				    $$ = new (PARSERHEAP()) UnLogic(ITM_NOT,$$);
				}
	      | value_expression not_like value_expression '{' TOK_ESCAPE value_expression '}'
				{
				  $$ = new (PARSERHEAP()) Like($1, $3, $6);
				  if ($2 == TOK_NOT)
				    $$ = new (PARSERHEAP()) UnLogic(ITM_NOT,$$);
				}
              | value_expression TOK_REGEXP value_expression
                                {
                                  //TODO
                                  $$ = new (PARSERHEAP()) Regexp($1,$3);
				  if ($2 == TOK_NOT)
				    $$ = new (PARSERHEAP()) UnLogic(ITM_NOT,$$);
                                } 

/* type item */
exists_predicate : TOK_EXISTS rel_subquery
				{
				  $$ = new (PARSERHEAP()) Exists($2);
				}

/* type item */
overlaps_predicate : value_expression_list_paren TOK_OVERLAPS value_expression_list_paren
        {
          ItemExprList  exprList1($1, PARSERHEAP());
          ItemExprList  exprList2($3, PARSERHEAP());
          //Syntax Rules:
          //  1) The degrees of <row value predicand 1> and <row value predicand 2> shall both be 2.
          if ((exprList1.entries() != 2)
              || (exprList1.entries() != exprList2.entries()))
          {
             *SqlParser_Diags << DgSqlCode(-4077)
                              << DgString0("OVERLAPS");
             YYERROR; //CHANGE TO YYABORT
          }

          $$ = new (PARSERHEAP()) Overlaps((*$1)[0], (*$1)[1], (*$3)[0], (*$3)[1]);
        }

/* type item */
search_condition : boolean_term
				;
              | search_condition TOK_OR boolean_term
				{
				  $$ = new (PARSERHEAP())
				    BiLogic(ITM_OR,
					    $1,
					    $3);
				}

/* type item */
boolean_term : boolean_factor
				;
              | boolean_term TOK_AND boolean_factor
				{
				  $$ = new (PARSERHEAP())
				    BiLogic(ITM_AND,
					    $1,
					    $3);
				}

/* type item */
boolean_factor : TOK_NOT boolean_test
				{
				  $$ = new (PARSERHEAP())
				    UnLogic(ITM_NOT,
					    $2);
				}
              | boolean_test
				;

/* type item */
boolean_test : boolean_primary TOK_IS TOK_NOT truth_value
				{
				  OperatorTypeEnum op = NO_OPERATOR_TYPE;
				  switch ($4)
				    {
				    case TOK_TRUE:
				      op = ITM_IS_TRUE;
				      break;
				    case TOK_FALSE:
				      op = ITM_IS_FALSE;
				      break;
				    case TOK_UNKNOWN:
				      op = ITM_IS_UNKNOWN;
				      break;
				    }
				    $$ = new (PARSERHEAP())
				      UnLogic(ITM_NOT,
					      new (PARSERHEAP())
					      UnLogic(op,
						      $1));
				}
              | boolean_primary TOK_IS truth_value
				{
				  OperatorTypeEnum op = NO_OPERATOR_TYPE;
				  switch ($3)
				    {
				    case TOK_TRUE:
				      op = ITM_IS_TRUE;
				      break;
				    case TOK_FALSE:
				      op = ITM_IS_FALSE;
				      break;
				    case TOK_UNKNOWN:
				      op = ITM_IS_UNKNOWN;
				      break;
				    }
				    $$ = new (PARSERHEAP())
				      UnLogic(op,
					      $1);
				}
              | boolean_primary

/* type tokval */
truth_value   : TOK_TRUE
              | TOK_FALSE
              | TOK_UNKNOWN

/* type item */
boolean_primary : predicate
              | '(' search_condition ')'
				{
				  $$ = $2;
				}
              | '(' search_condition ')' TOK_BEGIN_HINT TOK_SELECTIVITY selectivity_number TOK_END_HINT
              { 
                 $$ = $2;

                 if($6)
                 { 
                   ((ItemExpr *)$2)->setSelectivityFactor($6);
                   ((ItemExpr *)$2)->setSelectivitySetUsingHint();
                 }
              } 

/* type relx */
Rest_Of_insert_statement : no_check_log no_rollback TOK_INTO table_name query_expression order_by_clause access_type optional_limit_spec
        {
          if (!finalizeAccessOptions($5, $7)) YYERROR;

          //limit clause
          if ($8)
          {
	     RelExpr *query = $5;

            if (query->getFirstNRows() >= 0)
              {
                // cannot specify LIMIT and FIRST N clauses together.
                YYERROR;
              }
            else
              {
                NABoolean negate;
                if ($8->castToConstValue(negate))
                  {
                    ConstValue * limit = (ConstValue*)$8;
                    Lng32 scale = 0;
                    query->setFirstNRows(limit->getExactNumericValue(scale));
                  }
              }
          }
		  
          // insert into all columns
          $$ = new (PARSERHEAP())
            Insert(CorrName(*$4, PARSERHEAP()),
               NULL,
               REL_UNARY_INSERT,
               $5,
               NULL,
               $6);
               

	   if (($1 == 1) || ($1 == 3))
	     {
	       ((Insert*)$$)->setNoLogOperation();	
	     }
	   
	   if (($1 == 2) || ($1 == 3))
	     {
	       ((Insert*)$$)->setNoCheck(TRUE);
	     }

	   if(TRUE == $2)
	     {
	       ((Insert*)$$)->setNoRollbackOperation();
	     }
	   delete $4;
	   
	   
        }
        |
     no_check_log no_rollback TOK_INTO TOK_TABLE table_name query_expression order_by_clause access_type optional_limit_spec
        {
          if (!finalizeAccessOptions($6, $8)) YYERROR;

          //limit clause
          if ($9)
          {
	     RelExpr *query = $6;

            if (query->getFirstNRows() >= 0)
              {
                // cannot specify LIMIT and FIRST N clauses together.
                YYERROR;
              }
            else
              {
                NABoolean negate;
                if ($9->castToConstValue(negate))
                  {
                    ConstValue * limit = (ConstValue*)$9;
                    Lng32 scale = 0;
                    query->setFirstNRows(limit->getExactNumericValue(scale));
                  }
              }
          }
  
          // insert into all columns
          $$ = new (PARSERHEAP())
            Insert(CorrName(*$5, PARSERHEAP()),
               NULL,
               REL_UNARY_INSERT,
               $6,
               NULL,
               $7);

	   if (($1 == 1) || ($1 == 3))
	     {
	       ((Insert*)$$)->setNoLogOperation();	
	     }
	   
	   if (($1 == 2) || ($1 == 3))
	     {
	       ((Insert*)$$)->setNoCheck(TRUE);
	     }

	   if(TRUE == $2)
	     {
	       ((Insert*)$$)->setNoRollbackOperation();
	     }
	   delete $5;
        }
        |
        TOK_OVERWRITE TOK_TABLE table_name query_expression order_by_clause access_type optional_limit_spec
        {
          if (!finalizeAccessOptions($4, $6)) YYERROR;

          //limit clause
          if ($7)
          {
	     RelExpr *query = $4;

            if (query->getFirstNRows() >= 0)
              {
                // cannot specify LIMIT and FIRST N clauses together.
                YYERROR;
              }
            else
              {
                NABoolean negate;
                if ($7->castToConstValue(negate))
                  {
                    ConstValue * limit = (ConstValue*)$7;
                    Lng32 scale = 0;
                    query->setFirstNRows(limit->getExactNumericValue(scale));
                  }
              }
          }

          // insert into all columns
          $$ = new (PARSERHEAP())
            Insert(CorrName(*$3, PARSERHEAP()),
               NULL,
               REL_UNARY_INSERT,
               $4,
               NULL,
               $5);
          
          ((Insert*)$$)->setOverwriteHiveTable(TRUE);

          delete $3;
        }  

          | no_check_log no_rollback TOK_INTO  table_name '(' '*' ')' query_expression order_by_clause access_type optional_limit_spec
        {
          if (!finalizeAccessOptions($8, $10)) YYERROR;

          //limit clause
          if ($11)
          {
	     RelExpr *query = $8;

            if (query->getFirstNRows() >= 0)
              {
                // cannot specify LIMIT and FIRST N clauses together.
                YYERROR;
              }
            else
              {
                NABoolean negate;
                if ($11->castToConstValue(negate))
                  {
                    ConstValue * limit = (ConstValue*)$11;
                    Lng32 scale = 0;
                    query->setFirstNRows(limit->getExactNumericValue(scale));
                  }
              }
          }

          // insert into all columns --
          // Tandem extension to INSERT statement;
          // just ignore the redundant "(*)" columnlist.
          $$ = new (PARSERHEAP())
            Insert(CorrName(*$4, PARSERHEAP()),
               NULL,
               REL_UNARY_INSERT,
               $8,
               NULL,
               $9);

	  if (($1 == 1) || ($1 == 3))
	    {
	      ((Insert*)$$)->setNoLogOperation();	
	    }
	  
	  if (($1 == 2) || ($1 == 3))
	    {
	      ((Insert*)$$)->setNoCheck(TRUE);
	    }

	  if (TRUE == $2)
	    {
              ((Insert*)$$)->setNoRollbackOperation();
	    }
	  
          delete $4;
        }
          | no_check_log no_rollback TOK_INTO table_name TOK_DEFAULT TOK_VALUES 
                {
		  // insert defaults into all columns
		  Insert * insert = new (PARSERHEAP())
		    Insert(CorrName(*$4, PARSERHEAP()),
			   NULL,
			   REL_UNARY_INSERT);
		  
		  if (($1 == 1) || ($1 == 3))
		    {
		      ((Insert*)$$)->setNoLogOperation();	
		    }
		  
		  if (($1 == 2) || ($1 == 3))
		    {
		      ((Insert*)$$)->setNoCheck(TRUE);
		    }
	
                  if(TRUE == $2)
                   {
                      insert->setNoRollbackOperation();
                   }
	
		  $$ = insert;
	  
		  delete $4;
		}
              |	no_check_log no_rollback TOK_INTO table_name '(' '*' ')' TOK_DEFAULT TOK_VALUES
		{
		  // insert defaults into all columns --
		  // Tandem extension to INSERT statement;
		  // just ignore the redundant "(*)" columnlist.
		  $$ = new (PARSERHEAP())
                    Insert(CorrName(*$4, PARSERHEAP()),
			   NULL,
			   REL_UNARY_INSERT);

		  if (($1 == 1) || ($1 == 3))
		    {
		      ((Insert*)$$)->setNoLogOperation();	
		    }
	   
		  if (($1 == 2) || ($1 == 3))
		    {
		      ((Insert*)$$)->setNoCheck(TRUE);
		    }
		  
		  if (TRUE == $2)
		    {
		      ((Insert*)$$)->setNoRollbackOperation();
		    }
		  
                  delete $4;
                }
          | no_check_log no_rollback TOK_INTO table_name '(' column_list ')' query_expression order_by_clause optional_limit_spec
                {
                  //limit clause
                  if ($10)
                    {
          	        RelExpr *query = $8;
                      if (query->getFirstNRows() >= 0)
                        {
                          // cannot specify LIMIT and FIRST N clauses together.
                          YYERROR;
                        }
                      else
                        {
                          NABoolean negate;
                          if ($10->castToConstValue(negate))
                            {
                              ConstValue * limit = (ConstValue*)$10;
                              Lng32 scale = 0;
                              query->setFirstNRows(limit->getExactNumericValue(scale));
                            }
                        }
                    }
                
                  // insert into specified columns
                  $$ = new (PARSERHEAP())
                    Insert(CorrName(*$4, PARSERHEAP()),
                       NULL,
                       REL_UNARY_INSERT,
                       $8,
                       $6,
                       $9);

		  if (($1 == 1) || ($1 == 3))
		    {
		      ((Insert*)$$)->setNoLogOperation();	
		    }
		  
		  if (($1 == 2) || ($1 == 3))
		    {
		      ((Insert*)$$)->setNoCheck(TRUE);
		    }

		  if (TRUE == $2)
		    {
		      ((Insert*)$$)->setNoRollbackOperation();
		    }
                  delete $4;
                }
        |no_check_log no_rollback TOK_INTO table_name table_value_constructor atomic_clause
        {
          // insert into all columns
          $$ = new (PARSERHEAP())
            Insert(CorrName(*$4, PARSERHEAP()),
               NULL,
               REL_UNARY_INSERT,
               $5,
               NULL,
               NULL);

          $$->setTolerateNonFatalError($6);

	   if (($1 == 1) || ($1 == 3))
	     {
	       ((Insert*)$$)->setNoLogOperation();	
	     }
	   
	   if (($1 == 2) || ($1 == 3))
	     {
	       ((Insert*)$$)->setNoCheck(TRUE);
	     }

	  if (TRUE == $2)
	    {
	      ((Insert*)$$)->setNoRollbackOperation();
	    }
          delete $4;
        }
          | no_check_log no_rollback TOK_INTO  table_name '(' '*' ')' table_value_constructor atomic_clause
        {
          // insert into all columns --
          // Tandem extension to INSERT statement;
          // just ignore the redundant "(*)" columnlist.
          $$ = new (PARSERHEAP())
            Insert(CorrName(*$4, PARSERHEAP()),
               NULL,
               REL_UNARY_INSERT,
               $8,
               NULL,
               NULL);

          $$->setTolerateNonFatalError($9);

	  if (($1 == 1) || ($1 == 3))
	    {
	      ((Insert*)$$)->setNoLogOperation();	
	    }
	  
	  if (($1 == 2) || ($1 == 3))
	    {
	      ((Insert*)$$)->setNoCheck(TRUE);
	    }

	  if (TRUE == $2)
	    {
	      ((Insert*)$$)->setNoRollbackOperation();
	    }

          delete $4;
        }
        | no_check_log no_rollback TOK_INTO table_name '(' column_list ')' table_value_constructor atomic_clause
          {
            // insert into specified columns
            $$ = new (PARSERHEAP())
              Insert(CorrName(*$4, PARSERHEAP()),
                 NULL,
                 REL_UNARY_INSERT,
                 $8,
                 $6,
                 NULL);

            $$->setTolerateNonFatalError($9);

	    if (($1 == 1) || ($1 == 3))
	      {
		((Insert*)$$)->setNoLogOperation();	
	      }
	    
	    if (($1 == 2) || ($1 == 3))
	      {
		((Insert*)$$)->setNoCheck(TRUE);
	      }

	    if (TRUE == $2)
	      {
		((Insert*)$$)->setNoRollbackOperation();
	      }
            delete $4;
          } 
Rest_Of_insert_wo_INTO_statement: table_name query_expression order_by_clause access_type
	  {
	    CheckModeSpecial1();
	    
	    if (!finalizeAccessOptions($2, $4)) YYERROR;
	    
	    // insert into all columns
	    $$ = new (PARSERHEAP())
	      Insert(CorrName(*$1, PARSERHEAP()),
		     NULL,
		     REL_UNARY_INSERT,
		     $2,
		     NULL,
		     $3);
	    
	    delete $1;
	  }

	 | table_name '(' column_list ')' query_expression order_by_clause
	  {
	    CheckModeSpecial1();
	    
	    // insert into specified columns
	    $$ = new (PARSERHEAP())
	      Insert(CorrName(*$1, PARSERHEAP()),
		     NULL,
		     REL_UNARY_INSERT,
		     $5,
		     $3,
		     $6);
	    
	    delete $1;
	  } 

/* insertType */
Front_Of_Insert : TOK_INSERT 
                      {
                         $$ = Insert::SIMPLE_INSERT;                                   
                      }
              | TOK_UPSERT
                      {
			$$ = Insert::UPSERT_INSERT;
                      }
              | TOK_INSERT TOK_USING TOK_VSBB 
                      {
                         $$ = Insert::VSBB_INSERT_SYSTEM;
                      }
              | TOK_INSERT TOK_USING TOK_LOAD 
                      {
                         $$ = Insert::VSBB_LOAD_AUDITED;
                      }
              | TOK_UPSERT TOK_USING TOK_LOAD 
                      {
                         $$ = Insert::UPSERT_LOAD;
                      }

front_of_insert_with_rwrs :  TOK_UPSERT TOK_USING TOK_ROWSET
                      {
                        $$ = Insert::UPSERT_INSERT;
                      }

front_of_insert: TOK_INS
                      {
			CheckModeSpecial1();
			
			$$ = Insert::SIMPLE_INSERT;
                      }

              | Front_Of_Insert
                { $$ = $1; }

/* type uint */
/*returning_clause : TOK_RETURN TOK_LASTSYSKEY
                      {
			$$ = 1;
		      }
                 | TOK_RETURN output_hostvar_list
                      {
			TheHostVarRoles->setLastNunassignedTo($2,HV_IS_OUTPUT);
			$$ = 2;
		      }
                 | empty
                      {
			$$ = 0; //$$ = NULL;
		      }
		      */

/* type atomicityType	*/					 
atomic_clause : TOK_ATOMIC
		{
			$$ = RelExpr::ATOMIC_;
		}
		| TOK_NOT TOK_ATOMIC
		{
			$$ = RelExpr::NOT_ATOMIC_;
		}
              
/* type item */
column_list : identifier
				{
				  $$ = new (PARSERHEAP())
				    ColReference
				      (new (PARSERHEAP())
				       ColRefName(*$1, PARSERHEAP()));
				  delete $1;
				}
	      | identifier ',' column_list
				{
				  $$ = new (PARSERHEAP())
				    ItemList(
					     new (PARSERHEAP())
					     ColReference(
					        new (PARSERHEAP())
						    ColRefName(*$1, PARSERHEAP())), $3);
				  delete $1;
				}

/* type relx */
merge_statement : merge_stmt_start_tokens TOK_INTO table_name merge_stmt_using_clause merge_stmt_on_condition merge_stmt_when_clause
		  {
		    PtrPlaceHolder * pph = $6;
		    NABoolean isUpdate = (pph->ptr1_ != NULL);
		    ItemExpr * setClause = 
		      (ItemExpr*)pph->ptr2_;
		    ItemExpr * insertColList =
		      (ItemExpr *)pph->ptr3_;
		    ItemExpr * insertValueList =
		      (ItemExpr *)pph->ptr4_;
		    ItemExpr *where = (ItemExpr*)pph->ptr5_;
		    
		    Scan * inputScan =
		      new (PARSERHEAP())
		      Scan(CorrName(*$3, PARSERHEAP()));
		    inputScan->addSelPredTree($5);
		    
		    RelExpr * re = NULL;
		    if (isUpdate)
		      {
			re = new (PARSERHEAP())
			  MergeUpdate(CorrName(*$3, PARSERHEAP()),
				      NULL,
				      REL_UNARY_UPDATE,
				      inputScan,
				      setClause,
				      insertColList,
				      insertValueList,
				      PARSERHEAP(),
				      where);
		      }
		    else
		      {
			re = new (PARSERHEAP())
			  MergeDelete(CorrName(*$3, PARSERHEAP()),
				      NULL,
				      REL_UNARY_DELETE,
				      inputScan,
				      insertColList,
				      insertValueList);
		      }

		    if ($4)
		      {
			re = new(PARSERHEAP()) Join
			  ($4, re, REL_TSJ_FLOW, NULL);
			((Join*)re)->doNotTransformToTSJ();

			((Join*)re)->setTSJForMerge(TRUE);
			
			if (insertValueList)
			  ((Join*)re)->setTSJForMergeWithInsert(TRUE);

			((Join*)re)->setTSJForWrite(TRUE);
		      }
		    
		    $$ = re;
		  }

merge_stmt_start_tokens : TOK_MERGE 
                                        {
					  $$ = 0;
					}

/* type relx */
merge_stmt_using_clause : empty
                            {
			      $$ = NULL;
			    }
                          | TOK_USING rel_subquery as_clause
                            {
			      $$ = new (PARSERHEAP())
				RenameTable($2, *$3);
			      delete $3;
			    }
                          | TOK_USING rel_subquery as_clause '(' derived_column_list ')'
                            {
			      $$ = new (PARSERHEAP())
				RenameTable($2, *$3, $5);
			      delete $3;
			    }

/* type item */
merge_stmt_on_condition : TOK_ON search_condition
                            {
			      $$ = $2;
			    }

merge_stmt_when_clause :   merge_stmt_when_matched
                            {
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder
                                ($1->ptr1_, $1->ptr2_, NULL, NULL, $1->ptr3_);
			    }
                         | merge_stmt_when_not_matched
                            {
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder(
				     (new(PARSERHEAP()) NAString()), NULL, 
				     $1->ptr1_, $1->ptr2_);
			    }
                         | merge_stmt_when_matched merge_stmt_when_not_matched 
                            {
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder
				($1->ptr1_, $1->ptr2_, $2->ptr1_, $2->ptr2_,
				 $1->ptr3_);
			    }
                         | merge_stmt_when_not_matched merge_stmt_when_matched 
                            {
			      $$ = 
				new(PARSERHEAP()) PtrPlaceHolder
                                ($2->ptr1_, $2->ptr2_, $1->ptr1_, $1->ptr2_,
                                 $2->ptr3_);
			    }

/* type ptr_placeholder */
merge_stmt_when_matched     : TOK_WHEN TOK_MATCHED TOK_THEN TOK_UPDATE TOK_SET merge_stmt_set_clause where_clause
                            {
			      $$ = new(PARSERHEAP()) 
				PtrPlaceHolder((new(PARSERHEAP()) NAString()), $6, $7);
			    }
                            | TOK_WHEN TOK_MATCHED TOK_THEN TOK_UPD TOK_SET merge_stmt_set_clause where_clause
                            {
			      CheckModeSpecial1();

			      $$ = new(PARSERHEAP()) 
				PtrPlaceHolder((new(PARSERHEAP()) NAString()), $6, $7);
			    }
                            | TOK_WHEN TOK_MATCHED TOK_THEN TOK_DELETE
                            {
			      if (CmpCommon::getDefault(COMP_BOOL_174) == DF_OFF)
				{
				  YYERROR;
				}
			      
			      $$ = new(PARSERHEAP()) PtrPlaceHolder(NULL, NULL);
			    }

/* type item */
merge_stmt_set_clause       : set_update_commit_list

/* type ptr_placeholder */
merge_stmt_when_not_matched : TOK_WHEN TOK_NOT TOK_MATCHED TOK_THEN TOK_INSERT merge_insert_with_values
                            {
			      $$ = $6;
			    }
                            | TOK_WHEN TOK_NOT TOK_MATCHED TOK_THEN TOK_INS merge_insert_with_values
                            {
			      CheckModeSpecial1();

			      $$ = $6;
			    }
 
/* type ptr_placeholder */
merge_insert_with_values : '(' column_list ')' TOK_VALUES '(' value_expression_list ')'
                            {
			      $$ = new(PARSERHEAP()) PtrPlaceHolder($2, $6);
			    }
                           | TOK_VALUES '(' value_expression_list ')'
                            {
			      $$ = new(PARSERHEAP()) PtrPlaceHolder(NULL,$3);
			    }


/* type relx */
update_statement_searched : TOK_UPDATE update_statement_searched_body
                {
                  $$ = $2;
                }

// QSTUFF + Mv
/* type relx */
update_statement_searched_body : update_statement_target_table set_update_list where_clause
                {
                  // attach the WHERE clause to the input scan
                  $1->addSelPredTree($3);
                  $$ = new (PARSERHEAP())
                    Update(CorrName($1->getTableName(), PARSERHEAP()),
                           NULL,
                           REL_UNARY_UPDATE,
                           $1,
                           $2);
                }

		| update_statement_target_table as_clause set_update_list where_clause
                {
                  $1->getTableName().setCorrName(*$2); 
                  // attach the WHERE clause to the input scan
                  $1->addSelPredTree($4);
                  $$ = new (PARSERHEAP())
                    Update(CorrName($1->getTableName(), PARSERHEAP()),
                           NULL,
                           REL_UNARY_UPDATE,
                           $1,
                           $3);
                  delete $2;
                }

		| TOK_WITH TOK_NO TOK_ROLLBACK update_statement_target_table set_update_list where_clause
                {
                  // attach the WHERE clause to the input scan
                  $4->addSelPredTree($6);
                  $$ = new (PARSERHEAP())
                    Update(CorrName($4->getTableName(), PARSERHEAP()),
                       NULL,
                       REL_UNARY_UPDATE,
                       $4,
                       $5);
		   ((Update*)$$)->setNoRollbackOperation();
                }

		| TOK_WITH TOK_NO TOK_ROLLBACK update_statement_target_table as_clause set_update_list where_clause
                {
                  $4->getTableName().setCorrName(*$5); 
                  // attach the WHERE clause to the input scan
                  $4->addSelPredTree($7);
                  $$ = new (PARSERHEAP())
                    Update(CorrName($4->getTableName(), PARSERHEAP()),
                       NULL,
                       REL_UNARY_UPDATE,
                       $4,
                       $6);
                  ((Update*)$$)->setNoRollbackOperation();

                  delete $5;
                }

                | update_statement_target_table set_update_list TOK_WHERE TOK_CURRENT TOK_OF entity_name_as_item
                {
                  $$ = new (PARSERHEAP())
                    Update(CorrName($1->getTableName(), PARSERHEAP()),
                           NULL,
                           REL_UNARY_UPDATE,
                           $1,
                           $2,
                           $6);
                }

                | update_statement_target_table as_clause set_update_list TOK_WHERE TOK_CURRENT TOK_OF entity_name_as_item
                {
                  $1->getTableName().setCorrName(*$2); 
                  $$ = new (PARSERHEAP())
                    Update(CorrName($1->getTableName(), PARSERHEAP()),
                           NULL,
                           REL_UNARY_UPDATE,
                           $1,
                           $3,
                           $7);
                  delete $2;
                }

                | table_as_stream_any set_update_list where_clause
                {
                  if ($3 != NULL) {
                    // attach the WHERE clause to the input scan
                    $1->addSelPredTree($3);
                  }
                  $$ = new (PARSERHEAP())
                    Update(((Scan *)$1)->getTableName(),
                           NULL,
                           REL_UNARY_UPDATE,
                           $1,
                           $2);
                }

                | '[' firstn_sorted NUMERIC_LITERAL_EXACT_NO_SCALE ']' update_statement_target_table set_update_list
                       where_clause
                {
                  Int64 numRows = atoInt64($3->data());
                  if ($2 == TOK_LAST)
                    {
                      yyerror("LAST option not supported with UPDATE statement. \n");
                      YYERROR;
                    }

                  // attach the WHERE clause to the input scan
                  $5->addSelPredTree($7);
                  $$ = new (PARSERHEAP())
                    Update(CorrName($5->getTableName(), PARSERHEAP()),
                           NULL,
                           REL_UNARY_UPDATE,
                           $5,
                           $6);
                  $$->setFirstNRows(numRows);
                }
                | '[' firstn_sorted NUMERIC_LITERAL_EXACT_NO_SCALE ']' update_statement_target_table as_clause set_update_list
                            where_clause
                {
                  $5->getTableName().setCorrName(*$6); 
                  Int64 numRows = atoInt64($3->data());
                  if ($2 == TOK_LAST)
                    {
                      yyerror("LAST option not supported with UPDATE statement. \n");
                      YYERROR;
                    }

                  // attach the WHERE clause to the input scan
                  $5->addSelPredTree($8);
                  $$ = new (PARSERHEAP())
                    Update(CorrName($5->getTableName(), PARSERHEAP()),
                           NULL,
                           REL_UNARY_UPDATE,
                           $5,
                           $7);
                  $$->setFirstNRows(numRows);
                  delete $6;
                }

		| TOK_WITH TOK_NO TOK_ROLLBACK '[' firstn_sorted NUMERIC_LITERAL_EXACT_NO_SCALE ']'
                       update_statement_target_table set_update_list where_clause
                {
		  Int64 numRows = atoInt64($6->data());
                  if ($5 == TOK_LAST)
                    {
                      yyerror("LAST option not supported with UPDATE statement. \n");
                      YYERROR;
                    }

                  // attach the WHERE clause to the input scan
                  $8->addSelPredTree($10);
                  $$ = new (PARSERHEAP())
                    Update(CorrName($8->getTableName(), PARSERHEAP()),
                           NULL,
                           REL_UNARY_UPDATE,
                           $8,
                           $9);
                  ((Update*)$$)->setNoRollbackOperation();

                  $$->setFirstNRows(numRows);
                }

		| TOK_WITH TOK_NO TOK_ROLLBACK '[' firstn_sorted NUMERIC_LITERAL_EXACT_NO_SCALE ']'
                       update_statement_target_table as_clause set_update_list where_clause
                {
                  $8->getTableName().setCorrName(*$9); 

		  Int64 numRows = atoInt64($6->data());
                  if ($5 == TOK_LAST)
                    {
                      yyerror("LAST option not supported with UPDATE statement. \n");
                      YYERROR;
                    }

                  // attach the WHERE clause to the input scan
                  $8->addSelPredTree($11);
                  $$ = new (PARSERHEAP())
                    Update(CorrName($8->getTableName(), PARSERHEAP()),
                           NULL,
                           REL_UNARY_UPDATE,
                           $8,
                           $10);

                  ((Update*)$$)->setNoRollbackOperation();
                  $$->setFirstNRows(numRows);

                  delete $9;
                }

update_statement_target_table: table_name optimizer_hint
                {
                  Scan * inputScan = new (PARSERHEAP())
                    Scan(CorrName(*$1, PARSERHEAP()));
                  if ($2)
                    inputScan->setHint($2);
                  delete $1;
                  $$=inputScan;
                }

/* type item */
set_delete_list : TOK_SET TOK_ON TOK_ROLLBACK  set_delete_rollback_list
					   {
						  $$ = $4;
					   }
/* type item */
set_delete_rollback_list : set_clause
				   {
					((Assign *) $1)->setOnRollback(TRUE);
				   }
				  | set_clause ',' set_delete_rollback_list
				  {
				    ((Assign *) $1)->setOnRollback(TRUE);
				    $$ = new (PARSERHEAP()) ItemList($1, $3);
				  }
				

/* type item */
set_update_list : TOK_SET  set_update_commit_list
                 {
				   $$ = $2;
				 }

/* 				| TOK_SET TOK_ON TOK_ROLLBACK set_update_rollback_list
				 {
				   $$ = $4
				 }
*/

/* type item */
set_update_commit_list : set_clause
				;
	      | set_clause ',' set_update_commit_list
				{
				  $$ = new (PARSERHEAP()) ItemList($1, $3);
				}
	      | set_clause TOK_SET TOK_ON TOK_ROLLBACK set_update_rollback_list
		     {
			    $$ = new (PARSERHEAP()) ItemList($1, $5);
			 }
				 
/* type item */
set_update_rollback_list : set_clause
				{
				  ((Assign *) $1)->setOnRollback(TRUE);
				}
	            | set_clause ',' set_update_rollback_list
			 	{

				  ((Assign *) $1)->setOnRollback(TRUE);
				  $$ = new (PARSERHEAP()) ItemList($1, $3);

				}

// QSTUFF + Mv


/* You will see that the set_clause uses, in its right side, a reference
 * to a row_val_constructor_elmnt.  This is not exactly the way
 * ANSI expresses it.  But the grammar is the same.  We are re-using
 * row_val_constructor_elmnt rather than create an identical, but differently
 * named new non-terminal just to support the set_clause non-terminal.
 */

set_clause : identifier '=' value_expression
				{
				  $$ = new (PARSERHEAP())
				    Assign(new (PARSERHEAP())
					   ColReference(
					     new (PARSERHEAP()) ColRefName(*$1, PARSERHEAP())),
					   $3);
				  delete $1;
				}
                              | '(' column_list ')' '=' '(' value_expression_list ')'
				{
				  $$ = new (PARSERHEAP())
				    Assign($2, $6);
				}
                              | '(' column_list ')' '=' rel_subquery
				{
				  RowSubquery * rs = 
				    new (PARSERHEAP()) RowSubquery($5);

				  $$ = new (PARSERHEAP())
				    Assign($2, rs);
				}
                              | identifier '=' update_obj_to_lob_function
				{
				    ItemExpr * rc = $3;
				  if (rc->getOperatorType() == ITM_LOBUPDATE)
				    {
				      LOBupdate * lu = (LOBupdate*)rc;
				    
				      ColReference * cr = 
					new (PARSERHEAP())
					ColReference(new (PARSERHEAP()) ColRefName(*$1, PARSERHEAP()));
				      
				      LOBupdate * nlu = 
					new (PARSERHEAP()) LOBupdate(lu->child(0), cr, lu->child(2),
								     lu->getObj(), lu->isAppend());
				      
				      rc = nlu;
				    }

				  $$ = new (PARSERHEAP())
				    Assign(new (PARSERHEAP())
					   ColReference(
					     new (PARSERHEAP()) ColRefName(*$1, PARSERHEAP())),
					   rc);
				  delete $1;
				}
                         

/* type relx */
delete_start_tokens : TOK_DELETE no_check_log TOK_FROM table_name optimizer_hint
               {
                 TransMode *transMode = CmpCommon::transMode();

                 // Multi Commit must extract the where clause part
                 // of the query text for use at runtime.
                 // So mark the start of the WHERE clause here in
                 // case this DELETE is in fact an MULTI COMMIT Delete.
                 if (transMode->multiCommit() == TransMode::MC_ON_)
                   {
                     if(!ParNameLocListPtr) {
                       ParNameLocListPtr = new (PARSERHEAP()) 
                         ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     }
                     ParSetTextStartPosForMultiCommit(ParNameLocListPtr);
                   }

                 Scan * inputScan =
                   new (PARSERHEAP()) Scan(CorrName(*$4, PARSERHEAP()));
   
                 $$ = new (PARSERHEAP())
                   Delete(CorrName(*$4, PARSERHEAP()),
                          NULL,
                          REL_UNARY_DELETE,
                          inputScan,
                          NULL);
   
                 if (($2 == 1) || ($2 == 3))
                   {
                     ((Delete*)$$)->setNoLogOperation();	
                   }
   
                  if (($2 == 2) || ($2 == 3))
                   {
                     ((Delete*)$$)->setNoCheck(TRUE);
                   }

                  if ($5)
                   {
                     inputScan->setHint($5);
                   }
   
                 delete $4;
               }
          | TOK_DELETE no_check_log TOK_FROM table_name TOK_AS correlation_name optimizer_hint 
               {
                 TransMode *transMode = CmpCommon::transMode();

                 // Multi Commit must extract the where clause part
                 // of the query text for use at runtime.
                 // So mark the start of the WHERE clause here in
                 // case this DELETE is in fact an MULTI COMMIT Delete.
                 if (transMode->multiCommit() == TransMode::MC_ON_)
                   {
                     if(!ParNameLocListPtr) {
                       ParNameLocListPtr = new (PARSERHEAP()) 
                         ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     }
                     ParSetTextStartPosForMultiCommit(ParNameLocListPtr);
                   }

                 $4->setCorrName(*$6); 
                 Scan * inputScan =
                   new (PARSERHEAP()) Scan(CorrName(*$4, PARSERHEAP()));
   
                 $$ = new (PARSERHEAP())
                   Delete(CorrName(*$4, PARSERHEAP()),
                          NULL,
                          REL_UNARY_DELETE,
                          inputScan,
                          NULL);
   
                 if (($2 == 1) || ($2 == 3))
                   {
                     ((Delete*)$$)->setNoLogOperation();	
                   }

                  if (($2 == 2) || ($2 == 3))
                   {
                     ((Delete*)$$)->setNoCheck(TRUE);
                   }
    
                  if ($7)
                   {
                     inputScan->setHint($7);
                   }
   
                 delete $4;
                 delete $6;
               }

delete_statement : TOK_DELETE TOK_COLUMNS '(' quoted_string_list ')' TOK_FROM table_name optimizer_hint where_clause
               {
                 Scan * inputScan =
                   new (PARSERHEAP()) Scan(CorrName(*$7, PARSERHEAP()));

		 // attach the WHERE clause to the input scan
		 inputScan->addSelPredTree($9);
    
                 $$ = new (PARSERHEAP())
                   Delete(CorrName(*$7, PARSERHEAP()),
                          NULL,
                          REL_UNARY_DELETE,
                          inputScan,
                          NULL, NULL,
			  $4);
   
                  if ($8)
                    inputScan->setHint($8);

                 delete $7;
               }

delete_statement : delete_start_tokens where_clause
				{
                                  Delete *del = (Delete *)$1;
                                  ComASSERT(del);

                                  Scan * inputScan = (Scan *)(del->child(0)->castToRelExpr());
                                  ComASSERT(inputScan);

                                  // Is this Delete a MULTI COMMIT DELETE?
				  TransMode *transMode = CmpCommon::transMode();
                                  if (transMode->multiCommit() == TransMode::MC_ON_)
                                  {
                                    // If it is a MULTI-COMMIT Delete, do some error checking,
                                    // grab the string representation of the WHERE clause from
                                    // the query text and create the LongRunning operator.
                                    // The DELETE/SCAN created by the 'delete_start_tokens'
                                    // rule can be thrown away.

				    // Make sure the transaction modes are compatible
				    if (transMode->invalidMultiCommitCompatibility())
				    {
				      *SqlParser_Diags <<  DgSqlCode(-4352);
				      YYERROR;
				    }
                                    char *stmt = SQLTEXT();

                                     // If we can not get a single-byte string here, report error
                                     if ( stmt == NULL ) {
                                       *SqlParser_Diags <<  DgSqlCode(-3406);
                                       YYERROR;
                                     }
                    
				     // the WHERE clause cannot have a parameter or host varaible
				     if (($2 != NULL ) && ($2->containsOpType(ITM_DYN_PARAM) ||
							   $2->containsOpType(ITM_HOSTVAR)))
				       {
					 *SqlParser_Diags << DgSqlCode(-3426);
					 YYABORT;
				       } 

                                     StringPos start = 0;
                                     StringPos end = 0;
                                     char *where = NULL;
                                     ULng32 whereLen = 0;

                                     // Find the end of the WHERE clause if one exists.
                                     //
                                     if($2 != NULL) {

                                       if (ParGetTextStartEndPosForMultiCommit(ParNameLocListPtr,start, end))
                                         { yyerror(""); YYERROR; }

                                       ComASSERT(start > 0 && end > start);

                                       // Identify the where clause for use by the
                                       // ExeUtilLongRunning operator.
                                       //
                                       where = &stmt[start];
                                       whereLen = end-start;
                                     }

                                     WeAreInALRUOperation = TRUE;

                                     ExeUtilLongRunning * eue =
                                       new (PARSERHEAP ()) ExeUtilLongRunning(
                                            del->getTableName(),
                                            where,
                                            whereLen,
                                            ExeUtilLongRunning::LR_DELETE,
                                            0, // user did not specify the Multi Commit Size
                                            PARSERHEAP());
                    
                                      // attach the WHERE clause to LongRunning
                                      eue->addPredicateTree($2);

                                      // set the NOMVLOG MV option if specified
                                      eue->setNoLogOperation (del->isNoLogOperation() != FALSE);
                    
                                     // xn will be started, if needed, when the exeutilstmt stmt
                                     // is processed.
                                     eue->xnNeeded() = FALSE;

                                     // We got everything we need from the Delete and Scan operators,
                                     // so they can be deleted now.
                                     delete del;

                                     $$ = eue;
                                  }
                                  else
                                  {

                                    // attach the WHERE clause to the input scan
                                    inputScan->addSelPredTree($2);
                                    
                                    $$ = del;
                                  }
				}

/* type relx */
delete_statement : TOK_DELETE no_check_log TOK_WITH TOK_NO TOK_ROLLBACK TOK_FROM table_name optimizer_hint where_clause 
                {
                  Scan * inputScan =
                    new (PARSERHEAP()) Scan(CorrName(*$7, PARSERHEAP()));

                  // attach the WHERE clause to the input scan
                  inputScan->addSelPredTree($9);
                  $$ = new (PARSERHEAP())
                    Delete(CorrName(*$7, PARSERHEAP()),
                       NULL,
                       REL_UNARY_DELETE,
                       inputScan,
                       NULL);

                  if (($2 == 1) || ($2 == 3))
                  {
                    ((Delete*)$$)->setNoLogOperation();	
                  }

		    ((Delete*)$$)->setNoRollbackOperation();

                  if (($2 == 2) || ($2 == 3))
                   {
                     ((Delete*)$$)->setNoCheck(TRUE);
                   }
 
                  if ($8)
                    inputScan->setHint($8);

                  delete $7;
                }
		| TOK_DELETE no_check_log TOK_WITH TOK_NO TOK_ROLLBACK TOK_FROM table_name TOK_AS correlation_name
                             optimizer_hint where_clause 
                {
                  $7->setCorrName(*$9); 
                  Scan * inputScan =
                    new (PARSERHEAP()) Scan(CorrName(*$7, PARSERHEAP()));

                  // attach the WHERE clause to the input scan
                  inputScan->addSelPredTree($11);
                  $$ = new (PARSERHEAP())
                    Delete(CorrName(*$7, PARSERHEAP()),
                       NULL,
                       REL_UNARY_DELETE,
                       inputScan,
                       NULL);

                  if (($2 == 1) || ($2 == 3))
                  {
                    ((Delete*)$$)->setNoLogOperation();	
                  }

		    ((Delete*)$$)->setNoRollbackOperation();

                  if (($2 == 2) || ($2 == 3))
                   {
                     ((Delete*)$$)->setNoCheck(TRUE);
                   }
 
                  if ($10)
                    inputScan->setHint($10);

                  delete $7;
                  delete $9;
                }

delete_statement : TOK_DELETE no_check_log ignore_triggers '[' firstn_sorted NUMERIC_LITERAL_EXACT_NO_SCALE ']' TOK_FROM table_name optimizer_hint where_clause
				{
				  Scan * inputScan =
                                    new (PARSERHEAP()) Scan(CorrName(*$9, PARSERHEAP()));

				  Int64 numRows = atoInt64($6->data());
				  if ($5 == TOK_LAST)
				    {
				      yyerror("LAST option not supported with DELETE statement. \n");
				      YYERROR;
				    }

				  // attach the WHERE clause to the input scan
                                  inputScan->addSelPredTree($11);
				  $$ = new (PARSERHEAP())
				    Delete(CorrName(*$9, PARSERHEAP()),
					   NULL,
					   REL_UNARY_DELETE,
					   inputScan,
					   NULL);

				  if (($2 == 1) || ($2 == 3))
				    {
				      ((Delete*)$$)->setNoLogOperation();	
				    }
				  
				  if (TRUE == $3)
				    {
				      ((Delete*)$$)->setIgnoreTriggers(TRUE);
				    }

                                  if ($10)
                                    inputScan->setHint($10);

				  $$->setFirstNRows(numRows);

				  delete $9;
				}
		| TOK_DELETE no_check_log TOK_WITH TOK_NO TOK_ROLLBACK '[' firstn_sorted NUMERIC_LITERAL_EXACT_NO_SCALE ']'
                             TOK_FROM table_name optimizer_hint where_clause
                {
                  Scan * inputScan =
                    new (PARSERHEAP()) Scan(CorrName(*$11, PARSERHEAP()));

                    Int64 numRows = atoInt64($8->data());
                  if ($7 == TOK_LAST)
                    {
                      yyerror("LAST option not supported with DELETE statement. \n");
                      YYERROR;
                    }

                  // attach the WHERE clause to the input scan
                  inputScan->addSelPredTree($13);
                  $$ = new (PARSERHEAP())
                    Delete(CorrName(*$11, PARSERHEAP()),
                       NULL,
                       REL_UNARY_DELETE,
                       inputScan,
                       NULL);

                  if (($2 == 1) || ($2 == 3))
                    {
                      ((Delete*)$$)->setNoLogOperation();
                    }

                  ((Delete*)$$)->setNoRollbackOperation();

                  if ($12)
                    inputScan->setHint($12);

                  $$->setFirstNRows(numRows);

                  delete $11;
                }

                | delete_start_tokens TOK_WHERE TOK_CURRENT TOK_OF entity_name_as_item 
                                {
                                  Delete *del = (Delete *)$1;
                                  ComASSERT(del);
                                  
                                  del->currOfCursorName() = $5;

				  $$ = del;

                                }
                // QSTUFF + Mv
	        | TOK_DELETE no_check_log TOK_FROM table_as_stream_any where_clause
				{
		                  if ($5 != NULL) {
				    // attach the WHERE clause to the input scan
		  		    $4->addSelPredTree($5);
		                  }
				  $$ = new (PARSERHEAP())
				    Delete(((Scan *)$4)->getTableName(),
					   NULL,
					   REL_UNARY_DELETE,
					   $4,
					   NULL);
				  if (($2 == 1) || ($2 == 3))
				  {
					((Delete*)$$)->setNoLogOperation();	
				  }
				}

                | TOK_DELETE no_check_log TOK_FROM table_name set_delete_list where_clause
				{
                                  // Note: Hints not supported with SET ON ROLLBACK clause
				  Scan * inputScan =
				    new (PARSERHEAP()) Scan(CorrName(*$4, PARSERHEAP()));

		                  if ($6 != NULL) {
				    // attach the WHERE clause to the input scan
				    inputScan->addSelPredTree($6);
		                  }

				  $$ = new (PARSERHEAP())
				    Delete(CorrName(*$4, PARSERHEAP()),
					   NULL,
					   REL_UNARY_DELETE,
					   inputScan,
					   $5);
				  if (($2 == 1) || ($2 == 3))
				  {
					((Delete*)$$)->setNoLogOperation();	
				  }
				  delete $4; 
				}
        | TOK_DELETE no_check_log TOK_FROM table_name set_delete_list TOK_WHERE TOK_CURRENT TOK_OF entity_name_as_item
                    {
                                  // Note: Hints not supported with SET ON ROLLBACK clause
				  $$ = new (PARSERHEAP())
				    Delete(CorrName(*$4, PARSERHEAP()),
					   NULL,
					   REL_UNARY_DELETE,
					   new (PARSERHEAP()) Scan(CorrName(*$4, PARSERHEAP())),
					   $5,
					   $9);
				  if (($2 == 1) || ($2 == 3))
				  {
					((Delete*)$$)->setNoLogOperation();	
				  }
				  delete $4;
		   }

	       | TOK_DELETE no_check_log TOK_FROM table_as_stream_any set_delete_list where_clause
				{
                                  // Note: Hints not supported with SET ON ROLLBACK clause
		                  if ($6 != NULL) {
				    // attach the WHERE clause to the input scan
				    $4->addSelPredTree($6);
                		  }
				  $$ = new (PARSERHEAP())
				    Delete(((Scan *)$4)->getTableName(),
					   NULL,
					   REL_UNARY_DELETE,
					   $4,
					   $5);
				  if (($2 == 1) || ($2 == 3))
				    {
				      ((Delete*)$$)->setNoLogOperation();	
				    }
				}

              // QSTUFF + Mv
              // Long Running Delete
              | TOK_DELETE no_check_log TOK_WITH TOK_MULTI TOK_COMMIT multi_commit_size TOK_FROM table_name 
              {
		// Make sure the transaction modes are compatible
		if (CmpCommon::transMode()->invalidMultiCommitCompatibility())
		{
		    *SqlParser_Diags <<  DgSqlCode(-4352);
		    YYERROR;
		}

                 WeAreInALRUOperation = TRUE;

 		 ExeUtilLongRunning * eue = 
		   new (PARSERHEAP ()) ExeUtilLongRunning(
			CorrName(*$8, PARSERHEAP()),
                        NULL,      // where clause string
                        0,         // where clause string length
			ExeUtilLongRunning::LR_DELETE,           
			$6, // Multi Commit Size
			PARSERHEAP());

                 ComASSERT(eue->getMultiCommitSize() > 0);

	         eue->addPredicateTree(NULL);

                 // set the NOMVLOG MV option if specified
                 eue->setNoLogOperation ($2 == TRUE);
                    
		 // xn will be started, if needed, when the exeutilstmt stmt
		 // is processed.
		 eue->xnNeeded() = FALSE;
		 
		 $$ = eue;

	       }   
// Long Running Delete
| TOK_DELETE no_check_log TOK_WITH TOK_MULTI TOK_COMMIT multi_commit_size TOK_FROM table_name TOK_WHERE
              {
                // Multi Commit must extract the where clause part
                // of the query text for use at runtime.
                // So mark the start of the WHERE clause here
                if(!ParNameLocListPtr) {
                  ParNameLocListPtr = new (PARSERHEAP()) 
                    ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                }
                ParSetTextStartPosForMultiCommit(ParNameLocListPtr);
              }
  search_condition
              {
		// Make sure the transaction modes are compatible
		if (CmpCommon::transMode()->invalidMultiCommitCompatibility())
		{
		    *SqlParser_Diags <<  DgSqlCode(-4352);
		    YYERROR;
		}

                char *stmt = SQLTEXT();
                 
		 // If we can not get a single-byte string here, report error 
		 if ( stmt == NULL ) {
		   *SqlParser_Diags <<  DgSqlCode(-3406);
		   YYERROR;
		 }

		 // the WHERE clause cannot have a parameter or host varaible
		 if (($11 !=NULL) && ($11->containsOpType(ITM_DYN_PARAM) ||
				     $11->containsOpType(ITM_HOSTVAR)))
		   {
		     *SqlParser_Diags << DgSqlCode(-3426);
		     YYABORT;
		   }

                 StringPos start = 0;
                 StringPos end = 0;
                 char *where = NULL;
                 ULng32 whereLen = 0;

                 // Find the end of the WHERE clause if one exists.
                 //
                 if($11 != NULL) {

                   if (ParGetTextStartEndPosForMultiCommit(ParNameLocListPtr,start, end))
                     { yyerror(""); YYERROR; }

                   ComASSERT(start > 0 && end > start);

                   // Identify the where clause for use by the
                   // ExeUtilLongRunning operator.
                   //
                   where = &stmt[start];
                   whereLen = end-start;
                 }

                 WeAreInALRUOperation = TRUE;

 		 ExeUtilLongRunning * eue = 
		   new (PARSERHEAP ()) ExeUtilLongRunning(
			CorrName(*$8, PARSERHEAP()),
                        where,
                        whereLen,
			ExeUtilLongRunning::LR_DELETE,           
			$6, // Multi Commit Size
			PARSERHEAP());

                 ComASSERT(eue->getMultiCommitSize() > 0);

     	         // attach the WHERE clause to LongRunning
	         eue->addPredicateTree($11);
		 
                 // set the NOMVLOG MV option if specified
                 eue->setNoLogOperation ($2 == TRUE);
                    
		 // xn will be started, if needed, when the exeutilstmt stmt
		 // is processed.
		 eue->xnNeeded() = FALSE;
		 
		 $$ = eue;

	       }     

| TOK_DELETE TOK_ALL TOK_FROM TOK_TABLE '(' TOK_NATABLE_CACHE '(' ')' ')'
  {
    $$ = new (PARSERHEAP()) RelInternalSP("NATABLECACHEDELETE"
                                          , 0
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }  
| TOK_DELETE TOK_ALL TOK_FROM TOK_TABLE '(' TOK_QUERY_CACHE '(' value_expression_list ')' ')'
  {
    $$ = new (PARSERHEAP()) RelInternalSP("QUERYCACHEDELETE"
                                          , $8
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
  }  
|  TOK_DELETE TOK_ALL TOK_FROM TOK_TABLE '(' TOK_NAROUTINE_CACHE '(' ')' ')'
  {
    $$ = new (PARSERHEAP()) RelInternalSP("NAROUTINECACHEDELETE"
                                          , 0
                                          , REL_INTERNALSP
                                          , PARSERHEAP()
                                          , RelInternalSP::executeInSameArkcmp);
                                          } 

/* type uint */	       
multi_commit_size : empty
                       {
                        $$ = 0;
                       }
                  | TOK_EVERY unsigned_integer TOK_ROWS 
                       {
			 if($2 == 0)
			   {
			     *SqlParser_Diags << DgSqlCode(-3240); // commit size must be greater than zero		     
			   }
			 
			 // assuming that the user will
			 // always pass a valid unsigned long value (correct
			 // number of digits)
			 $$ = $2; 
                       }
             
 /* type relx */
transaction_statement : TOK_BEGIN
              {
                 $$ = new (PARSERHEAP()) RelTransaction(BEGIN_);
              }
      | TOK_BEGIN TOK_WORK
              {
                 $$ = new (PARSERHEAP()) RelTransaction(BEGIN_);
              }
      | TOK_BT
              {
                 $$ = new (PARSERHEAP()) RelTransaction(BEGIN_);
              }
      | TOK_COMMIT
              {
		$$ = new (PARSERHEAP()) RelTransaction(COMMIT_);
              }
      | TOK_COMMIT TOK_WORK
              {
		$$ = new (PARSERHEAP()) RelTransaction(COMMIT_);
              }
      | TOK_ET
              {
		$$ = new (PARSERHEAP()) RelTransaction(COMMIT_);
              }
      | TOK_ROLLBACK
              {
		$$ = new (PARSERHEAP()) RelTransaction(ROLLBACK_WAITED_);
              }
      | TOK_ROLLBACK TOK_WORK
              {
		$$ = new (PARSERHEAP()) RelTransaction(ROLLBACK_WAITED_);
              }
      | TOK_ROLLBACK TOK_WAITED
	      {
		$$ = new (PARSERHEAP()) RelTransaction(ROLLBACK_WAITED_);
              }
      | TOK_ROLLBACK TOK_WORK TOK_WAITED
              {
		$$ = new (PARSERHEAP()) RelTransaction(ROLLBACK_WAITED_);
              }
      | TOK_ROLLBACK TOK_NO TOK_WAITED
	      {
		$$ = new (PARSERHEAP()) RelTransaction(ROLLBACK_);
              }
      | TOK_ROLLBACK TOK_WORK TOK_NO TOK_WAITED
              {
		$$ = new (PARSERHEAP()) RelTransaction(ROLLBACK_);
              }
      | TOK_SET TOK_TRANSACTION TOK_AUTOCOMMIT on_off
              {
		TransMode * m = new (PARSERHEAP()) TransMode();
		m->autoCommit() = $4 ? TransMode::ON_ : TransMode::OFF_;

		$$ = new (PARSERHEAP())
		  RelTransaction(SET_TRANSACTION_, m);
              }

      | TOK_SET TOK_TRANSACTION TOK_AUTOBEGIN on_off
              {
		TransMode * m = new (PARSERHEAP()) TransMode();
		m->setFlags() = $4 ? TransMode::AUTO_BEGIN_ON_ : TransMode::AUTO_BEGIN_OFF_;

		$$ = new (PARSERHEAP())
		  RelTransaction(SET_TRANSACTION_, m);
              }

      | TOK_SET TOK_TRANSACTION TOK_ROLLBACK TOK_WAITED

              {
		TransMode * m = new (PARSERHEAP()) TransMode();
		m->rollbackMode() = TransMode::ROLLBACK_MODE_WAITED_;

		$$ = new (PARSERHEAP())
		  RelTransaction(SET_TRANSACTION_, m);
              }
      | TOK_SET TOK_TRANSACTION TOK_ROLLBACK TOK_NO TOK_WAITED
              {
		TransMode * m = new (PARSERHEAP()) TransMode();
		m->rollbackMode() = TransMode::ROLLBACK_MODE_NOWAITED_;

		$$ = new (PARSERHEAP())
		  RelTransaction(SET_TRANSACTION_, m);
              }

      | set_transaction_statement
		{
		  StmtDMLSetTransaction * st = (StmtDMLSetTransaction *)$1;

		  TransMode * m = new (PARSERHEAP())
		    TransMode(st->getIsolationLevel(), 
			      st->getAccessMode(),
			      TransMode::AC_NOT_SPECIFIED_,
			      st->getRollbackMode(),
			      -1, /* diagnostic area size */
			      st->getAutoAbortInterval(),
			      st->getMultiCommit(),
			      (ULng32)st->getMultiCommitSize());

		  $$ = new (PARSERHEAP())
		    RelTransaction(SET_TRANSACTION_, m, st->getDiagSizeNode());
		}

/* type boolean */
on_off : TOK_OFF
           {
	     $$ = FALSE;
	   }

         | TOK_ON
           {
	     $$ = TRUE;
	   }
         | empty
           {
	     $$ = TRUE;
           }

/* type boolean */
on_or_empty : TOK_OFF
           {
	     YYERROR;
	   }

         | TOK_ON
           {
	     $$ = TRUE;
	   }
         | empty
           {
	     $$ = TRUE;
           }


/* type longint */
autoabort_interval : TOK_RESET 
		     {
			$$ = -3 ;  /* denotes a user specified reset */
		     }
		   | NUMERIC_LITERAL_EXACT_NO_SCALE hour_hours
		   {
		      RemoveLeadingZeros(*$1);
		      short strSize = $1->length();
		      $$ = 3600*atoi(*$1);

		      if ((strSize > 4)||($$ > 21474836) || ($$ < 20))
		      {
		      *SqlParser_Diags << DgSqlCode(-3235) << DgString0(*$1) ;
                        YYERROR;
		      }

		   }
		   | NUMERIC_LITERAL_EXACT_NO_SCALE minute_minutes
		   {
		      RemoveLeadingZeros(*$1);
		      short strSize = $1->length();
		      $$ = 60*atol(*$1);

		      if ((strSize > 6)||($$ > 21474836) || ($$ < 20))
		      {
		      *SqlParser_Diags << DgSqlCode(-3235) << DgString0(*$1) ;
                        YYERROR;
		      }
		   }
		   | NUMERIC_LITERAL_EXACT_NO_SCALE second_seconds
		   {
		      RemoveLeadingZeros(*$1);
		      short strSize = $1->length();
		      $$ = atol(*$1);

		      if ((strSize > 8)||($$ > 21474836) || ($$ < 20))
		      {
		      *SqlParser_Diags << DgSqlCode(-3235) << DgString0(*$1) ;
                        YYERROR;
		      }
		   }
		   | unsigned_integer
		   {
		      if ($1 == 0)
			$$ = -2 ;  /* -2 denotes a 0 specified by the user */
		      else         /* this value cannot be overridden */
		      {
                        YYERROR;
		      }
		   }

/* type longint */
maxruntime_interval : NUMERIC_LITERAL_EXACT_NO_SCALE hour_hours
		   {
		      RemoveLeadingZeros(*$1);
		      short strSize = $1->length();
		      if (strSize > 4)
			{
			  YYERROR;
			}
		      
		      $$ = 3600*atoi(*$1);
		   }
		   | NUMERIC_LITERAL_EXACT_NO_SCALE minute_minutes
		   {
		      RemoveLeadingZeros(*$1);
		      short strSize = $1->length();
		      if (strSize > 6)
			{
			  YYERROR;
			}
		      $$ = 60*atol(*$1);
		   }

hour_hours	  : TOK_HOUR
		  | TOK_HOURS

minute_minutes	  : TOK_MINUTE
		  | TOK_MINUTES

second_seconds	  : TOK_SECOND
		  | TOK_SECONDS

/* type relx */
query_suspend_safe : TOK_CONTROL TOK_QUERY TOK_SUSPEND TOK_QID identifier
                  {
                     $$ = new (PARSERHEAP())
                      ControlRunningQuery(*$5, 
                        ControlRunningQuery::ControlQid,
                        ControlRunningQuery::Suspend, 
                       ControlRunningQuery::Safe);
                  }

/* type relx */
query_suspend_forced : TOK_CONTROL TOK_QUERY TOK_SUSPEND TOK_QID identifier ',' TOK_FORCE
                  {
                     $$ = new (PARSERHEAP())
                      ControlRunningQuery(*$5,
                        ControlRunningQuery::ControlQid,
                        ControlRunningQuery::Suspend, 
                        ControlRunningQuery::Force);
                  }
  
/* type relx */
query_activate : TOK_CONTROL TOK_QUERY TOK_ACTIVATE TOK_QID identifier 
                  {
                     $$ = new (PARSERHEAP())
                      ControlRunningQuery(*$5,
                        ControlRunningQuery::ControlQid,
                        ControlRunningQuery::Activate, 
                        ControlRunningQuery::CancelOrActivateIsAlwaysSafe);
                  }
/* type relx */
query_cancel_qid   : TOK_CONTROL TOK_QUERY TOK_CANCEL TOK_QID identifier
                      {
                      $$ = new (PARSERHEAP())
                        ControlRunningQuery(*$5,
                          ControlRunningQuery::ControlQid,
                          ControlRunningQuery::Cancel,
                          ControlRunningQuery::CancelOrActivateIsAlwaysSafe);
                      }

/* type relx */
query_cancel_pname : TOK_CONTROL TOK_QUERY TOK_CANCEL TOK_PID DOLLAR_IDENTIFIER
                      {
                      $$ = new (PARSERHEAP())
                        ControlRunningQuery(*$5,
                          ControlRunningQuery::ControlPname,
                          ControlRunningQuery::Cancel,
                          ControlRunningQuery::CancelOrActivateIsAlwaysSafe);
                      }

/* type relx */
query_cancel_nid_pid : TOK_CONTROL TOK_QUERY TOK_CANCEL TOK_PID
                       NUMERIC_LITERAL_EXACT_NO_SCALE ',' 
                       NUMERIC_LITERAL_EXACT_NO_SCALE
                      {
                      $$ = new (PARSERHEAP())
                        ControlRunningQuery(atoi($5->data()), 
                                            atoi($7->data()),
                          ControlRunningQuery::ControlNidPid,
                          ControlRunningQuery::Cancel,
                          ControlRunningQuery::CancelOrActivateIsAlwaysSafe);
                      }
/* type relx */
query_cancel_no_comment:  query_cancel_qid 
                        | query_cancel_pname
                        | query_cancel_nid_pid

/* type relx */
query_cancel_optional_comment : query_cancel_no_comment
                              | query_cancel_no_comment 
                                  TOK_COMMENT QUOTED_STRING
                  {
                     ((ControlRunningQuery *)$$)->setComment(*$3);
                  }

/* type relx */
lock_unlock_statement :   lock_statement
                        | unlock_statement

/* type relx */
lock_statement : TOK_LOCK TOK_TABLE table_name lock_mode lock_index_option
			{
			  $$ = new (PARSERHEAP())
			    RelLock(*$3, $4, (NOT $5), REL_LOCK);
			}
                 | TOK_LOCK TOK_TABLE table_name lock_mode lock_index_option TOK_PARALLEL TOK_EXECUTION TOK_ON
			{
			  $$ = new (PARSERHEAP())
			    RelLock(*$3, $4, (NOT $5), REL_LOCK, TRUE);
			}

/* type boolean */
lock_index_option : TOK_NO TOK_INDEX TOK_LOCK { $$ = TRUE; }
                    | empty { $$ = FALSE; }

/* type lockmode */
optional_lock_mode : lock_mode
                    | /* empty */
                    {
		      $$ = LOCK_MODE_NOT_SPECIFIED_;
		    }

/* type lockmode */
lock_mode :   TOK_IN TOK_SHARE TOK_MODE         { $$ = SHARE_;}
            | TOK_IN TOK_EXCLUSIVE TOK_MODE	{ $$ = EXCLUSIVE_;}
            | TOK_IN TOK_PROTECTED TOK_MODE	{ $$ = PROTECTED_;}


/* type relx */
unlock_statement : TOK_UNLOCK TOK_TABLE table_name
			{
			  $$ = new (PARSERHEAP())
			    RelLock(*$3, SHARE_/*no-op in unlock*/, TRUE, REL_UNLOCK);
			}
                   | TOK_UNLOCK TOK_TABLE table_name TOK_PARALLEL TOK_EXECUTION TOK_ON 
			{
			  $$ = new (PARSERHEAP())
			    RelLock(*$3, SHARE_/*no-op in unlock*/, TRUE, REL_UNLOCK, TRUE);
			}

/* type relx */
/* These are all Tandem syntax extensions. */
control_statement : TOK_CONTROL TOK_QUERY TOK_SHAPE query_shape_options query_shape_control
				{
				  if ($5->castToRelExpr() == NULL)
				    {
				      *SqlParser_Diags << DgSqlCode(-3113) <<
					DgString0("Relational expr. expected here.");
				      yyerror("");
				      YYERROR;
				    }
				  else if ($5->castToRelExpr()->getOperatorType() == REL_CONTROL_QUERY_SHAPE)
				    {
				      if ($4 != TOK_FALSE)
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Can't combine WITHOUT option and HOLD/RESTORE");
					  yyerror("");
					  YYERROR;
					}
				      else
					{
					  /*					  if ((getenv("SQLMX_REGRESS")) &&
					      (CmpCommon::getDefault(MODE_SEABASE) == DF_ON))
					    {
					      // TEMPTEMP. CQS doesn't work and causes many
					      // regressions failures. Temporarily CUT it.
					      $$ = new (PARSERHEAP()) CutOp(0);
					    }
					    else*/
					  $$ = $5->castToRelExpr();
					}
				    }
				  else
				    {
				      RelExpr * re = $5->castToRelExpr();
				      /*				      if ((getenv("SQLMX_REGRESS")) &&
					  (CmpCommon::getDefault(MODE_SEABASE) == DF_ON))
					{
					  // TEMPTEMP. CQS doesn't work and causes many
					  // regressions failures. Temporarily CUT it.
					  re = new (PARSERHEAP()) CutOp(0);
					}
				      */

				      $$ = new (PARSERHEAP())
					ControlQueryShape(
					     re, //$5->castToRelExpr(),
					     SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(),
					     FALSE,
					     FALSE,
					     ($4 == TOK_EXCHANGE || $4 == TOK_ENFORCERS || $4 == TOK_EXCHANGE_AND_SORT),
					     ($4 == TOK_SORT || $4 == TOK_ENFORCERS || $4 == TOK_EXCHANGE_AND_SORT));
				    }
				}
		  | TOK_CONTROL TOK_QUERY TOK_DEFAULT query_default_control
                                {
				  $$ = $4;
				}
		  | TOK_CQD query_default_control
                                {
				  $$ = $2;
				}
                  | TOK_CONTROL TOK_TABLE table_control
                                {
				  $$ = $3;
				}
                  | TOK_CONTROL TOK_SESSION session_control
                                {
				  $$ = $3;
				}
                  | declare_or_set_cqd
                  | set_session_default_statement

osim_statement : 
                    //control osim capture location '<osim directory path>';
                    //create directory and files, 
                    //begin a session to capture running queries and referred tables/views/statistics.
                   TOK_CONTROL TOK_OSIM TOK_CAPTURE TOK_LOCATION character_string_literal
                   {

                      OSIMControl *osim = new (PARSERHEAP()) OSIMControl( OptimizerSimulator::CAPTURE, 
                                                                                    *$5,
                                                                                    FALSE,
                                                                                    PARSERHEAP());
                      $$ = osim;
                   }
                   //control osim capture stop;
                   //end osim capture session, dump statistics data of referred tables.
                   |TOK_CONTROL TOK_OSIM TOK_CAPTURE TOK_STOP
                   {
                      OSIMControl *osim = new (PARSERHEAP()) OSIMControl( OptimizerSimulator::OFF, 
                                                                                    *(new (PARSERHEAP()) NAString("")),
                                                                                    FALSE,
                                                                                    PARSERHEAP());
                      $$ = osim;
                   }
                   //control osim load from '<osim directory path>';
                   //restore table DDLs, constraints, views on dev machine,
                   //using information in <osim directory path>, which is collected from production cluster,
                   //when qualified names of any existing objects conflict with objects to be loaded, 
                   //if ',FORCE' is present, drop the existing objects, otherwise abort.
                   |TOK_CONTROL TOK_OSIM TOK_LOAD TOK_FROM character_string_literal optional_osim_force
                   {
                      OSIMControl *osim = new (PARSERHEAP()) OSIMControl( OptimizerSimulator::LOAD, 
                                                                                    *$5,
                                                                                    $6,
                                                                                    PARSERHEAP());
                      $$ = osim;
                   }
                   //control osim simulate start;
                   //setup runtime information on dev machine for simulation production cluster in plan generation, 
                   //must run right after "constrol osim load ..." is issued.
                   |TOK_CONTROL TOK_OSIM TOK_SIMULATE TOK_START
                   {
                      OSIMControl *osim = new (PARSERHEAP()) OSIMControl( OptimizerSimulator::SIMULATE, 
                                                                                    *(new (PARSERHEAP()) NAString("")),
                                                                                    FALSE,
                                                                                    PARSERHEAP());
                      $$ = osim;
                   }
                   //control osim simulate continue '<osim diretory path>';
                   //setup runtime information on dev machine for simulation, 
                   //this command is used to continue a simulation in a new SQL session.
                   |TOK_CONTROL TOK_OSIM TOK_SIMULATE TOK_CONTINUE character_string_literal
                   {
                      OSIMControl *osim = new (PARSERHEAP()) OSIMControl( OptimizerSimulator::SIMULATE, 
                                                                                    *$5,
                                                                                    FALSE,
                                                                                    PARSERHEAP());
                      $$ = osim;
                   }
                   //control osim unload '<osim directory path>';
                   //cleanup tables created by "control osim load from ..." command, 
                   //the acutal action is to drop tables in <osim directory path>/CREATE_TABLE_DDLS.txt, 
                   //and objects that refer them.
                   |TOK_CONTROL TOK_OSIM TOK_UNLOAD character_string_literal
                   {
                      OSIMControl *osim = new (PARSERHEAP()) OSIMControl( OptimizerSimulator::UNLOAD, 
                                                                                    *$4,
                                                                                    FALSE,
                                                                                    PARSERHEAP());                                                            
                      $$ = osim;
                   }
optional_osim_force: ',' TOK_FORCE
                   {
                       $$ = TRUE;
                   }
                   |empty
                   { 
                       $$ = FALSE; 
                   }
/* type relx */
/* Except where noted (the Ansi flavor of SET CATALOG and of SET SCHEMA),
 * all of these are Tandem syntax extensions.
 */
declare_or_set_cqd: TOK_DECLARE TOK_CATALOG character_string_literal
                                {
				  PARSERASSERT((CharInfo::CharSet)SQLTEXTCHARSET() == CharInfo::UTF8);
				  $$ = new (PARSERHEAP())
				    ControlQueryDefault(
				      SQLTEXT(), CharInfo::UTF8, "CATALOG", *$3/*character_string_literal*/);
				}
                  | TOK_DECLARE TOK_CATALOG sql_mx_catalog_name
                                {
				  *$3 = ToAnsiIdentifier(*$3);
				  $$ = new (PARSERHEAP())
				    ControlQueryDefault(
				      SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "CATALOG", *$3);
				}

		  | TOK_DECLARE TOK_SCHEMA character_string_literal
                                {
				  if (! validateVolatileSchemaName(*$3/*character_string_literal*/))
				    {
				      YYERROR;
				    }
				  
				  PARSERASSERT((CharInfo::CharSet)SQLTEXTCHARSET() == CharInfo::UTF8);
				  $$ = new (PARSERHEAP())
				    ControlQueryDefault(
					 SQLTEXT(), CharInfo::UTF8, "SCHEMA", *$3/*character_string_literal*/);
				}

          | TOK_DECLARE TOK_SCHEMA schema_name
                {
				  
				  NAString tmpSchema($3->getSchemaNameAsAnsiString());
		  if (! validateVolatileSchemaName(tmpSchema))
		    {
		      YYERROR;
		    }
		  
				  $$ = new (PARSERHEAP())
				    ControlQueryDefault(
				      SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(),"SCHEMA", tmpSchema);
				}
                  | TOK_DECLARE TOK_NAMETYPE character_string_literal
                                {
                                  // DEFAULT_CHARSET has no effect on character_string_literal in this context
                                  $$ = new (PARSERHEAP())
                                    ControlQueryDefault(
                                      SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "NAMETYPE", *$3);
				}
                  | TOK_DECLARE TOK_NAMETYPE regular_identifier
                                {
                                  $$ = new (PARSERHEAP())
                                    ControlQueryDefault(
                                      SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "NAMETYPE", *$3);
				}

		  /* The SET flavor is dynamic (the extra TRUE flag).
		  /* See the comments way at the top for when
		  /* normalizeDynamicCQD() needs to be called.
		  /*/
                  | TOK_SET TOK_CATALOG character_string_literal
                                {
				  // ANSI 16.1
				  //## 'literal' needs to be char-expr (hv, etc)
// EJF L4J - CQD dynamic are not allowed in Compound Statements
                      if (beginsWith(SQLTEXT(),"BEGIN"))  {
                        *SqlParser_Diags << DgSqlCode(-3175);
                        YYERROR;
                        }
                      else  { // business as usual
                        PARSERASSERT((CharInfo::CharSet)SQLTEXTCHARSET() == CharInfo::UTF8);
                        $$ = new (PARSERHEAP())
                        ControlQueryDefault(
                        SQLTEXT(), CharInfo::UTF8, "CATALOG", *$3/*character_string_literal*/, TRUE);
			}
                      }
                  | TOK_SET TOK_CATALOG sql_mx_catalog_name
                                {
// EJF L4J - CQD dynamic are not allowed in Compound Statements
                      if (beginsWith(SQLTEXT(),"BEGIN"))  {
                        *SqlParser_Diags << DgSqlCode(-3175);
                        YYERROR;
                        }
                      else  { // business as usual
						// normalizeDynamicDQD requires the catalog in the original charset.
						NAString tmpCatalog(ToAnsiIdentifier(*$3));
				  $$ = normalizeDynamicCQD(
				    "CATALOG", tmpCatalog);
				}
                        }

                  | TOK_SET TOK_SCHEMA character_string_literal
                        {
		       	  // ANSI 16.2
			  //## 'literal' needs to be char-expr (hv, etc)
			  // EJF L4J - CQD dynamic are not allowed in Compound Statements
			  if (beginsWith(SQLTEXT(),"BEGIN"))  {
			    *SqlParser_Diags << DgSqlCode(-3175);
			    YYERROR;
			  }
			  else  { // business as usual
			    if (! validateVolatileSchemaName(*$3/*character_string_literal*/))
			      {
				YYERROR;
			      }
			    
			    PARSERASSERT((CharInfo::CharSet)SQLTEXTCHARSET() == CharInfo::UTF8);
			    $$ = new (PARSERHEAP())
			      ControlQueryDefault(
				   SQLTEXT(), CharInfo::UTF8, "SCHEMA", *$3/*character_string_literal*/, TRUE);
			  }
                        }
                  | TOK_SET TOK_SCHEMA schema_name
                        {
			  // EJF L4J - CQD dynamic are not allowed in Compound Statements
			  if (beginsWith(SQLTEXT(),"BEGIN"))  {
			    *SqlParser_Diags << DgSqlCode(-3175);
			    YYERROR;
			  }
			  else  { // business as usual
				  NAString tmpSchema($3->getSchemaNameAsAnsiString());

				  if (! validateVolatileSchemaName(tmpSchema))
				    {
				      YYERROR;
				    }
				  
				  // normalizeDynamicCQD requires the schema in the original charset.
				  $$ = normalizeDynamicCQD(
				       "SCHEMA", tmpSchema
				       );
			  }
			}
                  | TOK_SET TOK_NAMETYPE character_string_literal
                                {
                                  // DEFAULT_CHARSET has no effect on character_string_literal in this context
                                  $$ = new (PARSERHEAP())
                                    ControlQueryDefault(
                                      SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "NAMETYPE", *$3, TRUE);
                                }
                  | TOK_SET TOK_NAMETYPE regular_identifier
                                {
				  $$ = normalizeDynamicCQD(
				    "NAMETYPE", *$3);
				}

/* type tokval */
query_shape_options : TOK_IMPLICIT TOK_EXCHANGE
                        {
			  $$ = $2;
			}
                      | TOK_WITHOUT TOK_EXCHANGE
                        {
			  $$ = $2;
			}
                      | TOK_IMPLICIT TOK_SORT
                        {
			  $$ = $2;
			}
                      | TOK_WITHOUT TOK_SORT
                        {
			  $$ = $2;
			}
                      | TOK_IMPLICIT TOK_EXCHANGE_AND_SORT
                        {
			  $$ = $2;
			}
                      | TOK_IMPLICIT TOK_ENFORCERS
                        {
			  $$ = $2;
			}
                      | TOK_WITHOUT TOK_EXCHANGE_AND_SORT
                        {
			  $$ = $2;
			}
                      | TOK_WITHOUT TOK_ENFORCERS
                        {
			  $$ = $2;
			}
                      | /* empty */
                        {
			  $$ = TOK_FALSE;
			}

/* type exprnode */
query_shape_control : shape_identifier
				{
				  // tuple, cut, scan and misc. others are nodes
				  // that are allowed without any arguments,
				  // TYPE1 and TYPE2 are allowed as 3rd or 4th
				  // arguments of join plan shapes
				  if (*$1 == "TUPLE")
				    {
				      $$ = new (PARSERHEAP()) Tuple();
				    }
				  else if (*$1 == "CUT" OR
					   *$1 == "ANYTHING" OR
					   *$1 == "OFF" OR
					   *$1 == "INSERT" OR
					   *$1 == "UPDATE" OR
					   *$1 == "UPDATE_UNIQUE" OR
					   *$1 == "DELETE" OR
					   *$1 == "DELETE_UNIQUE"
					   )
				    {
				      $$ = new (PARSERHEAP()) CutOp(0);
				    }
				  else if (*$1 == "SCAN" OR
					   *$1 == "FILE_SCAN" OR
					   *$1 == "INDEX_SCAN" )
				    {
				      $$ = new (PARSERHEAP()) ScanForceWildCard();
				    }
                                  else if (*$1 == "EXPLAIN")
                                    {
                                      $$ = new (PARSERHEAP()) ExplainFunc();
                                    }
				  else if (*$1 == "ISOLATED_SCALAR_UDF" )
				    {
				      $$ = new (PARSERHEAP()) UDFForceWildCard(REL_FORCE_ANY_SCALAR_UDF);
				    }
				  else if (*$1 == "TMUDF" )
				    {
				      $$ = new (PARSERHEAP()) WildCardOp(REL_ANY_LEAF_TABLE_MAPPING_UDF);
				    }
				  else if (*$1 == "FAST_EXTRACT" ||
                                           *$1 == "HIVE_INSERT")
				    {
				      $$ = new (PARSERHEAP()) WildCardOp(REL_ANY_EXTRACT);
				    }
				  else if (*$1 == "FORWARD")
				    {
				      $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)->setScanOptions(ScanForceWildCard::DIRECTION_FORWARD);
				    }
				  else if (*$1 == "REVERSE")
				    {
				      $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)->setScanOptions(ScanForceWildCard::DIRECTION_REVERSED);
				    }
				  // The following 5 cases (DENSE,SPARSE,SYSTEM,TYPE1,and TYPE2)
				  // will be better handled via a new class (derived from ExprNode)
				  // that can pass the information. The problem with passing it 
				  // using ConstValue objects is the possible confusion with
				  // literals passed similarly
				  else if (*$1 == "SPARSE")
				    {
				      $$ = new (PARSERHEAP()) ConstValue(_SPARSE_);
				    }
				  else if (*$1 == "DENSE")
				    {
				      $$ = new (PARSERHEAP()) ConstValue(_DENSE_);
				    }
				  else if (*$1 == "SYSTEM")
				    {
				      $$ = new (PARSERHEAP()) ConstValue(_SYSTEM_);
				    }
				  else if (*$1 == "PLAN0")
				    {
				      $$ = new (PARSERHEAP()) ConstValue("PLAN0");
				    }
				  else if (*$1 == "PLAN1")
				    {
				      $$ = new (PARSERHEAP()) ConstValue("PLAN1");
				    }
				  else if (*$1 == "PLAN2")
				    {
				      $$ = new (PARSERHEAP()) ConstValue("PLAN2");
				    }
				  else if (*$1 == "PLAN3")
				    {
				      $$ = new (PARSERHEAP()) ConstValue("PLAN3");
				    }
				  else if (*$1 == "TYPE1")
				    {
				      $$ = new (PARSERHEAP()) ConstValue("TYPE1");
				    }
				  else if (*$1 == "TYPE2")
				    {
				      $$ = new (PARSERHEAP()) ConstValue("TYPE2");
				    }
                                  else if (*$1 == "INDEXJOIN")
                                    {
                                      $$ = new (PARSERHEAP()) ConstValue("INDEXJOIN");
                                    }
				  else if (*$1 == "GROUP")
				    {
				      $$ = new (PARSERHEAP()) ConstValue("GROUP");
				    }
				  else if (*$1 == "SPLIT")
				    {
				      $$ = new (PARSERHEAP()) ConstValue("SPLIT");
				    }
				  else if (*$1 == "REPART")
				    {
				      $$ = new (PARSERHEAP()) ConstValue("REPART");
				    }
				  else if (*$1 == "HOLD")
				    {
				      $$ = new (PARSERHEAP())
				       ControlQueryShape(
				         NULL, SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), TRUE);
				    }
				  else if (*$1 == "RESTORE")
				    {
				      $$ = new (PARSERHEAP())
				       ControlQueryShape(
				         NULL, SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), FALSE);
				    }
				  else
				    {

				      *SqlParser_Diags << DgSqlCode(-3113) <<
					DgString0(NAString(*$1) +
						  " is not a valid shape directive (at least not when used without arguments).");
				      yyerror("");
				      YYERROR;
				    }
				}
	      | literal
				{
				  // this could be a tablename or another
				  // argument to some node
				  $$ = $1;
				}

	      | shape_identifier literal
				{
				  // this can be a scan option

				  NABoolean dummyNegate = FALSE;
				  ConstValue *cv = $2->castToConstValue(dummyNegate);
                                  const NAType *nat = NULL;

                                  if (cv)
                                    nat = cv->getType();

                                  if (cv && nat->getTypeQualifier() == NA_CHARACTER_TYPE)
                                    {
                                      NAString * tempstr =
                                        charToChar((Lng32)CharInfo::UTF8, // targetCS
                                                   (const char *) cv->getConstValue(),
                                                   cv->getStorageSize(), 
                                                   (Lng32)((CharType *) nat)->getCharSet(), // sourceCS
                                                   PARSERHEAP());
                                      if (tempstr == NULL)
                                        {
                                          *SqlParser_Diags << DgSqlCode(-3113) << 
                                            DgString0("Error converting scan shape argument to UTF-8");
                                          return NULL;
                                        }
                                      cv = new (PARSERHEAP()) ConstValue (*tempstr, CharInfo::UTF8);
                                      delete tempstr;
                                      nat = cv->getType();
                                    }

				  if (*$1 == "TABLE")
				    {
				      if (!cv)
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Character constant for table name expected.");
					  return NULL;
					}
				      if (nat->getTypeQualifier() == NA_CHARACTER_TYPE)
					{
					  NAString tableName ((char *) cv->getConstValue(),
                                                              (size_t) cv->getStorageSize());
					  if (tableName != "")
					    {
					      ComObjectName tname ( tableName
					                          , COM_TABLE_NAME
					                          , FALSE // NABoolean createDropAlias - n/a
					                          , PARSERHEAP() // CollHeap * h
					                          , NASTRING_ALLOW_NSK_GUARDIAN_NAME_FORMAT // unsigned short pv_flags
					                          );
					      tableName = tname.getExternalName();
					      if (tableName == "")
						{
						  *SqlParser_Diags << DgSqlCode(-3113) <<
						    DgString0("Table name is not an ANSI name.");
						  return NULL;
						}
					      $$ = new (PARSERHEAP()) ScanForceWildCard(tableName);
					    }						  
					  else
					    {
					      *SqlParser_Diags << DgSqlCode(-3113) <<
						DgString0("Expected non Empty String for table name.");
					      return NULL;
					    }
					}
				      else
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Character constant for table name expected.");
					  return NULL;
					}
				    }
				  
				  else if ((*$1 == "ACCESS_PATH")||(*$1 == "PATH"))
				    {
				      if (!cv)
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for access path.");
					  return NULL;
					}
				      if (nat->getTypeQualifier() == NA_CHARACTER_TYPE)
					{
					  NAString indexName ((char *) cv->getConstValue(),
                                                              (size_t) cv->getStorageSize());
					  if (indexName != "")
					    {
					      ComObjectName iname ( indexName
					                          , COM_INDEX_NAME
					                          , FALSE // NABoolean createDropAlias - n/a
					                          , PARSERHEAP() // CollHeap * h
					                          , NASTRING_ALLOW_NSK_GUARDIAN_NAME_FORMAT // unsigned short pv_flags
					                          );
					      indexName = iname.getExternalName();
					      if (indexName == "")
						{
						  *SqlParser_Diags << DgSqlCode(-3113) <<
						    DgString0("Index name is not an ANSI name.");
						  return NULL;
						}
					      $$ = new (PARSERHEAP()) ScanForceWildCard();
					      ((ScanForceWildCard*)$$)->setIndexName(indexName);
					    }						  
					  else
					    {
					      *SqlParser_Diags << DgSqlCode(-3113) <<
						DgString0("Expected non Empty String for index name. use ACCESS_PATH ANY for system decision.");
					      return NULL;
					    }
					}
				      else
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for access path.");
					  return NULL;
					}
				    }
				  
				  else if ((*$1 == "MDAM_COLUMNS"))
				    {
				      short numColumns;
				      if (!cv)
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for MDAM_COLUMNS.");
					  return NULL;
					}
				      if (nat->getTypeQualifier() == NA_NUMERIC_TYPE)
					{
					  if (cv->getStorageSize() > 2)
					    {
					      *SqlParser_Diags << DgSqlCode(-3113) <<
						DgString0("Number of columns (short int) expected.");
					      return NULL;
					    }
					  numColumns = 
                                            (cv->getStorageSize() == 1 
                                             ? *((Int8*) cv->getConstValue()) 
                                             : *((short *) cv->getConstValue()));
					}
				      else
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for MDAM_COLUMNS.");
					  return NULL;
					}
				      $$ = new (PARSERHEAP()) ScanForceWildCard();
				      ((ScanForceWildCard*)$$)->setColumnOptions((Int32)numColumns,
								ScanForceWildCard::MDAM_COLUMNS_NO_MORE);
				    }

				  else if ((*$1 == "BLOCKS_PER_ACCESS"))
				    {
				      Lng32 blocksPerAccess;
				      if (!cv)
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for BLOCKS_PER_ACCESS.");
					  return NULL;
					}
				      if (nat->getTypeQualifier() == NA_NUMERIC_TYPE)
					{
                                          if (cv->getStorageSize() <= 1)
                                            blocksPerAccess = *((Int8 *) cv->getConstValue());
                                          else if (cv->getStorageSize() <= 2)
                                            blocksPerAccess = *((short *) cv->getConstValue());
                                          else if (cv->getStorageSize() <= 4)
                                            blocksPerAccess = *((Lng32 *) cv->getConstValue());
                                          else
                                            {
                                              *SqlParser_Diags << DgSqlCode(-3113) <<
                                                DgString0("Illegal argument for BLOCKS_PER_ACCESS.");
                                              return NULL;
                                            }

					}
				      else
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for BLOCKS_PER_ACCESS.");
					  return NULL;
					}
				      $$ = new (PARSERHEAP()) ScanForceWildCard();
				      ((ScanForceWildCard*)$$)->setNumberOfBlocksToReadPerAccess(blocksPerAccess);
				    } // blocks_per_access
				  
				  // Handle "SCALAR_UDF 'functionname' and "UDF_ACTION 'actionname'".  
				  // These are the function name and action name, respectively, for a UDF.
				  else if (*$1 == "SCALAR_UDF" || *$1 == "UDF_ACTION")
				    {
				      if (!cv)
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Character constant for function/action names expected.");
					  return NULL;
					}
				      if (nat->getTypeQualifier() == NA_CHARACTER_TYPE)
					{
					  NAString name ((char *) cv->getConstValue(),
                                                              (size_t) cv->getStorageSize());
					  if (name != "")
					    {
					      if (*$1 == "SCALAR_UDF")
					      {
  					        ComObjectName oname(name, COM_TABLE_NAME);
					        name = oname.getExternalName();
					        if (name == "")
						{
						  *SqlParser_Diags << DgSqlCode(-3113) <<
						     DgString0("Function name is not an ANSI name.");
						  return NULL;
						}
					        $$ = new (PARSERHEAP()) UDFForceWildCard(name, "");
					      }
					      else
					        $$ = new (PARSERHEAP()) UDFForceWildCard("", name);
 					    }						  
					  else
					    {
					      *SqlParser_Diags << DgSqlCode(-3113) <<
						DgString0("Expected non Empty String for function/action name.");
					      return NULL;
					    }
					}
				      else
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Character constant for function/action name expected.");
					  return NULL;
					}
				    }
				  else
				    {
				      *SqlParser_Diags << DgSqlCode(-3113) <<
					DgString0(NAString(*$1) +
						  " is not a valid shape directive (at least not when used with the given argument).");
				      yyerror("");
				      YYERROR;
				    }
				}
	      
	      | shape_identifier shape_identifier
		                {
				  if ((*$1 == "ACCESS_PATH")||(*$1 == "PATH"))	
				    {
				      if (*$2 == "ANY")
					{
					  $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)->setScanOptions(ScanForceWildCard::INDEX_SYSTEM); 	
					}
				      else
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for access path.");
					  return NULL;
					}
				    }
				  
				  else if (*$1 == "MDAM")
				    {
				      if (*$2 == "SYSTEM")
					{
					  $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)->setScanOptions(ScanForceWildCard::MDAM_SYSTEM); 	
					}
				      else if (*$2 == "OFF")
					{
					  $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)->setScanOptions(ScanForceWildCard::MDAM_OFF); 	
					}
				      else if (*$2 == "FORCED")
					{
					  $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)->setScanOptions(ScanForceWildCard::MDAM_FORCED); 	
					}
				      else
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for MDAM.");
					  return NULL;
					}
				    }
				  
				  else if (*$1 == "MDAM_COLUMNS")
				    {
				      if (*$2 == "SYSTEM")
					{
					  $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)
					    ->setColumnOptions(0,ScanForceWildCard::MDAM_COLUMNS_REST_BY_SYSTEM);	
					}
				      else if (*$2 == "ALL")
					{
					  $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)
					    ->setColumnOptions(0,ScanForceWildCard::MDAM_COLUMNS_ALL); 	
					}
				      else
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for MDAM_COLUMNS.");
					  return NULL;
					}
				    }
				  
				  else if (*$1 == "DIRECTION")
				    {
				      if (*$2 == "SYSTEM")
					{
					  $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)->setScanOptions(ScanForceWildCard::DIRECTION_SYSTEM); 	
					}
				      else if (*$2 == "FORWARD")
					{
					  $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)->setScanOptions(ScanForceWildCard::DIRECTION_FORWARD); 	
					}
				      else if (*$2 == "REVERSE")
					{
					  $$ = new (PARSERHEAP()) ScanForceWildCard();
					  ((ScanForceWildCard*)$$)->setScanOptions(ScanForceWildCard::DIRECTION_REVERSED); 	
					}
				      else
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for direction.");
					  return NULL;
					}
				    }
				  else
				    {
				      *SqlParser_Diags << DgSqlCode(-3113) <<
					DgString0("The statement <" + NAString(*$1) + " " + NAString(*$2)
						  + "> is not a valid shape directive.");
				      yyerror("");
				      YYERROR;
				    }
				}			  
	      
	      | shape_identifier '(' shape_arg_list ')'
		                {
				  $$ = DecodeShapeSyntax(*$1, $3,
				  			 SqlParser_Diags,
							 PARSERHEAP());
				  if ($$ == NULL)
				    {
				      yyerror("");
				      YYERROR;
				    }
				  delete $1;
				  delete $3;
				}
	
	      | shape_identifier shape_identifier '(' shape_arg_list ')'
				{
				  if (*$1 == "MDAM_COLUMNS")	
				    {
				      $$ = new (PARSERHEAP()) ScanForceWildCard();
				      NABoolean dummyNegate = FALSE;
				      Int32 numColumns = $4->entries();
				      ItemExpr *itm;
				      
				      ScanForceWildCard::scanOptionEnum* columnAlgorithms
					= new (PARSERHEAP()) ScanForceWildCard::scanOptionEnum[numColumns];
				      
				      for (Int32 i=0; i<numColumns; i++)
					{
					  itm = $4->at(i)->castToItemExpr();
					  if (itm == NULL OR 
					      itm->castToConstValue(dummyNegate) == NULL)
					    {
					      *SqlParser_Diags << DgSqlCode(-3113) <<
						DgString0("Illegal MDAM_COLUMNS (...) argument");
					      return NULL;
					    }
					  const NAType *nat = itm->castToConstValue(dummyNegate)->getType();
					  if (nat->getTypeQualifier() != NA_NUMERIC_TYPE)
					    {
					      *SqlParser_Diags << DgSqlCode(-3113) <<
						DgString0("Illegal MDAM_COLUMNS (...) argument");
					      return NULL;
					    }
					  short arg =
					    *((short *) itm->castToConstValue(dummyNegate)->getConstValue());
					  
					  if (arg == _SYSTEM_)
					    {
					      columnAlgorithms[i] = ScanForceWildCard::COLUMN_SYSTEM;
					    }
					  else if (arg == _SPARSE_)
					    {
					      columnAlgorithms[i] = ScanForceWildCard::COLUMN_SPARSE;
					    }
					  else if (arg == _DENSE_)
					    {
					      columnAlgorithms[i] = ScanForceWildCard::COLUMN_DENSE;
					    }
					  else
					    {
					      *SqlParser_Diags << DgSqlCode(-3113) <<
						DgString0("Illegal MDAM_COLUMNS (...) argument.");
					      return NULL;
					    }
					}
				      if (*$2 == "ALL")
					{
					  ((ScanForceWildCard*)$$)->
					    setColumnOptions(numColumns, columnAlgorithms,
							     ScanForceWildCard::MDAM_COLUMNS_ALL);
					}
				      else if (*$2 == "SYSTEM")
					{
					  ((ScanForceWildCard*)$$)->
					    setColumnOptions(numColumns, columnAlgorithms,
							     ScanForceWildCard::MDAM_COLUMNS_REST_BY_SYSTEM);
					}
				      else
					{
					  *SqlParser_Diags << DgSqlCode(-3113) <<
					    DgString0("Illegal argument for MDAM_COLUMNS.");
					  return NULL;
					}
				    }

				  else
				  {
				    *SqlParser_Diags << DgSqlCode(-3113) <<
					DgString0("The statement <" + NAString(*$1) + " " + NAString(*$2)
					+ " (...)> is not a valid shape directive.");
				    yyerror("");
				    YYERROR;
				  }
				}

/* type stringval */
shape_identifier : identifier
	      | token_shape_identifier
                                {
				  // some of the shape identifiers are actually
				  // keywords recognized by the parser
                                  $$ = unicodeToChar
					 (
                                          ToTokvalPlusYYText(&$1)->yytext,
					  ToTokvalPlusYYText(&$1)->yyleng,
					   (CharInfo::CharSet) (
					                        ComGetNameInterfaceCharSet()
					                        ),
					  PARSERHEAP());
				  // upshift the text, a regular
				  // identifier gets upshifted as well
				  $$->toUpper();
                                }

/* type tokval */
token_shape_identifier : TOK_JOIN
	      | TOK_UNION
              | TOK_OFF
	      | TOK_ANY
	      | TOK_ALL
	      | TOK_TABLE
	      | TOK_GROUP
              | TOK_TRANSPOSE
              | TOK_INSERT
              | TOK_UPDATE
              | TOK_DELETE

/* type exprnodeptrs */
shape_arg_list : query_shape_control
				{
				  $$ = new (PARSERHEAP())
					    ExprNodePtrList(PARSERHEAP());
				  $$->insert($1);
				}
	      | shape_arg_list ',' query_shape_control
				{
				  $1->insert($3);
				  $$ = $1;
				}
qid_identifier : identifier
                  {
                    $$ = $1;
                   }
                  | TOK_CURRENT
                  {
                    $$ = new (PARSERHEAP()) NAString("CURRENT", PARSERHEAP());
                  }
/* type relx */
/* See RelControl.h and NADefaults.cpp for why the separate reset() counter */
/* ODBC and SQLCI need the RESET (and RESET RESET) capability */
query_default_control : default_identifier QUOTED_STRING
                   {
                     // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                     // Need convert schema name to ISO_MAPPING character set before
                     // validating...
		     if (*$1 == "SCHEMA")
		       {
			 if (! validateVolatileSchemaName(*$2))
			   {
			     YYERROR;
			   }
		       }

		     $$ = new (PARSERHEAP())
		     		ControlQueryDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$1,*$2);
		   }
	      |		default_identifier TOK_RESET
                   {
		     $$ = new (PARSERHEAP())
		     		ControlQueryDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$1,"");
		     ((ControlAbstractClass *)$$)->reset() = 1;
		   }
	      |		'*' TOK_RESET
                   {
		     $$ = new (PARSERHEAP())
		     		ControlQueryDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "","");
		     ((ControlAbstractClass *)$$)->reset() = 1;
		   }
	      |		'*' TOK_RESET TOK_RESET
                   {
		     $$ = new (PARSERHEAP())
		     		ControlQueryDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "","RESET");
		     ((ControlAbstractClass *)$$)->reset() = 2;
		   }
              |		default_identifier TOK_HOLD
                   {
		     $$ = new (PARSERHEAP())
		     		ControlQueryDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$1,"", FALSE, 1);
		   }
              |		default_identifier TOK_RESTORE
                   {
		     $$ = new (PARSERHEAP())
		     		ControlQueryDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$1,"", FALSE, 2);
		   }
	

/* type stringval */
/* We do NOT allow '*' here; it's meaningless and breaks NADefaults */
default_identifier : identifier
		   {
		   }
              | TOK_CATALOG
                   {
		     $$ = new (PARSERHEAP()) NAString("CATALOG", PARSERHEAP());
		   }
              | TOK_SCHEMA
                   {
		     $$ = new (PARSERHEAP()) NAString("SCHEMA", PARSERHEAP());
		   }

/* type relx */
/*   Notice that we allow all of
 *             CONTROL TABLE table_name * 'value';
 *             CONTROL TABLE * * 'value';
 *
 *   All the table wildcards (*) are CorrName("*",TRUE), i.e. isFabricated.
 *   All the token wildcards (*) and RESET's are EMPTY NAStrings ("", not "*").
 */
table_control : table_name table_control_identifier QUOTED_STRING
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                  // Need to convert table_name to ISO_MAPPING character set ???
		  $$ = new (PARSERHEAP()) ControlTable($1, SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$2, *$3);
		}
              | '*'        table_control_identifier QUOTED_STRING
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		  $$ = new (PARSERHEAP()) ControlTable(
			 new (PARSERHEAP()) CorrName("*", TRUE, PARSERHEAP()),
			 SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$2, *$3);
		}

              | table_name table_control_identifier TOK_RESET
                {
                  // Need to convert table_name to ISO_MAPPING character set ???
		  $$ = new (PARSERHEAP()) ControlTable($1, SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$2, "");
		  ((ControlAbstractClass *)$$)->reset() = 1;
		}
              | '*'        table_control_identifier TOK_RESET
                {
		  $$ = new (PARSERHEAP()) ControlTable(
			 new (PARSERHEAP()) CorrName("*", TRUE, PARSERHEAP()),
			 SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$2, "");
		  ((ControlAbstractClass *)$$)->reset() = 1;
		}

              | table_name TOK_RESET	/* synonym for <table_name '*' RESET> */
                {
                  // Need to convert table_name to ISO_MAPPING character set ???
		  $$ = new (PARSERHEAP()) ControlTable($1, SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "", "");
		  ((ControlAbstractClass *)$$)->reset() = 1;
		}
              | '*'        TOK_RESET	/* synonym for <'*' '*' RESET> */
                {
		  $$ = 
		    new (PARSERHEAP()) ControlTable(
			 new (PARSERHEAP()) CorrName("*", TRUE, PARSERHEAP()),
			 SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "", "");
		  ((ControlAbstractClass *)$$)->reset() = 1;
		}

/* type stringval */
table_control_identifier: identifier
	      | '*'	{ $$ = new (PARSERHEAP()) NAString(); }

/* type relx */
session_control : QUOTED_STRING QUOTED_STRING
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		  $$ = new (PARSERHEAP()) ControlSession(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$1, *$2);
		}
	      | TOK_SET QUOTED_STRING QUOTED_STRING
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		  $$ = new (PARSERHEAP()) ControlSession(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$2, *$3);
		}

              | QUOTED_STRING TOK_RESET 
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		  $$ = new (PARSERHEAP()) ControlSession(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$1, "");
		  ((ControlAbstractClass *)$$)->reset() = 1;
		}
              | TOK_RESET QUOTED_STRING
                {
                  // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		  $$ = new (PARSERHEAP()) ControlSession(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$2, "");
		  ((ControlAbstractClass *)$$)->reset() = 1;
		}

              | '*' TOK_RESET 
                {
		  $$ = new (PARSERHEAP()) ControlSession(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "", "");
		  ((ControlAbstractClass *)$$)->reset() = 1;
		}
              | TOK_RESET '*'
                {
		  $$ = new (PARSERHEAP()) ControlSession(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "", "");
		  ((ControlAbstractClass *)$$)->reset() = 1;
		}

/* type describeType */
showcontrol_type:
	    '*'				{ $$ = Describe::CONTROL_ALL_; }
	  | TOK_ALL			{ $$ = Describe::CONTROL_ALL_; }
          | TOK_SHAPE			{ $$ = Describe::CONTROL_SHAPE_; }
          | TOK_QUERY TOK_SHAPE		{ $$ = Describe::CONTROL_SHAPE_; }
          | TOK_DEFAULT			{ $$ = Describe::CONTROL_DEFAULTS_; }
          | TOK_DEFAULTS		{ $$ = Describe::CONTROL_DEFAULTS_; }
          | TOK_QUERY TOK_DEFAULT	{ $$ = Describe::CONTROL_DEFAULTS_; }
          | TOK_QUERY TOK_DEFAULTS	{ $$ = Describe::CONTROL_DEFAULTS_; }
          | TOK_TABLE			{ $$ = Describe::CONTROL_TABLE_; }
          | TOK_SESSION			{ $$ = Describe::CONTROL_SESSION_; }

showplan_starting_tokens : TOK_SHOWPLAN showplan_options
                           {
                             SqlParser_CurrentParser->hiveDDLInfo_->essd_ = Parser::HiveDDLInfo::SHOWPLAN_;

                             char buf[40];
                             SqlParser_CurrentParser->hiveDDLInfo_->essdQueryStartPos_ = 9;

                             if ($2 != 0)
                               {
                                 SqlParser_CurrentParser->hiveDDLInfo_->essdOptions_ = 
                                   str_itoa($2, buf);

                                 SqlParser_CurrentParser->hiveDDLInfo_->essdQueryStartPos_ += strlen("option ") + strlen("'t'");
                               }

                             $$ = $2;
                           }

/* type relx */
show_statement:
	     TOK_SHOWCONTROL showcontrol_type 
		    optional_control_identifier optional_comma_match_clause 
             {
	       // For this Describe, the putative 'tableName' parameter
	       // is really our optional identifier.
	       // And another kludge, we pass ",MATCH FULL" in 'corr name'.
               CorrName id;
	       NABoolean showHeader = TRUE;
               
               if ($3)
	          id = CorrName(*$3, PARSERHEAP());
               else
	          id = CorrName("", PARSERHEAP());
	       if ($3 && $4 == Describe::MATCH_FULL_) 
	         id.setCorrName("FULL");
	       else if ($3 && $4 == Describe::MATCH_FULL_NO_HEADER_) {
	         id.setCorrName("FULL");
		 showHeader = FALSE;
	       }

	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
			 Describe(SQLTEXT(), id, $2, COM_TABLE_NAME, 0, showHeader),
			 REL_ROOT,	
			 new (PARSERHEAP())
			 ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	     }
	   | TOK_SHOWDDL table_name ',' TOK_EXPLAIN
	     {
               // this option is not supported and causes a crash.
               // It either need to fixed or removed.
               *SqlParser_Diags <<  DgSqlCode(-3131);
               YYERROR;

               CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
	       NAString * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
	                                       , PARSERHEAP() // in  - NAMemory * heapUsedForOutputBuffers
	                                       );
	       // If we can not get a variable-width multi-byte or single-byte string here, report error 
	       if ( stmt == NULL )
                 {
                   *SqlParser_Diags <<  DgSqlCode(-3406);
                   YYERROR;
                 }

               DDLExpr * de = new(PARSERHEAP()) DDLExpr
                 (NULL,
                  (char*)stmt->data(), 
                  stmtCharSet,
                  PARSERHEAP());
               
               de->setShowddlExplain(TRUE);
               de->setExplObjName($2->getQualifiedNameObj());

	       ExeUtilDisplayExplainComplex * eue =
		 new (PARSERHEAP()) 
		 ExeUtilDisplayExplainComplex((char*)stmt->data(),
					      stmtCharSet,
					      NULL,
					      de,
					      PARSERHEAP());
	       
	       $$ = eue;
	     }
	   | TOK_SHOWDDL table_name ',' TOK_EXPLAIN ',' TOK_NO TOK_LABEL TOK_STATISTICS
	     {
               // this option is not supported and causes a crash.
               // It either need to fixed or removed.
               *SqlParser_Diags <<  DgSqlCode(-3131);
               YYERROR;

	       CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
	       NAString  * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
						, PARSERHEAP() // in  - NAMemory * heapUsedForOutputBuffers
						);
	       // If we can not get a variable-width multi-byte or single-byte string here, report error 
	       if ( stmt == NULL )
	       {
	         *SqlParser_Diags <<  DgSqlCode(-3406);
	         YYERROR;
	       }

               DDLExpr * de = new(PARSERHEAP()) DDLExpr
                 (NULL,
                  (char*)stmt->data(), 
                  stmtCharSet,
                  PARSERHEAP());
               
               de->setShowddlExplain(TRUE);
               de->setNoLabelStats(TRUE);
               de->setExplObjName($2->getQualifiedNameObj());

	       ExeUtilDisplayExplainComplex * eue =
		 new (PARSERHEAP()) 
		 ExeUtilDisplayExplainComplex((char*)stmt->data(),
                                              stmtCharSet,
					      NULL,
					      de,
					      PARSERHEAP());
	       
	       $$ = eue;
	     }
	   | TOK_SHOWDDL table_name ',' TOK_EXPLAIN TOK_INTERNAL ',' attribute_num_rows_clause
	     {
	       double numRows = $7->castToElemDDLFileAttrPOSTableSize()->getNumRows();
	       CharInfo::CharSet stmtCharSet = CharInfo::UnknownCharSet;
	       NAString  * stmt = getSqlStmtStr ( stmtCharSet  // out - CharInfo::CharSet &
	                                        , PARSERHEAP() // in  - NAMemory * heapUsedForOutputBuffers
	                                        );
	       // If we can not get a variable-width multi-byte or single-byte string here, report error 
	       if ( stmt == NULL )
	       {
	         *SqlParser_Diags <<  DgSqlCode(-3406);
	         YYERROR;
	       }
               DDLExpr * de = new(PARSERHEAP()) DDLExpr
                 (NULL,
                  (char*)stmt->data(), 
                  stmtCharSet,
                  PARSERHEAP());
               
               de->setShowddlExplain(TRUE);
               de->setShowddlExplainInt(TRUE);
               de->setNumExplRows(numRows);
               de->setExplObjName($2->getQualifiedNameObj());

	       $$ = de;
	     }
           | TOK_SHOWDDL table_name optional_showddl_object_options_list
	     {
	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
			 Describe(SQLTEXT(), *$2, Describe::SHOWDDL_,
			          COM_TABLE_NAME, $3/*optional_sqlmp_option*/),
			 REL_ROOT,	
			 new (PARSERHEAP())
			 ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	     }
           | TOK_SHOWDDL table_name ',' TOK_LOB TOK_DETAILS optional_showddl_object_options_list
	     {
	       ExeUtilLobShowddl * ls = new(PARSERHEAP()) 
		 ExeUtilLobShowddl(*$2, $6, PARSERHEAP());
	       $$ = ls;
	     }
          | TOK_SHOWDDL TOK_TABLE table_name optional_showddl_object_options_list
	     {
	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
			 Describe(SQLTEXT(), *$3, Describe::SHOWDDL_, 
			          COM_TABLE_NAME, $4/*optional_sqlmp_option*/),
			 REL_ROOT,	
			 new (PARSERHEAP())
			 ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	     }
          | TOK_SHOWDDL table_mapping_function_tokens actual_routine_name 
            optional_showddl_object_options_list
	     {
               $3 
                 ->getQualifiedNameObj().setObjectNameSpace(COM_UDF_NAME);
	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
			 Describe(SQLTEXT(), *$3/*actual_routine_name*/, Describe::SHOWDDL_, 
			          COM_UDF_NAME, $4/*optional_showddl_options_lsit*/),
			 REL_ROOT,
			 new (PARSERHEAP())
			 ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	     }
          | TOK_SHOWDDL TOK_SCHEMA schema_name optional_showddl_schema_options_list
	     {
	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
			 Describe(SQLTEXT(), *$3, Describe::SHOWDDL_, $4),
			 REL_ROOT,	
			 new (PARSERHEAP())
			 ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	     }
          | TOK_SHOWDDL_USER authorization_identifier 
            {
              $$ = new (PARSERHEAP())
                RelRoot(new (PARSERHEAP())
                  Describe(SQLTEXT(), COM_USER_CLASS, *$2, Describe::SHOWDDL_),
                  REL_ROOT,
                  new (PARSERHEAP())
                  ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP()))); 
            }
          | TOK_SHOWDDL_ROLE authorization_identifier
              optional_showddl_role_option
            {
              $$ = new (PARSERHEAP())
                RelRoot(new (PARSERHEAP())
                  Describe(SQLTEXT(), COM_ROLE_CLASS, *$2, Describe::SHOWDDL_, $3),
                  REL_ROOT,
                  new (PARSERHEAP())
                  ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
            }
  
          | TOK_SHOWDDL_COMPONENT identifier
            {
              $$ = new (PARSERHEAP())
                RelRoot(new (PARSERHEAP())
                  Describe(SQLTEXT(), *$2),
                  REL_ROOT,
                  new (PARSERHEAP())
                  ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
            }
  
          | TOK_SHOWDDL_LIBRARY table_name 
               optional_showddl_object_options_list
  	       {
  	         $2 
                   ->getQualifiedNameObj().setObjectNameSpace(COM_LIBRARY_NAME); 
  	         $$ = new (PARSERHEAP())
        		 RelRoot(new (PARSERHEAP()) 
    	  		 Describe(SQLTEXT(), *$2, Describe::SHOWDDL_, COM_LIBRARY_NAME, $3),
  	  	           	 REL_ROOT, new (PARSERHEAP())
  			     ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
  	         delete $2; // CorrName * qualified_name
  	       }	  

          | TOK_SHOWDDL_SEQUENCE table_name optional_showddl_object_options_list
	     {
	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
			 Describe(SQLTEXT(), *$2, Describe::SHOWDDL_, 
			          COM_SEQUENCE_GENERATOR_NAME, $3),
			 REL_ROOT,	
			 new (PARSERHEAP())
			 ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	     }

          | TOK_SHOWDDL TOK_PROCEDURE actual_routine_name 
             optional_showddl_object_options_list
	     {
	     // SHOWDDL no longer relies on the PROCEDURE keyword. It now
	     // handles procedures in the same manner as tables since procedures
	     // are now in the TA namespace.
	       $3 // actual_routine_name
		 ->getQualifiedNameObj().setObjectNameSpace(COM_UDF_NAME); // SPJ
	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
			 Describe(SQLTEXT(), *$3, Describe::SHOWDDL_, COM_UDF_NAME, $4),
			 REL_ROOT,	
			 new (PARSERHEAP())
			 ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	       delete $3; // CorrName * actual_routine_name
	     }	  
          | TOK_SHOWDDL TOK_FUNCTION actual_routine_name
            optional_showddl_action_name_clause optional_showddl_object_options_list
             {
               $$ = SqlParserAux_buildDescribeForFunctionAndAction
                 ( $3 // in - CorrName * actual_routine_name of UDF or UUDF  - deep copy
                 , $4 // in - CorrName * optional_showddl_action_name_clause - deep copy
                 , $5 // in - long       optional_showddl_object_objects_list
                 );
               delete $3; // CorrName * actual_routine_name of UDF or UUDF
               delete $4; // CorrName * actual_routine_name of routine action
             }
	   | TOK_INVOKE table_name
	     {
	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
			 Describe(SQLTEXT(), *$2, Describe::INVOKE_),
			 REL_ROOT,	
			 new (PARSERHEAP())
			 ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	     }
	   | TOK_INVOKE table_as_procedure
	     {
	       CorrName * c = NULL;
	       if ($2->getOperatorType() == REL_EXPLAIN ||
	           $2->getOperatorType() == REL_STATISTICS ||
	           $2->getOperatorType() == REL_HIVEMD_ACCESS ||
		   $2->getOperatorType() == REL_EXE_UTIL ||
		   $2->getOperatorType() == REL_SCAN)
		 {
                   if ($2->getOperatorType() == REL_EXE_UTIL)
                     {
		       c = new(PARSERHEAP())
			 CorrName(((ExeUtilExpr *)$2)->
				  getVirtualTableName());
                       c->setSpecialType(ExtendedQualName::VIRTUAL_TABLE);
                     }
		   else if ($2->getOperatorType() == REL_SCAN)
		     {
		       Scan* ha = (Scan*)$2;
		       c = new(PARSERHEAP())
			 CorrName(ha->getTableName());
		     }
                   else
		     {
		       c = new(PARSERHEAP())
			 CorrName(((TableValuedFunction *)$2)->
				  getVirtualTableName());
		       c->setSpecialType(ExtendedQualName::VIRTUAL_TABLE);
		     }

		   $$ = new (PARSERHEAP())
		     RelRoot(new (PARSERHEAP())
			     Describe(SQLTEXT(), *c, Describe::INVOKE_),
			     REL_ROOT,	
			     new (PARSERHEAP())
			     ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
		   delete c;
		 }
	       else {
		 // error here  SOLN 10-050216-4754
		 *SqlParser_Diags << DgSqlCode(-3131);
		 YYERROR;
	       }
	     }
	  | showplan_starting_tokens interactive_query_expression
	     {
	       // create a dummy name so as to satisfy the constructor of
	       // Describe. The tablename param is not used for SHOWPLAN qry.
	       CorrName c;

	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
		   Describe(SQLTEXT(), c, Describe::PLAN_,COM_TABLE_NAME,$1),
			    REL_ROOT,	
			    new (PARSERHEAP())
			      ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));

	     }

	  | showplan_starting_tokens TOK_EXPLAIN optional_options interactive_query_expression
	     {
	       // create a dummy name so as to satisfy the constructor of
	       // Describe. The tablename param is not used for SHOWPLAN qry.
	       CorrName c;

	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
		   Describe(SQLTEXT(), c, Describe::PLAN_,COM_TABLE_NAME,$1),
			    REL_ROOT,	
			    new (PARSERHEAP())
			      ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));

               SqlParser_CurrentParser->hiveDDLInfo_->essd_ = Parser::HiveDDLInfo::SHOWPLAN_;
	     }

	  | showplan_starting_tokens TOK_PROCEDURE '(' character_string_literal ',' character_string_literal ')'
	     {
               // DEFAULT_CHARSET has no effect on character_string_literal in this context
               //
	       // create a name of the form "module.statement", where
	       // the first char literal is the module and the second
	       // is the statement/procedure in that module. Statement
	       // name could be '*' for all statements.
	       //NAString temp(*$4);
	       //temp.append('.');
	       //temp.append(*$6);

	       CorrName c (*$6, NULL, *$4);
	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
		   Describe(SQLTEXT(), c, Describe::STATIC_PLAN_,COM_TABLE_NAME,$1),
			    REL_ROOT,	
			    new (PARSERHEAP())
			      ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	     }

	  | TOK_SHOWSHAPE 
            {
              SqlParser_CurrentParser->hiveDDLInfo_->essd_ = Parser::HiveDDLInfo::SHOWSHAPE_;
            }
            interactive_query_expression
	     {
	       // create a dummy name so as to satisfy the constructor of
	       // Describe. The tablename param is not used for SHOWPLAN qry.
	       CorrName c;

	       $$ = new (PARSERHEAP())
		 RelRoot(new (PARSERHEAP())
		   Describe(SQLTEXT(), c, Describe::SHAPE_),
			    REL_ROOT,	
			    new (PARSERHEAP())
			      ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));

	     }
       | TOK_SHOWSTATS TOK_FOR TOK_QUERY query_expression
         {
           CorrName c;
           $$ = new (PARSERHEAP())
         RelRoot(new (PARSERHEAP())
             Describe(SQLTEXT(), c, Describe::SHOWQRYSTATS_),
             REL_ROOT,	
             new (PARSERHEAP())
             ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
         }

        // The purpose of these showstats productions is to accept every possible combination so that the command
        // can be passed through to be really parsed by the USTATS parser.  Only the most obvious syntax errors 
        // will be found here. 
       | TOK_SHOWSTATS TOK_FOR TOK_TABLE table_name	TOK_ON group_list showstats_opts
         {
           $$ = new (PARSERHEAP())
         RelRoot(new (PARSERHEAP())
             Describe(SQLTEXT(), *$4, Describe::SHOWSTATS_),
             REL_ROOT,	
             new (PARSERHEAP())
             ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
         }

       | TOK_SHOWSTATS TOK_FOR TOK_LOG TOK_TABLE table_name     TOK_ON group_list showstats_opts
         {
           $$ = new (PARSERHEAP())
         RelRoot(new (PARSERHEAP())
             Describe(SQLTEXT(), *$5, Describe::SHOWSTATS_),
             REL_ROOT,
             new (PARSERHEAP())
             ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
         }

	 | TOK_SHOWTRANSACTION
         {
           // create a dummy name so as to satisfy the constructor of
           // Describe. The tablename param is not used for SHOWTRANSACTION qry.
           CorrName c;

           $$ = new (PARSERHEAP())
         RelRoot(new (PARSERHEAP())
           Describe(SQLTEXT(), c, Describe::TRANSACTION_),
                REL_ROOT,	
                new (PARSERHEAP())
                  ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
         }
	 | TOK_SHOWSET TOK_DEFAULTS TOK_ALL
	 {
	   $$ = new (PARSERHEAP())
	     RelRoot(new (PARSERHEAP())
		     ExeUtilShowSet(
			  ((CmpCommon::getDefault(SHOWCONTROL_SHOW_ALL) == DF_ON) 
			   ? ExeUtilShowSet::ALL_DEFAULTS_ 
			   : ExeUtilShowSet::EXTERNALIZED_DEFAULTS_)),
		     REL_ROOT,	
		     new (PARSERHEAP())
		     ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	 }
	 | TOK_SHOWSET TOK_DEFAULTS
	 {
	   $$ = new (PARSERHEAP())
	     RelRoot(new (PARSERHEAP())
		     ExeUtilShowSet(ExeUtilShowSet::EXTERNALIZED_DEFAULTS_),
		     REL_ROOT,	
		     new (PARSERHEAP())
		     ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	 }
         | TOK_SHOWSET TOK_DEFAULT default_identifier
	 {
	   $$ = new (PARSERHEAP())
	     RelRoot(new (PARSERHEAP())
		     ExeUtilShowSet(ExeUtilShowSet::SINGLE_DEFAULT_,
				    *$3),
		     REL_ROOT,	
		     new (PARSERHEAP())
		     ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	 }
	 | TOK_GET TOK_ENVVARS
	 {
	   // create a dummy name so as to satisfy the constructor of
	   // Describe. The tablename param is not used for SHOWSET qry.
	   CorrName c;
	   
	   $$ = new (PARSERHEAP())
	     RelRoot(new (PARSERHEAP())
		     Describe(SQLTEXT(), c, Describe::ENVVARS_),
		     REL_ROOT,	
		     new (PARSERHEAP())
		     ColReference(new (PARSERHEAP()) ColRefName(TRUE, PARSERHEAP())));
	 }

/* type corrName */
optional_showddl_action_name_clause : empty
         {
           // optional_showddl_action_name_clause ::= empty

           $$ = NULL;
         }
                                    | TOK_ACTION actual_routine_action_name
         {
           // optional_showddl_action_name_clause ::=
           // TOK_ACTION actual_routine_action_name

           $$ = $2; // CorrName * actual_routine_action_name
         }

group_list : id_group_list                               { $$ = 0; }
           | TOK_EVERY TOK_KEY                           { $$ = 0; }
           | TOK_EVERY TOK_COLUMN                        { $$ = 0; }
           | TOK_EXISTING TOK_COLUMN                     { $$ = 0; } 
           | TOK_EXISTING TOK_COLUMNS                    { $$ = 0; } 
           | TOK_NECESSARY TOK_COLUMN                    { $$ = 0; } 
           | TOK_NECESSARY TOK_COLUMNS                   { $$ = 0; } 
           | TOK_EVERY TOK_KEY ',' id_group_list         { $$ = 0; }
           | TOK_EVERY TOK_COLUMN ',' id_group_list      { $$ = 0; }
           | TOK_EXISTING TOK_COLUMN ',' id_group_list   { $$ = 0; }
           | TOK_EXISTING TOK_COLUMNS ',' id_group_list  { $$ = 0; }
           | TOK_NECESSARY TOK_COLUMN ',' id_group_list  { $$ = 0; }
           | TOK_NECESSARY TOK_COLUMNS ',' id_group_list { $$ = 0; }

id_group_list : id_group                    { $$ = 0; }
              | id_group ',' id_group_list  { $$ = 0; }

id_group : identifier                                  { $$ = 0; }
         | '(' id_list ')'                             { $$ = 0; }
         | identifier TOK_TO identifier                { $$ = 0; }
         | '(' identifier ')' TOK_TO identifier        { $$ = 0; }
         | identifier TOK_TO '(' identifier ')'        { $$ = 0; }
         | '(' identifier ')' TOK_TO '('identifier ')' { $$ = 0; }

id_list : identifier              { $$ = 0; }
        | identifier ',' id_list  { $$ = 0; }

showstats_opts : empty       { $$ = 0; }
               | TOK_DETAIL  { $$ = 0; }

/* type showcontrolEnum */
optional_comma_match_clause : empty	  { $$ = Describe::MATCH_NONE_; }
			    | ',' TOK_MATCH TOK_FULL	   { $$ = Describe::MATCH_FULL_; }
			    | ',' TOK_MATCH TOK_PARTIAL	   { $$ = Describe::MATCH_PARTIAL_; }
			    | ',' TOK_MATCH TOK_FULL ',' TOK_NO TOK_HEADER	   
							   { $$ = Describe::MATCH_FULL_NO_HEADER_; }

/* type stringval */
optional_control_identifier:
	  default_identifier
			/* DEFAULTS attribute-name,
			 * or session-control first-quoted-string,
			 * or table-control-identifier
			 */
	  | '*'		{ $$ = NULL; }
	  | empty	{ $$ = NULL; }

/* type collationVal */
collate_clause : TOK_COLLATE TOK_DEFAULT   { $$ = CharInfo::DefaultCollation; }


               | TOK_COLLATE TOK_CHARACTER TOK_SET	    /* SQL/MP syntax */
	       				   { $$ = CharInfo::DefaultCollation; }

	       | TOK_COLLATE qualified_name
                   {
	      	     QualifiedName *qn = qualifiedNameFromStrings($2);
	       	     if (!qn) YYERROR;

		     // X.Y.Z is not NSK, but Y.Z or Z is ambiguous
		     // (could be ANSICAT.Y.Z *or* \NSK.$VOL.Y.Z)
		     // so we let the NAMETYPE default decide --
		     // with the added fillip that if the string is just Z,
		     // we first look it up as-is, w/o applying NSK vol.subvol
		     // (thus the string SJIS will be found as the system-
		     // defined collation, rather than bypassed in favor of
		     // \NSK.$VOL.SV.SJIS).
		     //
		     $$ = CharInfo::UNKNOWN_COLLATION;
		     NABoolean lookupNameAsNSK = FALSE;

		     if ($$ == CharInfo::UNKNOWN_COLLATION) {

		     // Lookup the name.  If unknown, emit WARNING and CONTINUE.
		     // It's a warning+continue, not an error,
		     // to allow the later "discovery" of user-defined
		     // collations via ReadTableDef's inserting them into the
		     // CollationDB.  SynthType and/or catman/CreateTable
		     // will emit error later if truly unknown then.
		     //
		     //## This REALLY needs to be done in the Binder,
		     //## a full-blown metadata lookup to see if user-defined
		     //## collation object exists...
		     //## so we should return a NAME (char * or NAString *)
		     //## instead of a CharInfo::Collation enum...
		     //
		     //## For most DML, let ItemExpr::synthesizeType(bindWA)
		     //## resolve the name, apply defaults, do the lookup...
		     //
		     //## First, though, need to figure out here
		     //## how to handle pure data types, e.g.,
		     //## - the target datatype of a CAST,
		     //## - column datatypes in a CREATE TABLE,
		     //## - hostvar datatypes.
		     //## Would still be nice to attach the collation name
		     //## string, perhaps a NAME pointer in CharType,
		     //## and validate/resolve it later,
		     //## in synthType for most DML but other places
		     //## for the 3 add'l cases noted above,
		     //## with proper error messages...  Perhaps someday!
		     //
		     NAString n(qn->getQualifiedNameAsAnsiString());
		     $$ = CharInfo::getCollationEnum(n, lookupNameAsNSK);
		     maybeEmitWarning3169($$, n);
		     if ( $$ == CharInfo::CZECH_COLLATION  &&
		          SqlParser_ISO_MAPPING != CharInfo::ISO88591 )
		          {
		              // CZECH COLLATION supported in only ISO88591 config.
		              *SqlParser_Diags << DgSqlCode(-3429);
		              YYABORT;
		          }
		     }
		   }

               | TOK_COLLATE guardian_location_name
                   {
		     NAString n(*$2);
		     ComMPLoc loc(n, ComMPLoc::FILE);
		     if (!loc.isValid(ComMPLoc::FILE)) { yyerror(""); YYERROR; }
		     n = loc.getMPName();

		     // These names are all non-ANSI:  $x.y.z  or  \s.$x.y.z
		     NABoolean lookupNameAsNSK = TRUE;

		     // Lookup the name.  If unknown, emit WARNING and CONTINUE.
		     //## This REALLY needs to be done in the Binder, etc. ...
		     $$ = CharInfo::getCollationEnum(n, lookupNameAsNSK);
		     maybeEmitWarning3169($$, n);
                   }

/* type collationAndCoercibility */
	/* Ansi 4.2.3 says that by default, hostvars and literals are COERCIBLE,
	 * unless they have a COLLATE clause in which case they're EXPLICIT.
	 * Only column refs can be IMPLICIT (and NATable.cpp makes them so).
	 */
collation_option : 
                   { $$.collation_    = CharInfo::DefaultCollation;
		     $$.coercibility_ = CharInfo::COERCIBLE;
		   }
                 | collate_clause
                   { $$.collation_    = $1;
		     $$.coercibility_ = CharInfo::EXPLICIT;
		   }

/* type tokval */
ordering_spec : TOK_ASC 
              | TOK_DESC
              | TOK_ASCENDING
              | TOK_DESCENDING

/* type item */
sort_or_group_key :   value_expression
                   {
                     ItemExpr * ie = $1;
                     ConstValue * cv = NULL;
                     if ((ie->getOperatorType() == ITM_CONSTANT) &&
                         ((cv = (ConstValue*)ie)->canGetExactNumericValue()) &&
                         (cv->getType()->getScale() == 0))
                       {
                         Int64 val = cv->getExactNumericValue();
                         ie = new (PARSERHEAP()) SelIndex(val);
                       }
                     else if (ie->getOperatorType() == ITM_REFERENCE)
                       {
                         ie = $1;
                       }
                     else
                       {
                         if (CmpCommon::getDefault(GROUP_OR_ORDER_BY_EXPR) == DF_OFF)
			   {
			     YYERROR;
			   }
                         ie = $1;
                       }

                     $$ = ie;
                   }

/* type item */
dml_column_reference : qualified_name 
		{
		   // helps with computing view text
		   //
		   ParInsertNameLoc($1->getPosition(), $1->getNameLength());
		   //
		   // note that colRefNameFromStrings()
		   // contains code that deletes $1
		   //
		   ColRefName  *newColRefName = colRefNameFromStrings($1);
		   if (newColRefName == NULL) YYABORT;
		   $$ = new (PARSERHEAP()) ColReference(newColRefName);
                }

/* item */
sort_spec : sort_or_group_key
          | sort_or_group_key collate_clause
              {
		// WARNING!  I don't support a collate_clause in a sort_spec.
                *SqlParser_Diags << DgSqlCode(+3023);
              }
          | sort_or_group_key ordering_spec
              {
		$$ = $1;
		if ($2 == TOK_DESC || $2 == TOK_DESCENDING)
		  {
		    $$ = new (PARSERHEAP()) InverseOrder($$);
		  }
              }
          | sort_or_group_key collate_clause ordering_spec
              {
		// WARNING!  I don't support collate_clauses in a sort_spec.
                *SqlParser_Diags << DgSqlCode(+3023);
              }

/* item */
sort_spec_list : sort_spec
   | sort_spec ',' sort_spec_list
           {
              $$ = new (PARSERHEAP()) ItemList( $1, $3);
           }

order_by_clause_non_empty : TOK_ORDER TOK_BY sort_spec_list
{ $$ = $3; }

/* item */
order_by_clause : TOK_ORDER TOK_BY sort_spec_list
                              { $$ = $3; }
                          |  empty
                             {
                               $$ = NULL;
                             }


/* type relx */
set_statement:  set_table_statement

/* type corrName */
set_table_name:  table_name   // includes the case of hostvar WITH a prototype
                   { $$ = $1 ; }
                | HOSTVAR   // The case of hostvar WITHOUT a prototype
                   {   // Solution: Add a bogus prototype
		     HostVar *hv = makeHostVar($1,NULL);
		     delete $1;  // okay to delete, a copy made in makeHostVar

                     // fake a dummy prototype
                     hv->setPrototypeValue("DUMMY");

	             // Remove leading/trailing blanks from string literal --
	             // the token(s) within the literal is the real proto value
	             TrimNAStringSpace(hv->getPrototypeValue());
	             if (hv->getPrototypeValue().isNull())
	             {
	                yyerror("");	// emits syntax error 15001
	                YYERROR;
	             }

		     AllHostVars->insert(hv);
		     TheHostVarRoles->addARole(HV_IS_INPUT);
		     // prepare a CorrName from the HV 
		     $$ = new (PARSERHEAP())
		       CorrName("HostVar$",PARSERHEAP(),hv->getName(),"$HV");
		     assert($$);
		     $$->setPrototype(hv);
		   }
                |  '*'
                   {
		     $$ = new (PARSERHEAP()) CorrName("*", TRUE, PARSERHEAP());
		   }

/* type boolean */
optional_stream: TOK_STREAM { $$ = TRUE ; } | empty { $$ = FALSE ; }

/* type item */
timeout_value:   literal
               | simple_host_variable
	       { TheHostVarRoles->setLastUnassignedTo(HV_IS_INPUT); $$ = $1 ;}
               | dynamic_parameter

/* type stmt_ptr */
set_table_statement: TOK_SET TOK_TABLE set_table_name 
                     optional_stream TOK_TIMEOUT  TOK_RESET
                   {
		     $$ = new (PARSERHEAP())   // a RESET 
		       RelSetTimeout( *$3, NULL, $4, TRUE );
                     *SqlParser_Diags << DgSqlCode(-4222)
                                      << DgString0("SET TABLE TIMEOUT");
                     yyerror("");
                     YYABORT;
		   }
                  |  TOK_SET TOK_TABLE set_table_name  // a timeout value
                     optional_stream TOK_TIMEOUT  timeout_value
                   {
		     $$ = new (PARSERHEAP()) 
		       RelSetTimeout( *$3, (ItemExpr *) $6 , $4);
                     *SqlParser_Diags << DgSqlCode(-4222)
                                      << DgString0("SET TABLE TIMEOUT");
                     yyerror("");
                     YYABORT;
		   }
                     

/* type relx */

set_session_default_statement : TOK_SET TOK_SESSION TOK_DEFAULT default_identifier QUOTED_STRING
                   {
                     // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
		     $$ = new (PARSERHEAP())
		       SetSessionDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), *$4, *$5);
		   }

set_session_default_statement : TOK_SET TOK_PARSERFLAGS NUMERIC_LITERAL_EXACT_NO_SCALE
                   {
		     $$ = new (PARSERHEAP())
		       SetSessionDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "SET_PARSERFLAGS", *$3);
		   }
	           | TOK_RESET TOK_PARSERFLAGS NUMERIC_LITERAL_EXACT_NO_SCALE
                   {
		     $$ = new (PARSERHEAP())
		       SetSessionDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "RESET_PARSERFLAGS", *$3);
		   }
	           | TOK_RESET TOK_PARSERFLAGS
                   {
		     char flags[100];
		     Int32 flagVal = 0x7FFFFFFF;
		     str_itoa(flagVal, flags);
		     
		     $$ = new (PARSERHEAP())
		       SetSessionDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), "RESET_PARSERFLAGS", flags);
		   }
                   | TOK_SET TOK_ENVVAR identifier
                     {
		       SqlParser_CurrentParser->getLexer()->setReturnAllChars();
		     }
                     ANY_STRING
                     {
		       NAString envNam = "SET_ENVVAR_";
		       envNam += *$3;
		       
		       NAString envVal;
		       
		       if ($5 == NULL)
			 envVal = "1";
		       else
			 envVal = *$5;

		       // trim leading and trailing spaces
		       envVal = envVal.strip(NAString::both);

		       $$ = new (PARSERHEAP())
			 SetSessionDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), envNam, envVal);
		       
		       SqlParser_CurrentParser->getLexer()->resetReturnAllChars();
		     }
                   | TOK_RESET TOK_ENVVAR identifier
                   {
		     NAString envNam = "RESET_ENVVAR_";
		     envNam += *$3;

		     NAString envVal;
		     $$ = new (PARSERHEAP())
		       SetSessionDefault(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), envNam, envVal);
		   }

opt_atomic_clause: empty
	    {
	      $$ = RelExpr::UNSPECIFIED_ ;
	    }
	  | atomic_clause
	    {
	      $$ = $1;
	    }

/* type relx */
psm_3gl_statement: TOK_BEGIN opt_atomic_clause psm_3gl_block_start TOK_END
      {

	/* Validate Compound statement that is the triggered action */
	if (InsideTriggerDefinition == TRUE) {

	  /* trigger definition allows only BEGIN ATOMIC */
	  if ($2 != RelExpr::ATOMIC_) {
	    *SqlParser_Diags << DgSqlCode(-11050);
	    yyerror("");
	    YYABORT;
	  }

	  /* Empty block is an error inside Trigger Definition */
	  if ($3 == NULL) {
	    *SqlParser_Diags << DgSqlCode(-11018);
	    yyerror("");
	    YYABORT;
	  }
	} else if ($2 == RelExpr::ATOMIC_) {
	  /* if CS is not part of trigger definition, BEGIN ATOMIC
	  * should raise syntax error to maintain old behavior
	  */
	  *SqlParser_Diags << DgSqlCode(-15001);
	  yyerror("");
	  YYABORT;
	}
 
        if ( $3 == NULL ) { 
             $$ = NULL;
        } else {
          if ( $3->getOperatorType() == REL_COMPOUND_STMT )
            MarkInteriorNodesAsInCompoundStmt($3); 

          $$ = $3; 
        } 
      }
    | TOK_IF {InIfCondition = TRUE; ++in3GL_;} any_expression {InIfCondition = FALSE;} TOK_THEN psm_3gl_block_end elseif_else_opt
      TOK_END TOK_IF
      {
        if (($6 != NULL) && ($6->getOperatorType() == REL_COMPOUND_STMT) &&
                            (!($6->isinBlockStmt())))
            MarkInteriorNodesAsInCompoundStmt($6); 
        $$ = getIfRelExpr($3, $6, $7);
      }
    | TOK_BEGIN TOK_END 
    {  
    
      if (InsideTriggerDefinition == TRUE) {
		/* Empty block is an error inside Trigger Definition */
		*SqlParser_Diags << DgSqlCode(-11018);
		yyerror("");
		YYABORT;
	  }
        in3GL_++;
        $$ = NULL;
    } 

elseif_else_opt: empty { $$ = NULL; }
    | TOK_ELSEIF {InIfCondition = TRUE;} any_expression {InIfCondition = FALSE;} TOK_THEN psm_3gl_block_end elseif_else_opt
      { 
        if (($6 != NULL) && ($6->getOperatorType() == REL_COMPOUND_STMT) &&
                            (!($6->isinBlockStmt())))
            MarkInteriorNodesAsInCompoundStmt($6); 
        $$ = getIfRelExpr($3, $6, $7);
      }
    | TOK_ELSE psm_3gl_block_end 
      { 
        if (($2 != NULL) && ($2->getOperatorType() == REL_COMPOUND_STMT) &&
                            (!($2->isinBlockStmt())))
            MarkInteriorNodesAsInCompoundStmt($2); 
        $$ = $2; 
      } 

psm_3gl_block_start: { ++in3GL_; } psm_3gl_block_end 
      {
        $$ = $2;
      } 
	
/* Returns NULL for empty compound statement list */
psm_3gl_block_end : psm_3gl_stmt ';' psm_3gl_block_end
      { 
         if ( $1 == NULL ) {
            if ($3 == NULL) 
              $$ = NULL;
            else
              $$ = $3;
         } else {
	    // We can't deal with queries inside a CS if CS is part of
	    // trigger defintion. So raise error if this is the case.
	    if (InsideTriggerDefinition == TRUE) {
	      RelExpr *node = (RelExpr*)((RelExpr*)$1)->getChild(0);
	      if (node->getOperatorType() == REL_SCAN) {
		*SqlParser_Diags << DgSqlCode(-11047);
		YYERROR;
	      }
	    }
            if ( $3 == NULL )
               $$ = $1;
            else {
              CompoundStmt *cs = new (PARSERHEAP()) CompoundStmt($1, $3); 
              $$ = cs; 
            }
         }
      }
         | psm_3gl_stmt ';' 
      {
	// We can't deal with queries inside a CS is CS is part of
	// trigger defintion. So raise error if this is the case.
	if ($1 != NULL && InsideTriggerDefinition == TRUE) {
	  RelExpr *node = (RelExpr*)((RelExpr*)$1)->getChild(0);
	  if (node->getOperatorType() == REL_SCAN) {
	    *SqlParser_Diags << DgSqlCode(-11047);
	    YYERROR;
	  }
	}
	$$ = $1;
      }
         | psm_3gl_stmt ';' ';'
      { 
        *SqlParser_Diags << DgSqlCode(-3182);
        YYERROR;
      }

psm_3gl_stmt: interactive_query_expression
      { 
        if ($1) {
          RelExpr *node = (RelExpr*)((RelExpr*)$1)->getChild(0);
          switch (node->getOperatorType()) {
            // all stmts are allowed in compound stmts except:
            //   transaction, ddl, update statistics, stream stmts
// EJF L4J - CQD stmts are not allowed, error flagged
//   at create time else RelExpr CMPASSERTS in optimizer.
          default:
            break;
          case REL_DDL:
            *SqlParser_Diags << DgSqlCode(-3174) << DgString0(node->getText());
            break;
          case REL_TRANSACTION:
            *SqlParser_Diags << DgSqlCode(-3171) << DgString0(node->getText());
            break;
          }
        }
        $$ = $1;
      }
    | dynamic_sql_disallowed_in_cs
        { 
          *SqlParser_Diags << DgSqlCode(-3175);
          $$ = NULL;
        } 

/* stmt_ptr */
dynamic_sql_disallowed_in_cs : close_statement
	       | declare_dynamic_cursor
	       | describe_statement
	       | dynamic_prepare
	       | dynamic_execute
	       | execute_immediate
	       | fetch_cursor
	       | open_cursor

assignment_value : query_specification
                   {
					     
					RelRoot *temp = (RelRoot *) $1;
						 
					// Now store all variables found in output_hostvar_list into
					// a Root node. AssignmentHostVars contains such variables
                    for (CollIndex i = 0; i < AssignmentHostVars->entries(); i++) {
 		              temp->addAssignmentStTree((*AssignmentHostVars)[i]);
                    }

     		        AssignmentHostVars->clear();

                    $$ = temp;
					}

                  | value_expression_list
                   {

				     Tuple *tempTuple  = new (PARSERHEAP()) Tuple($1);
                     RelRoot *tempRoot = new (PARSERHEAP()) RelRoot(tempTuple);

				     // Now store all variables found in output_hostvar_list into
					 // a Root node. AssignmentHostVars contains such variables
                     for (CollIndex i = 0; i < AssignmentHostVars->entries(); i++) {
 		                tempRoot->addAssignmentStTree((*AssignmentHostVars)[i]);
                     }

     		         AssignmentHostVars->clear();
                     $$ = tempRoot;
                    }



/* Assignment statement for Compound Statements */
assignment_statement: TOK_SET {InAssignmentSt = TRUE;} output_hostvar_list {InAssignmentSt = FALSE;}
                              '=' assignment_value
                      {	    
					    ThereAreAssignments = TRUE;
					    TheHostVarRoles->setLastNunassignedTo($3,HV_IS_INPUT_OUTPUT);
					    NumOfScalars = NumOfArrays = 0;
					    $$ = $6;
					   }


/* type longint */
optional_showddl_schema_options_list : empty 
           {
             if(CmpCommon::getDefault(SHOWDDL_DISPLAY_FORMAT) == DF_INTERNAL )
             {
               $$ = 64;
             }
             else if (CmpCommon::getDefault(SHOWDDL_DISPLAY_FORMAT) == DF_EXTERNAL )
             {
               $$ = 32;
             }
             else
             {
               $$ = 0;
             }
          }

     |  ',' showddl_options_list
             {
  	       $$ = $2;
	       if (NOT($$ & 32) && NOT($$ & 64))
	       {
                 if(CmpCommon::getDefault(SHOWDDL_DISPLAY_FORMAT) == DF_INTERNAL )
               {
                 $$ = $$ + 64;
               }
                 else if (CmpCommon::getDefault(SHOWDDL_DISPLAY_FORMAT) == DF_EXTERNAL )
               {
                 $$ = $$ + 32;
               }
	     }

             // if mutually exclusive option have been specified, 
             // reject the command.  Mutually exclusinve options
             // include BRIEF(8)/DETAIL(4) and EXTERNAL(32)/INTERNAL(64).
             if ( (($2 & 4) && ($2 & 8)) ||
                  (($2 & 32) && ($2 & 64)) ||
                  (($2 & 16) && ($2 & 128)) ||
                  (($2 & 128) && ($2 & 256)) ||
		  (($2 & 16) && ($2 & 256)))
             {
                 yyerror("");        // emits syntax error 15001
                 YYERROR;
             }
	   }
	   
/* type longint */
showddl_options_list : showddl_options
        | showddl_options_list ',' showddl_options 
           {
	     $$ = $1 + $3;
	   
	   }

/* type longint */
showddl_options : 
        TOK_DETAIL
           {
	     $$ = 4;
	   }
     |  TOK_BRIEF
           {
	     $$ = 8;
	   }
     |  TOK_PRIVILEGES
           {
	     $$ = 16;
	   }
     |  TOK_GRANTEES
           {
	     $$ = 16;
	   }
     |  TOK_EXTERNAL
           {
	     $$ = 32;
	   }
     |  TOK_INTERNAL
           {
	     $$ = 64;
	   }
     |  TOK_PRIVILEGES TOK_ONLY
           {
	     $$ = 128;
	   }
     |  TOK_SYNONYMS TOK_ONLY
           {
	     $$ = 256;
	   }

/* type longint */
optional_showddl_object_options_list : empty
           {
             if(CmpCommon::getDefault(SHOWDDL_DISPLAY_FORMAT) == DF_INTERNAL )
             {
               $$ = 64;
             }
             else if (CmpCommon::getDefault(SHOWDDL_DISPLAY_FORMAT) == DF_EXTERNAL )
             {
               $$ = 32;
             }
             else
             {
               $$ = 0;
             }
          }

     | ',' showddl_options_list
           {
             $$ = $2;
             if (NOT($$ & 32) && NOT($$ & 64))
             {
               if(CmpCommon::getDefault(SHOWDDL_DISPLAY_FORMAT) == DF_INTERNAL )
              {
                 $$ = $$ + 64;
               }
                 else if (CmpCommon::getDefault(SHOWDDL_DISPLAY_FORMAT) == DF_EXTERNAL )
               {
                 $$ = $$ + 32;
               }
             }
             // if mutually exclusive or unsupported options have been
             // specified, reject the command.  Mutually exclusinve options
             // include EXTERNAL(32)/INTERNAL(64), unsupported options
             // include BRIEF(8)/DETAIL(4).
             if ( (($2 & 32) && ($2 & 64)) ||
                  ($2 & 8) )
             {
                 yyerror("");        // emits syntax error 15001
                 YYERROR;
             }
           }

optional_showddl_role_option : empty
           { 
             $$ = 0;
           }
             
     | ',' TOK_GRANTEES
           {
             $$ = 16;
           }
     | ',' TOK_PRIVILEGES
           {
             $$ = 16;
           }

/* type uint */
schema_or_database : TOK_SCHEMA
                     {
                       $$ = 1;
                     }
                     | TOK_DATABASE
                     {
                       $$ = 2;
                     }

/* type pStmtDDL */
schema_definition : TOK_CREATE schema_class schema_or_database schema_name_clause char_set collation_option
                    {
                      // cannot use keyword DATABASE if not hive ddl.
                      if (($3 == 2) &&
                          (NOT SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_))
                        {
                          YYERROR;
                        }

                      NAString extSchName($4->getSchemaName().getSchemaNameAsAnsiString());
                      if (! validateVolatileSchemaName(extSchName))
                      {
                        YYERROR;
                      }

                    // allocate the CharType object and pass it to StmDDLCreateSchema. 
                    // StmtDDLCreateSchema will free the memory there.
                    CharType *charType = new (PARSERHEAP()) CharType(PARSERHEAP(), CharType::LiteralSchema, 
                                                      0, 0, FALSE, FALSE, FALSE, FALSE, FALSE,
                                                      $5, $6.collation_, $6.coercibility_ );
                                                         
                    StmtDDLCreateSchema *pNode = new (PARSERHEAP())
                      StmtDDLCreateSchema( *$4 /*schema_name_clause*/,
                                            $2, /* schema class */
                                            charType );
                     pNode->synthesize();
                     $$ = pNode;
                     delete $4 /*schema_name_clause*/;
                   }

schema_definition : TOK_CREATE schema_class schema_or_database TOK_IF TOK_NOT TOK_EXISTS 
                    schema_name_clause char_set collation_option
                    {
                     // cannot use keyword DATABASE if not hive ddl.
                      if (($3 == 2) &&
                          (NOT SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_))
                        {
                          YYERROR;
                        }

                      NAString extSchName($7->getSchemaName().getSchemaNameAsAnsiString());
                      if (! validateVolatileSchemaName(extSchName))
                      {
                        YYERROR;
                      }

                      // allocate the CharType object and pass it to StmDDLCreateSchema. 
                      // StmtDDLCreateSchema will free the memory there.
                      CharType *charType = new (PARSERHEAP()) CharType(PARSERHEAP(), CharType::LiteralSchema,
                                                        0, 0, FALSE, FALSE, FALSE, FALSE, FALSE,
                                                        $8, $9.collation_, $9.coercibility_ );

                      StmtDDLCreateSchema *pNode = new (PARSERHEAP())
                        StmtDDLCreateSchema( *$7 /*schema_name_clause*/,
                                             $2, /* schema class */
                                             charType);
                      pNode->setCreateIfNotExists(TRUE);
                      pNode->synthesize();
                      delete $7 /*schema_name_clause*/;

                      SqlParser_CurrentParser->hiveDDLInfo_->ifExistsOrNotExists_ = TRUE;

                      $$ = pNode;
                    }


schema_definition : TOK_CREATE TOK_VOLATILE TOK_SCHEMA 
				{
				  SchemaName * vsn = 
				    processVolatileSchemaName(NULL, FALSE, TRUE);
				  if (!vsn)
				    YYERROR;

				  ElemDDLSchemaName edsn(*vsn);
                                  StmtDDLCreateSchema *pNode =
				    new (PARSERHEAP())
				      StmtDDLCreateSchema(
                                      edsn /*schema_name_clause*/,
                                      COM_SCHEMA_CLASS_SHARED, /* schema class */
                                      NULL);
				  pNode->setIsVolatile(TRUE);
				  pNode->setProcessAsExeUtil(TRUE);
                                  pNode->synthesize();
                                  $$ = pNode;
				}

/* type schemaClassEnum */
schema_class : empty
                                { 
                                  $$ = COM_SCHEMA_CLASS_DEFAULT;

                                  SqlParser_CurrentParser->hiveDDLInfo_->
                                    setValues(TRUE, StmtDDLonHiveObjects::CREATE_, StmtDDLonHiveObjects::SCHEMA_);
                                }
                              | TOK_PRIVATE
                                {
                                  $$ = COM_SCHEMA_CLASS_PRIVATE;
                                }
                              | TOK_SHARED
                                {
                                  $$ = COM_SCHEMA_CLASS_SHARED;
                                }

/* type pElemDDLSchemaName */
schema_name_clause : schema_name
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLSchemaName(*$1, "", PARSERHEAP());

                                  delete $1;
                                }

                      | TOK_AUTHORIZATION schema_authorization_identifier
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLSchemaName(*$2, *$2, PARSERHEAP());
                                  delete $2;
                                }

                      | schema_name TOK_AUTHORIZATION
                                schema_authorization_identifier
                                {
				  $$ = new (PARSERHEAP()) ElemDDLSchemaName(*$1, *$3, PARSERHEAP());
                                  delete $1;
                                  delete $3;
                                }

/* type pSchemaName */
schema_name : schema_name_ss
              {
                StringPos namePos = $1->getPosition();
                size_t nameLen = $1->getNameLength();
                $$ = schemaNameFromStrings($1);
                if ($$ == NULL) 
                  YYABORT;

                SqlParser_CurrentParser->hiveDDLInfo_->ddlNamePos_ = namePos;
                SqlParser_CurrentParser->hiveDDLInfo_->ddlNameLen_ = nameLen;

                preprocessHiveDDL(
                     $$->getCatalogName(), 
                     SqlParser_CurrentParser->hiveDDLInfo_);  
              }

/* type strSeq */
schema_name_ss : identifier
                 {
                   ShortStringSequence *strseq =
                     new (PARSERHEAP()) ShortStringSequence($1);
                   if (! strseq->isValid()) 
                     YYABORT;
                   $$ = strseq;
                 }
                | schema_name_ss '.' identifier
                 {
                   $1->append($3);
                   if (! $1->isValid()) 
                     YYABORT;
                   
                   $$ = $1;
                 }

/* type stringval */
schema_authorization_identifier : authorization_identifier

/* type stringval */
authorization_identifier : identifier
                                {
                                  // upshift even if delimited
                                  $$->toUpper();
                                }

/* type stringval */
external_user_identifier : identifier
                                {
                                  // upshift even if delimited
                                  NAString temp (*$$);
                                  $$->toUpper();
                                }

/* type pStmtDDL */

routine_definition : TOK_CREATE TOK_PROCEDURE optional_if_not_exists_clause ddl_qualified_name
                        routine_params_list_clause
                        optional_create_routine_attribute_list
                        optional_by_auth_identifier
                                {
                                  QualifiedName noActionQualName(PARSERHEAP());
                                  StmtDDLCreateRoutine *pNode =
                                    new (PARSERHEAP()) StmtDDLCreateRoutine
                                    ( *$4  // ddl_qualified_name of SPJs
                                    , noActionQualName
                                    , $5   // ElemDDLNode *  routine_params_list_clause
                                    , NULL // ElemDDLNode *  optional_routine_returns_clause
                                    , NULL // ElemDDLNode *  optional_passthrough_inputs_clause
                                    , $6   // ElemDDLNode *  optional_create_routine_attribute_list
                                    , COM_PROCEDURE_TYPE // ComRoutineType
                                    , PARSERHEAP()
                                    );
                                  pNode->setCreateIfNotExists($3);
                                  pNode->setOwner($7/*optional_by_auth_identifier*/);
                                  pNode->synthesize();
                                  $$ = pNode;
                                  delete $4;  // ddl_qualified_name of routine
                                }

  | TOK_CREATE create_scalar_function_tokens optional_if_not_exists_clause ddl_qualified_name
    routine_params_list_clause
    optional_routine_returns_clause
    optional_passthrough_inputs_clause
    optional_create_function_attribute_list
    {
      QualifiedName noActionQualName(PARSERHEAP());
      StmtDDLCreateRoutine *pNode =
        new (PARSERHEAP()) StmtDDLCreateRoutine
        ( *$4 // ddl_qualified_name of scalar function
          , noActionQualName
          , $5  // ElemDDLNode *  routine_params_list_clause
          , $6  // ElemDDLNode *  optional_routine_returns_clause
          , $7  // ElemDDLNode *  optional_passthrough_inputs_clause
          , $8  // ElemDDLNode *  optional_create_function_attribute_list
          , COM_SCALAR_UDF_TYPE // ComRoutineType create_scalar_function_tokens
          , PARSERHEAP()
          );
      pNode->setCreateIfNotExists($3); 
      pNode->synthesize();
      $$ = pNode;
      delete $4;  // ddl_qualified_name of routine
    }

  | TOK_CREATE table_mapping_function_tokens optional_if_not_exists_clause 
    ddl_qualified_name
    routine_params_list_clause
    optional_routine_returns_clause
    optional_passthrough_inputs_clause
    optional_create_function_attribute_list
    optional_by_auth_identifier
    {
      QualifiedName noActionQualName(PARSERHEAP());
      StmtDDLCreateRoutine *pNode =
        new (PARSERHEAP()) StmtDDLCreateRoutine
        ( *$4 // ddl_qualified_name of scalar function
          , noActionQualName
          , $5  // ElemDDLNode *  routine_params_list_clause
          , $6  // ElemDDLNode *  optional_routine_returns_clause
          , $7  // ElemDDLNode *  optional_passthrough_inputs_clause
          , $8  // ElemDDLNode *  optional_create_function_attribute_list
          , COM_TABLE_UDF_TYPE // ComRoutineType table_mapping_function_tokens
          , PARSERHEAP()
          );
      pNode->setCreateIfNotExists($3);
      pNode->setOwner($9/*optional_by_auth_identifier*/);
      pNode->synthesize();
      $$ = pNode;
      delete $4;  // ddl_qualified_name of routine
    }

  | TOK_CREATE universal_function_tokens optional_if_not_exists_clause 
    ddl_qualified_name
    universal_function_param_clause
    optional_create_function_attribute_list
    {
      QualifiedName noActionQualName(PARSERHEAP());
      StmtDDLCreateRoutine *pNode =
        new (PARSERHEAP()) StmtDDLCreateRoutine
        ( *$4  // ddl_qualified_name of universal function
          , noActionQualName
          , NULL // ElemDDLNode * optional_routine_params_list
          , NULL // ElemDDLNode * optional_routine_returns_clause
          , NULL // ElemDDLNode * optional_passthrough_inputs_clause
          , $6   // ElemDDLNode * optional_create_function_attribute_list
          , COM_UNIVERSAL_UDF_TYPE // ComRoutineType universal_function_tokens
          , PARSERHEAP()
          );
      pNode->setCreateIfNotExists($3);
      pNode->setUudfParamKindList($5); // universal_function_param_clause
      pNode->synthesize();
      $$ = pNode;
      delete $4;  // ddl_qualified_name of routine
    }

/* type routineTypeEnum */
create_scalar_function_tokens : TOK_FUNCTION
                                {
                                  $$ = COM_SCALAR_UDF_TYPE;
                                }
                              | TOK_SCALAR TOK_FUNCTION
                                {
                                  $$ = COM_SCALAR_UDF_TYPE;
                                }

/* type routineTypeEnum */
table_mapping_function_tokens : TOK_TABLE_MAPPING TOK_FUNCTION
                                {
                                  $$ = COM_TABLE_UDF_TYPE;
                                }

/* type routineTypeEnum */
universal_function_tokens : TOK_UNIVERSAL TOK_FUNCTION
                                {
                                  $$ = COM_UNIVERSAL_UDF_TYPE;
                                }

universal_function_param_clause : '(' universal_function_param_list ')'
                                {
                                  $$ = $2; // universal_function_param_list
                                }

/* type pElemDDL */
universal_function_param_list : universal_function_param
                              | universal_function_param_list ',' universal_function_param
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLList ( $1 , $3 );
                                }

/* type pElemDDL */
universal_function_param : empty
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUudfParamDef(COM_UUDF_PARAM_OMITTED);
                                }
                             | TOK_ACTION
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUudfParamDef(COM_UUDF_PARAM_ACTION);
                                }
                             | TOK_SAS_FORMAT
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUudfParamDef(COM_UUDF_PARAM_SAS_FORMAT);
                                }

                             | TOK_SAS_LOCALE
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUudfParamDef(COM_UUDF_PARAM_SAS_LOCALE);
                                }

                             | TOK_SAS_MODEL_INPUT_TABLE
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUudfParamDef(COM_UUDF_PARAM_SAS_MODEL_INPUT_TABLE);
                                }

/* type pElemDDL */
routine_params_list_clause : '(' routine_params_list ')'
                                {
                                  $$ = $2;
                                }
                           | TOK_LPAREN_BEFORE_DATATYPE routine_params_list ')'
                                {
                                  $$ = $2;
                                }
                                

/* type pStmtDDL */
alter_function_statement : TOK_ALTER universal_function_tokens ddl_qualified_name
                           TOK_ADD TOK_ACTION routine_action_qualified_name
                           routine_params_list_clause
                           routine_returns_clause
                           optional_passthrough_inputs_clause
                           optional_create_function_attribute_list
                                {
                                  StmtDDLCreateRoutine *pNode99 = new (PARSERHEAP())
                                    StmtDDLCreateRoutine
                                    ( *$3 // ddl_qualified_name of uudf - deep copy
                                    , *$6 // ddl_qualified_name of action - deep copy
                                    ,  $7 // routine_params_list_clause
                                    ,  $8 // routine_returns_clause
                                    ,  $9 // optional_passthrough_inputs_clause
                                    , $10 // optional_create_function_attribute_list
                                    , COM_ACTION_UDF_TYPE
                                    , PARSERHEAP()
                                    );
                                  pNode99->synthesize();
                                  $$ = pNode99;
                                  delete $3; // ddl_qualified_name of uudf
                                  delete $6; // ddl_qualified_name of action
                                }

                         | TOK_ALTER universal_function_tokens ddl_qualified_name
                           TOK_DROP TOK_ACTION routine_action_qualified_name
                           optional_cleanup    optional_drop_behavior
                           optional_validate   optional_logfile
                                {
                                  $$ = SqlParserAux_buildDropAction
                                    ( $3  // in - QualifiedName * ddl_qualified_name of uudf   - deep copy
                                    , $6  // in - QualifiedName * ddl_qualified_name of action - deep copy
                                    , $7  // in - NABoolean       optional_cleanup
                                    , $8  // in - ComDropBehavior optional_drop_behavior
                                    , $9  // in - NABoolean       optional_validate
                                    , $10 // in - NAString      * optional_logfile             - deep copy
                                    );
                                  delete $3; // ddl_qualified_name of uudf
                                  delete $6; // ddl_qualified_name of action
                                  if ($10) delete $10; // optional_logfile name
                                  if ($$ EQU NULL) { yyerror(""); YYERROR; } // Error: internal syntax only!
                                }

                         | TOK_ALTER TOK_FUNCTION ddl_qualified_name
                           optional_alter_passthrough_inputs_clause
                           optional_add_passthrough_inputs_clause
                           optional_create_function_attribute_list
                                {
                                  $$ = SqlParserAux_buildAlterFunction
                                    ( $3 // in - NAString    * ddl_qualified_name of function - deep copy
                                    , $4 // in - ElemDDLNode * optional_alter_passthrough_inputs_clause
                                    , $5 // in - ElemDDLNode * optional_add_passthrough_inputs_clause
                                    , $6 // in - ElemDDLNode * optional_create_function_attribute_list
                                    );
                                  delete $3; // ddl_qualified_name of function
                                }

                         | TOK_ALTER universal_function_tokens ddl_qualified_name
                           TOK_ALTER TOK_ACTION routine_action_qualified_name
                           optional_alter_passthrough_inputs_clause
                           optional_add_passthrough_inputs_clause
                           optional_create_function_attribute_list
                                {
                                  $$ = SqlParserAux_buildAlterAction
                                    ( $3 // in - ddl_qualified_name of UUDF - deep copy
                                    , $6 // in - ddl_qualified_name of routine action - deep copy
                                    , $7 // in - optional_alter_passthrough_inputs_clause
                                    , $8 // in - optional_add_passthrough_inputs_clause
                                    , $9 // in - optional_create_function_attribute_list
                                    );
                                  delete $3; // ddl_qualified_name of universal function
                                  delete $6; // ddl_qualified_name of routine action
                                }

                         | TOK_ALTER table_mapping_function_tokens ddl_qualified_name
                           optional_alter_passthrough_inputs_clause
                           optional_add_passthrough_inputs_clause
                           optional_create_function_attribute_list
                                {
                                  $$ = SqlParserAux_buildAlterTableMappingFunction
                                    ( $3 // in - QualifiedName * ddl_qualified_name of function - deep copy
                                    , $4 // in - ElemDDLNode   * optional_alter_passthrough_inputs_clause
                                    , $5 // in - ElemDDLNode   * optional_add_passthrough_inputs_clause
                                    , $6 // in - ElemDDLNode   * optional_create_function_attribute_list
                                    );
                                 delete $3; // ddl_qualified_name of table mapping function
                                }

/* type pElemDDL */
optional_alter_passthrough_inputs_clause : empty { $$ = NULL; }
                                         | alter_passthrough_inputs_clause

/* type pElemDDL */
alter_passthrough_inputs_clause : TOK_ALTER passthrough_inputs_clause_start_tokens
                                  { HexStringLiteralNotAllowed = FALSE; }
                                  alter_passthrough_params_list
                                {
                                  $$ = $4; // alter_passthrough_params_list
                                  HexStringLiteralNotAllowed = TRUE;
                                }

/* type pElemDDL */
alter_passthrough_params_list : alter_passthrough_param
                              | '(' alter_passthrough_params ')'
                                {
                                  $$ = $2; // alter_passthrough_params
                                }

/* type pElemDDL */
alter_passthrough_params : alter_passthrough_param
                         | alter_passthrough_params ',' alter_passthrough_param
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLList($1/*params*/, $3 /*param*/);
                                }

/* type pElemDDL */
alter_passthrough_param : passthrough_param_position passthrough_input_value optional_passthrough_input_type
                                {
                                  $$ = SqlParserAux_buildAlterPassThroughParamDef
                                    ( $1 // in - unsigned int  passthrough_param_position
                                    , $2 // in - ElemDDLNode * passthrough_input_value - shallow copy
                                    , $3 // in - ComRoutinePassThroughInputType optional_passthrough_input_type
                                    );
                                }

/* type pElemDDL */
optional_add_passthrough_inputs_clause : empty { $$ = NULL; }
                                       | TOK_ADD passthrough_inputs_clause
                                {
                                  $$ = $2; // passthrough_inputs_clause
                                }

/* type routineExecutionMode */
routine_execution_mode : TOK_FAST { $$ = COM_ROUTINE_FAST_EXECUTION; }
                       | TOK_SAFE { $$ = COM_ROUTINE_SAFE_EXECUTION; }

/* type pElemDDL */
optional_routine_returns_clause : empty { $$ = NULL; }
                                | routine_returns_clause

/* type pElemDDL */
routine_returns_clause : return_tokens routine_return_param
                                {
                                  $$ = $2;
                                }
                       | return_tokens routine_return_params
                                {
                                  $$ = $2;
                                }

/* type tokval */
return_tokens:  TOK_RETURN | TOK_RETURNS

/* type pElemDDL */
routine_return_params : '(' routine_return_param_list ')'
                                {
                                  $$ = $2;
                                }
                      | TOK_LPAREN_BEFORE_DATATYPE routine_return_param_list ')'
                                {
                                  $$ = $2;
                                }

/* type pElemDDL */
routine_return_param_list : routine_return_param_optional_not_null
                          | routine_return_param_list ','
                            routine_return_param_optional_not_null
                            {
                              $$ = new (PARSERHEAP())
                                ElemDDLList ($1/*list*/, $3/*param*/);
                            }

/* type pElemDDL */
routine_return_param : optional_return_param_mode optional_param_name routine_predef_type
                       {
                         ElemDDLParamDef *p = new (PARSERHEAP())
                           ElemDDLParamDef($3 /*predef_type*/,
                                           $2 /*optional_param_name*/,
                                           $1 /*optional_return_param_mode*/,
                                           PARSERHEAP());
                         delete $2 /*optional_param_name*/;
                         $$ = p;
                       }

/* type pElemDDL */
routine_return_param_optional_not_null :
  optional_return_param_mode
  optional_param_name
  routine_predef_type
  optional_cast_spec_not_null_spec
  {
    ElemDDLParamDef *p = new (PARSERHEAP())
      ElemDDLParamDef($3 /*predef_type*/,
                      $2 /*optional_param_name*/,
                      $1 /*optional_return_param_mode*/,
                      PARSERHEAP());
    if ($4)
    {
      // NOT NULL specified
      NAType *t = p->getParamDataType();
      t->setNullable(FALSE);
    }
    delete $2 /*optional_param_name*/;
    $$ = p;
  }

/* type routineParamMode */
optional_return_param_mode : TOK_OUT { $$ = COM_OUTPUT_PARAM; }
                           | empty   { $$ = COM_OUTPUT_PARAM; }

/* type tokval */
passthrough_inputs_clause_start_tokens : TOK_PASS TOK_THROUGH TOK_INPUT
                                       | TOK_PASS TOK_THROUGH TOK_INPUTS

/* type pElemDDL */
optional_passthrough_inputs_clause : empty { $$ =  NULL; }
                                   | passthrough_inputs_clause

/* type pElemDDL */
passthrough_inputs_clause : passthrough_inputs_clause_start_tokens
                            { HexStringLiteralNotAllowed = FALSE; }
                             passthrough_params_list
                                {
                                  $$ =  $3; // passthrough_params_list
                                  HexStringLiteralNotAllowed = TRUE;
                                }

/* type pElemDDL */
passthrough_params_list : passthrough_param
                        | '(' passthrough_params ')'
                                {
                                  $$ = $2; // passthrough_params
                                }

/* type pElemDDL */
passthrough_params : passthrough_param
                   | passthrough_params ',' passthrough_param
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLList ($1, $3);
                                }

/* type pElemDDL */
passthrough_param : passthrough_input_value optional_passthrough_input_type
                                {
                                  ElemDDLPassThroughParamDef *pNode11 = $1 // passthrough_input_value
                                    ->castToElemDDLPassThroughParamDef();
                                  pNode11->setPassThroughInputType($2); // optional_passthrough_input_type
                                  $$ = pNode11;
                                }

/* type passThroughInputType */
optional_passthrough_input_type : TOK_TEXT
                                {
                                  $$ = COM_ROUTINE_PASS_THROUGH_INPUT_TEXT_TYPE;
                                }
                                | TOK_BINARY
                                {
                                  $$ = COM_ROUTINE_PASS_THROUGH_INPUT_BINARY_TYPE;
                                }
                                | empty
                                {
                                  $$ = COM_ROUTINE_PASS_THROUGH_INPUT_BINARY_TYPE;
                                }

/* type uint */
passthrough_param_position : TOK_POSITION unsigned_integer
                                {
                                  $$ = $2; // unsigned_integer
                                }

/* type pElemDDL */
passthrough_input_value : TOK_VALUE literal_negatable
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLPassThroughParamDef ( $2    // literal_negatable - shallow copy
                                                               , PARSERHEAP()
                                                               );
                                }

                        | TOK_VALUE TOK_FROM TOK_FILE std_char_string_literal
                                {
                                  // TOK_FILE is a non-reserved word (i.e., FILE can be a parameter name).
                                  // Production passthrough_input_value ::= TOK_FILE std_char_string_literal
                                  // does not work.  Must use a reserved keyword like TOK_VALUE or TOK_FROM
                                  // for the parsing to work correctly.  We do not have to use both VALUE and
                                  // FROM, but VALUE FROM FILE '/usr/fred/udf/passthru1.dat' just sounds good.
                                  // With the use of the non-terminal symbol std_char_string_literal, a
                                  // long OSS file path name can be broken into several parts - for example:
                                  // VALUE FROM FILE '/usr/fred/a/'
                                  //                 'very/long/path/'
                                  //                 'name'
                                  // Accept neither _iso88591 nor _ucs2 string literal prefix.

                                  $$ = new (PARSERHEAP())
                                    ElemDDLPassThroughParamDef ( *$4 // std_char_string_literal - deep copy
                                                               , PARSERHEAP()
                                                               );
                                  delete $4; // std_char_string_literal
                                }

/* type pElemDDL */
routine_params_list :   empty
                                {
                                  $$ = NULL;
                                }
                      | routine_params 

/* type pElemDDL */
routine_params : routine_param
                      | routine_params ',' routine_param
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLList ($1, $3);
                                }

/* type pElemDDL */
routine_param : optional_param_mode optional_param_name routine_predef_type
                  optional_cast_spec_not_null_spec
                {
                  if ($4)
                    $3->setNullable(FALSE);

                  $$ = new (PARSERHEAP()) ElemDDLParamDef(
						  $3 /*predef_type*/,
						  $2 /*optional_param_name*/,
						  $1 /*optional_param_mode*/,
                                                  PARSERHEAP());
                  delete $2 /*optional_param_name*/;
                }

/* type na_type */
routine_predef_type : predef_type
               {
                 if (($1->getTypeName() == LiteralTinyInt) &&
                     ((CmpCommon::getDefault(TRAF_TINYINT_SUPPORT) == DF_OFF) ||
                      (CmpCommon::getDefault(TRAF_TINYINT_SPJ_SUPPORT) == DF_OFF)))
                   {
                     NumericType * nt = (NumericType*)$1;
                     $$ = new (PARSERHEAP()) 
                       SQLSmall(PARSERHEAP(), NOT nt->isUnsigned(), $1->supportsSQLnull());
                   }
               }

/* type pElemDDLParamName */
optional_param_name : empty
                         {
                           $$ = NULL;
                         }
                    | param_name

/* type pElemDDLParamName */
param_name : IDENTIFIER
                         {
                           if ( ($1==NULL) || transformIdentifier(*$1)) YYERROR;
                           $$ = new (PARSERHEAP())ElemDDLParamName(*$1);
                           delete $1;
                         }
                    | DELIMITED_IDENTIFIER
                         {
                           if ( ($1==NULL) || transformIdentifier(*$1)) YYERROR;
                               $$ = new (PARSERHEAP())ElemDDLParamName(*$1);
                           delete $1;
                         }
                    | nonreserved_word
                         {  
                           NAString temp = *(unicodeToChar
                                            (ToTokvalPlusYYText(&$1)->yytext,
                                             ToTokvalPlusYYText(&$1)->yyleng,
                                             (CharInfo::CharSet) (
                                                                  ComGetNameInterfaceCharSet()
                                                                  ),
                                             PARSERHEAP()) );
                           temp.toUpper();
                           $$ = new (PARSERHEAP())ElemDDLParamName(temp);	   
                         }
                    | nonreserved_func_word
                         {  
                           NAString temp = *(unicodeToChar
                                            (ToTokvalPlusYYText(&$1)->yytext,
                                             ToTokvalPlusYYText(&$1)->yyleng,
                                             (CharInfo::CharSet) (
                                                                  ComGetNameInterfaceCharSet()
                                                                  ),
                                             PARSERHEAP()) );
                           temp.toUpper();
                           $$ = new (PARSERHEAP())ElemDDLParamName(temp);	   
                         }
			 /* Please check.
                    | empty
                         {
                           $$ = NULL;
                         }
*/
/* type routineParamMode */
optional_param_mode : TOK_IN 
                         {
                           $$ = COM_INPUT_PARAM;
                         }
                    | TOK_OUT 
                         {
                           $$ = COM_OUTPUT_PARAM;
                         }
                    | TOK_INOUT
                         {
                           $$ = COM_INOUT_PARAM;
                         }
                    | empty
                         {
                           $$ = COM_INPUT_PARAM;
                         }

/* type pElemDDL */
optional_create_routine_attribute_list : empty
                         {
                       $$ = NULL;
                         }
                      | create_routine_attribute_list

/* type pElemDDL */
create_routine_attribute_list : create_routine_attribute
                      | create_routine_attribute_list create_routine_attribute
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLOptionList(
                                       $1 /*create_routine_attribute_list*/,
                                       $2 /*create_routine_attribute*/);
                                }

/* type pElemDDL */
optional_create_function_attribute_list : empty { $$ = NULL; }
                      | create_function_attribute_list

/* type pElemDDL */
create_function_attribute_list : create_function_attribute
                      | create_function_attribute_list create_function_attribute
    {
      $$ = new (PARSERHEAP()) ElemDDLOptionList($1 /*list*/, $2 /*attr*/);
    }

/* type stringval */
std_char_string_literal : QUOTED_STRING
    {
      // std_char_string_literal ::= QUOTED_STRING


      PARSERASSERT(getStringCharSet(&$1/*QUOTED_STRING*/) == CharInfo::ISO88591 ||
                   getStringCharSet(&$1/*QUOTED_STRING*/) == CharInfo::UTF8);

      // We do not need to make the following call if the parameter is not $1 (e.g., $2).
      // The parser, by default, already copied the contents of the data structure
      // associating with $1 to that of $$.  We must make the following call if
      // we change the contents of the data structure associating with $1 and want to
      // copy the changes to the parser data structure associating with $$.
      //
      // The following call is not needed for this case.  The above comments described
      // how to use this function call (instead of $$ = $1).  In the semantic actions
      // of the next grammar production, this function must be called.  You may want
      // to walk through that code and read the associating comments.
      ToStringvalWithCharSet(&$$/*lhs*/)->shallowCopy(ToStringvalWithCharSet(&$1/*QUOTED_STRING*/)); // $$ = $1;

    }
  | std_char_string_literal QUOTED_STRING
    {
      // std_char_string_literal ::= std_char_string_literal QUOTED_STRING


      PARSERASSERT(getStringCharSet(&$1/*std_char_string_literal*/) == CharInfo::ISO88591 ||
                   getStringCharSet(&$1/*std_char_string_literal*/) == CharInfo::UTF8);
      PARSERASSERT(getStringCharSet(&$2/*QUOTED_STRING*/) == CharInfo::ISO88591 ||
                   getStringCharSet(&$2/*QUOTED_STRING*/) == CharInfo::UTF8);

      if ( getStringCharSet(&$1) == getStringCharSet(&$2) ||
           getStringCharSet(&$1) == CharInfo::UTF8 )
      {
        ToStringvalWithCharSet(&$$)->shallowCopy(ToStringvalWithCharSet(&$1)); // the default behavior
        $$->append(*$2);
        // if (getStringCharSet(&$2) == CharInfo::ISO88591)
        //   PARSERASSERT(NAStringHasOnly7BitAsciiChars(*$2));
        delete $2;
      }
      else if (getStringCharSet(&$2) == CharInfo::UTF8)
      {
        // PARSERASSERT(getStringCharSet(&$1) == CharInfo::ISO88591 && NAStringHasOnly7BitAsciiChars(*$1));
        ToStringvalWithCharSet(&$$)->shallowCopy(ToStringvalWithCharSet(&$2)); // must do this instead of $$ = $2;
        ToStringvalWithCharSet(&$$)->stringval = $1; // same as $$ = $1;
        $$->append(*$2);
        delete $2;
      }
      else
      {
        charsetMismatchError(&$1, &$2);
        YYERROR;
      }
    }


/* type pElemDDL */
create_routine_attribute : location_clause
                      | udr_external_name_clause
                      | udr_external_path_clause
                      | udr_language_clause
                      | udr_library_clause
                      | udr_param_style_clause
                      | udr_access_clause
                      | udr_result_sets_clause
                      | udr_deterministic_clause
                      | udr_isolate_clause
                      | udr_transaction_clause
                      | udr_external_security_clause

/* type pElemDDL */
create_function_attribute : create_function_udr_attribute
                          | create_function_udf_attribute

/* type pElemDDL */
create_function_udr_attribute : location_clause
                              | udr_external_name_clause
                              | udr_language_clause
                              | udr_deterministic_clause
                              | udr_access_clause
                              | udr_isolate_clause
                              | udr_transaction_clause
                              | udr_library_clause

/* type pElemDDL */
create_function_udf_attribute : udf_param_style_clause
                              | udf_version_tag_clause
                              | udf_optimization_hint_clause
                              | udf_state_area_clause
                              | udf_execution_mode_clause
                              | udf_special_attributes_clause
                              | udf_parallelism_clause
                              | udf_final_call_clause

/* type pElemDDL */
udr_external_name_clause : TOK_EXTERNAL TOK_NAME std_char_string_literal
                                {
                                  // DEFAULT_CHARSET has no effect on std_char_string_literal in this context
                                  // A long external name can span several lines - For example:
                                  // EXTERNAL NAME 'a_very_very_'
                                  //               'long_external_name'
                                  $$ = new (PARSERHEAP()) ElemDDLUdrExternalName(*$3); // std_char_string_literal
                                }

/* type pElemDDL */
udr_external_path_clause : TOK_EXTERNAL TOK_PATH std_char_string_literal
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrExternalPath(*$3); // std_char_string_literal
                                }

/* type pElemDDL */
udr_language_clause : TOK_LANGUAGE TOK_JAVA
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrLanguage(COM_LANGUAGE_JAVA);
                                } 
                    | TOK_LANGUAGE TOK_C
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrLanguage(COM_LANGUAGE_C);
                                } 
                    | TOK_LANGUAGE TOK_CPP
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrLanguage(COM_LANGUAGE_CPP);
                                } 
                    | TOK_LANGUAGE TOK_SQL
                                {
                                  yyerror("The LANGUAGE SQL clause is not supported within a routine definition. \n");
                                  YYERROR;
                                  $$ = new (PARSERHEAP()) ElemDDLUdrLanguage(COM_LANGUAGE_SQL);
                                } 

/* type pElemDDL */
udr_library_clause : TOK_LIBRARY ddl_qualified_name
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrLibrary(*$2);
                                } 
/* type pElemDDL */
udf_param_style_clause : routine_parameter_style_sql | routine_parameter_style_sqlrow

/* type pElemDDL */
routine_parameter_style_sql : TOK_PARAMETER TOK_STYLE TOK_SQL
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrParamStyle(COM_STYLE_SQL);
                                }

/* type pElemDDL */
routine_parameter_style_sqlrow : TOK_PARAMETER TOK_STYLE TOK_SQLROW
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrParamStyle(COM_STYLE_SQLROW);
                                  YYERROR; // this style is no longer allowed in DDL syntax
                                }

/* type pElemDDL */
udr_param_style_clause : TOK_PARAMETER TOK_STYLE TOK_JAVA
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrParamStyle(COM_STYLE_JAVA_CALL);
                                } 
                       | routine_parameter_style_sql
                       | routine_parameter_style_sqlrow
                                {
                                  $$ = $1;
                                  yyerror("The PARAMETER STYLE SQLROW clause is not supported within a procedure definition. \n");
                                  YYERROR;
                                } 
                       | TOK_PARAMETER TOK_STYLE TOK_GENERAL
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrParamStyle(COM_STYLE_GENERAL);
                                } 

/* type pElemDDL */
udr_access_clause : TOK_NO TOK_SQL
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrSqlAccess(COM_NO_SQL);
                                } 
                    | TOK_MODIFIES TOK_SQL TOK_DATA
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrSqlAccess(COM_MODIFIES_SQL);
                                } 
                    | TOK_READS TOK_SQL TOK_DATA
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrSqlAccess(COM_READS_SQL);
                                } 
                    | TOK_CONTAINS TOK_SQL
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrSqlAccess(COM_CONTAINS_SQL);
                                } 

/* type pElemDDL */
udr_result_sets_clause : TOK_DYNAMIC TOK_RESULT TOK_SETS unsigned_integer
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrMaxResults($4 /*unsigned_integer*/);
                                } 

/* type pElemDDL */
udr_deterministic_clause : TOK_DETERMINISTIC
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrDeterministic(TRUE);
                                } 
                    | TOK_NOT TOK_DETERMINISTIC
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrDeterministic(FALSE);
                                } 

/* type pElemDDL */
udr_isolate_clause : TOK_ISOLATE
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrIsolate(TRUE);
                                } 
                    | TOK_NO TOK_ISOLATE
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLUdrIsolate(FALSE);
                                } 
/* type pElemDDL */
udr_transaction_clause : TOK_TRANSACTION TOK_REQUIRED
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLUdrTransaction(COM_TRANSACTION_REQUIRED);
                                } 
                    | TOK_NO TOK_TRANSACTION TOK_REQUIRED
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLUdrTransaction(COM_NO_TRANSACTION_REQUIRED);
                                } 

/* type pElemDDL */
udr_external_security_clause : udr_external_security_definer | udr_external_security_invoker

/* type pElemDDL */
udr_external_security_definer : TOK_EXTERNAL TOK_SECURITY TOK_DEFINER
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrExternalSecurity(COM_ROUTINE_EXTERNAL_SECURITY_DEFINER);
                                }

/* type pElemDDL */
udr_external_security_invoker : TOK_EXTERNAL TOK_SECURITY TOK_INVOKER
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLUdrExternalSecurity(COM_ROUTINE_EXTERNAL_SECURITY_INVOKER);
                                }

/* type pElemDDL */
udf_special_attributes_clause : file_attribute_keyword udf_special_attributes
  {
    $$ = new (PARSERHEAP()) ElemDDLUdfSpecialAttributes(*$2); // deep copy
    delete $2; // udf_special_attributes
  }

/* type stringval */
udf_special_attributes : std_char_string_literal
                       | '(' std_char_string_literal ')'
  {
    $$ = $2; // std_char_string_literal
  }

/* type pElemDDL */
udf_final_call_clause : TOK_FINAL TOK_CALL
  {
    $$ = new (PARSERHEAP()) ElemDDLUdfFinalCall(TRUE);
  }
                      | TOK_NO TOK_FINAL TOK_CALL
  {
    $$ = new (PARSERHEAP()) ElemDDLUdfFinalCall(FALSE);
  }

/* type pElemDDL */
udf_state_area_clause : TOK_STATE TOK_AREA TOK_SIZE unsigned_integer
  {
    $$ = new (PARSERHEAP()) ElemDDLUdfStateAreaSize($4/*unsigned_integer*/);
  }
                      | TOK_NO TOK_STATE TOK_AREA
  {
    $$ = new (PARSERHEAP()) ElemDDLUdfStateAreaSize(0);
  }

/* type pElemDDL */
udf_parallelism_clause : TOK_ALLOW TOK_ANY TOK_PARALLELISM
  {
    $$ = new (PARSERHEAP()) ElemDDLUdfParallelism(COM_ROUTINE_ANY_PARALLELISM);
  }
                       | TOK_NO TOK_PARALLELISM
  {
    $$ = new (PARSERHEAP()) ElemDDLUdfParallelism(COM_ROUTINE_NO_PARALLELISM);
  }

/* type pElemDDL */
udf_execution_mode_clause : routine_execution_mode TOK_EXECUTION TOK_MODE
  {
    $$ = new (PARSERHEAP()) ElemDDLUdfExecutionMode($1/*routine_execution_mode*/);
  }

/* type pElemDDL */
udf_optimization_hint_clause : udf_number_of_unique_values_clause
  | udf_optimization_stage udf_resource_kind TOK_COST udf_cost
  {
    $$ = SqlParserAux_buildUdfOptimizationHint ( $1 // in - int       udf_optimization_stage
                                               , $2 // in - int       udf_resource_kind
                                               , $4 // in - ComSInt32 udf_cost
                                               );
    if ($$ EQU NULL) { yyerror(""); YYERROR; }
  }

/* type tokval */
udf_optimization_stage : TOK_INITIAL | TOK_NORMAL

/* type tokval */
udf_resource_kind : TOK_CPU
                  | TOK_IO
                  | TOK_MESSAGE

/* type longint */
udf_cost : TOK_SYSTEM
  {
    $$ = -1;
  }
         | unsigned_integer
  {
    $$ = (Lng32)$1; // unsigned_integer
  }

/* type tokval */
number_of_unique_values_tokens : TOK_NUMBER TOK_OF TOK_UNIQUE TOK_OUTPUT TOK_VALUES

/* type pElemDDL */
udf_number_of_unique_values_clause : number_of_unique_values_tokens number_of_unique_output_values
  {
    $$ = $2; // ElemDDLNode * number_of_unique_values
  }

/* type pElemDDL */
number_of_unique_output_values : TOK_SYSTEM
  {
    ElemDDLUdfOptimizationHint * pNode63 = new (PARSERHEAP())
      ElemDDLUdfOptimizationHint(COM_UDF_NUMBER_OF_UNIQUE_OUTPUT_VALUES);
    pNode63->setUniqueOutputValuesParseTree(NULL); // use system settings
    pNode63->synthesize();
    $$ = pNode63;
  }
                        | '(' unique_output_value_list ')'
  {
    ElemDDLUdfOptimizationHint * pNode66 = new (PARSERHEAP())
      ElemDDLUdfOptimizationHint(COM_UDF_NUMBER_OF_UNIQUE_OUTPUT_VALUES);
    pNode66->setUniqueOutputValuesParseTree($2); // ItemExprList * unique_output_value_list
    pNode66->synthesize();
    $$ = pNode66;
  }

/* type itemlist */
unique_output_value_list : unique_output_value
  {
    ItemExprList *itemList777 = new (PARSERHEAP()) ItemExprList(PARSERHEAP());
    itemList777->insert($1); // ItemExpr * unique_output_value
    $$ = itemList777;
  }
                         | unique_output_value_list ',' unique_output_value
  {
    ItemExprList *itemList333 = (ItemExprList *)$1; // unique_output_value_list
    itemList333->insert($3); // ItemExpr * unique_output_value
    $$ = itemList333;
  }

/* type item */
unique_output_value : TOK_SYSTEM
  {
    NAString *theValue22 = new (PARSERHEAP()) NAString("1", PARSERHEAP());
    ItemExpr *returnValue = literalOfNumericNoScale(theValue22, '-'); // -1
    if (!returnValue) YYERROR;
    $$ = returnValue;
    // delete theValue22;
    /*
  }
                    | NUMERIC_LITERAL_EXACT_NO_SCALE
  {
    ItemExpr *returnValue = literalOfNumericNoScale($1); // deep copy
    if (!returnValue) YYERROR;
    $$ = returnValue;
    delete $1; // NAString * NUMERIC_LITERAL_EXACT_NO_SCALE
    */
  }
                    | literal

/* type pElemDDL */
udf_version_tag_clause : TOK_VERSION TOK_TAG std_char_string_literal
  {
    $$ = new (PARSERHEAP()) ElemDDLUdfVersionTag(*$3); // deep copy
    delete $3; // std_char_string_literal
  }

optional_hive_options : empty 
                      {
                        $$ = NULL;
                      }
                      | TOK_HIVE TOK_OPTIONS QUOTED_STRING
                      {
                        $$ = $3;
                      }

/* type pStmtDDL */
table_definition : create_table_start_tokens 
                        ddl_qualified_name 
                        table_definition_body
                        optional_create_table_attribute_list
                        optional_in_memory_clause
                        optional_map_to_hbase_clause
                        optional_hbase_data_format
	  	   {
                     $1->setOptions(TableTokens::OPT_NONE);
		     QualifiedName * qn;
                     if ($1->isVolatile())
                       qn = processVolatileDDLName($2, TRUE, TRUE);
		     else
                       qn = processVolatileDDLName($2, FALSE, FALSE);
		     if (! qn)
                       YYABORT;

                     if ($6) // map to hbase table
                       {
                         if ($1->getType() != TableTokens::TYPE_EXTERNAL_TABLE)
                           YYERROR;

                         // cannot be create like
                         if ($3->castToElemDDLLikeCreateTable())
                           {
                             *SqlParser_Diags << DgSqlCode(-3242)
                                              << DgString0("Cannot specify LIKE clause with mapped hbase tables.");
                             YYERROR;
                           }
                         
                         // cannot specify cat/schema names
                         if ((NOT qn->getCatalogName().isNull()) ||
                             (NOT qn->getSchemaName().isNull()))
                           {
                             *SqlParser_Diags << DgSqlCode(-3242)
                                              << DgString0("Cannot specify catalog or schema names with mapped hbase tables.");
                             YYERROR;
                           }
                       }

		     StmtDDLCreateTable *pNode =
		       new (PARSERHEAP())
		       StmtDDLCreateTable(
			    *qn, //ddl_qualified_name
			    $3,  //table_definition_body
			    $4,  //optional_create_table_attribute_list
			    NULL,
			    NULL,
			    PARSERHEAP());

                     if ($6)
                       {
                         CorrName cn(*$6);
                         pNode->setLikeSourceTableName(cn);

                         pNode->setMapToHbaseTable(TRUE);

                         pNode->setHbaseDataFormat($7);
                       }

                     $1->setTableTokens(pNode);
		     pNode->synthesize();

		     if (ParNameCTLocListPtr)
		       {
			 delete ParNameCTLocListPtr;
			 ParNameCTLocListPtr = NULL;
		       }

		     $$ = pNode;
                     delete $1; //TableTokens
		     delete $2; //ddl_qualified_name
		   }

table_definition : create_table_start_tokens 
                   ddl_qualified_name
                   like_definition
	  	   {
                     $1->setOptions(TableTokens::OPT_NONE);
		     QualifiedName * qn;
                     if ($1->isVolatile())
                       qn = processVolatileDDLName($2, TRUE, TRUE);
		     else
                       qn = processVolatileDDLName($2, FALSE, FALSE);
		     if (! qn)
                       YYABORT;

		     StmtDDLCreateTable *pNode =
		       new (PARSERHEAP())
		       StmtDDLCreateTable(
			    *qn, //ddl_qualified_name
			    $3,  //like_definition
			    NULL,
			    NULL,
			    NULL,
			    PARSERHEAP());

                     $1->setTableTokens(pNode);
		     pNode->synthesize();

		     if (ParNameCTLocListPtr)
		       {
			 delete ParNameCTLocListPtr;
			 ParNameCTLocListPtr = NULL;
		       }

		     $$ = pNode;
                     delete $1; //TableTokens
		     delete $2; //ddl_qualified_name
		   }

		 | TOK_CREATE special_table_name
                        table_definition_body
                        optional_create_table_attribute_list
		   {
		     StmtDDLCreateTable *pNode =
		       new (PARSERHEAP())
		       StmtDDLCreateTable(
			    $2->getQualifiedNameObj() /*table_name*/,
			    $3 /*table_definition_body*/,
			    $4 /*optional_create_table_
				*attribute_list*/,
			    NULL,
			    NULL,
			    PARSERHEAP());
		     pNode->setTableType($2->getSpecialType());
		     pNode->synthesize();
		     
		     if (ParNameCTLocListPtr)
		       {
			 delete ParNameCTLocListPtr;
			 ParNameCTLocListPtr = NULL;
		       }
		     
		     $$ = pNode;
		     delete $2; /*special_table_name*/
		   }

                 | create_table_start_tokens
                   ddl_qualified_name
 		   table_definition_body
 		   optional_create_table_attribute_list 
 		   create_table_as_attr_list_end
		   ctas_load_and_in_memory_options
		   ctas_insert_columns
                   optional_hive_options
		   create_table_as_token 
                   {
                     if (CmpCommon::getDefault(HIVE_CTAS_IN_NATIVE_MODE) == DF_OFF)
                       SqlParser_CurrentParser->hiveDDLInfo_->setFoundDDL(FALSE);                       
                   }
		   optional_locking_stmt_list 
                   query_expression 
                   optional_limit_spec
		   {
		     QualifiedName * qn;

		     if ($1->getType() == TableTokens::TYPE_GHOST_TABLE) // ghost table
		       {
			 // Syntax error: CREATE GHOST TABLE ... AS ...
			 yyerror("");
			 YYERROR;
		       }

                     $1->setOptions($6);
                     if ($1->isVolatile())
                       qn = processVolatileDDLName($2, FALSE, FALSE);
		     else
		       qn = $2;
		     if (! qn)
			 YYABORT;

		     RelRoot *top = finalize($12);
                   //limit clause
                   if ($13)
                   {
                     if (top->getFirstNRows() >= 0)
                       {
                         // cannot specify LIMIT and FIRST N clauses together.
                         YYERROR;
                       }
                     else
                       {
                         NABoolean negate;
                         if ($13->castToConstValue(negate))
                           {
                             ConstValue * limit = (ConstValue*)$13;
                             Lng32 scale = 0;
                             top->setFirstNRows(limit->getExactNumericValue(scale));
                             top->setFirstNRowsParam(NULL);
                           }
                         else
                           {
                             top->setFirstNRowsParam($13);
                             top->setFirstNRows(-1);
                           }
                       }
                   }

		     StmtDDLCreateTable *pNode =
		       new (PARSERHEAP())
		       StmtDDLCreateTable(
			    *qn, //ddl_qualified_name
			    $3,  // table_definition_body
			    $4,  // optional_create_table_attribute_list
			    $7,  // insert column list 
			    top,
			    PARSERHEAP());
                     $1->setTableTokens(pNode);
		     pNode->synthesize();
		     
		     if (ParSetTextEndPos(pNode)) 
		       {					
			 yyerror("");				
			 YYERROR;				
		       }

		     if (ParNameCTLocListPtr)
		       {
			 delete ParNameCTLocListPtr;
			 ParNameCTLocListPtr = NULL;
		       }

                     if ($8)
                       pNode->setHiveOptions(*$8);

		     $$ = pNode;
                     delete $1; //TableTokens
		     delete $2; //ddl_qualified_name
		   }

                 | create_table_start_tokens 
                   ddl_qualified_name 
                   {
                     if (CmpCommon::getDefault(HIVE_CTAS_IN_NATIVE_MODE) == DF_OFF)
                       SqlParser_CurrentParser->hiveDDLInfo_->setFoundDDL(FALSE);                       
                   }
		   optional_create_table_attribute_list 
		   create_table_as_attr_list_end
		   ctas_load_and_in_memory_options
		   ctas_insert_columns
                   optional_hive_options
		   create_table_as_token 
		   optional_locking_stmt_list 
                   query_expression 
                   optional_limit_spec
		   {
		     QualifiedName * qn;

		     if ($1->getType() == TableTokens::TYPE_GHOST_TABLE) // ghost table
		       {
			 // Syntax error: CREATE GHOST TABLE ... AS ...
			 yyerror("");
			 YYERROR;
		       }

                     $1->setOptions($6);
                     if ($1->isVolatile())
                       qn = processVolatileDDLName($2, FALSE, FALSE);
		     else
		       qn = $2;
		     if (! qn)
                       YYABORT;

		     RelRoot *top = finalize($11);
                   //limit clause
                   if ($12)
                   {
                     if (top->getFirstNRows() >= 0)
                       {
                         // cannot specify LIMIT and FIRST N clauses together.
                         YYERROR;
                       }
                     else
                       {
                         NABoolean negate;
                         if ($12->castToConstValue(negate))
                           {
                             ConstValue * limit = (ConstValue*)$12;
                             Lng32 scale = 0;
                             top->setFirstNRows(limit->getExactNumericValue(scale));
                             top->setFirstNRowsParam(NULL);
                           }
                         else
                           {
                             top->setFirstNRowsParam($12);
                             top->setFirstNRows(-1);
                           }
                       }
                   }
		     
		     StmtDDLCreateTable *pNode =
		       new (PARSERHEAP())
		       StmtDDLCreateTable(
			    *qn,  //ddl_qualified_name
			    NULL, //table_definition_body
			    $4,   //optional_create_table_attribute_list
			    $7,   //insert column list 
			    top,
			    PARSERHEAP());
                     $1->setTableTokens(pNode);
		     pNode->synthesize();
		     
		     if (ParSetTextEndPos(pNode)) 
		       {					
			 yyerror("");				
			 YYERROR;				
		       }

		     if (ParNameCTLocListPtr)
		       {
			 delete ParNameCTLocListPtr;
			 ParNameCTLocListPtr = NULL;
		       }

                     if ($8)
                       pNode->setHiveOptions(*$8);

		     $$ = pNode;
                     delete $1; //TableTokens
		     delete $2;  //ddl_qualified_name
		   }

              | TOK_CREATE TOK_HBASE TOK_TABLE identifier '(' col_fam_quoted_string_list ')'
               {
		 QualifiedName qn(*$4);

		 StmtDDLCreateHbaseTable *pNode =
		   new (PARSERHEAP())
		   StmtDDLCreateHbaseTable(
				      qn /*ddl_qualified_name*/,
				      $6,
				      NULL,
				      PARSERHEAP());

		 $$ = pNode;
               }
              | TOK_CREATE TOK_HBASE TOK_TABLE identifier '(' col_fam_quoted_string_list ')' hbase_table_options
               {
		 QualifiedName qn(*$4);

		 StmtDDLCreateHbaseTable *pNode =
		   new (PARSERHEAP())
		   StmtDDLCreateHbaseTable(
				      qn /*ddl_qualified_name*/,
				      $6,
				      $8->castToElemDDLHbaseOptions(), /* hbase options list */
				      PARSERHEAP());

		 $$ = pNode;
               }

/* tableTokens */
create_table_start_tokens : 
                   TOK_CREATE TOK_TABLE optional_if_not_exists_clause
                   {
		     ParNameCTLocListPtr = new (PARSERHEAP())
		       ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_REGULAR_TABLE, $3); 
                     $$ = tableTokens;

                     SqlParser_CurrentParser->hiveDDLInfo_->
                       setValues(TRUE, StmtDDLonHiveObjects::CREATE_, StmtDDLonHiveObjects::TABLE_, $3);
		   }

                   | TOK_CREATE TOK_EXTERNAL TOK_TABLE optional_if_not_exists_clause
                   {
		     ParNameCTLocListPtr = new (PARSERHEAP())
		       ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_EXTERNAL_TABLE, $4); 
                     $$ = tableTokens;

                     SqlParser_CurrentParser->hiveDDLInfo_->
                       setValues(TRUE, StmtDDLonHiveObjects::CREATE_, StmtDDLonHiveObjects::TABLE_, $4);
		   }

                   | TOK_CREATE TOK_IMPLICIT TOK_EXTERNAL TOK_TABLE optional_if_not_exists_clause
                   {
                     if (! Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
                       {
                         yyerror(""); YYERROR; /*internal syntax only!*/
                       }
                     
		     ParNameCTLocListPtr = new (PARSERHEAP())
		       ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_IMPLICIT_EXTERNAL_TABLE, $5); 
                     $$ = tableTokens;
		   }

                   | TOK_CREATE TOK_SET TOK_TABLE optional_if_not_exists_clause
                   {
		     ParNameCTLocListPtr = new (PARSERHEAP())
		       ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_SET_TABLE, $4); 
                     $$ = tableTokens;
		   }

                   | TOK_CREATE TOK_MULTISET TOK_TABLE optional_if_not_exists_clause 
                   {
		     if (NOT SqlParser_CurrentParser->modeSpecial1())
		       {
			 YYERROR;
		       }

		     ParNameCTLocListPtr = new (PARSERHEAP())
		       ParNameLocList(SQLTEXT(), PARSERHEAP());
                     TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_MULTISET_TABLE, $4); 
                     $$ = tableTokens;
		   }

                   | TOK_CREATE TOK_VOLATILE TOK_TABLE optional_if_not_exists_clause 
                   {
		     ParNameCTLocListPtr = new (PARSERHEAP())
		       ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                    if (CmpCommon::getDefault(MODE_SPECIAL_1) == DF_ON)
                    { 
                       TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_VOLATILE_TABLE_MODE_SPECIAL1, $4); 
                       $$ = tableTokens;
                    }

                    else
                    {                      
                       TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_VOLATILE_TABLE, $4); 
                       $$ = tableTokens;
                    }
		   }

                   | TOK_CREATE TOK_LOCAL TOK_TEMPORARY TOK_TABLE optional_if_not_exists_clause
                   {
		     ParNameCTLocListPtr = new (PARSERHEAP())
		       ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_VOLATILE_TABLE, $5); 
                     $$ = tableTokens;
		   }

                   | TOK_CREATE TOK_GLOBAL TOK_TEMPORARY TOK_TABLE optional_if_not_exists_clause 
                   {
                     CheckModeSpecial4;
 
		     ParNameCTLocListPtr = new (PARSERHEAP())
		       ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_VOLATILE_TABLE, $5); 
                     $$ = tableTokens;
		   }

                   | TOK_CREATE ghost TOK_TABLE 
                   {
                     ParNameCTLocListPtr = new (PARSERHEAP())
                     ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_GHOST_TABLE, FALSE); 
                     $$ = tableTokens;
                   }

                   | TOK_CREATE TOK_SET TOK_VOLATILE TOK_TABLE optional_if_not_exists_clause
                   {
		     ParNameCTLocListPtr = new (PARSERHEAP())
		     ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_VOLATILE_SET_TABLE, $5); 
                     $$ = tableTokens;
		   }

		   | TOK_CREATE TOK_MULTISET TOK_VOLATILE TOK_TABLE optional_if_not_exists_clause
                   {
                     CheckModeSpecial1();
		     ParNameCTLocListPtr = new (PARSERHEAP())
		     ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                     TableTokens *tableTokens = new TableTokens(TableTokens::TYPE_VOLATILE_MULTISET_TABLE, $5); 
                     $$ = tableTokens;
		   }

/* type boolean */
optional_if_not_exists_clause : 
                empty
                  {
                    $$ = FALSE;
                  }
               | TOK_IF TOK_NOT TOK_EXISTS
                  {
                    $$ = TRUE;
                  }

/* type boolean */
optional_if_exists_clause :
          empty
            {
               $$ = FALSE;
             }
          | TOK_IF TOK_EXISTS
             {
               $$ = TRUE;
             }

/* type boolean */
optional_if_not_registered_clause : 
                empty
                  {
                    $$ = FALSE;
                  }
               | TOK_IF TOK_NOT TOK_REGISTERED
                  {
                    $$ = TRUE;
                  }
               | TOK_IF TOK_NOT TOK_EXISTS
                  {
                    $$ = TRUE;
                  }

/* type boolean */
optional_if_registered_clause :
          empty
            {
               $$ = FALSE;
             }
          | TOK_IF TOK_REGISTERED
             {
               $$ = TRUE;
             }
          | TOK_IF TOK_EXISTS
             {
               $$ = TRUE;
             }


create_table_as_attr_list_start: empty
	           {
		     // Mark the text begining of attr list
		     if (ParNameCTLocListPtr)
		       ParSetBeginOfCreateTableAsAttrList(ParNameCTLocListPtr);
		   }

create_table_as_attr_list_end: empty
	           {
		     // Mark the text begining of attr list
		     if (ParNameCTLocListPtr)
		       ParSetEndOfCreateTableAsAttrList(ParNameCTLocListPtr);
		   }

ctas_load_and_in_memory_options : TOK_LOAD TOK_IF TOK_EXISTS 
                   {
		     $$ = TableTokens::OPT_LOAD; 
		   }
                 | TOK_NO_LOAD
                   {
		     if (CmpCommon::getDefault(IN_MEMORY_OBJECT_DEFN) == DF_ON)
		       $$ = TableTokens::OPT_IN_MEM; 
		     else
		       $$ = TableTokens::OPT_NO_LOAD; 
		   }
                 | TOK_NO_LOAD TOK_IN TOK_MEMORY 
                   {
		     $$ = TableTokens::OPT_IN_MEM; 
		   }
                 | TOK_LOAD TOK_IF TOK_EXISTS TOK_WITH TOK_TRUNCATE
                   {
		     $$ = TableTokens::OPT_LOAD_WITH_DELETE; 
		   }
                 | TOK_LOAD TOK_IF TOK_EXISTS TOK_WITH TOK_DELETE TOK_DATA
                   {
		     $$ = TableTokens::OPT_LOAD_WITH_DELETE; 
		   }
                 | empty 
                   {		  
		     if (CmpCommon::getDefault(IN_MEMORY_OBJECT_DEFN) == DF_ON)
		       $$ = TableTokens::OPT_IN_MEM; 
		     else
		       $$ = TableTokens::OPT_NONE;
		   }

/* type pElemDDL */
ctas_insert_columns : TOK_INSERT TOK_COLUMNS '(' view_column_def_list ')'
                   {
		     if (CmpCommon::getDefault(COMP_BOOL_207) == DF_OFF)
		       {
			 YYERROR;
		       }

		     $$ = $4;
		   }
                 | empty {$$ = 0;}

create_table_as_token: TOK_AS
	{
	  // Mark the text begining of AS query
	  if (ParNameCTLocListPtr)
	    ParSetBeginOfCreateTableAsQueryPos(ParNameCTLocListPtr);
	}

/* type pElemDDL */
table_definition_body : table_element_list
                      | external_table_definition
                      | table_element_list external_table_definition
                        {
                          $$ = new (PARSERHEAP())
                            ElemDDLList(
                                 $1 /*table_elements*/,
                                 $2 /*table_element*/);
                        }

/* type pElemDDL */
table_element_list : '(' table_elements ')'
                                {
                                  $$ = $2 /*table_elements*/;
                                }
				   | optional_ignored_table_options '(' table_elements ')'
                                {
                                  $$ = $3 /*table_elements*/;
                                }

/* type tokval */
empty : 	{ $$ = 0; }

/* type pElemDDL */
table_elements : table_element
                      | table_elements ',' table_element
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLList(
						$1 /*table_elements*/,
						$3 /*table_element*/);
                                }

/* type pElemDDL */
table_element : set_in_column_defn column_definition reset_in_column_defn
                        {
                          $$ = $2;
                        }
                      | table_constraint_definition

set_in_column_defn : 
                  {
                    in_col_defn = TRUE; 
                    $$=1;
                  }
reset_in_column_defn : 
                  {
                    in_col_defn = FALSE;
                    $$  = 0;
                  }

/* type pElemDDL */
column_definition : qualified_name data_type optional_column_attributes
                                {
                                  NAType * type = $2;

                                  if (CmpCommon::getDefault(MODE_SPECIAL_4) == DF_ON) 
                                    {
                                      // change DATE to TIMESTAMP(0)
                                      if ((type->getTypeQualifier() == NA_DATETIME_TYPE) &&
                                          (type->getPrecision() == SQLDTCODE_DATE))
                                        {
                                          type = new (PARSERHEAP()) SQLTimestamp(PARSERHEAP(), TRUE, 0);
                                        }

                                      // change FLOAT(p) to NUMERIC(p)
                                      else if ((type->getFSDatatype() == REC_FLOAT64) &&
                                               (((SQLDoublePrecision*)type)->fromFloat()))
                                        {
                                          SQLDoublePrecision* f = (SQLDoublePrecision*) type;
                                          Lng32 numPrec = f->origPrecision();
                                          if (numPrec == 0)
                                            numPrec = 18;

                                          if (numPrec > MAX_HARDWARE_SUPPORTED_SIGNED_NUMERIC_PRECISION)
                                            type = new (PARSERHEAP()) 
                                              SQLBigNum(PARSERHEAP(), numPrec, 0, TRUE, TRUE, TRUE);
                                          else
                                            {
                                              const Int16 DisAmbiguate = 0; // added for 64bit project

                                              type = new (PARSERHEAP()) 
                                                SQLNumeric(PARSERHEAP(), TRUE, numPrec, 0, DisAmbiguate);
                                            }
                                        }
                                    }

                                  NAString * colFam = NULL;
                                  NAString * colNam = NULL;
                                  ShortStringSequence *strseq = $1;
                                  Lng32 numParts = strseq->numParts();
                                  if (CmpCommon::getDefault(TRAF_MULTI_COL_FAM) == DF_OFF)
                                    {
                                      if (numParts != 1)
                                        YYERROR;
                                      colNam = strseq->extract(0);
                                    }
                                  else
                                    {
                                      if (numParts > 2)
                                        YYERROR;

                                      if (numParts == 1)
                                        colNam = strseq->extract(0);
                                      else
                                        {
                                          colFam = strseq->extract(0);
                                          colNam = strseq->extract(1);
                                        }
                                    }

                                  $$ = new (PARSERHEAP())
				    ElemDDLColDef(
                                         colFam /* column family */,
                                         colNam /*column_name*/,
                                         type /*data_type*/,
                                         $3 /*optional_column_attributes*/);
                                  delete $1 /*column_name*/;
                                }

column_definition : qualified_name 
                                {
                                  NAString * colFam = NULL;
                                  NAString * colNam = NULL;
                                  ShortStringSequence *strseq = $1;
                                  Lng32 numParts = strseq->numParts();
                                  if (CmpCommon::getDefault(TRAF_MULTI_COL_FAM) == DF_OFF)
                                    {
                                      if (numParts != 1)
                                        YYERROR;
                                      colNam = strseq->extract(0);
                                    }
                                  else
                                    {
                                      if (numParts > 2)
                                        YYERROR;

                                      if (numParts == 1)
                                        colNam = strseq->extract(0);
                                      else
                                        {
                                          colFam = strseq->extract(0);
                                          colNam = strseq->extract(1);
                                        }
                                    }

                                  $$ = new (PARSERHEAP())
				    ElemDDLColDef(
                                         colFam /* column family */,
                                         colNam /*column_name*/,
                                         NULL,
                                         NULL);
                                  delete $1 /*column_name*/;
                                }

/* type stringval */
column_name : identifier

/* type pElemDDL */
col_def_default_clause : TOK_DEFAULT enableCharsetInferenceInColDefaultVal col_def_default_clause_argument
				{
				  $$ = $3 /*col_def_default_clause_argument*/;
                                  restoreInferCharsetState();
				}

                | TOK_NO_DEFAULT
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColDefault(
                                       ElemDDLColDefault::COL_NO_DEFAULT);
                                }
                | TOK_GENERATED sg_type sg_identity_option
                                {
				 				
			          // Process GENERATED BY DEFAULT or GENERATED ALWAYS AS					  
                                  ElemDDLSGOptions *pSGOptions = NULL;
		                           
		                  if ($3)
		                    {
		                       pSGOptions = $3->castToElemDDLColDefault()->getSGOptions();
		                       if (pSGOptions)
		                         pSGOptions->setCDType($2);
			               else
				         YYERROR;
				    }
				  else
				    YYERROR;
				  
                                   $$ = $3;
                                   
                                }
 /* type pElemDDL */
col_def_default_clause_argument : literal_negatable
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColDefault(
				       ElemDDLColDefault::COL_DEFAULT,
                                       $1 /*literal*/);
                                }

                      | datetime_value_function
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColDefault(
                                       ElemDDLColDefault::COL_DEFAULT,
                                       $1 /*datetime_value_function*/);
                                }

                      | datetime_misc_function_used_as_default
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColDefault(
                                       ElemDDLColDefault::COL_FUNCTION_DEFAULT);

                                  ((ElemDDLColDefault *)$$)->setDefaultExprString( (const NAString &)((DateFormat*)$1)->getOriginalString());
                                  ((ElemDDLColDefault *)$$)->setDefaultValueExpr($1);
                                }
                      | builtin_function_user
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColDefault(
                                       ElemDDLColDefault::COL_DEFAULT,
                                       $1 /*builtin_function_user*/);
                                }

                      | null_constant
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColDefault(
                                       ElemDDLColDefault::COL_DEFAULT,
                                       $1 /*null_constant*/);
                                }
                       
 /* type uint */
sg_type : TOK_BY TOK_DEFAULT TOK_AS
      {
        $$ = 1;
      }
        | TOK_ALWAYS TOK_AS
      {
        $$ = 2;
      }
                  
 /* type pElemDDL */                              
 sg_identity_option : sg_identity_function
                                { /* sg_identity_option */
				  $$ = new (PARSERHEAP())
				    ElemDDLColDefault(
						      ElemDDLColDefault::COL_DEFAULT,
						      NULL,
						      (ElemDDLSGOptions *)$1  /* ElemDDLSGOptions */
						      );
                                }                               

/* type pElemDDL */
optional_column_attributes : empty
                                {
                                  $$ = NULL;
                                }

                      | compress_clause
                      | column_attributes optional_compress_clause

/* type pElemDDL */
column_attributes : column_attribute
                      | column_attributes column_attribute
                                {
				  if ($2)
				    {
				      $$ = new (PARSERHEAP())
					ElemDDLList(
						    $1 /*column_attributes*/,
						    $2 /*column_attribute*/);
				    }
				  else
				    $$ = $1;
                                }

/* type pElemDDL */
column_attribute : column_constraint_definition
		    | optional_loggable
                    | optional_lobattrs
                    | heading
                    | serialized
                    | col_def_default_clause

/* type pElemDDL */
column_constraint_definition :  constraint_name_definition
                                column_constraint
                                optional_constraint_attributes
                                {
                                  $$ = $2 /*column_constraint*/;
				  if ($2)
				    {
				      $2->setConstraintName(
							    *$1 /*constraint_name_definition*/);
				      $2->setConstraintAttributes(
								  $3 /*optional_constraint_
								      *attributes*/);
				    }
                                  delete $1 /*constraint_name_definition*/;
                                }
                      | column_constraint optional_constraint_attributes
                                {
                                  $$ = $1 /*column_constraint*/;
				  if ($1)
				    $1->setConstraintAttributes(
								$2 /*optional_constraint_attributes*/);
                                }

/* type pQualName */
constraint_name_definition : TOK_CONSTRAINT constraint_name
                                {
                                  $$ = $2 /*constraint_name*/;
                                }

/* type pElemDDLConstraint */
column_constraint :  TOK_NOT TOK_NULL
                                {
			          NonISO88591LiteralEncountered = FALSE;
                                  $$ = new (PARSERHEAP()) ElemDDLConstraintNotNull(TRUE, PARSERHEAP());
                                }
                     |  TOK_NOT TOK_NULL TOK_ENABLE
                                {
			          NonISO88591LiteralEncountered = FALSE;
                                  $$ = new (PARSERHEAP()) ElemDDLConstraintNotNull(TRUE, PARSERHEAP());
                                }
                     |  TOK_NULL
                                {
				  NonISO88591LiteralEncountered = FALSE;
                                  $$ = new (PARSERHEAP()) ElemDDLConstraintNotNull(FALSE, PARSERHEAP());
                                }

                      | { NonISO88591LiteralEncountered = FALSE; } column_unique_specification
				{
				  $$ = $2 /*column_unique_specification*/;
				}

                      | { NonISO88591LiteralEncountered = FALSE; } references_specification
				{
				  $$ = $2 /*references_specification*/;
				}

                      | { NonISO88591LiteralEncountered = FALSE; } check_constraint_definition 
				{
				  $$ = $2 /*check_constraint_definition*/;
				}

// pElemDDLL
optional_loggable : TOK_LOGGABLE
					{
						$$ = new (PARSERHEAP()) ElemDDLLoggable(TRUE);
					}
					| TOK_NOT TOK_LOGGABLE
					{
						$$ = new (PARSERHEAP()) ElemDDLLoggable(FALSE);
					}

// pElemDDLL
optional_lobattrs :  TOK_STORAGE  QUOTED_STRING
        {
	  LobsStorage ls;
	  
	   if (*$2 == "external")
	    ls = Lob_External_HDFS_File;
	  else
	    ls = Lob_HDFS_File;

	  $$ = new (PARSERHEAP()) ElemDDLLobAttrs(ls);
	}

/* type columnOrderingEnum */
ddl_ordering_spec : TOK_ASC
				{
				  $$ = COM_ASCENDING_ORDER;
				}

                      | TOK_ASCENDING
				{
				  $$ = COM_ASCENDING_ORDER;
				}

                      | TOK_DESC
				{
				  $$ = COM_DESCENDING_ORDER;
				}

                      | TOK_DESCENDING
				{
				  $$ = COM_DESCENDING_ORDER;
				}

/* type pElemDDLConstraintUnique */
column_unique_specification : unique_constraint_specification
                      | TOK_PRIMARY TOK_KEY optional_nullable_pkey
                                {
                                  $$ = new (PARSERHEAP()) 
                                    ElemDDLConstraintPKColumn(
                                         COM_ASCENDING_ORDER, 
                                         $3 /*isNullable*/);
                                }

                      | TOK_PRIMARY TOK_KEY optional_nullable_pkey ddl_ordering_spec
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLConstraintPKColumn(
                                         $4 /*ddl_ordering_spec*/,
                                         $3 /*isNullable*/);
                                }

/* type pElemDDLConstraintUnique */
unique_constraint_specification : TOK_UNIQUE
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLConstraintUnique();
                                }

/* type pElemDDLConstraintUnique */
unique_specification : unique_constraint_specification
                      | TOK_PRIMARY TOK_KEY optional_nullable_pkey
                                {
                                  $$ = new (PARSERHEAP()) 
                                    ElemDDLConstraintPK(NULL, ComPkeySerialization::COM_SER_NOT_SPECIFIED,
                                                        $3);
                                }
                      | TOK_PRIMARY TOK_KEY optional_nullable_pkey TOK_SERIALIZED
                                {
                                  $$ = new (PARSERHEAP()) 
                                    ElemDDLConstraintPK(NULL, ComPkeySerialization::COM_SERIALIZED,
                                                        $3);
                                }
                      | TOK_PRIMARY TOK_KEY optional_nullable_pkey TOK_NOT TOK_SERIALIZED
                                {
                                  $$ = new (PARSERHEAP()) 
                                    ElemDDLConstraintPK(NULL, ComPkeySerialization::COM_NOT_SERIALIZED,
                                                        $3);
                                }

/* type pElemDDLConstraint */
check_constraint_definition : check_constraint_starting_tokens
                                search_condition ')'
                                {
                                  ElemDDLConstraintCheck *pCkCnstrnt =
                                    new (PARSERHEAP())
				      ElemDDLConstraintCheck(
                                        $2 /*search_condition*/,
                                        *ParNameLocListPtr,
                                        PARSERHEAP());
                                  if (ParSetTextEndPos(pCkCnstrnt)) 
				    { yyerror(""); YYERROR; }
                                  $$ = pCkCnstrnt;
                                  //
                                  // ParNameLocListPtr is no longer needed.
                                  //
                                  delete ParNameLocListPtr;
                                  ParNameLocListPtr = NULL;
                                }

/* type tokval */
check_constraint_starting_tokens : TOK_CHECK '('
                                {
                                  //
                                  // Allocates a working array to contain
                                  // the information relating to the
                                  // location of the ANSI name components
                                  // appearing in the search condition of
                                  // the check constraint definition.
                                  // This array helps with the computing of
                                  // the check constraint search condition
                                  // text.
                                  //
                                  // Also keeps track of the start position
                                  // of the search condition in the input
                                  // string.
                                  //
                                  ParNameLocListPtr = new (PARSERHEAP()) 
 				      ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                                  ParSetTextStartPosForCheckConstraint(
                                        ParNameLocListPtr);
                                }

/* type pElemDDLConstraintRI */
references_specification : TOK_REFERENCES referenced_table_and_columns
                                optional_ri_match_clause
                                optional_referential_triggered_action
                                {
				  if ($3 == COM_PARTIAL_MATCH_OPTION) {
				    // MATCH PARTIAL phrase not yet supported.
				    *SqlParser_Diags << DgSqlCode(-3024);
				    YYERROR;
				  }
                                  $$ = new (PARSERHEAP())
				    ElemDDLConstraintRI(
                                       $2 /*referenced_table_and_columns*/,
                                       $3 /*optional_ri_match_clause*/,
                                       $4 /*optional_referential_
                                           *triggered_action*/);
                                }

/* type pElemDDL */
referenced_table_and_columns : ddl_qualified_name
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLReferences(
                                        *$1 /*ddl_qualified_name*/);
                                  delete $1 /*ddl_qualified_name*/;
                                }
                      | ddl_qualified_name '(' reference_column_list ')'
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLReferences(
                                        *$1 /*ddl_qualified_name*/,
                                         $3 /*reference_column_list*/);
                                  delete $1 /*ddl_qualified_name*/;
                                }

/* type matchTypeEnum */
optional_ri_match_clause    : empty	  { $$ = COM_NONE_MATCH_OPTION; }
			    | match_clause
                                {
                                  $$ = $1;
                                  // MATCH clause is not yet supported in
                                  // referential integrity constraint
                                  // definition.
                                  *SqlParser_Diags << DgSqlCode(-3029)
                                          << DgString0("MATCH clause");
                                  YYABORT;                                  
                                }

match_clause		    : TOK_MATCH match_type { $$ = $2; }

match_type		    : TOK_FULL	  { $$ = COM_FULL_MATCH_OPTION; }
			    | TOK_PARTIAL { $$ = COM_PARTIAL_MATCH_OPTION; }

/* type pElemDDL */
optional_referential_triggered_action : empty { $$ = NULL; }
                      | referential_triggered_actions

/* type pElemDDL */
referential_triggered_actions : referential_triggered_action
                      | referential_triggered_actions
                                referential_triggered_action
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLList(
                                       $1 /*referential_triggered_actions*/,
                                       $2 /*referential_triggered_action*/);
                                }

/* type pElemDDL */
referential_triggered_action : update_rule
                      | delete_rule

/* type pElemDDL */
update_rule : TOK_ON TOK_UPDATE referential_action
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLRefTrigActUpdateRule(
                                       $3 /*referential_action*/);
                                }

/* type pElemDDL */
delete_rule : TOK_ON TOK_DELETE referential_action
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLRefTrigActDeleteRule(
                                       $3 /*referential_action*/);
                                }

/* type pElemDDL */
referential_action : TOK_CASCADE
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLRefActCascade();
                                  // CASCADE is not yet supported in
                                  // referential integrity constraint
                                  // definition.
                                  *SqlParser_Diags << DgSqlCode(-3029)
                                                   << DgString0("CASCADE");
                                  YYABORT;
                                }

                      | TOK_SET TOK_NULL
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLRefActSetNull();
                                  // SET NULL is not yet supported in
                                  // referential integrity constraint
                                  // definition.
                                  *SqlParser_Diags << DgSqlCode(-3029)
                                                   << DgString0("SET NULL");
                                  YYABORT;
                                }

                      | TOK_SET TOK_DEFAULT
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLRefActSetDefault();
                                  // SET DEFAULT is not yet supported in
                                  // referential integrity constraint
                                  // definition.
                                  *SqlParser_Diags << DgSqlCode(-3029)
                                                   << DgString0("SET DEFAULT");
                                  YYABORT;
                                }

                      | TOK_NO TOK_ACTION
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLRefActNoAction();
                                }
                      | TOK_RESTRICT
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLRefActRestrict();
                                }


/* type pElemDDL */
optional_constraint_attributes : empty
                                {
                                  $$ = NULL;
                                }

                      | constraint_attributes

/* type pElemDDL */
constraint_attributes : constraint_attribute
                      | constraint_attributes constraint_attribute
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLList(
                                       $1 /*constraint_attributes*/,
                                       $2 /*constraint_attribute*/);
                                }

/* type stringval */
format_attributes : empty { $$ = NULL; }
                    |  TOK_FORMAT QUOTED_STRING  
                         { 
			   $$ = $2; 
			 }

/* type pElemDDL */
constraint_attribute : constraint_attribute_droppable
						| constraint_attribute_enforced

/* type pElemDDL */
constraint_attribute_droppable : TOK_DROPPABLE
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLConstraintAttrDroppable(TRUE);
                                }
                      | TOK_NOT_DROPPABLE
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLConstraintAttrDroppable(FALSE);
								}
/* type pElemDDL */
constraint_attribute_enforced : TOK_ENFORCED
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLConstraintAttrEnforced(TRUE);
                                }
                         | TOK_NOT_ENFORCED
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLConstraintAttrEnforced(FALSE);
                                } 

/* type pElemDDL */
heading : TOK_HEADING heading_character_string_literal
                                {
                                  $$ = $2; // heading_character_string_literal - type pElemDDL
                                }
                      | TOK_NO TOK_HEADING
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLColHeading(ElemDDLColHeading::COL_NO_HEADING);
                                }

/* type pElemDDL */
heading_character_string_literal : character_string_literal
                                {
                                  // heading_character_string_literal ::= character_string_literal

                                  NAString *pHeadingText = $1/*character_string_literal*/;
                                  TrimNAStringSpace(*pHeadingText, FALSE, TRUE);  // trim trailing blanks
                                  $$ = new (PARSERHEAP()) ElemDDLColHeading(ElemDDLColHeading::COL_HEADING,
                                                                            *pHeadingText/*deep copy*/);
                                  delete pHeadingText;
                                }
                      | unicode_string_literal
				{
                                     NAString *pCString = NULL;
                                     if ($1/*unicode_string_literal*/->length() == 0)
                                       pCString = new(PARSERHEAP()) NAString(PARSERHEAP()); // an empty string
                                     else
                                       pCString = unicodeToChar
                                       ( $1/*unicode_string_literal*/->data()   // const NAWchar *
                                       , $1/*unicode_string_literal*/->length() // in NAWchars
                                       , (Lng32) ComGetNameInterfaceCharSet()   // CharInfo::UTF8
                                       , PARSERHEAP()                           // heap for *pCString
                                       , FALSE                     // in - NABoolean allowInvalidChar
                                       );
                                     if (pCString == NULL)
                                     {
                                       // The string argument contains characters that cannot be converted.
                                       *SqlParser_Diags << DgSqlCode(-8413);
                                       YYERROR;
                                     }
                                     $$ = new (PARSERHEAP()) ElemDDLColHeading
                                       ( ElemDDLColHeading::COL_HEADING
                                       , *pCString // deep copy
                                       );
                                     delete $1; // NAWString * unicode_string_literal
                                     delete pCString;
				}

/* type pElemDDL */
serialized : TOK_SERIALIZED
                                {
				  if (CmpCommon::getDefault(MODE_SEABASE) == DF_OFF)
				    {
				      // Not for non-seabase mode
				      yyerror("");
				      YYERROR;
				    }

				  $$ = new (PARSERHEAP()) ElemDDLSeabaseSerialized(TRUE);
                                }
                         | TOK_NOT TOK_SERIALIZED
                                {
				  if (CmpCommon::getDefault(MODE_SEABASE) == DF_OFF)
				    {
				      // Not for non-seabase mode
				      yyerror("");
				      YYERROR;
				    }

				  $$ = new (PARSERHEAP()) ElemDDLSeabaseSerialized(FALSE);
                                }

/* type pElemDDL */
optional_compress_clause : empty
                           { $$ = NULL; }
                         | compress_clause
                           { $$ = NULL; }

compress_clause : TOK_COMPRESS
                  { $$ = NULL; }
                | TOK_COMPRESS literal
                  { $$ = NULL; }
                | TOK_COMPRESS '(' literal ')'
                  { $$ = NULL; }
                | TOK_COMPRESS value_expression_list_paren
                  { $$ = NULL; }


/* type pElemDDL */
table_constraint_definition : { NonISO88591LiteralEncountered = FALSE; } constraint_name_definition table_constraint
                                optional_constraint_attributes
                                {
                                  $3->setConstraintName(
                                      *$2 /*constraint_name_definition*/);
                                  $3->setConstraintKind(ElemDDLConstraint::
                                                        TABLE_CONSTRAINT_DEF);
                                  $3->setConstraintAttributes(
                                       $4 /*optional_constraint_attributes*/);
                                  $$ = $3 /*table_constraint*/;
                                  delete $2 /*constraint_name_definition*/;
                                }

                      | { NonISO88591LiteralEncountered = FALSE; } table_constraint optional_constraint_attributes
                                {
                                  $2->setConstraintKind(ElemDDLConstraint::
                                                        TABLE_CONSTRAINT_DEF);
                                  $2->setConstraintAttributes(
                                       $3 /*optional_constraint_attributes*/);
                                  $$ = $2 /*table_constraint*/;
                                }

/* type pElemDDLConstraint */
table_constraint : unique_constraint_definition
		 | references_constraint_definition
		 | check_constraint_definition

/* type pElemDDLConstraint */
unique_constraint_definition : unique_specification '(' unique_column_list ')'
                                {
                                  $1->setColumnRefList(
                                       $3 /*unique_column_list*/);
                                  $$ = $1 /*unique_specification*/;
                                }

/* type pElemDDL */
unique_column_list : column_reference_list

/* type pElemDDL */
column_reference_list : column_reference
                      | column_reference_list ',' column_reference
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColRefList(
                                       $1 /*column_reference_list*/,
                                       $3 /*column_reference*/);
                                }

/* type pElemDDL */
column_reference : column_name
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColRef(
                                        *$1 /*column_name*/,
                                        COM_UNKNOWN_ORDER /*default val*/,
                                        PARSERHEAP());
                                  delete $1 /*column_name*/;
                                }

                      | column_name ddl_ordering_spec
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColRef(
                                        *$1 /*column_name*/,
                                         $2 /*ddl_ordering_spec*/,
                                        PARSERHEAP());
                                  delete $1 /*column_name*/;
                                }

/* type pElemDDLConstraint */
references_constraint_definition : 
      TOK_FOREIGN TOK_KEY '(' referencing_columns ')' references_specification
                                {
                                  $6->setReferencingColumnNameList(
                                       $4 /*referencing_columns*/);
                                  $$ = $6 /*references_specification*/;
                                }

/* type pElemDDL */
referencing_columns : reference_column_list

/* type pElemDDL */
reference_column_list : column_name_list

/* type pElemDDL */
column_name_list : column_name_spec
                      | column_name_list ',' column_name_spec
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColNameList(
                                       $1 /*column_name_list*/,
                                       $3 /*column_name_spec*/);
                                }

/* type pElemDDL */
column_name_spec : column_name
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColName(*$1 /*column_name*/);
                                  delete $1 /*column_name*/;
                                }

/* type pElemDDL */
like_definition : TOK_LIKE source_table optional_like_option_list
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLLikeCreateTable(
                                        *$2 /*source_table*/,
                                         $3 /*optional_like_option_list*/,
                                        FALSE,
                                        PARSERHEAP());
                                  delete $2 /*source_table*/;
                                }

/* type pElemDDL */
external_table_definition : TOK_FOR source_table
                                {
                                  if (SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_)
                                    SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_ = FALSE;

                                  if (SqlParser_CurrentParser->hiveDDLInfo_->backquotedDelimFound_)
                                    { 
                                      yyerror(""); 
                                      YYERROR;
                                    }

                                  $$ = new (PARSERHEAP())
				    ElemDDLLikeCreateTable(
                                        *$2 /*source_table*/,
                                        NULL,
                                        TRUE, 
                                        PARSERHEAP());
                                  delete $2 /*source_table*/;
                                }

//++ MV
// added support for special tables
/* type corrName */
source_table : qualified_name 
		  {
		     // helps with computing view text
		     //
		     ParInsertNameLoc($1->getPosition(), $1->getNameLength());
		     //
		     // note that corrNameFromStrings()
		     // contains code that deletes $1
		     //
		     $$ = corrNameFromStrings($1);
		     if ($$ == NULL) YYABORT;

		     if (processVolatileDDLName(&($$->getQualifiedNameObj()),
						FALSE, FALSE) == NULL)
		       YYABORT;
		  }
	       | TOK_TABLE '(' TOK_IUD_LOG_TABLE qualified_name 
		 optional_special_table_loc_clause ')'
		  {
		    if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
		    {
			// note that corrNameFromStrings()
			// contains code that deletes $4
			//
			$$ = corrNameFromStrings($4);
			$$->setSpecialType(ExtendedQualName::IUD_LOG_TABLE);
			if ($5 /*optional_special_table_loc_clause*/ NEQ NULL)
			{
			  $$/*actual_table_name*/->setPartnClause(*$5);
			  delete $5/*optional_special_table_loc_clause*/;
			}
		    }
		    else
		      { yyerror(""); YYERROR; /*internal syntax only!*/}
		  } 

	       | TOK_TABLE '(' TOK_RANGE_LOG_TABLE qualified_name 
		 optional_special_table_loc_clause ')'
		  {
		    if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
		    {
			// note that corrNameFromStrings()
			// contains code that deletes $4
			//
			$$ = corrNameFromStrings($4);
			$$->setSpecialType(ExtendedQualName::RANGE_LOG_TABLE);
			if ($5 /*optional_special_table_loc_clause*/ NEQ NULL)
			{
			  $$/*actual_table_name*/->setPartnClause(*$5);
			  delete $5/*optional_special_table_loc_clause*/;
			}
		    }
		    else
		      { yyerror(""); YYERROR; /*internal syntax only!*/}
		  }
//-- MV

/* type pElemDDL */
optional_like_option_list : empty
                                {
                                  $$ = NULL;
                                }

                      | like_option_list

/* type pElemDDL */
like_option_list : like_option
                      | like_option_list like_option
                                {
                                  if ($1 != NULL && $2 != NULL)
                                    $$ = new (PARSERHEAP())
                                      ElemDDLList(
                                           $1 /*like_option_list*/,
                                           $2 /*like_option*/);
                                  else if ($1 != NULL)
                                    $$ = $1;
                                  else
                                    $$ = $2;
                                }

/* type pElemDDL */
like_option : TOK_WITHOUT TOK_CONSTRAINTS
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLLikeOptWithoutConstraints();
                                }
                      | TOK_WITH TOK_CONSTRAINTS
                                {
                                  // for backward compatibility
                                  $$ = NULL;
                                }

                      | TOK_WITH TOK_HEADINGS
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLLikeOptWithHeadings();
                                }
                      | TOK_WITH TOK_PARTITIONS
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLLikeOptWithHorizontalPartitions();
                                }
                      | TOK_WITH TOK_HORIZONTAL TOK_PARTITIONS
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLLikeOptWithHorizontalPartitions();
                                }
                      | TOK_WITHOUT TOK_SALT
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLLikeOptWithoutSalt();
                                }
                      | TOK_WITHOUT TOK_DIVISION
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLLikeOptWithoutDivision();
                                }
                      | salt_by_clause
                                {
                                  ElemDDLSaltOptionsClause * saltClause = 
                                    $1->castToElemDDLSaltOptionsClause();
                                  ComASSERT($1->castToElemDDLSaltOptionsClause());
                                  $$ = new (PARSERHEAP())
                                    ElemDDLLikeSaltClause(saltClause);
                                }
                      | TOK_LIMIT TOK_COLUMN TOK_LENGTH TOK_TO unsigned_integer
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLLikeLimitColumnLength($5);
                                }
                      | TOK_WITHOUT TOK_ROW TOK_FORMAT
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLLikeOptWithoutRowFormat();
                                }
                      | TOK_WITHOUT TOK_LOB TOK_COLUMNS
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLLikeOptWithoutLobColumns();
                                }

/* type pElemDDL */
optional_create_table_attribute_list : create_table_as_attr_list_start
                                {
                                  $$ = NULL;
                                }

                      | create_table_as_attr_list_start create_table_attribute_list
                                {
				  $$ = $2;
				}

/* type pElemDDL */
create_table_attribute_list : create_table_attribute
                      | create_table_attribute_list create_table_attribute
                                {
                                  if ($1 == NULL)
                                  {
                                     $$ = $2;
                                  }
                                  else if ($2 == NULL)
                                  {
                                     $$ = $1;
                                  }
                                  else
                                  $$ = new (PARSERHEAP())
				    ElemDDLOptionList(
                                       $1 /*create_table_attribute_list*/,
                                       $2 /*create_table_attribute*/);
                                }

/* type pElemDDL */
create_table_attribute : file_attribute_clause
                      | location_clause
                      | partition_definition
                      | salt_by_clause
                      | division_by_clause
                      | store_by_clause
		      | mv_file_attribute_clause // for MVs only
                      | file_attribute_pos_clause
                      | table_feature
                      | hbase_table_options 

/* type pElemDDL */
file_attribute_clause : file_attribute_keyword file_attribute_list
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrClause(
                                       $2 /*file_attribute_list*/);
                                }

/* type tokval */
file_attribute_keyword : TOK_ATTRIBUTE
                      |  TOK_ATTRIBUTES

/* type pElemDDL */
file_attribute_list : file_attribute

                      | file_attribute_list file_attribute
                                {
                                  // *** Error *** comma must be used
                                  // to separate file attributes
                                  //*SqlParser_Diags << DgSqlCode(-3026);

                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrList(
                                       $1 /*file_attribute_list*/,
                                       $2 /*file_attribute*/);
                                }

                      | file_attribute_list ',' file_attribute
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrList(
                                       $1 /*file_attribute_list*/,
                                       $3 /*file_attribute*/);
                                }

/* type pElemDDL */
file_attribute :        file_attribute_allocate_clause
                      | file_attribute_audit_clause
                      | file_attribute_audit_compress_clause
                      | file_attribute_block_size_clause
                      | file_attribute_buffered_clause
                      | file_attribute_clear_on_purge_clause
                      | file_attribute_compression_clause
/* not yet supported: | file_attribute_dcompress_clause		***/
                      | file_attribute_deallocate_clause
                      | file_attribute_icompress_clause
/* not supported anymore | file_attribute_max_size_clause       ***/
					  | file_attribute_extent_clause
					  | file_attribute_maxextent_clause
					  | file_attribute_rangelog_clause
					  | file_attribute_lockonrefresh_clause
					  | file_attribute_insertlog_clause
					  | file_attribute_mvs_allowed_clause
					  | file_attribute_uid_clause
                      | file_attribute_row_format_clause
                      | file_attribute_no_label_update_clause
                      | file_attribute_owner_clause
                      | file_attribute_default_col_fam

/* type pElemDDL */           
file_attribute_allocate_clause : TOK_ALLOCATE unsigned_smallint
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrAllocate(
                                       $2 /*unsigned_smallint*/);
                                }
 
/* type pElemDDL */
file_attribute_audit_clause : TOK_AUDIT
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrAudit(TRUE);
                                }

                      | TOK_NO TOK_AUDIT
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrAudit(FALSE);
                                }

/* type pElemDDL */
file_attribute_audit_compress_clause : TOK_AUDITCOMPRESS
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrAuditCompress(TRUE);
                                }

                      | TOK_NO TOK_AUDITCOMPRESS
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrAuditCompress(FALSE);
                                }

/* type pElemDDL */
file_attribute_block_size_clause : TOK_BLOCKSIZE unsigned_integer
                                optional_block_size_unit
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrBlockSize(
                                       $2 /*unsigned_integer*/);
                                }

/* type tokval */
optional_block_size_unit : empty
                      | TOK_BYTES

/* type pElemDDL */
file_attribute_buffered_clause : TOK_BUFFERED
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLFileAttrBuffered(TRUE);
                                }

                      | TOK_NO TOK_BUFFERED
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrBuffered(FALSE);
                                }

/* type pElemDDL */
file_attribute_clear_on_purge_clause : TOK_CLEARONPURGE
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrClearOnPurge(TRUE);
                                }

                      | TOK_NO TOK_CLEARONPURGE
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrClearOnPurge(FALSE);
                                }

/* type pElemDDL */
file_attribute_compression_clause : TOK_COMPRESSION
                        {
                           ComCompressionType compressionType;
                           if (CmpCommon::getDefault(COMPRESSION_TYPE, 0) == DF_HARDWARE)
                              compressionType = COM_HARDWARE_COMPRESSION;
                           else if (CmpCommon::getDefault(COMPRESSION_TYPE, 0) == DF_SOFTWARE)
                              compressionType = COM_SOFTWARE_COMPRESSION;
                           else
                             compressionType = COM_NO_COMPRESSION;

                          $$ = new (PARSERHEAP())
                          ElemDDLFileAttrCompression(compressionType);
                     
                        }
                        |
                        TOK_NO TOK_COMPRESSION
                        {
                          $$ = new (PARSERHEAP())
                          ElemDDLFileAttrCompression(COM_NO_COMPRESSION);
                        }
                        | 
                        TOK_COMPRESSION TOK_TYPE TOK_NONE
                        {
                          $$ = new (PARSERHEAP())
                          ElemDDLFileAttrCompression(COM_NO_COMPRESSION);
                        }
                        | TOK_COMPRESSION TOK_TYPE TOK_SOFTWARE
                        {
                          $$ = new (PARSERHEAP())
                          ElemDDLFileAttrCompression(COM_SOFTWARE_COMPRESSION);
                        }
                        | TOK_COMPRESSION TOK_TYPE TOK_HARDWARE
                        {
                          $$ = new (PARSERHEAP())
                          ElemDDLFileAttrCompression(COM_HARDWARE_COMPRESSION);
                        }

/* type pElemDDL */
file_attribute_deallocate_clause : TOK_DEALLOCATE
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrDeallocate();
                                }

/* type pElemDDL */
file_attribute_icompress_clause : TOK_ICOMPRESS
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrICompress(TRUE);
                                }

                      | TOK_NO TOK_ICOMPRESS
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrICompress(FALSE);
                                }

/* type pElemDDL */
file_attribute_extent_clause : TOK_EXTENT file_attribute_extent
                                {
                                  $$ = $2 /*file_attribute_extent*/;
                                }

optional_page : empty
              | TOK_PAGE
              | TOK_PAGES

/* longint */
extent_page : unsigned_integer optional_page { $$ = (Lng32)$1; }

/* longint */
signed_extent_page : sign extent_page 
				     { 
                       if ($1 == '+') /* ignore plus sign and continue */
                         $$ = $2;
                       else { // Negative value not allowed for EXTENT value.
                         *SqlParser_Diags << DgSqlCode(-3198);
                         $$ = 0;
                         YYABORT;
                       }
                     }

/* type pElemDDL */
file_attribute_extent : TOK_UNBOUNDED
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrExtents();
                                }

                      | extent_page
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLFileAttrExtents( 
                                       $1 /*unsigned_integer (pri ext)*/,
                                       $1 /*unsigned_integer (sec ext)*/);
                                }

                      | '(' extent_page ')'
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLFileAttrExtents(
                                       $2 /*unsigned_integer (pri ext)*/,
			               $2 /*unsigned_integer (sec ext)*/);
                                }

                      | '(' extent_page ',' extent_page ')'
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrExtents(
                                       $2 /*unsigned_integer (pri ext)*/,
                                       $4 /*unsigned_integer (sec ext)*/);

                                }

                      | signed_extent_page
                        {
				  $$ = new (PARSERHEAP())
                                  ElemDDLFileAttrExtents( 
                                       $1 /*unsigned_integer (pri ext)*/,
                                       $1 /*unsigned_integer (sec ext)*/);
                        }

                      | '(' signed_extent_page ')'
                        {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLFileAttrExtents(
                                       $2 /*unsigned_integer (pri ext)*/);
			              /*since no sec ext was supplied, let the default be used*/
                        }

                      | '(' signed_extent_page ',' extent_page ')'
                        {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrExtents(
                                       $2 /*unsigned_integer (pri ext)*/,
                                       $4 /*unsigned_integer (sec ext)*/);
                        }

                      | '(' extent_page ',' signed_extent_page ')'
                        {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrExtents(
                                       $2 /*unsigned_integer (pri ext)*/,
                                       $4 /*unsigned_integer (sec ext)*/);
                        }

                      | '(' signed_extent_page ',' signed_extent_page ')'
                        {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrExtents(
                                       $2 /*unsigned_integer (pri ext)*/,
                                       $4 /*unsigned_integer (sec ext)*/);
                        }

/* type pElemDDL */
file_attribute_maxextent_clause : TOK_MAXEXTENTS file_attribute_maxextent
                                {
                                  $$ = $2 /*file_attribute_maxextent*/;
                                }

file_attribute_maxextent : TOK_UNBOUNDED
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrMaxExtents();
                                }

                      | extent_page
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrMaxExtents(
                                       $1 /*unsigned_integer (max ext)*/);
                                }

/* type pElemDDL */
file_attribute_no_label_update_clause : TOK_NO TOK_LABEL TOK_UPDATE
                                {
				  if (! Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
				    {
				      yyerror(""); YYERROR; /*internal syntax only!*/
				    }

                                  $$ = new (PARSERHEAP())
				    ElemDDLFileAttrNoLabelUpdate(TRUE);
                                }

//++ MV 
// type pElemDDL 
file_attribute_rangelog_clause : range_log_type TOK_RANGELOG
								{
									$$ = new (PARSERHEAP())
										ElemDDLFileAttrRangeLog($1);
								}

//++ MV 
// type rangelogType 
range_log_type : TOK_NO
					{
						$$ = COM_NO_RANGELOG;
					}
					| TOK_AUTOMATIC
					{
						$$ = COM_AUTO_RANGELOG;
					}
					| TOK_MANUAL
					{
						$$ = COM_MANUAL_RANGELOG;
					}
					| TOK_MIXED
					{
						$$ = COM_MIXED_RANGELOG;
					}


// type pElemDDL 
file_attribute_lockonrefresh_clause: TOK_LOCKONREFRESH
									 {
										$$ = new (PARSERHEAP())
											ElemDDLFileAttrLockOnRefresh(TRUE);
									 }
									 | TOK_NO TOK_LOCKONREFRESH
									 {
										$$ = new (PARSERHEAP())
											ElemDDLFileAttrLockOnRefresh(FALSE);
									 }



// type <pElemDDL>  		
file_attribute_insertlog_clause: TOK_INSERTLOG
								 {
										$$ = new (PARSERHEAP())
											ElemDDLFileAttrInsertLog(TRUE);

								 }
								 | TOK_NO TOK_INSERTLOG
								 {
										$$ = new (PARSERHEAP())
											ElemDDLFileAttrInsertLog(FALSE);
								 }


// type <pElemDDL>  		
file_attribute_mvs_allowed_clause: 	mvs_allowed_type TOK_MVS TOK_ALLOWED
									{
										$$ = new (PARSERHEAP())
											ElemDDLFileAttrMvsAllowed($1);

									}


// type <mvsAllowedType>  
mvs_allowed_type: TOK_NO
				  {
					  $$ = COM_NO_MVS_ALLOWED;
				  }
				  | TOK_ON TOK_STATEMENT
				  {
					$$ = COM_ON_STATEMENT_MVS_ALLOWED;
				  }
				  | TOK_ON TOK_REQUEST
				  {
					$$ = COM_ON_REQUEST_MVS_ALLOWED;
				  }
				  | TOK_RECOMPUTE
				  {
					$$ = COM_RECOMPUTE_MVS_ALLOWED;
				  }
				  | TOK_ALL
				  {
					$$ = COM_ALL_MVS_ALLOWED;
				  }


/* type pElemDDL */
file_attribute_uid_clause : TOK_UID NUMERIC_LITERAL_EXACT_NO_SCALE
                                {
       // This syntax to be used by Backup/Restore only.
       // If Backup/Restore is ever implemented then add a parserflag for it 
       // and report the 3001 error only if flag is not set.
                                  *SqlParser_Diags << DgSqlCode(-3001) << DgString0("UID");

       // Uncomment the next 2 lines if Backup/Restore is ever implemented.
				  //$$ = new (PARSERHEAP()) ElemDDLFileAttrUID(atoInt64($2->data()));
				  //delete $2;		   
                                }

/* type pElemDDL */
file_attribute_owner_clause : TOK_BY authorization_identifier
                                  {
                                    $$ = new (PARSERHEAP()) ElemDDLFileAttrOwner(*$2);
                                    delete $2;
                                  }
 

/* type pElemDDL */
file_attribute_row_format_clause : TOK_ALIGNED TOK_FORMAT
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLFileAttrRowFormat
				    (ElemDDLFileAttrRowFormat::eALIGNED);
                                }
				| TOK_PACKED TOK_FORMAT
				{
                                  yyerror("");
                                  YYERROR;
                                  
                                  $$ = new (PARSERHEAP()) ElemDDLFileAttrRowFormat
				    (ElemDDLFileAttrRowFormat::ePACKED);
				}
				| TOK_HBASE TOK_FORMAT
				{
                                  $$ = new (PARSERHEAP()) ElemDDLFileAttrRowFormat
				    (ElemDDLFileAttrRowFormat::eHBASE);
				}

/* type pElemDDL */
file_attribute_default_col_fam : TOK_DEFAULT TOK_COLUMN TOK_FAMILY QUOTED_STRING
                                {
                                  if (CmpCommon::getDefault(TRAF_MULTI_COL_FAM) == DF_OFF)
                                    {
                                      YYERROR;
                                    }

                                  $$ = new (PARSERHEAP()) ElemDDLFileAttrColFam(*$4);
                                }

/* type pElemDDL */
attribute_inmemory_options_clause : 
           TOK_INDEX TOK_LEVELS unsigned_integer
           {
	     // max of index levels of partitions that
	     // belong to this table.
	     $$ = new (PARSERHEAP()) 
	       ElemDDLFileAttrPOSTableSize(-1,-1,-1,$3,-1);
	   }

	 | TOK_PARTITIONS TOK_EOF  NUMERIC_LITERAL_EXACT_NO_SCALE
	   {
	     // EOF for one partition of the table in bytes.
	     $$ = new (PARSERHEAP()) 
	       ElemDDLFileAttrPOSTableSize(-1,-1,-1,-1,atoInt64($3->data()));
	   }

/* type pElemDDL */
file_attribute_pos_clause : TOK_INITIAL TOK_TABLE TOK_SIZE unsigned_integer
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSTableSize($4, -1, -1);
                                }
                         |  TOK_MAX TOK_TABLE TOK_SIZE unsigned_integer
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSTableSize(-1, $4, -1);
                                }
                         |  TOK_TABLE TOK_SIZE '(' unsigned_integer ',' unsigned_integer ')'
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSTableSize($4, $6, -1);
                                }
                         |  attribute_num_rows_clause

                         // applies only to inMemory table definitions
                         |  attribute_inmemory_options_clause

                         |  TOK_NUMBER TOK_OF TOK_LOCAL TOK_PARTITIONS unsigned_integer
                                {
				  // negative number of partitions except -1 
				  // indicate local partitions. 
				  // -1 in numPartns field indicates that partn
				  // clause was not specified.
				  // If num of local partns is 1, set the value
				  // to zero.
				  // 1 local partition is the same as no partitions.
				  Int32 partitions = ($5 == 1 ? 0 : -1 * $5);
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSNumPartns(($5 == 1 ? 0 : -(Int32)$5));
                                }
                         |  TOK_NO_PARTITION
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSNumPartns(0);
                                }
                         |  TOK_NO_PARTITIONS
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSNumPartns(0);
                                }
                         |  TOK_IGNORE TOK_POS
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSIgnore(TRUE);
                                }
                         |  TOK_NUMBER TOK_OF TOK_LOCAL TOK_PARTITIONS TOK_SYSTEM
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSNumPartns(-MAX_COMSINT32);
                                }
                         |  TOK_NUMBER TOK_OF TOK_ALL TOK_PARTITIONS unsigned_integer
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSNumPartns($5);
                                }
                         |  TOK_NUMBER TOK_OF TOK_ALL TOK_PARTITIONS TOK_SYSTEM
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSNumPartns(MAX_COMSINT32);
                                }
                         |  TOK_NUMBER TOK_OF TOK_PARTITIONS unsigned_integer
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSNumPartns($4);
                                }
                         |  TOK_NUMBER TOK_OF TOK_PARTITIONS TOK_SYSTEM
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSNumPartns(MAX_COMSINT32);
                                }
                         | TOK_DISK TOK_POOL unsigned_integer
                           {
                             $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSDiskPool($3,MAX_COMSINT32);
                           }
                         | TOK_DISK TOK_POOL unsigned_integer TOK_OF unsigned_integer
                           {
                             $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSDiskPool($3,$5);
                           }
                         | TOK_DISK TOK_POOL TOK_ANY TOK_OF unsigned_integer
                           {
                             $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSDiskPool(MAX_COMSINT32, $5);
                           }


/* type pElemDDL */
attribute_num_rows_clause : TOK_NUMBER TOK_OF TOK_ROWS unsigned_integer
                                {
				  $$ = new (PARSERHEAP()) ElemDDLFileAttrPOSTableSize(-1, -1, $4);
                                }
                          | TOK_NUMBER TOK_OF TOK_ROWS NUMERIC_LITERAL_APPROX
                                {
				  ConstValue * cv = 
				    (ConstValue*)(literalOfApproxNumeric($4));
				  if (! cv) 
				    YYERROR;

				  $$ = 
				    new (PARSERHEAP()) ElemDDLFileAttrPOSTableSize(
					 -1, -1, 
					 ((cv->getStorageSize() == sizeof(float))
					  ? *(float*)(cv->getConstValue())
					  : *(double*)(cv->getConstValue())));
                                }

/* type ComPartitioningScheme */
partition_type    : empty
                      {
                        $$ = COM_HASH_V2_PARTITIONING;   
                      }
                  | TOK_RANGE
                      {
			if (CmpCommon::getDefault(ALLOW_RANGE_PARTITIONING) == DF_OFF)
			  {
			    // range partitioning is allowed only if this CQD is set.
			    YYERROR;
			  }
			
                        $$ = COM_RANGE_PARTITIONING;
                      }
                  | TOK_HASH
                      {
                        $$ = COM_HASH_V1_PARTITIONING;   
                      }
                  | TOK_HASH2
                      {
                        $$ = COM_HASH_V2_PARTITIONING;   
                      }

/* TD-style ON COMMIT clause -- ignore it! */

table_feature : TOK_NOT_DROPPABLE
                { 
                    $$ = new (PARSERHEAP())
                      ElemDDLTableFeature(COM_NOT_DROPPABLE);
                }
                | TOK_DROPPABLE
                {
                    $$ = new (PARSERHEAP())
                      ElemDDLTableFeature(COM_DROPPABLE);
                }
                | TOK_INSERT_ONLY
                { 
                  if (CmpCommon::getDefault(CAT_ALLOW_NEW_FEATUREX)==DF_OFF)
                  {
                    // Not yet externalized
                    yyerror("");
                    YYERROR;
                  }

                  $$ = new (PARSERHEAP())
                     ElemDDLTableFeature(COM_DROPPABLE_INSERT_ONLY);
                }
                | TOK_INSERT_ONLY ',' TOK_NOT_DROPPABLE
                { 
                  if (CmpCommon::getDefault(CAT_ALLOW_NEW_FEATUREX)==DF_OFF)
                  {
                    // Not yet externalized
                    yyerror("");
                    YYERROR;
                  }
                  $$ = new (PARSERHEAP())
                    ElemDDLTableFeature(COM_NOT_DROPPABLE_INSERT_ONLY);
               }
               | TOK_INSERT_ONLY ',' TOK_DROPPABLE
               {
                  if (CmpCommon::getDefault(CAT_ALLOW_NEW_FEATUREX)==DF_OFF)
                  {
                    // Not yet externalized
                    yyerror("");
                    YYERROR;
                  }

                  $$ = new (PARSERHEAP())
                    ElemDDLTableFeature(COM_DROPPABLE_INSERT_ONLY);
                }
                | TOK_NOT_DROPPABLE ',' TOK_INSERT_ONLY
                {
                  if (CmpCommon::getDefault(CAT_ALLOW_NEW_FEATUREX)==DF_OFF)
                  {
                    // Not yet externalized
                    yyerror("");
                    YYERROR;
                  }
                  $$ = new (PARSERHEAP())
                    ElemDDLTableFeature(COM_NOT_DROPPABLE_INSERT_ONLY);
                }
                | TOK_DROPPABLE ',' TOK_INSERT_ONLY
                {
                  if (CmpCommon::getDefault(CAT_ALLOW_NEW_FEATUREX)==DF_OFF)
                  {
                    // Not yet externalized
                    yyerror("");
                    YYERROR;
                  }

                  $$ = new (PARSERHEAP())
                    ElemDDLTableFeature( COM_DROPPABLE_INSERT_ONLY);
                }


is_not_droppable : TOK_DROPPABLE
                   { $$ = FALSE; }
                 | TOK_NOT_DROPPABLE
                   { $$ = TRUE; }

online_or_offline    : TOK_ONLINE
                      { $$ = TRUE; }
                     | TOK_OFFLINE
                      { $$ = FALSE; }

/* type boolean */
optional_in_memory_clause : empty
                             {   
			       if (CmpCommon::getDefault(IN_MEMORY_OBJECT_DEFN) == DF_ON)
				 $$ = TRUE;
			       else
				 $$ = FALSE; 
			     }
                            | TOK_IN TOK_MEMORY
                             { 
			       $$ = TRUE; 
			     }

/* type stringval */
optional_map_to_hbase_clause : empty
                             {   
                               $$ = NULL;
			     }
                            | TOK_MAP TOK_TO TOK_HBASE TOK_TABLE identifier
                             { 
			       $$ = $5; 
			     }
/* type int */
optional_hbase_data_format : empty
                             {   
                               $$ = TRUE; // varchar format
			     }
                            | TOK_DATA TOK_FORMAT TOK_VARCHAR
                             { 
			       // data is stored in var length string format 
			       // For ex, 123 is stored as a 3 byte string "123"
			       $$ = TRUE; 
			     }
                            | TOK_DATA TOK_FORMAT TOK_NATIVE
                             { 
			       // data is stored in native format.
			       // For ex, smallint is stored as 2 byte binary
			       $$ = FALSE;
			     }

hbase_table_options : TOK_HBASE_OPTIONS '('  hbase_options_list ')'
                              {
				$$ = new (PARSERHEAP()) 
				  ElemDDLHbaseOptions($3, PARSERHEAP());
			      }

hbase_options_list : hbase_option
                      {
			NAList<HbaseCreateOption*> * hbol =
			  new (PARSERHEAP ()) NAList<HbaseCreateOption*>(PARSERHEAP ());
			hbol->insert($1);
			$$ = hbol;
		      }
                     | hbase_options_list ',' hbase_option
                      {
			$1->insert($3);
			$$ = $1;
		      }
;

hbase_option : identifier '=' QUOTED_STRING
                     {
			 //			 new(PARSERHEAP()) HbaseCreateOption(*$1, *$3);
		       NAText key($1->data());
		       NAText val($3->data());
		       HbaseCreateOption * hbo =
			 new(PARSERHEAP()) HbaseCreateOption(key, val);
		       $$ = hbo;
		     }

/* type pElemDDL */
partition_definition : partition_type TOK_PARTITION 
                                     optional_partition_definition_body
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLPartitionClause(
                                       $3 /*optional_partition_definition_body*/,
                                       NULL /*partition_by_column_list*/, 
                                       $1 /*partition_type*/);
                                }
                     | partition_type TOK_PARTITION_BY partition_by_column_list 
                                     optional_partition_definition_body
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLPartitionClause(
                                       $4 /*optional_partition_definition_body*/,
                                       $3 /*partition_by_column_list*/, 
                                       $1 /*partition_type*/);
                                }
                     | partition_type TOK_PARTITION_BY TOK_RANGE_N '(' range_n_args ')'
                       { $$ = NULL ; }

/* TD-style partition definition -- ignore so we use HASH2 by default! */

range_n_args : range_n_arg
             | range_n_arg ',' range_n_args


range_n_arg : value_expression TOK_BETWEEN value_expression { $$ = NULL; }
            | value_expression TOK_BETWEEN '*'              { $$ = NULL; }

            | value_expression TOK_BETWEEN value_expression
                               TOK_AND     value_expression { $$ = NULL; }

            | value_expression TOK_BETWEEN '*'
                               TOK_AND     value_expression { $$ = NULL; }
            | value_expression TOK_BETWEEN value_expression
                               TOK_AND     '*'              { $$ = NULL; }

            | value_expression TOK_BETWEEN '*' TOK_AND '*'  { $$ = NULL; }

            | value_expression TOK_BETWEEN value_expression
                               TOK_EACH    literal          { $$ = NULL; }
            | value_expression TOK_BETWEEN value_expression
                               TOK_AND     value_expression
                               TOK_EACH    literal          { $$ = NULL; }
            | value_expression TOK_BETWEEN value_expression
                               TOK_AND     '*'
                               TOK_EACH    literal          { $$ = NULL; }

            | value_expression                              { $$ = NULL; }
            | '*'                                           { $$ = NULL; }
            | value_expression TOK_AND  value_expression    { $$ = NULL; }
            | '*'              TOK_AND  value_expression    { $$ = NULL; }
            | value_expression TOK_AND  '*'                 { $$ = NULL; }
            | '*'              TOK_AND  '*'                 { $$ = NULL; }

            | value_expression TOK_EACH literal             { $$ = NULL; }
            | value_expression TOK_AND  value_expression
                               TOK_EACH literal             { $$ = NULL; }
            | value_expression TOK_AND '*' TOK_EACH literal { $$ = NULL; }

            | TOK_NO TOK_RANGE TOK_OR  TOK_UNKNOWN          { $$ = NULL; }
            | TOK_NO TOK_RANGE                              { $$ = NULL; }

/* type pElemDDL */
partition_by_column_list : '(' column_reference_list ')'
                                {
                                  $$ = new (PARSERHEAP())
				      ElemDDLPartitionByColumnList(
                                       $2 /*column_reference_list*/);
                                }

/* type pElemDDL */
optional_partition_definition_body : empty
                                {
                                  $$ = NULL;
                                }
                             | partition_definition_body
                                {
                                  $$ = $1 /*partition_definition_body*/;
                                }

/* type pElemDDL */
partition_definition_body : '(' partition_list ')'
                                {
                                  $$ = $2 /*partition_list*/;
                                }

                   /* | other partitioning scheme such as hash */
                   /* | new partitioning method such as balance */

/* type pElemDDL */
partition_list : range_partition_list
                      | system_partition_list

/* type pElemDDL */
range_partition_list : range_partition
                      | range_partition_list ',' range_partition
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLPartitionList(
                                       $1 /*range_partition_list*/,
                                       $3 /*range_partition*/);
                                }
/* type pElemDDL */
range_partition : partition_add_drop_option { NonISO88591LiteralEncountered = FALSE; } TOK_FIRST TOK_KEY key_list
                                location_clause optional_partition_attribute_list
                                {
				  if (NonISO88591LiteralEncountered) {
				    *SqlParser_Diags << DgSqlCode(-1240);
				    YYABORT;
				  }
                                  $$ = new (PARSERHEAP())
				    ElemDDLPartitionRange(
                                       $1 /*partition_add_drop_option*/,
                                       $5 /*key_list*/,
                                       $6 /*location_clause*/,
                                       $7 /*optional_partition_attribute_list*/);
                                }

/* type pElemDDL */
key_list :   key_value
	 | '(' key_value_list ')'
                                {
                                  $$ = $2 /*key_value_list*/;
                                }
/* type pElemDDL */
system_partition_list : system_partition
                      | system_partition_list ',' system_partition
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLPartitionList(
                                       $1 /*system_partition_list*/,
                                       $3 /*system_partition*/);
                                }

/* type pElemDDL */
system_partition : partition_add_drop_option location_clause
                                optional_partition_attribute_list
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLPartitionSystem(
                                       $1 /*partition_add_drop_option*/,
                                       $2 /*location_clause*/,
                                       $3 /*optional_partition_attribute_list*/);
                                }

/* type pElemDDL */
optional_partition_attribute_list : empty
                                {
                                  $$ = NULL;
                                }

                      | partition_attribute_list

/* type pElemDDL */
partition_attribute_list :   partition_attribute

		      | partition_attribute_list partition_attribute
		     
        {

                    $$ = new (PARSERHEAP()) ElemDDLPartnAttrList(
                                       $1 /*partition_attribute_list*/,
                                       $2 /*partition_attribute*/);
        }
/* type pElemDDL */
partition_attribute : file_attribute_extent_clause
		      | file_attribute_maxextent_clause

/* type partitionOptionEnum */
partition_add_drop_option : TOK_ADD
                                {
                                  $$ = ElemDDLPartition::ADD_OPTION;
                                }

                      | TOK_DROP
                                {
                                  $$ = ElemDDLPartition::DROP_OPTION;
                                }

/* type pElemDDL */
key_value :  literal_negatable
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLKeyValue($1 /*literal*/);
                                }

                      | null_constant
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLKeyValue($1 /*literal*/);
                                }

/* type pElemDDL */
key_value_list : key_value
                      | key_value_list ',' key_value
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLKeyValueList(
                                       $1 /*key_value_list*/,
                                       $3 /*key_value*/);
                                }

/* type tokval */
division_by_clause_starting_tokens : TOK_DIVISION TOK_BY '('
                               {
                                 // division_by_clause_starting_tokens ::= TOK_DIVISION TOK_BY '('

                                 // This code is similar to that of check_constraint_starting_tokens 
                                 ParNameDivByLocListPtr = new (PARSERHEAP()) 
                                   ParNameLocList ( SQLTEXT()
                                                  , (CharInfo::CharSet)SQLTEXTCHARSET()
                                                  , SQLTEXTW()
                                                  , PARSERHEAP()
                                                  );
                                  ParSetTextStartPosForDivisionByClause(ParNameDivByLocListPtr);
                               }

/* type pElemDDL */
salt_by_clause : TOK_SALT TOK_USING NUMERIC_LITERAL_EXACT_NO_SCALE TOK_PARTITIONS optional_salt_column_list
                               {
                                 Int32 numParts = (Int32) atoi(*$3);
                                 if (numParts < 0)
                                   YYERROR;
                                 $$ = new (PARSERHEAP()) ElemDDLSaltOptionsClause($5, numParts);
                               }

optional_salt_column_list : TOK_ON '(' column_reference_list ')'
                               {
                                 $$ = $3;
                               }
                   | /* empty */
                               {
                                 $$ = NULL;
                               }

/* type pElemDDL */
salt_like_clause : TOK_SALT TOK_LIKE TOK_TABLE
                               {
                                 $$ = new (PARSERHEAP()) ElemDDLSaltOptionsClause(TRUE); //like table
                               }

/* type pElemDDL */
division_by_clause : division_by_clause_starting_tokens sort_by_value_expression_list  optional_division_column_names ')'
                               {
                                 // division_by_clause ::= division_by_clause_starting_tokens sort_by_value_expression_list ')'

                                 ElemDDLDivisionClause * pDivClause = new (PARSERHEAP())
                                   ElemDDLDivisionClause($2); // sort_by_value_expression_list
                                 pDivClause->setNameLocList(*ParNameDivByLocListPtr); // deep copy
                                 if (ParSetTextEndPos(pDivClause))
                                 {
                                   YYERROR;
                                 }
                                 pDivClause->setStartPosition(ParNameDivByLocListPtr->getTextStartPosition());
                                 delete ParNameDivByLocListPtr;
                                 ParNameDivByLocListPtr = NULL;
                                 if ($3)
                                   {
                                     pDivClause->synthesize($3 /*column_reference_list*/);
                                     if (NOT pDivClause->isNumOfDivExprsAndColsMatched())
                                       {
                                         YYERROR;
                                       }
                                   }
                                   
                                 $$ = pDivClause;
                               }

/* type pElemDDL */
optional_division_column_names : empty
                               { $$ = NULL; }
                    | TOK_NAMED TOK_AS '(' column_reference_list ')'
                               {
                                 $$ = $4;
                               }

/* type pElemDDL */
store_by_clause : TOK_STORE TOK_BY store_option_clause
                                {
                                  $$ = $3 /*store_option*/;
                                }

                  | TOK_UNIQUE TOK_PRIMARY_INDEX  '(' column_reference_list ')'
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLStoreOptKeyColumnList(
                                       $4 /*column_reference_list*/,
                                       TRUE);
                                }
                  | TOK_PRIMARY_INDEX  '(' column_reference_list ')'
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLStoreOptKeyColumnList(
                                       $3 /*column_reference_list*/);
                                }
                  | TOK_PRIMARY TOK_KEY TOK_NOT TOK_SERIALIZED '(' column_reference_list ')' 
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLStoreOptKeyColumnList(
                                       $6 /*column_reference_list*/,
				       TRUE, FALSE, TRUE);
                                  ((ElemDDLStoreOptKeyColumnList*)$$)->
                                    setSerializedOption(ComPkeySerialization::COM_NOT_SERIALIZED);
                                }

                  | TOK_PRIMARY TOK_KEY TOK_SERIALIZED '(' column_reference_list ')' 
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLStoreOptKeyColumnList(
                                       $5 /*column_reference_list*/,
				       TRUE, FALSE, TRUE);
                                  ((ElemDDLStoreOptKeyColumnList*)$$)->
                                    setSerializedOption(ComPkeySerialization::COM_SERIALIZED);
                                }

                  | TOK_PRIMARY TOK_KEY  '(' column_reference_list ')'
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLStoreOptKeyColumnList(
                                       $4 /*column_reference_list*/,
				       TRUE, FALSE, TRUE);
                                }

/* type pElemDDL */
store_option_clause : TOK_UNIQUE unique_store_option
                                {
                                  $$ = $2 /*unique_store_option*/;
                                }
                      | store_option
                                {
                                  $$ = $1 /*store_option*/;
                                }

/* type pElemDDL */
unique_store_option : TOK_PRIMARY TOK_KEY
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLStoreOptNondroppablePK(
                                       TRUE /*unique*/ );
                                }

                      | '(' column_reference_list ')'
                                {
                                  CHECK_DBTRANSPORTER ;
                                  $$ = new (PARSERHEAP())
				    ElemDDLStoreOptKeyColumnList(
                                       $2 /*column_reference_list*/,
                                       FALSE,
                                       TRUE /*uniqueStoreByKeyList*/ );
                                }

/* type pElemDDL */
store_option : TOK_PRIMARY TOK_KEY
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLStoreOptNondroppablePK(
                                       FALSE /*not unique*/ );
                                }

                      | '(' column_reference_list ')'
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLStoreOptKeyColumnList(
                                       $2 /*column_reference_list*/);
                                }

                      | TOK_ENTRY TOK_ORDER
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLStoreOptEntryOrder();
				  // Illegal syntax error
				  YYERROR;
                                }

/* type pStmtDDL */
view_definition : create_view_keywords 
                                optional_if_not_exists_clause 
                                ddl_qualified_name
                                optional_view_column_list
                                optional_location_clause
                                optional_by_auth_identifier
                                TOK_AS optional_locking_stmt_list 
                                query_expression
                                order_by_clause
                                optional_with_check_option
                                {
				  RelRoot *top = finalize($9);
				  if (($10) &&
				      (CmpCommon::getDefault(ALLOW_ORDER_BY_IN_CREATE_VIEW) == DF_OFF))
				    {
				      YYERROR;
				    }

                                  top->addOrderByTree($10);
				  if ((top->accessOptions().userSpecified()) &&
				      (CmpCommon::getDefault(ALLOW_ISOLATION_LEVEL_IN_CREATE_VIEW) == DF_OFF))
				    {
				      // Genesis 10-980217-0467:
				      // FOR xxx ACCESS not allowed in C.V.
				      // At first blush allowing it seems a nifty
				      // shorthand -- but it does not fit at all
				      // well with Ansi/Tdm txn/stmt
				      // isolation-level defaulting model.
				      // Also see BindWA::bindView.
				      *SqlParser_Diags << DgSqlCode(-3168);
				      ComASSERT(top->accessOptions().lockMode() ==
						LOCK_MODE_NOT_SPECIFIED_);
				      YYERROR;
				    }
                                   //10-070108-1558 -Begin
                                   //[First/Any N] syntax is not allowed in
                                   // CREATE VIEW statement
                                   //But if internal CQD is set, it is allowed.
                                   if(CmpCommon::getDefault(ALLOW_FIRSTN_IN_SUBQUERIES) != DF_ON)
                                   {
                                   if ($9->getFirstNRows() != -1)
                                   {
                                      *SqlParser_Diags << DgSqlCode(-4103);
                                       YYERROR;
                                   }
                                   }
                                   //10-070108-1558 -End

				  StmtDDLCreateView *pCreateViewParseNode
				    = new (PARSERHEAP())
				    StmtDDLCreateView(
					 *$3 /*ddl_qualified_name*/,
					 *ParNameLocListPtr,

                                         $4 /*optional_view_column_list*/,
                                         $5 /*optional_location_clause*/,
                                         top,
                                         $11 /*optional_with_check_option*/,
                                         $1 /*optional_create_view_behavior_enum*/,
                                         $6 /*optional_by_auth_identifier*/);

                                  if ($2)
                                    pCreateViewParseNode->setCreateIfNotExists(TRUE);

                                  delete $3 /*ddl_qualified_name*/;
                                  pCreateViewParseNode->synthesize();
                                  if (ParSetTextEndPos(pCreateViewParseNode))
				    { yyerror(""); YYERROR; }
                                  $$ = pCreateViewParseNode;
                                }

/* type tokval */
create_view_keywords : TOK_CREATE TOK_VIEW
                                {
				  //
                                  // This is the first production being
                                  // reduced in the processing of create
                                  // view statement.
                                  //
                                  // Allocates a working array to contain
                                  // the information relating to the
                                  // location of the ANSI name components
                                  // appearing in the create view statement.
                                  // This array helps with the computing of
                                  // the view text.
                                  //
                                  // Also keeps track of the start position
                                  // of the create view statement in the
                                  // input string.
                                  //
				  NonISO88591LiteralEncountered = FALSE;

                                  ParNameLocListPtr = new (PARSERHEAP())
                                    ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                                  ParSetTextStartPosForCreateView(
                                        ParNameLocListPtr);
                                  $$ = COM_CREATE_VIEW_BEHAVIOR;

                                  SqlParser_CurrentParser->hiveDDLInfo_->
                                    setValues(TRUE, StmtDDLonHiveObjects::CREATE_, StmtDDLonHiveObjects::VIEW_);
                                }
                     | TOK_CREATE TOK_SYSTEM TOK_VIEW
                                {
                                  // see comment above
                                  NonISO88591LiteralEncountered = FALSE;

                                  ParNameLocListPtr = new (PARSERHEAP())
                                      ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                                  ParSetTextStartPosForCreateView(
                                        ParNameLocListPtr);
                                  $$ = COM_CREATE_SYSTEM_VIEW_BEHAVIOR;

                                }
                     | TOK_CREATE TOK_OR TOK_REPLACE TOK_VIEW 
                                {
                                  // see comment above
                                  NonISO88591LiteralEncountered = FALSE;

                                  ParNameLocListPtr = new (PARSERHEAP())
                                      ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                                  ParSetTextStartPosForCreateView(
                                        ParNameLocListPtr);
                                  $$ = COM_CREATE_OR_REPLACE_VIEW_BEHAVIOR;

                                }
                     | TOK_CREATE TOK_OR TOK_REPLACE TOK_VIEW TOK_CASCADE
                                {
                                  // see comment above
                                  NonISO88591LiteralEncountered = FALSE;

                                  ParNameLocListPtr = new (PARSERHEAP())
                                      ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
                                  ParSetTextStartPosForCreateView(
                                        ParNameLocListPtr);
                                  $$ = COM_CREATE_OR_REPLACE_VIEW_CASCADE_BEHAVIOR;

                                }

/* type pQualName */
routine_action_qualified_name : routine_action_name
                                {
                                  // routine_action_qualified_name ::= routine_action_name

                                  // helps with computing view text
                                  ParInsertNameLoc($1->getPosition(),
                                                   $1->getNameLength());
                                  //
                                  // note that qualifiedNameFromStrings()
                                  // contains code that deletes $1
                                  //
                                  $$ = qualifiedNameFromStrings($1);
                                  if ($$ == NULL) 
                                    YYABORT;
                                  
                                  $$ = processVolatileDDLName($$, FALSE, FALSE);
                                  if ($$ == NULL)
                                    YYABORT;

                                  $$->setObjectNameSpace(COM_UUDF_ACTION_NAME);
                                }

/* type pQualName */
ddl_qualified_name : qualified_name
		     {
                       // ddl_qualified_name :
                       // helps with computing view text
                       //
                       StringPos namePos = $1->getPosition();
                       size_t nameLen = $1->getNameLength();
                       ParInsertNameLoc(namePos, nameLen);
                       
                       //
                       // note that qualifiedNameFromStrings()
                       // contains code that deletes $1
                       //
                       $$ = qualifiedNameFromStrings($1);
                       if ($$ == NULL) 
                         YYABORT;
                       
                       $$ = processVolatileDDLName($$, FALSE, FALSE);
                       if ($$ == NULL)
                         YYABORT;
                       
                       SqlParser_CurrentParser->hiveDDLInfo_->ddlNamePos_ = namePos;
                       SqlParser_CurrentParser->hiveDDLInfo_->ddlNameLen_ = nameLen;
                     
                       preprocessHiveDDL(
                            $$->getCatalogName(), 
                            SqlParser_CurrentParser->hiveDDLInfo_);  
                     }

/* type pQualName */
volatile_ddl_qualified_name : qualified_name
				{
				  // helps with computing view text
				  //
				  ParInsertNameLoc($1->getPosition(),
				     		   $1->getNameLength());
				  //
				  // note that qualifiedNameFromStrings()
				  // contains code that deletes $1
				  //
				  $$ = qualifiedNameFromStrings($1);
				  if ($$ == NULL) 
				    YYABORT;


				  $$ = processVolatileDDLName($$, TRUE, TRUE);
				  if ($$ == NULL) 
				    YYABORT;
				}

/* type pElemDDL */
/*	The following productions are intended to ensure we ignore the following options.
Create Table <tablename> [,CHECKSUM = ALL|DEFAULT|LOW|MEDIUM|HIGH|NONE]	
Create Table <tablename> [,[NO] FALLBACK [PROTECTION]]	  
Create Table <tablename> [,FREESPACE = <int value> [PERCENT]]  
Create Table <tablename> [,[NO|DUAL|LOCAL|NOT LOCAL] AFTER JOURNAL]	 
Create Table <tablename> [,[NO|DUAL] [BEFORE] JOURNAL]	 
Create Table <tablename> [,[NO] LOG]  
*/
optional_ignored_table_options :  optional_ignored_table_option
                               | optional_ignored_table_option  optional_ignored_table_options

optional_ignored_table_option :   ',' TOK_FALLBACK optional_ignored_suffix	 { $$ = NULL; }
					           |  ',' TOK_NO TOK_FALLBACK optional_ignored_suffix	 { $$ = NULL; }
					           |  ',' TOK_FREESPACE '=' unsigned_integer optional_ignored_suffix	 { $$ = NULL; }
							   |  ',' TOK_CHECKSUM '='  optional_ignored_suffix	 { $$ = NULL; }
							   |  ',' TOK_CHECKSUM '='  IDENTIFIER	 { $$ = NULL; }		// this is for NONE
  						       |  ',' TOK_LOG { $$ = NULL; }
							   |  ',' TOK_NO TOK_LOG { $$ = NULL; }
					   		   |  ',' optional_ignored_prefix optional_ignored_prefix2 TOK_JOURNAL  { $$ = NULL; }

optional_ignored_suffix : empty { $$ = NULL; }
				   	 	 | TOK_PROTECTION { $$ = NULL; }
				   		 | TOK_PERCENT { $$ = NULL; }
				   		 | TOK_ALL { $$ = NULL; }
				   		 | TOK_DEFAULT { $$ = NULL; }

optional_ignored_prefix : empty { $$ = NULL; }
                        | TOK_NO { $$ = NULL; }
                        | TOK_DUAL { $$ = NULL; }
				   		| TOK_LOCAL { $$ = NULL; }
				   	    | TOK_NOT TOK_LOCAL { $$ = NULL; }

optional_ignored_prefix2 : empty { $$ = NULL; }
                        | TOK_BEFORE { $$ = NULL; }
				 		| TOK_AFTER { $$ = NULL; }  
/* type pElemDDL */
optional_view_column_list : empty
                                {
                                  $$ = NULL;
                                }
                      | view_column_list

/* type pElemDDL */
view_column_list : '(' view_column_def_list ')'
                       {
			 //   Keep position of end of column list
			 if(ParNameLocListPtr==NULL) YYERROR;  // 10-060228-4747
			 ParSetEndOfOptionalColumnListPos(ParNameLocListPtr);
			 
			 $$ = $2 /*view_column_name_list*/;
		       }

/* type pElemDDL */
view_column_def_list : view_column_definition
                      | view_column_def_list ',' view_column_definition
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLList(
                                       $1 /*view_column_def_list*/,
                                       $3 /*view_column_definition*/);
                                }

/* type pElemDDL */
view_column_definition : column_name
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColViewDef(
                                        *$1 /*column_name*/);
                                  delete $1 /*column_name*/;
                                }

                      | column_name heading
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLColViewDef(
                                        *$1 /*column_name*/,
                                         $2 /*heading*/);
                                  delete $1 /*column_name*/;
                                }

/* type pElemDDL */
optional_with_check_option : empty
                                {
                                  $$ = NULL;
                                }

                      | with_check_option

/* type pElemDDL */
with_check_option : TOK_WITH optional_levels_clause TOK_CHECK TOK_OPTION
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLWithCheckOption(
                                       $2 /*optional_levels_clause*/);
                                }

/* type levelEnum */
optional_levels_clause : empty
                                {
                                  $$ = COM_CASCADED_LEVEL;
                                }

                      | levels_clause

/* type levelEnum */
levels_clause : TOK_CASCADED
                                {
                                  $$ = COM_CASCADED_LEVEL;
                                }

                      | TOK_LOCAL
                                {
                                  // *** Error *** WITH LOCAL CHECK
                                  // OPTION clause not supported.
                                  *SqlParser_Diags << DgSqlCode(-3119);
                                  $$ = COM_LOCAL_LEVEL;
                                }

/* type pStmtDDL */
give_statement : TOK_GIVE TOK_SCHEMA schema_name 
                 TOK_TO authorization_identifier optional_drop_behavior
                                {
                  $$ = new (PARSERHEAP())
                    StmtDDLGiveSchema(
                                         *$3 /*schema_name*/,
                                         *$5 /*authorization_identifier*/,
                                          $6 /*drop behavior*/);
                  delete $5;
                  delete $3;
                                }

               |
                 TOK_GIVE givable_object_type ddl_qualified_name 
                 TOK_TO authorization_identifier
                                {
                  $$ = new (PARSERHEAP())
                    StmtDDLGiveObject(
                                          $2, /*ComObjectType*/
                                         *$3, /*qualified_name*/
                                         *$5 /*authorization_identifier*/);
                  delete $3;
                  delete $5;
                                }
                       
               |
                 TOK_GIVE TOK_ALL TOK_FROM authorization_identifier 
                 TOK_TO authorization_identifier
                                {
                  $$ = new (PARSERHEAP())
                    StmtDDLGiveAll(
                                         *$4, /*from auth ID*/
                                         *$6  /*to auth ID*/);
                  delete $4;
                  delete $6;
                                }
                       
/* type pObjectTypeEnum */
givable_object_type:       TOK_TABLE
                           {
                             $$ = COM_BASE_TABLE_OBJECT;
                           }
                           | TOK_VIEW
                           {
                             $$ = COM_VIEW_OBJECT;
                           }
                           | TOK_LIBRARY
                           {
                             $$ = COM_LIBRARY_OBJECT;
                           }
                           | TOK_PROCEDURE
                           {
                             $$ = COM_STORED_PROCEDURE_OBJECT;
                           }
                           | TOK_FUNCTION
                           {
                             $$ = COM_USER_DEFINED_ROUTINE_OBJECT;
                           }

/* type pStmtDDL */
revoke_role_statement : TOK_REVOKE optional_with_admin_option
                                   TOK_ROLE authorization_identifier_list
                                   TOK_FROM grantee_list
                                   optional_drop_behavior
                                   optional_granted_by
                        {
                          $$ = new (PARSERHEAP())
                            StmtDDLRoleGrant(
                                $4 , /* authorization_identifier_list - role list */
                                $6 , /* grantee list */
                                $2 , /* optional_with_admin_option */
                                $8 , /* optional granted by */
                                $7 , /* optional drop behavior */
                                FALSE /* isGrantRole */ );
                        }

/* type boolean */
optional_with_admin_option : empty
                             {
                               $$ = FALSE;
                             }

                           | TOK_WITH TOK_ADMIN TOK_OPTION
                           {
                             $$ = TRUE;
                           }

/*admin_option_for : empty
                   {
                       $$ = FALSE;
                   }
              | TOK_ADMIN TOK_OPTION TOK_FOR
                   {
                       $$ = TRUE;
                   }*/

/* type pElemDDL */
authorization_identifier_list : authorization_identifier
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLGrantee(*$1 /*authorization_identifier*/);
                                  delete $1 /*authorization_identifier*/;
                                }

                     | authorization_identifier_list ',' authorization_identifier
                       {
                         $$ = new (PARSERHEAP())
                           ElemDDLList
                           ( $1 /*authorization_identifier_list*/
                           , new (PARSERHEAP())
                             ElemDDLGrantee(*$3 /*authorization_identifier*/)
                           );
                         delete $3 /*authorization_identifier*/;
                       }

/* type pElemDDL */
optional_granted_by: empty
                     { 
                       $$ = NULL;
                     }
                   | optional_granted TOK_BY TOK_CURRENT_USER
                     {
                       // we make a grantee node with CURRENT_USER as the 
                       // name of the grantee(user).   This special case 
                       // is then handled in the Exec code
                       NAString currentUserConstant("CURRENT_USER");
                      
                       $$ = new (PARSERHEAP())
                       ElemDDLGrantee(currentUserConstant,
                                      PARSERHEAP());                     
                     }
                   | optional_granted TOK_BY authorization_identifier
                     {
                       // optional_granted_by ::= TOK_GRANTED TOK_BY authorization_identifier

                                  $$ = new (PARSERHEAP())
                                    ElemDDLGrantee(
                                        *$3 /*authorization_identifier*/,
                                        PARSERHEAP());
                                  delete $3 /*authorization_identifier*/;
                     } 

/* type boolean */
optional_granted : empty
                   {
                     $$ = FALSE;
                   }
                 | TOK_GRANTED
                   {
                     $$ = TRUE;
                   }
                           
/* type pStmtDDL */
grant_statement : TOK_GRANT privileges TOK_ON ddl_object_name optional_action
                            TOK_TO grantee_list optional_with_grant_option
                            optional_granted_by
                          {
                            $$ = new (PARSERHEAP())
                              StmtDDLGrant($2 /*privileges*/,
                                          *$4 /*ddl_object_name*/,
                                           $7 /*grantee_list*/,
                                           $8 /*optional_with_grant_option*/,
                                           $9 /*optional_granted_by*/,
                                           $5 /*optional_action*/);
                            delete  $4  /*ddl_object_name*/;

//                  | TOK_GRANT privileges TOK_ON TOK_TABLE '(' ghost TOK_TABLE ddl_qualified_name ')' optional_action
//                            TOK_TO grantee_list optional_with_grant_option
//                            optional_granted_by

//                          {
//			    $8->setSpecialType(ExtendedQualName::GHOST_TABLE);
//
//                            $$ = new (PARSERHEAP())
//                              StmtDDLGrant($2 /*privileges*/,
//                                          *$8 /*ddl_object_name*/,
//                                           $12 /*grantee_list*/,
//                                           $13 /*optional_with_grant_option*/,
//                                           $14 /*optional_granted_by*/,
//                                           $10 /*optional_action*/);
//                            delete  $8  /*ddl_object_name*/;
//                          }

                          }

/* type pStmtDDL */
grant_schema_statement : TOK_GRANT privileges TOK_ON TOK_SCHEMA schema_name 
                            TOK_TO grantee_list optional_with_grant_option
                            optional_granted_by
                          {
 			    $$ = new (PARSERHEAP())
			      StmtDDLSchGrant($2 /*privileges*/,
                                             *$5 /*schema_name*/,
                                              $7 /*grantee_list*/,
                                              $8 /*optional_with_grant_option*/,
                                              $9 /*optional_granted_by*/);
                            delete $5 /*schema_name*/;
                         }
                       | TOK_GRANT privileges TOK_ON TOK_DEFAULT TOK_SCHEMA
                            TOK_TO grantee_list optional_with_grant_option
                            optional_granted_by
                          {
                            if (!Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
                            {
                              yyerror(""); YYERROR; /*internal syntax only!*/
                            }

                            SchemaName defaultSchema;
                            ElemDDLSchemaName schemaName(defaultSchema);

                            $$ = new (PARSERHEAP())
                              StmtDDLSchGrant($2 /*privileges*/,
                                              schemaName /*schema_name*/,
                                              $7 /*grantee_list*/,
                                              $8 /*optional_with_grant_option*/,
                                              $9 /*optional_granted_by*/);
                         }

/* type pStmtDDL */
grant_role_statement : TOK_GRANT TOK_ROLE authorization_identifier_list TOK_TO grantee_list
                                 optional_with_admin_option
                                 optional_granted_by
                       {
                          $$ = new (PARSERHEAP())
			       StmtDDLRoleGrant(
                                $3 , /*role list*/ 
                                $5 , /* grantee list */
                                $6 , /* optional with admin option */
				$7 , /* optional granted by */ 
				COM_UNKNOWN_DROP_BEHAVIOR, /* optional drop behavior */
				TRUE  /* isGrantRole */  );
                       }                                   

/* type pStmtDDL */
grant_component_privilege_stmt :  TOK_GRANT TOK_COMPONENT privilege_or_privileges_token
                                            component_privilege_name_list
                                            TOK_ON component_name
                                            TOK_TO authorization_identifier_or_public
                                            optional_with_grant_option
                                            optional_granted_by
               {
                 // grant_component_privilege_stmt ::=
                 //   TOK_GRANT TOK_COMPONENT privilege_or_privileges_token
                 //             component_privilege_name_list TOK_ON component_name
                 //             TOK_ON component_name
                 //             TOK_TO authorization_identifier
                 //             optional_with_grant_option
                 //             optional_granted_by
                 $$ = new(PARSERHEAP())
                   StmtDDLGrantComponentPrivilege
                   ( $4  // component_privilege_name_list - shallow copy
                   , *$6 // component_name - deep copy
                   , *$8 // authorization_identifier - a.k.a. user_role_name - deep copy
                   , ($9 != NULL) // optional_with_grant_option - NABoolean
                   , $10 // optional granted by
                   , PARSERHEAP()
                   );
                 // cannot delete $4 (shallow copy)
                 delete $6; // component_name
                 delete $8; // authorization_identifier - a.k.a. user_role_name
                 delete $9; // optional_with_grant_option
               }

authorization_identifier_or_public : authorization_identifier
                                     {
                                       $$=$1;
                                     }
                                     | TOK_PUBLIC
				     {
                                       NAString *tmp = new
 					   (PARSERHEAP()) NAString(("PUBLIC"),PARSERHEAP());
                                        $$ = tmp;
				     }
/* type pConstStringList */
component_privilege_name_list : component_privilege_name
               {
                 $$ = new (PARSERHEAP()) ConstStringList(PARSERHEAP ());
                 $$->insert($1); // component_privilege_name - NAString * stringval - shallow copy
               }
               | component_privilege_name_list ',' component_privilege_name
               {
                 // See if the privilege name has already been specified
                 for (CollIndex i = 0; i < $1->entries(); i++)
                 {
                    NAString listName = $1->operator[](i)->data();
                    NAString currentName = $3->data();
                    if (listName == currentName)
                    {
                      *SqlParser_Diags << DgSqlCode(-3170);
                       YYABORT;
                    }
                 }
                 $1->insert($3); // $3 - NAString   * component_privilege_name      - shallow copy
                 $$ = $1;        // ConstStringList * component_privilege_name_list - shallow copy
               }
/* type tokval */
privilege_or_privileges_token : TOK_PRIVILEGE  { }
                              | TOK_PRIVILEGES { }
				                        
privileges : TOK_ALL TOK_PRIVILEGES
             {
               $$ = new (PARSERHEAP())
               ElemDDLPrivileges(ElemDDLNode::ALL);
             }
             | TOK_ALL
             {
               $$ = new (PARSERHEAP())
               ElemDDLPrivileges(ElemDDLNode::ALL);
             }
             | privilege_action_list
             {
               $$ = new (PARSERHEAP())
               ElemDDLPrivileges($1 /*priv_action_list*/);
             }


/* type pElemDDL */
privilege_action_list : privilege_action | privilege_action_list ',' privilege_action
                        {
		          $$ = new (PARSERHEAP())
		            ElemDDLList( $1 /*privilege_action_list*/,
                                         $3 /*privilege_action*/ );
                        }		      

		
/* type pElemDDL */
privilege_action:			
		      TOK_SELECT optional_privilege_column_list
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActSelect(
                                       $2 /*optional_privilege_column_list */);
                                }

                      | TOK_DELETE
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDelete();
                                }
                              
                      | TOK_EXECUTE
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActExecute();
                                }
			
		      | TOK_INSERT optional_privilege_column_list
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActInsert(
                                       $2 /*optional_privilege_column_list*/);
                                }

                      | TOK_UPDATE optional_privilege_column_list
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActUpdate(
                                       $2 /*optional_privilege_column_list*/);
                                }

                      | TOK_USAGE
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActUsage();
                                }
			
                      | TOK_REFERENCES optional_privilege_column_list
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActReferences(
                                       $2 /*optional_privilege_column_list*/);
                                }
				
		      /* DDL privileges */		
				
                      | TOK_ALTER  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActAlter();
                                }

                      | TOK_ALTER_LIBRARY  
                                {
				 $$ = new (PARSERHEAP())
				     ElemDDLPrivActAlterLibrary();
				}

                      | TOK_ALTER_MV  
                                {
				 $$ = new (PARSERHEAP())
				     ElemDDLPrivActAlterMV();
				}

                      | TOK_ALTER_MV_GROUP  
                                {
			         $$ = new (PARSERHEAP())
				   ElemDDLPrivActAlterMVGroup();
                                }

                      | TOK_ALTER_ROUTINE_ACTION
                                {
                                 $$ = new (PARSERHEAP())
                                   ElemDDLPrivActAlterRoutineAction();
                                }

                      | TOK_ALTER_ROUTINE
                                {
                                 $$ = new (PARSERHEAP())
                                   ElemDDLPrivActAlterRoutine();
                                }

                      | TOK_ALTER_SYNONYM  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActAlterSynonym();
                                }

                      | TOK_ALTER_TABLE  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActAlterTable();
                                }

                      | TOK_ALTER_TRIGGER  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActAlterTrigger();
                                }

                      | TOK_ALTER_VIEW  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActAlterView();
                                }

                      | TOK_CREATE  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActCreate();
                                }

                      | TOK_CREATE_LIBRARY  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActCreateLibrary();
                                }

                      | TOK_CREATE_MV  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActCreateMV();
                                }

                      | TOK_CREATE_MV_GROUP  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActCreateMVGroup();
                                }

                      | TOK_CREATE_ROUTINE_ACTION
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLPrivActCreateRoutineAction();
                                }

                      | TOK_CREATE_ROUTINE
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLPrivActCreateRoutine();
                                }

                      | TOK_CREATE_TABLE  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActCreateTable();
                                }

                      | TOK_CREATE_TRIGGER  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActCreateTrigger();
                                }

                      | TOK_CREATE_SYNONYM  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActCreateSynonym();
                                }
				
		      | TOK_CREATE_PROCEDURE  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActCreateProcedure();
                                }

                      | TOK_CREATE_VIEW  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActCreateView();
                                }

                      | TOK_DBA  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDBA();
                                }

                      | TOK_DROP  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDrop();
                                }

                      | TOK_DROP_LIBRARY  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDropLibrary();
                                }

                      | TOK_DROP_MV  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDropMV();
                                }

                      | TOK_DROP_MV_GROUP  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDropMVGroup();
                                }

                      | TOK_DROP_PROCEDURE  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDropProcedure();
                                }

                      | TOK_DROP_ROUTINE_ACTION
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLPrivActDropRoutineAction();
                                }
                      | TOK_DROP_ROUTINE
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLPrivActDropRoutine();
                                }
                      | TOK_DROP_SYNONYM  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDropSynonym();
                                }

                      | TOK_DROP_TABLE  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDropTable();
                                }

                      | TOK_DROP_TRIGGER  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDropTrigger();
                                }
				
		      | TOK_DROP_VIEW  
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActDropView();
                                }

		      /* Utility privileges */
		      		
                      | TOK_MAINTAIN  
                                { yyerror(""); 
                                  YYERROR;
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActMaintain();
                                }
				
                      | TOK_REFRESH  
                                { yyerror(""); 
                                  YYERROR;
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActRefresh();
                                }
				
                      | TOK_TRANSFORM  
                                { yyerror(""); 
                                  YYERROR;
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActTransform();
                                }
				
                      | TOK_UPDATE_STATS  
                                { yyerror(""); 
                                  YYERROR;
				  $$ = new (PARSERHEAP())
				    ElemDDLPrivActUpdateStats();
                                }

                      | TOK_ALL_DDL
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLPrivActAllDDL();
                                }

                      | TOK_ALL_DML
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLPrivActAllDML();
                                }

                      | TOK_ALL_UTILITY
                                {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLPrivActAllOther();
                                }

optional_privilege_column_list : empty
                                {
				  $$ = NULL;
                                }
                      | '(' privilege_column_list ')'
                                {
				  $$ = $2 /*privilege_column_list*/;
                                }

/* type pElemDDL */
privilege_column_list : column_name_list

/* type pQualName */
ddl_object_name : ddl_qualified_name {
                         $1->setObjectNameSpace(COM_TABLE_NAME);
                         $$ = $1; }
                      | TOK_TABLE ddl_qualified_name {
                                  $2->setObjectNameSpace(COM_TABLE_NAME);
				  $$ = $2; }
                      | TOK_TABLE_MAPPING ddl_qualified_name {
                                  $2->setObjectNameSpace(COM_UDF_NAME);
                                  $$ = $2; }
                      | TOK_PROCEDURE ddl_qualified_name {
                                  $2->setObjectNameSpace(COM_UDF_NAME);
				  $$ = $2; }
                      | TOK_FUNCTION ddl_qualified_name {
                                  $2->setObjectNameSpace(COM_UDF_NAME);
                                  $$ = $2; }
                                
                      | TOK_LIBRARY ddl_qualified_name {
                                  $2->setObjectNameSpace(COM_LIBRARY_NAME);
                                  $$ = $2; }
                      | TOK_SEQUENCE ddl_qualified_name {
                                  $2->setObjectNameSpace(COM_SEQUENCE_GENERATOR_NAME);
                                  $$ = $2; }
                                
/* type pElemDDL */
grantee_list : grantee
                      | grantee_list ',' grantee
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLList(
                                       $1 /*grantee_list*/,
                                       $3 /*grantee*/);
                                }

/* type pElemDDL */
grantee : TOK_PUBLIC
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLGrantee(PARSERHEAP());
                                }

                      | authorization_identifier
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLGrantee(
                                        *$1 /*authorization_identifier*/,
                                        PARSERHEAP());
                                  delete $1 /*authorization_identifier*/;
                                }


/* type pElemDDL */
optional_with_grant_option : empty
                                {
				  $$ = NULL;
                                }

                      | with_grant_option

optional_action : empty
                  { $$ = NULL; }
                | TOK_FOR TOK_ACTION routine_action_qualified_name
                  { $$ = $3; }

/* type pElemDDL */
with_grant_option : TOK_WITH TOK_GRANT TOK_OPTION
                                {
				  $$ = new (PARSERHEAP())
				    ElemDDLWithGrantOption();
                                }
/* type pElemDDL */
optional_by_auth_identifier : empty
                                {
				  $$ = NULL;
                                }

                      | TOK_BY authorization_identifier
                                {
                                  if (!Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                                  {
                                    // Internal syntax: not allowed
                                    yyerror("");
                                    YYERROR;
                                  }
				  $$ = new (PARSERHEAP())
				    ElemDDLGrantee(
                                        *$2 /*authorization_identifier*/,
                                        PARSERHEAP());
                                  delete $2 /*authorization_identifier*/;
                                }






/* type pQualName */
constraint_name : ddl_qualified_name

/* type pStmtDDL */
catalog_definition : TOK_CREATE TOK_CATALOG catalog_definition2
                     {
                       $$ = $3;
		     }


/* type pStmtDDL */
catalog_definition2 : sql_mx_catalog_name optional_create_catalog_attribute_list
                      {
			$$ = new (PARSERHEAP())
			  StmtDDLCreateCatalog(*$1, $2);
			delete $1;
		      }


/* type stringval */
catalog_name	    : sql_mx_catalog_name
		    | sql_mp_catalog_name

/* type stringval */
sql_mx_catalog_name : identifier

/* type stringval */
sql_mp_catalog_name : SYSTEM_VOLUME_NAME '.' identifier
                        {
			  // SQL/MP style catalog name specified.
			  $1->append(".");
			  $1->append(*$3);
			  $$ = $1;
			  delete $3;
			}
                      | empty
                        {
			  *SqlParser_Diags << DgSqlCode(-3157);
			  $$ = NULL;
			  YYABORT;
			}

/* type pElemDDL */
optional_create_catalog_attribute_list : empty
                                {
                                  $$ = NULL;
                                }
                      | create_catalog_attribute_list

/* type pElemDDL */
create_catalog_attribute_list : create_catalog_attribute
                      | create_catalog_attribute_list create_catalog_attribute
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLList(
                                       $1 /*create_catalog_attribute_list*/,
                                       $2 /*create_catalog_attribute*/);
                                }

/* type pElemDDL */
create_catalog_attribute : location_clause

/* type pElemDDL */

location_clause : TOK_LOCATION location_definition optional_partition_name_clause
                                {
                                  $$ = $2; // location_definition
                                  ElemDDLLocation *pLocClause = (ElemDDLLocation *)$$;
                                  NAString partitionName;
                                  if ($3 != NULL)
                                    partitionName = *$3;
                                  pLocClause->setPartitionName(partitionName);
                                }


/* type stringval */
volume_only_name : DOLLAR_IDENTIFIER
				{
				  //
				  // regular_identifier represents a disk
				  // name without the dollar symbol prefix.
				  // This scheme allows white spaces
				  // between the dollar symbol prefix
				  // and the name.  The embedded white
                                  // spaces, if appear, are removed.
				  //
				  $$ = $1 /*regular_identifier (disk name)*/;
                                }

/* type stringval */
oss_path_name : oss_path_name_elem
                      | oss_path_name oss_path_name_elem
                                {
				  // This scheme allows white spaces
				  // between elements in an OSS path
				  // name.  The embedded white spaces,
				  // if appear, are removed.
				  //
                                  $1/*oss_path_name*/->append(*$2);
				  delete $2 /*oss_path_name_elem*/;
				  $$ = $1;
                                }

/* type stringval */
oss_path_name_elem : '/' regular_identifier
                                {
                                  $2/*regular_identifier*/->prepend('/');
				  $$ = $2;
                                }

/* type stringval */
log_file_name : std_char_string_literal
              | regular_identifier
              | oss_path_name

/* type stringval */
optional_partition_name_clause : empty
				{
                                  $$ = NULL;
				}

			| TOK_NAME partition_name
				{
                                  $$ = $2;
				}
/* type pElemDDL */
location_definition : guardian_location_name
                                {
                                  $$ = new (PARSERHEAP()) ElemDDLLocation(
                                       ElemDDLLocation::LOCATION_GUARDIAN_NAME,
                                       *$1);
                                  delete $1;
                                  if (NOT $$->castToElemDDLLocation()->isSubvolumeNameValid() ||
                                      NOT $$->castToElemDDLLocation()->isFilenameValid())
                                    {
                                      // The location name is not valid.
                                      yyerror("");
                                      YYERROR;
                                    }
                                }

                      // VO: Removed alternative that allowed OSS style location spec
/*  ** It has been decided that syntax of the location clause can be
 *  ** LOCATION $VOLUME where $VOLUME is a Guardian volume name.  We
 *  ** can no longer use the '$' symbol for the environment variable.
 *                      
 *                      | '$' identifier TOK_AS partition_name
 *                              {
 *                                // *** Error *** environment variable
 *                                // not allowed in LOCATION clause.
 *
 *				  *SqlParser_Diags << DgSqlCode(-????);
 *
 *                                // needs to check to make sure that the
 *                                // environment variable name syntax is
 *                                // valid.  Currently, no checking is
 *                                // being done.
 *                                //
 *                                $$ = new (PARSERHEAP()) ElemDDLLocation(
 *                                     ElemDDLLocation::
 *                                     LOCATION_ENVIRONMENT_VARIABLE,
 *                                      *$2); // identifier (env var name)
 *                                delete $2;  // identifier
 *                              }
 */

/* type stringval */
guardian_location_name : guardian_volume_name
                       | guardian_volume_name '.' 
		         regular_identifier   '.'
			 regular_identifier
				{
				  $1->append("." + *$3 + "." + *$5);
				  delete $3; // regular_identifier (subvol)
				  delete $5; // regular_identifier (file00)
				  $$ = $1;
				}

/* type stringval */
guardian_volume_name : SYSTEM_VOLUME_NAME
		     | volume_only_name

partition_name :  identifier

/*********************************************/
/****  Handle  CREATE TRIGGER  statement  ****/
/****          B E G I N                  ****/
/*********************************************/

/* type itemList */
trigger_set_clause_list : trigger_set_clause 
             {
	       ItemExprList * iel = 
		 new(PARSERHEAP()) ItemExprList( PARSERHEAP() );
	       iel->insert( $1 );
	       $$ = iel ;
	     }
           | trigger_set_clause_list ',' trigger_set_clause 
             {
	       ((ItemExprList *)$1)->insert( $3 );
	       $$ = $1;
	     }

/* type item */
trigger_set_clause : identifier '=' value_expression
             {
	       // meantime: we require fully qualified left-hand name
	       *SqlParser_Diags << DgSqlCode(-11017) ; // must be qualified
	       YYABORT;
	     }
           | identifier '.' identifier '=' value_expression
             {
	       $$ = new (PARSERHEAP())
		 Assign(new (PARSERHEAP())
			ColReference(new (PARSERHEAP()) ColRefName(*$3,*$1)), $5);
	       delete $1;
	       delete $3;
	     }

/* type item */
triggered_before_action: empty   // I.e. anything not SET or SIGNAL
                {
		  // Before triggers support only SET or SIGNAL actions
		  *SqlParser_Diags << DgSqlCode(-11014);
		  yyerror("");
		  YYABORT;
		} 
              | item_signal_statement 
		{
		  $$ = $1 ;
		}
              | TOK_SET trigger_set_clause_list
                {
		  // Pass an ItemExprList as an ItemExpr -- convert it
		  $$ =  new (PARSERHEAP()) NATypeToItem( (NAType *) $2 );
		}

/* type relx */
triggered_after_action: empty   // Empty or any option not listed below
                {
		  // empty action not supported !!
		  *SqlParser_Diags << DgSqlCode(-11018);
		  yyerror("");
		  YYABORT;
		} 
              | TOK_SET
                {
		  *SqlParser_Diags << DgSqlCode(-11015) ; // no SET for AFTER
		  yyerror("");
		  YYABORT;
		}
              | front_of_insert Rest_Of_insert_statement 
		{
		  $$ = finalize($2, FALSE);
		}
	      |	 update_statement_searched access_type
		{
		  $$ = finalize($1, FALSE);
		  RelRoot * treeTopPtr = (RelRoot *)$$;
		  if ($2 != TransMode::ACCESS_TYPE_NOT_SPECIFIED_)
		    treeTopPtr->accessOptions().accessType() = $2;
		}
	      | delete_statement  access_type
		{
		  $$ = finalize($1, FALSE);
		  RelRoot * treeTopPtr = (RelRoot *)$$;
		  if ($2 != TransMode::ACCESS_TYPE_NOT_SPECIFIED_)
		    treeTopPtr->accessOptions().accessType() = $2;
		}
              | signal_statement
		{
		  $$ = finalize($1, FALSE);
		}
	| standalone_call_statement
	  {
	    $$ = finalize($1, FALSE);
	  }
	| psm_3gl_statement
	  {
	    if (($1 != NULL)) {
	      --in3GL_;
	      $$ = finalize($1, FALSE);
	      CSInsideTriggerDefinition = TRUE;
	    } else {
	      // empty block is an error.
	      *SqlParser_Diags << DgSqlCode(-11018);
	      yyerror("");
	      YYABORT;
	    }
	  }


triggerred_when_clause: empty
               {
		 $$ = NULL;
	       }
          | TOK_WHEN '(' any_expression ')'
               {
		 $$ = $3;
	       }

/* type iudOp */
iud_event: TOK_INSERT
                  {
                     $$ = COM_INSERT;
                  }
         | TOK_UPDATE
                  {
                     $$ = COM_UPDATE;
                  }
         | TOK_DELETE
                  {
                     $$ = COM_DELETE;
                  }

optional_update_column_list : empty
                  {
		    $$ = NULL;
		  }
         | TOK_OF '(' column_reference_list ')'
                  {
		    $$ = $3 /* column_reference_list */;
		  }

optional_row_table:  /* empty */
	    {
	  $$ = ParTRIG_SCOPE_NONE;
	}
      | TOK_ROW
	    {
	  $$ = ParTRIG_SCOPE_ROW;
	}
      | TOK_TABLE
	    {
	$$ = ParTRIG_SCOPE_TABLE; 
	}

referencing_clause:  empty
            {
              $$ = NULL;
	    }
            | TOK_REFERENCING TOK_OLD optional_row_table as_clause
            {
               RowOrTableClause1 = $3;	     
                $$ =  new (PARSERHEAP()) OldNewNames( $4, NULL );
            }
            | TOK_REFERENCING TOK_NEW optional_row_table as_clause
            {
              RowOrTableClause1 = $3;	      
              $$ =  new (PARSERHEAP()) OldNewNames( NULL, $4 );	    
            }
            | TOK_REFERENCING TOK_OLD optional_row_table as_clause ',' TOK_NEW 
			optional_row_table as_clause
            {
              // make sure that we are using the same keyword in both clauses if they are both
              // specified. In other words we cannot have referencing clauses like
  		// REFERENCING OLD ROW AS OLDR, NEW TABLE AS NEWT
		 if (($3 && $7) && ($3 != $7))
		{
			*SqlParser_Diags << DgSqlCode(-11049);
			YYABORT;
		}
              
              RowOrTableClause1 = $3;
              RowOrTableClause2 = $7;
                    $$ =  new (PARSERHEAP()) OldNewNames( $4, $8 );
                  }
            | TOK_REFERENCING TOK_NEW optional_row_table as_clause ',' TOK_OLD 
			optional_row_table as_clause
            {
              if (($3 && $7) && ($3 != $7))
		{
			*SqlParser_Diags << DgSqlCode(-11049);
			YYABORT;
		}
                 
              RowOrTableClause1 = $3;
              RowOrTableClause2 = $7;
                    $$ =  new (PARSERHEAP()) OldNewNames( $8, $4 );	    
            }


before_action_orientation: empty
                     {
            	if ((RowOrTableClause1 == ParTRIG_SCOPE_TABLE) || (RowOrTableClause2 == ParTRIG_SCOPE_TABLE))
		{
			*SqlParser_Diags << DgSqlCode(-11049);
			YYABORT;
		}
                        $$ = FALSE;   /* Default is ROW */
                     }
                  | TOK_FOR TOK_EACH TOK_ROW
                     {
               	if ((RowOrTableClause1 == ParTRIG_SCOPE_TABLE) || (RowOrTableClause2 == ParTRIG_SCOPE_TABLE))
		{
			*SqlParser_Diags << DgSqlCode(-11049);
			YYABORT;
		}
               	$$ = FALSE;
             }
            | TOK_FOR TOK_EACH TOK_STATEMENT
            {
                // no such thing as before-stmt trigger
		       *SqlParser_Diags << DgSqlCode(-11010);
		        YYABORT;
		     }

after_action_orientation: empty
                     {
                 if ((RowOrTableClause1 == ParTRIG_SCOPE_ROW) || (RowOrTableClause2 == ParTRIG_SCOPE_ROW))
		{
			*SqlParser_Diags << DgSqlCode(-11049);
			YYABORT;
		}
                        $$ = TRUE;   /* Default is STATEMENT */
                     }
                  | TOK_FOR TOK_EACH TOK_ROW
                     {
                if ((RowOrTableClause1 == ParTRIG_SCOPE_TABLE) || (RowOrTableClause2 == ParTRIG_SCOPE_TABLE))
		{
			*SqlParser_Diags << DgSqlCode(-11049);
			YYABORT;
		}
               	$$ = FALSE;
             }
             | TOK_FOR TOK_EACH TOK_STATEMENT
             {
               	if ((RowOrTableClause1 == ParTRIG_SCOPE_ROW) || (RowOrTableClause2 == ParTRIG_SCOPE_ROW))
		{
			*SqlParser_Diags << DgSqlCode(-11049);
			YYABORT;
		}
               	$$ = TRUE;
             }


// returns pStmtDDL
trigger_definition: before_trigger_definition
		{
		  /* Reset the trigger related globals */
		  RowOrTableClause1 = ParTRIG_SCOPE_NONE;
		  RowOrTableClause2 = ParTRIG_SCOPE_NONE;
		  InsideTriggerDefinition = FALSE;
		  CSInsideTriggerDefinition = FALSE;
		  $$ = $1;
		}
	      | after_trigger_definition
		{
		  /* Reset the trigger related globals */
		  RowOrTableClause1 = ParTRIG_SCOPE_NONE;
		  RowOrTableClause2 = ParTRIG_SCOPE_NONE;
		  InsideTriggerDefinition = FALSE;
		  CSInsideTriggerDefinition = FALSE;
		  $$ = $1;
		}


// returns pStmtDDL
before_trigger_definition: before_trigger_prefix triggerred_when_clause
                                                    triggered_before_action
            {
	      $$ = $1;  // the CreateTriggerStmt object to return

	      StmtDDLCreateTrigger *triggerObject = $1;
	      assert ( !triggerObject->isAfter()); // Only for BEFORE triggers	      
	      // Find the end of the input text and keep it
	      if (ParSetTextEndPos(triggerObject)) { yyerror(""); YYERROR; }

	      // The "ParNameLocListPtr" should NOT be deleted here !   ;
	      // It is kept in triggerObject, and would be deleted by   ;
	      // the destructor of triggerObject
	      ParNameLocListPtr = NULL;
	      
              if ( $3 == NULL ) { yyerror(""); YYERROR; }

	      // Prepare the REFERENCING names
	      TableRefList nameList;
	      prepareReferencingNames( nameList, triggerObject );

	      // Construct the appropriate BeforeTrigger object
	      BeforeTrigger * bt;
	      if ( ITM_NATYPE == $3->getOperatorType() ) { // Action is SET
		// Undo the (ugly) "wrapping" by taking the ItemExpr's child
		ItemExprList * iel = (ItemExprList *) 
		  ((NATypeToItem *)$3)->synthesizeType();
		bt = new(PARSERHEAP()) BeforeTrigger(nameList, $2, iel); 
	      } else {      // Action must be "signal" 
		assert ( ITM_RAISE_ERROR == $3->getOperatorType() ) ; 
		RaiseError * re = (RaiseError *) $3 ;
		bt = new(PARSERHEAP()) BeforeTrigger(nameList, $2, re); 
	      }
	      triggerObject->setAction( bt ); // Add the action tree
	    }

// returns pStmtDDL
after_trigger_definition: after_trigger_prefix triggerred_when_clause
                                              triggered_after_action
            {	    
	      $$ = $1;   // the CreateTriggerStmt object to return

	      StmtDDLCreateTrigger *triggerObject = $1;
	      assert ( triggerObject->isAfter() );  // Only for AFTER triggers	      
	      // Find the end of the input text and keep it
	      if (ParSetTextEndPos(triggerObject)) { yyerror(""); YYERROR; }

	      // The "ParNameLocListPtr" should NOT be deleted here !   ;
	      // It is kept in triggerObject, and would be deleted by   ;
	      // the destructor of triggerObject
	      ParNameLocListPtr = NULL;
	      
              if ( $3 ) ((RelRoot *)$3)->setRootFlag(FALSE); // not a true root
	      else { yyerror(""); YYERROR; }
	      
	      // Prepare the REFERENCING names
	      TableRefList nameList;
	      prepareReferencingNames( nameList, triggerObject );

	      //  for the "else" of the 'when clause'
	      ItemExpr *noOpArg = new (PARSERHEAP()) ConstValue(0);
	      RelExpr  *noOp = new (PARSERHEAP()) Tuple(noOpArg);
	      RelRoot  *noOpRoot = new (PARSERHEAP()) RelRoot(noOp);
              noOpRoot->setEmptySelectList();
	      
	      ItemExpr * whenCond = $2;
	      if ( whenCond == NULL ) 
		whenCond = new (PARSERHEAP()) BoolVal(ITM_RETURN_TRUE);
	      else
		if (whenCond->containsSubquery())
		{
		  *SqlParser_Diags << DgSqlCode(-11023);
		  YYABORT;
		}

	      Union *u = new (PARSERHEAP()) 
		Union($3, noOpRoot, NULL, whenCond); 
	      u->setCondUnary();
	      RelExpr *triggerAction = u;
	      if ( ! triggerObject->isStatement() ) {
		// This is an After Row trigger - need a RenameReference node
		triggerAction = new(PARSERHEAP()) 
		  RenameReference(triggerAction, nameList);
	      }

	      // does this trigger use ROW or TABLE keywords in its referencing clause
	      if (CSInsideTriggerDefinition)
	         triggerObject->setHasCSInAction ();

	      // add the action tree (with a RelRoot) to pNode
	      triggerObject->setAction(finalize(triggerAction));
	    }

before_trigger_prefix: create_trigger_keywords ddl_qualified_name 
             optional_by_auth_identifier 
             TOK_BEFORE iud_event optional_update_column_list TOK_ON
             ddl_qualified_name referencing_clause before_action_orientation
             {
               *SqlParser_Diags << DgSqlCode(-3131);
               YYERROR;

		InsideTriggerDefinition = TRUE;

	       // 
               // Initialize names for REFERENCING 
	       //
	       NAString *oldName = NULL;
	       NAString *newName = NULL;
	       
	       if ( $9 ) { // if there is a referencing clause
		 oldName = $9->oldName();
		 newName = $9->newName();
	       }
	       //
	       //  Perform semantic checks
	       //
		   Int32 errCount =0;
	       if ( $10 )  {           // NO BEFORE-STMT TRIGGERS !!
		 *SqlParser_Diags << DgSqlCode(-11010);
		 errCount++;
		   }
	       if ( $5 != COM_UPDATE && $6 ) { // Only UPDATE can have columns
		 *SqlParser_Diags << DgSqlCode(-11011);
		 errCount++;
		   }
	       if ( NULL != oldName && $5 == COM_INSERT ) { // Insert: No OLD
		 *SqlParser_Diags << DgSqlCode(-11012);
		 errCount++;
		   }
	       if ( NULL != newName && $5 == COM_DELETE ) { // Delete: No NEW
		 *SqlParser_Diags << DgSqlCode(-11013);
		 errCount++;
		   }
	       if ( errCount > 0 ) { // any errors ?
		 delete $2;
		 delete $8;
		 YYABORT;
	       }

               // is this trigger using ROW or TABLE keywords in its referencing clause
               NABoolean hasRowOrTableInRefClause = ((RowOrTableClause1 != ParTRIG_SCOPE_NONE ) || 
                                                     (RowOrTableClause2 != ParTRIG_SCOPE_NONE));

	       StmtDDLCreateTrigger *pNode =
		 new (PARSERHEAP())
		 StmtDDLCreateTrigger(
				      *$2 /* trigger_name */,
				      ParNameLocListPtr,
				      FALSE /* before_trigger */,
				      hasRowOrTableInRefClause,
				      $5 /* iud_event */,
				      $6 /* opt_update_col_list */,
				      *$8 /* subject table qual name */,
				      oldName, 
				      newName,
				      $10 /* action_orientation */,
                                      $3 /* optional auth id */
				      );
	       pNode->synthesize();
	       delete $2 /* trigger_name */;
	       delete $8 /* ddl_qualified_name */;
	       if ( $9 ) delete $9 /* referencing_clause */;
	       $$ = pNode;
	     }

after_trigger_prefix: create_trigger_keywords ddl_qualified_name 
             optional_by_auth_identifier
             TOK_AFTER iud_event optional_update_column_list TOK_ON
             ddl_qualified_name referencing_clause after_action_orientation
             {
               *SqlParser_Diags << DgSqlCode(-3131);
               YYERROR;

		InsideTriggerDefinition = TRUE;

	       // 
               // Initialize names for REFERENCING 
	       //
	       NAString *oldName = NULL;
	       NAString *newName = NULL;
	       
	       if ( $9 ) { // if there is a referencing clause
		 oldName = $9->oldName();
		 newName = $9->newName();
	       }
	       //
	       //  Perform semantic checks
	       //
	       if ( $5 != COM_UPDATE && $6 ) // Only UPDATE can have columns
		 *SqlParser_Diags << DgSqlCode(-11011);
	       if ( NULL != oldName && $5 == COM_INSERT )  // Insert: No OLD
		 *SqlParser_Diags << DgSqlCode(-11012);
	       if ( NULL != newName && $5 == COM_DELETE )  // Delete: No NEW
		 *SqlParser_Diags << DgSqlCode(-11013);
	       if ( SqlParser_Diags->getNumber(DgSqlCode::ERROR_) > 0 ) { // any errors ?
		 delete $2;
		 delete $8;
		 YYABORT;
	       }

               // is this trigger using ROW or TABLE keywords in its referencing clause
               NABoolean hasRowOrTableInRefClause = ((RowOrTableClause1 != ParTRIG_SCOPE_NONE ) || 
                                                     (RowOrTableClause2 != ParTRIG_SCOPE_NONE));

	       StmtDDLCreateTrigger *pNode =
		 new (PARSERHEAP())
		 StmtDDLCreateTrigger(
				      *$2 /* trigger_name */,
				      ParNameLocListPtr,
				      TRUE /* after_trigger */,
				      hasRowOrTableInRefClause,
				      $5 /* iud_event */,
				      $6 /* opt_update_col_list */,
				      *$8 /* subject table qual name */,
				      oldName, 
				      newName,
				      $10 /* action_orientation */,
                                      $3 /* optional auth it */
				      );
	       pNode->synthesize();
	       delete $2 /* trigger_name */;
	       delete $8 /* ddl_qualified_name */;
	       if ( $9 ) delete $9 /* referencing_clause */;
	       $$ = pNode;
	     }

create_trigger_keywords: TOK_CREATE TOK_TRIGGER 
              {
                // This is the first production being reduced in the 
		// processing of create trigger statement.
		//
		// Keep track of the start position of the create trigger
		// statement in the input string.

		NonISO88591LiteralEncountered = FALSE;

		ParNameLocListPtr = new (PARSERHEAP())
		  ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
		ParSetTextStartPosForCreateTrigger(ParNameLocListPtr);
	      }

/*********************************************/
/****  Handle  CREATE TRIGGER  statement  ****/
/****           E N D                     ****/
/*********************************************/

//----------------------------------------------------------------------------
//++ MV
//----------------------------------------------------------------------------

mv_token: TOK_MV 
         {
         }
        | TOK_MATERIALIZED TOK_VIEW 
         {
         }

/* type refreshType */
refresh_type: TOK_RECOMPUTE
                  {
                     $$ = COM_RECOMPUTE;
                  }
            | TOK_REFRESH TOK_ON TOK_STATEMENT
                  {
                     $$ = COM_ON_STATEMENT;
                  }
            | TOK_REFRESH TOK_ON TOK_REQUEST
                  {
                     $$ = COM_ON_REQUEST;
                  }
            | TOK_REFRESH TOK_BY TOK_USER
                  {
                     $$ = COM_BY_USER;
                  }

// type pElemDDL
create_mv_attribute_table_lists : empty
	    {
	      $$ = NULL;
	    }
	    | create_mv_one_attribute_table_list

	    | create_mv_attribute_table_lists create_mv_one_attribute_table_list
	      {
		$$ = new (PARSERHEAP())ElemDDLList($1, // list
						   $2 // one
						   );
	      }
 

// type pElemDDL
create_mv_one_attribute_table_list : ignore_changes_on_table_list

// type pElemDDL
ignore_changes_on_table_list: TOK_IGNORE TOK_CHANGES TOK_ON qual_name_list
			  {
			    $$ = new(PARSERHEAP())
				ElemDDLCreateMVOneAttributeTableList
						  (COM_IGNORE_CHANGES, $4 );
			  }

// type pElemDDL 
qual_name_list : qual_name
		| qual_name_list ',' qual_name
	       {
		  $$ = new (PARSERHEAP()) ElemDDLList($1, // ElemDDLList
						      $3  // ElemDDLQualName
						      );
	       }

				 


// type pElemDDL 
qual_name : ddl_qualified_name
	   {
		$$ = new (PARSERHEAP())ElemDDLQualName(*$1);
		delete $1;
	   }



/* type mvStatus */
mv_initialization_clause:  TOK_INITIALIZE TOK_ON TOK_CREATE
			   {
			     $$ = MVINIT_ON_CREATE;
			   }
			 | TOK_INITIALIZED TOK_ON TOK_CREATE
			   {
			     $$ = MVINIT_ON_CREATE;
			   }
			 | TOK_INITIALIZE TOK_ON TOK_REFRESH
			   {
			     $$ = MVINIT_ON_REFRESH;
			   }
			 | TOK_INITIALIZED TOK_ON TOK_REFRESH
			   {
			     $$ = MVINIT_ON_REFRESH;
			   }
			 | TOK_NO TOK_INITIALIZATION
			   {
			     $$ = MVINIT_NO_INIT;
			   }
			 | TOK_INITIALIZE TOK_BY TOK_USER
			   {
			     $$ = MVINIT_BY_USER;
			   }

/* type boolean */
optional_query_rewrite: empty
                   {
		     // Keep (in a global variable) the begining
		     // of the "optional file options" clause
		     ParSetBeginingOfFileOptionsListPos(ParNameLocListPtr);

                     $$ = (CmpCommon::getDefault(MVQR_REWRITE_ENABLED_OPTION) == DF_ON);
                   }
                 | enable_status TOK_QUERY TOK_REWRITE
                   {
		     // Keep (in a global variable) the begining
		     // of the "optional file options" clause
		     ParSetBeginingOfFileOptionsListPos(ParNameLocListPtr);

		     $$ = $1;   /* Enable/Disable query rewrite */
                   }

/* type pElemDDL */
// taken from CREATE TABLE (like optional_create_table_attribute_list)
optional_create_mv_file_options : 
                   empty
                     {
		       $$ = NULL; 
		     }
                 | create_table_attribute_list
                     {
		       // Mark the text end of the table options list
		       ParSetEndOfFileOptionsListPos(ParNameLocListPtr);
		       
		       $$ = $1;
		     }


// type pElemDDL 
mv_file_attribute_clause : mv_file_attribute_keyword mv_file_attribute_list
			 {
			  $$ = new (PARSERHEAP())ElemDDLMVFileAttrClause($2);
			 }


// type tokval 
mv_file_attribute_keyword : TOK_MVATTRIBUTE
			  | TOK_MVATTRIBUTES


// type pElemDDL 
mv_file_attribute_list: mv_file_attribute
		      | mv_file_attribute_list ',' mv_file_attribute
		      {
			$$ = new (PARSERHEAP())ElemDDLFileAttrList($1, $3);
		      }

// type pElemDDL 
mv_file_attribute : mv_audit_type
		  {
		    $$ = new (PARSERHEAP())ElemDDLFileAttrMvAudit($1);
		  }
		  | TOK_COMMIT TOK_REFRESH TOK_EACH unsigned_integer
		  {
		    $$ = new (PARSERHEAP())ElemDDLFileAttrMVCommitEach($4);
		  }


mv_audit_type: TOK_AUDIT 	
	    {
		    $$ = COM_MV_AUDIT;
	    }
	    | TOK_NO TOK_AUDIT
	    {
		    $$ = COM_MV_NO_AUDIT;
	    }
	    | TOK_NO TOK_AUDITONREFRESH
	    {
		    $$ = COM_MV_NO_AUDIT_ON_REFRESH;
	    }


as_token: TOK_AS
	{
	   // Mark the text begining of the MV query
	   ParSetBeginOfMVQueryPos(ParNameLocListPtr);
	}


//----------------------------------------------------------------------------
// type pStmtDDL 
mv_definition: create_mv_keywords ddl_qualified_name
		optional_view_column_list
		refresh_type
		create_mv_attribute_table_lists // changes clause
		mv_initialization_clause
		optional_query_rewrite
		optional_create_mv_file_options
//                optional_by_auth_identifier		
                optional_in_memory_clause
                as_token query_expression
    {
      *SqlParser_Diags << DgSqlCode(-3131);
      YYERROR;

      RelRoot *top = finalize($11);
      ForUpdateSpec spec(FALSE);
      spec.finalizeUpdatability(top);

      if (($9) &&
	  (CmpCommon::getDefault(COMP_BOOL_219) == DF_OFF))
	{
	  // syntax not yet supported
	  yyerror(""); 
	  YYERROR; 
	}

      // ( The following was taken from CREATE VIEW )
      // The following applies when the user specified BROWSE, STABLE or 
      // REPEATABLE access type and/or the user specified SHARE or EXCLUSIVE 
      // lock mode
      if (top->accessOptions().userSpecified())
	{
	  // Genesis 10-980217-0467:
	  // FOR xxx ACCESS not allowed in C.V.
	  // At first blush allowing it seems a nifty shorthand -- but it 
	  // does not fit at all well with Ansi/Tdm txn/stmt isolation-level 
	  // defaulting model. Also see BindWA::bindView.
	  *SqlParser_Diags << DgSqlCode(-3168);
	  ComASSERT(top->accessOptions().lockMode() ==
		    LOCK_MODE_NOT_SPECIFIED_);
	  YYERROR;
	}

      //++MV
      // FIRST/ANY is not allowed in query expresion of MVs.
      if ($11->getFirstNRows() != -1)
      {
	*SqlParser_Diags << DgSqlCode(-12318);
	YYERROR;
      }
      //--MV

      // REFRESH BY USER Syntax
      if ($4 == COM_BY_USER)
	{
	  if ($6 != MVINIT_BY_USER &&
	      $6 != MVINIT_ON_CREATE)
	    { // REFRESH BY USER must be followed by INITIALIZE BY USER or ON CREATE.
	      *SqlParser_Diags << DgSqlCode(-12332);
	      YYERROR;
	    }
	}
      else
        { // This is not REFRESH BY USER, do not allow INIT BY USER
	  if ($6 == MVINIT_BY_USER)
	    { // This materialized view cannot be of type INITIALIZE BY USER.
	      *SqlParser_Diags << DgSqlCode(-12085);
	      YYERROR;
	    }
        }
      
      StmtDDLCreateMV *pCreateMVParseNode
	= new (PARSERHEAP())
	     StmtDDLCreateMV( *$2,  // ddl_qualified_name 
			      *ParNameLocListPtr,
			      $3, // optional_view_column_list 
			      $4, // refresh_type 
			      $5, // changes clause 
			      $6, // mv_initialization_clause 
			      $7, // optional_query_rewrite 
			      $8, // optional_create_mv_file_options 
			      top,
                              NULL // optional_by_auth_identifier
			      );
      delete $2; // ddl_qualified_name 

      pCreateMVParseNode->setInMemoryObjectDefn($9);

      pCreateMVParseNode->synthesize();

      if (ParSetTextEndPos(pCreateMVParseNode)) // Set the end of text, and 
	{					// copy all those global 
	  yyerror("");				// position keepers into this 
	  YYERROR;				// ParseNode
	}

      $$ = pCreateMVParseNode;

      if ($1) /*create_mv_keywords*/
        $$->setIsGhostObject(TRUE);

      //
      // ParNameLocListPtr is no longer needed. Cleanup globals.
      //
      delete ParNameLocListPtr;
      ParNameLocListPtr = NULL;
      ParNameLocListPtr = ParNameSavedLocListPtr;
      ParEndOfOptionalColumnListPos = 0 ;
      ParBeginingOfFileOptionsListPos = 0;
      ParEndOfFileOptionsListPos = 0;
      ParEndOfSelectColumnListPos = 0 ;
      WeAreInACreateMVStatement = FALSE;
      ThisIsTheFirstMVQuerySelect = TRUE;
    }


/* type boolean */
create_mv_keywords: TOK_CREATE optional_ghost mv_token
              {
                // This is the first production being reduced in the 
		// processing of create mv statement.
		//
		// Keep track of the start position of the create mv
		// statement in the input string.

		ParNameSavedLocListPtr = ParNameLocListPtr;
		ParNameLocListPtr = new (PARSERHEAP())
		  ParNameLocList(SQLTEXT(), (CharInfo::CharSet)SQLTEXTCHARSET(), SQLTEXTW(), PARSERHEAP());
		ParSetTextStartPosForCreateMV(ParNameLocListPtr);

		WeAreInACreateMVStatement = TRUE;

                $$ = $2; /*optional_ghost*/
	      }




// OZ create mv group stmt

// type pStmtDDL 
create_mvrgroup_statement : TOK_CREATE TOK_MVGROUP ddl_qualified_name
{
  *SqlParser_Diags << DgSqlCode(-3131);
  YYERROR;

  $$ = new (PARSERHEAP())StmtDDLCreateMvRGroup(*$3);
  delete $3;
}


//----------------------------------------------------------------------------
//-- MV
//----------------------------------------------------------------------------

					
/* type pStmtDDL */
index_definition : TOK_CREATE optional_unique_optional_ghost TOK_INDEX
                        index_name TOK_ON optional_ghost_ddl_qualified_name
                        index_column_list optional_ignore_clause 
                        optional_index_option_list
                        optional_in_memory_clause
                                {
                                  StmtDDLCreateIndex *pNode =
                                    new (PARSERHEAP())
				      StmtDDLCreateIndex(
                                       ($2 == 1 || $2 == 3) /* UNIQUE */,
                                      *$4 /*index_name*/,
				       *$6 /*optional_ghost_ddl_qualified_name*/,
                                       $7 /*index_column_list*/,
                                       $8 /* optional_ignore_clause */, 
                                       $9 /*optional_index_option_list*/);

				  pNode->setInMemoryObjectDefn($10);
                                  pNode->synthesize();
                                  if ($2 == 2 || $2 == 3) /* GHOST */
                                  {
                                    pNode->setIsGhostObject(TRUE);         /* Create a ghost index */
                                    // Ghost index. The table may be regular or ghost.
                                    if ($6 /*optional_ghost_ddl_qualified_name*/ ->isGhost())
                                      pNode->setIsIndexOnGhostTable(TRUE); /* on a ghost table */
                                  } else {
                                    // Regular index. The table cannot be ghost.
                                    if ($6 /*optional_ghost_ddl_qualified_name*/ ->isGhost())
                                    {
				      yyerror("");
				      YYERROR;
                                    }
                                  }
                                  delete $4 /*index_name*/;
                                  delete $6 /*optional_ghost_ddl_qualified_name*/;
                                  $$ = pNode;
                                }

                 | TOK_CREATE TOK_VOLATILE optional_unique_option TOK_INDEX
                        index_name TOK_ON volatile_ddl_qualified_name
                        index_column_list optional_index_option_list
                        optional_in_memory_clause
                              {
				StmtDDLCreateIndex *pNode =
				  new (PARSERHEAP())
				  StmtDDLCreateIndex(
                                       $3 /*optional_unique_option*/,
				       *$5 /*index_name*/,
				       *$7 /*ddl_qualified_name*/,
                                       $8 /*index_column_list*/,
                                       FALSE /*optional_ignore_clause*/,
                                       $9 /*optional_index_option_list*/);
				pNode->setIsVolatile(TRUE);
				pNode->setProcessAsExeUtil(TRUE);

				pNode->setInMemoryObjectDefn($10);

				pNode->synthesize();
				delete $5 /*index_name*/;
				delete $7 /*ddl_qualified_name*/;
				$$ = pNode;
			      }

 /* type pStmtDDL */
populate_index_definition: TOK_POPULATE TOK_INDEX
                        index_name TOK_ON ddl_qualified_name optional_purgedata
                                {
                                  
                                  StmtDDLPopulateIndex *pNode =
                                    new (PARSERHEAP())
				      StmtDDLPopulateIndex(
                                           FALSE, FALSE,
                                           *$3 /*index_name*/,
                                           *$5 /*ddl_qualified_name*/);
                                 pNode->synthesize();

                                  delete $3 /*index_name*/;
                                  delete $5 /*ddl_qualified_name*/;
                                  $$ = pNode;
                               }

                    | TOK_POPULATE TOK_ALL TOK_INDEXES
                        TOK_ON ddl_qualified_name 
                                {
                                  
				  NAString cn("DUMMY");

                                  StmtDDLPopulateIndex *pNode =
                                    new (PARSERHEAP())
				      StmtDDLPopulateIndex(
                                           TRUE, FALSE,
                                           cn /*index_name*/,
                                           *$5 /*ddl_qualified_name*/);
				  pNode->synthesize();
				  
                                  delete $5 /*ddl_qualified_name*/;
                                  $$ = pNode;
                               }
                            | TOK_POPULATE TOK_ALL TOK_UNIQUE TOK_INDEXES
                              TOK_ON ddl_qualified_name 
                                {
                                  

				  NAString cn("DUMMY");

                                  StmtDDLPopulateIndex *pNode =
                                    new (PARSERHEAP())
				      StmtDDLPopulateIndex(
                                           FALSE,TRUE,
                                           cn /*index_name*/,
                                           *$6 /*ddl_qualified_name*/);
				  pNode->synthesize();
				  
                                  delete $6 /*ddl_qualified_name*/;
                                  $$ = pNode;
                               }

/* type boolean */
optional_purgedata : empty
                                {
                                  $$ = FALSE;
                                }
                      | TOK_PURGEDATA
                                {
                                  $$ = TRUE;
                                }

/* type boolean */
optional_unique_option : empty
                                {
                                  $$ = FALSE;
                                }
                      | TOK_UNIQUE
                                {
                                  $$ = TRUE;
                                }

// We use optional_unique_optional_ghost instead of optional_unique optional_ghost
// in order to avoid shift/reduce conflicts.
/* type uint */
optional_unique_optional_ghost : empty
                                 {
                                   $$ = 0;
                                 }
                                 | TOK_UNIQUE
                                 {
                                   $$ = 1;
                                 }
                                 | ghost
                                 {
                                   $$ = 2;
                                 }
                                 | TOK_UNIQUE ghost
                                 {
                                   $$ = 3;
                                 }

/* type pQualName */
optional_ghost_ddl_qualified_name : ddl_qualified_name
                                 {
                                   $$ = $1;
                                 }
                                 | ghost TOK_TABLE ddl_qualified_name
                                 {
                                   $$ = $3;
                                   $$->setIsGhost(TRUE);
                                 }

/* type stringval */
index_name : identifier

/* type pElemDDL */
index_column_list : '(' column_reference_list ')'
                                {
                                  $$ = $2 /*column_reference_list*/;
                                }

/* type boolean */
optional_ignore_clause : empty
                                {
                                  $$ = FALSE;
                                }
                      | TOK_IGNORE TOK_POS
                                {
                                  $$ = TRUE;
                                }

/* type pElemDDL */
optional_index_option_list : empty
                                {
                                  $$ = NULL;
                                }
                      | index_option_list


/* type pElemDDL */
index_option_list : index_option_spec
                      | index_option_list index_option_spec
                                {
                                  if ($1 == NULL)
                                  {
                                     $$ = $2;
                                  }
                                  else if ($2 == NULL)
                                  {
                                     $$ = $1;
                                  }
                                  else
                                  $$ = new (PARSERHEAP())
				    ElemDDLOptionList(
                                       $1 /*index_option_list*/,
                                       $2 /*index_option_spec*/);
                                }

/* type pElemDDL */
index_option_spec : location_clause
                      | partition_definition
                      | file_attribute_clause
                      | parallel_execution_clause
                      | populate_option
                      | attribute_num_rows_clause
                      | index_division_clause
                      | hbase_table_options
                      | salt_like_clause
                      | TOK_TABLESPACE IDENTIFIER
                         {
			   $$ = NULL;
			 }

/* type pElemDDL */
index_division_clause : division_by_clause
                        {
                          YYERROR;
                        }

                      | TOK_DIVISION TOK_LIKE TOK_TABLE
                        {
                          // index_division_clause ::= TOK_DIVISION TOK_LIKE TOK_TABLE

                          $$ = new (PARSERHEAP())
                            ElemDDLDivisionClause(ElemDDLDivisionClause::DIVISION_LIKE_TABLE);
                        }

/* type pElemDDL */

populate_option: TOK_NO TOK_POPULATE
                 {
		   ElemDDLIndexPopulateOption * elemIndex = new (PARSERHEAP())
                                                               ElemDDLIndexPopulateOption();
                   elemIndex->setNoPopulateClause(TRUE);
                   elemIndex->setNoPopulateOptionCount();
		   $$ = elemIndex;
                 }
 
                 | TOK_POPULATE
                   {
		      ElemDDLIndexPopulateOption * elemIndex = new (PARSERHEAP())
                                                               ElemDDLIndexPopulateOption();
                      elemIndex->setPopulateOptionCount();
                      $$ = elemIndex;
                          
                   }
 
/* type pElemDDL */
parallel_execution_clause : TOK_PARALLEL TOK_EXECUTION parallel_execution_spec
                                {
                                  // *** Error *** PARALLEL EXECUTION
                                  // clause not supported yet
				  *SqlParser_Diags << DgSqlCode(-3030);
                                  $$ = $3 /*parallel_execution_spec*/;
                                }

/* type pElemDDL */
parallel_execution_spec : TOK_ON
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLParallelExec(
                                       TRUE /*TOK_ON*/);
                                }

                      | TOK_ON TOK_CONFIG oss_path_name
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLParallelExec(
                                       TRUE /*TOK_ON*/,
                                       *$3  /*oss_path_name*/);
                                  delete $3;
                                }

                      | TOK_OFF
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLParallelExec(
                                       FALSE /*TOK_OFF*/);
                                }

/* type pStmtDDL */
initialize_sql_statement : TOK_INITIALIZE_SQL 
                             optional_create_role_list
                             optional_register_user_list
                         {
                           StmtDDLInitializeSQL *pNode = new (PARSERHEAP()) 
                             StmtDDLInitializeSQL($2, $3, PARSERHEAP());
                           pNode->synthesize();
                           $$ = pNode;
                         }

/* type pElemDDL */
optional_create_role_list :  empty
                          {
                            $$ = NULL;
                          }
                          | init_create_role_list

/* type pElemDDL */
init_create_role_list : init_create_role_element
                      | init_create_role_list init_create_role_element
                      {
                        $$ = new (PARSERHEAP())
                               ElemDDLList( $1 /*init_create_role_list*/,
                                            $2 /*init_create_role_element*/);
                      }

/* type pElemDDL */
init_create_role_element : create_role_statement
                    {
                      if ($1)
                        $$ = $1->castToElemDDLNode();
                      else
                        $$ = NULL;
                    }



/* type pElemDDL */
optional_register_user_list :  empty
                            {
                              $$ = NULL;
                            }
                            | init_register_user_list

/* type pElemDDL */
init_register_user_list : init_register_user_element
                        | init_register_user_list init_register_user_element
                        {
                          $$ = new (PARSERHEAP())
                             ElemDDLList($1 /*init_register_user_list*/,
                                         $2 /*init_register_user_element*/);
                        }

/* type pElemDDL */
init_register_user_element : register_user_statement
                           {
                             if ($1)
                               $$ = $1->castToElemDDLNode();
                             else
                               $$ = NULL;
                           }

/* type pElemDDL */
optional_location_clause : empty
                                {
				  $$ = NULL;
                                }

                      | location_clause

/* type pStmtDDL */
create_sequence_statement : TOK_CREATE TOK_SEQUENCE ddl_qualified_name sequence_generator_options
		      {
			ElemDDLSGOptions *sgOptions = 
			  new (PARSERHEAP()) ElemDDLSGOptions(
							      COM_EXTERNAL_SG,
							      $4 /*sequence_generator_option_list*/);
			
			$$ = new (PARSERHEAP())
			  StmtDDLCreateSequence(
					      *$3 /*seq_name_clause*/,
					      sgOptions /*seq gen options*/);
			delete $3 /*seq_name*/;
		      }
                   | TOK_CREATE TOK_INTERNAL TOK_SEQUENCE ddl_qualified_name sequence_generator_options
		      {
                        if (! Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
                          {
                            yyerror(""); YYERROR; /*internal syntax only!*/
                          }

			ElemDDLSGOptions *sgOptions = 
			  new (PARSERHEAP()) ElemDDLSGOptions(
							      COM_INTERNAL_SG, 
							      $5 /*sequence_generator_option_list*/);
			
			$$ = new (PARSERHEAP())
			  StmtDDLCreateSequence(
					      *$4 /*seq_name_clause*/,
					      sgOptions /*seq gen options*/);
			delete $4 /*seq_name*/;
		      }

alter_sequence_statement : TOK_ALTER TOK_SEQUENCE ddl_qualified_name all_sequence_generator_options
		      {
			ElemDDLSGOptions *sgOptions = 
			  new (PARSERHEAP()) ElemDDLSGOptions(
							      2, /* SG_EXTERNAL */
							      $4 /*sequence_generator_option_list*/);
			
			$$ = new (PARSERHEAP())
			  StmtDDLCreateSequence(
					      *$3 /*seq_name_clause*/,
					      sgOptions /*seq gen options*/,
					      TRUE /*alter*/);
			delete $3 /*seq_name*/;
		      }

alter_sequence_statement : TOK_ALTER TOK_INTERNAL TOK_SEQUENCE ddl_qualified_name all_sequence_generator_options
		      {
                        if (! Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
                          {
                            yyerror(""); YYERROR; /*internal syntax only!*/
                          }

			ElemDDLSGOptions *sgOptions = 
			  new (PARSERHEAP()) ElemDDLSGOptions(
							      1, /* SG_INTERNAL */
							      $5 /*sequence_generator_option_list*/);
			
			$$ = new (PARSERHEAP())
			  StmtDDLCreateSequence(
					      *$4 /*seq_name_clause*/,
					      sgOptions /*seq gen options*/,
					      TRUE /*alter*/);
			delete $4 /*seq_name*/;
		      }

/* type pStmtDDL */
cleanup_objects_statement : TOK_CLEANUP cleanup_object_identifier ddl_qualified_name optional_cleanup_return_details
               {
                 StmtDDLCleanupObjects::ObjectType ot;
                 if (*$2 == "TABLE")
                   ot = StmtDDLCleanupObjects::TABLE_;
                 else if (*$2 == "INDEX")
                   ot = StmtDDLCleanupObjects::INDEX_;
                 else if (*$2 == "VIEW")
                   ot = StmtDDLCleanupObjects::VIEW_;
                 else if (*$2 == "SEQUENCE")
                   ot = StmtDDLCleanupObjects::SEQUENCE_;
                 else if ((*$2 == "SCHEMA") ||
                          (*$2 == "SCHEMA_P"))
                   ot = StmtDDLCleanupObjects::SCHEMA_PRIVATE_;
                 else if (*$2 == "SCHEMA_S")
                   ot = StmtDDLCleanupObjects::SCHEMA_SHARED_;
                 else if (*$2 == "HBASE_TABLE")
                   ot = StmtDDLCleanupObjects::HBASE_TABLE_;
                 else if (*$2 == "OBJECT")
                   ot = StmtDDLCleanupObjects::UNKNOWN_;
                 else
                   YYERROR;

                 QualifiedName * qn = $3;
                 if ((ot == StmtDDLCleanupObjects::SCHEMA_PRIVATE_) ||
                     (ot == StmtDDLCleanupObjects::SCHEMA_SHARED_))
                   {
                     if ($3->fullyExpanded()) // cannot be a 3-part name
                       YYERROR;

                     qn = new(PARSERHEAP()) QualifiedName(SEABASE_SCHEMA_OBJECTNAME,
                                                          $3->getObjectName(),
                                                          $3->getSchemaName());
                   }

                 StmtDDLCleanupObjects *pNode = new (PARSERHEAP())
                   StmtDDLCleanupObjects(ot,
                                         qn->getQualifiedNameAsAnsiString(),
                                         NULL,
                                         PARSERHEAP());

                 if ($4 == TRUE)
                   {
                     // not yet supported
                     YYERROR;

                     pNode->setGetStatus(TRUE);
                     pNode->setReturnDetails(TRUE);
                   }

                 delete $3;

		 $$ = pNode;
	       }
             | TOK_CLEANUP cleanup_object_identifier ddl_qualified_name ',' TOK_UID  NUMERIC_LITERAL_EXACT_NO_SCALE optional_cleanup_return_details
               {
                 StmtDDLCleanupObjects::ObjectType ot;
                 if (*$2 == "TABLE")
                   ot = StmtDDLCleanupObjects::TABLE_;
                 else if (*$2 == "INDEX")
                   ot = StmtDDLCleanupObjects::INDEX_;
                 else if (*$2 == "VIEW")
                   ot = StmtDDLCleanupObjects::VIEW_;
                 else if (*$2 == "SEQUENCE")
                   ot = StmtDDLCleanupObjects::SEQUENCE_;
                 else if (*$2 == "OBJECT")
                   ot = StmtDDLCleanupObjects::UNKNOWN_;
                 else
                   YYERROR;

                 QualifiedName * qn = $3;
                 StmtDDLCleanupObjects *pNode = new (PARSERHEAP())
                   StmtDDLCleanupObjects(ot,
                                         qn->getQualifiedNameAsAnsiString(),
                                         $6,
                                         PARSERHEAP());
                 
                 if ($7 == TRUE)
                   {
                     // not yet supported
                     YYERROR;
                     
                     pNode->setGetStatus(TRUE);
                     pNode->setReturnDetails(TRUE);
                   }

                 delete $3;
                 delete $6;

		 $$ = pNode;
	       }
            | TOK_CLEANUP TOK_UID NUMERIC_LITERAL_EXACT_NO_SCALE  
               {
                 StmtDDLCleanupObjects *pNode = new (PARSERHEAP())
                   StmtDDLCleanupObjects(StmtDDLCleanupObjects::OBJECT_UID_,
                                         *$3,
                                         NULL,
                                         PARSERHEAP());

                 delete $3;

		 $$ = pNode;
	       }
           | TOK_CLEANUP TOK_METADATA optional_cleanup_return_details
               {
                 StmtDDLCleanupObjects *pNode = new (PARSERHEAP())
                   StmtDDLCleanupObjects(StmtDDLCleanupObjects::OBSOLETE_,
                                         "",
                                         NULL,
                                         PARSERHEAP());

                 pNode->setGetStatus(TRUE);
                 if ($3 == TRUE)
                   pNode->setReturnDetails(TRUE);

		 $$ = pNode;
	       }
           | TOK_CLEANUP TOK_METADATA  ',' TOK_CHECK optional_cleanup_return_details
               {
                 StmtDDLCleanupObjects *pNode = new (PARSERHEAP())
                   StmtDDLCleanupObjects(StmtDDLCleanupObjects::OBSOLETE_,
                                         "",
                                         NULL,
                                         PARSERHEAP());
                 pNode->setCheckOnly(TRUE);
                 pNode->setGetStatus(TRUE);
                 if ($5 == TRUE)
                   pNode->setReturnDetails(TRUE);

		 $$ = pNode;
	       }

cleanup_object_identifier : object_identifier
                       | TOK_PRIVATE TOK_SCHEMA   { $$ = new (PARSERHEAP()) NAString("SCHEMA_P"); }
                       | TOK_SHARED TOK_SCHEMA   { $$ = new (PARSERHEAP()) NAString("SCHEMA_S"); }
                       | TOK_OBJECT { $$ = new (PARSERHEAP()) NAString("OBJECT");}
                       | TOK_HIVE TOK_TABLE { $$ = new (PARSERHEAP()) NAString("HIVE_TABLE");}
                       | TOK_HIVE TOK_VIEW { $$ = new (PARSERHEAP()) NAString("HIVE_VIEW");}
                       | TOK_HBASE TOK_TABLE { $$ = new (PARSERHEAP()) NAString("HBASE_TABLE");}

/* type boolean */
optional_cleanup_return_details : empty
                                       {
                                         $$ = FALSE;
                                       }
                                     | ',' TOK_RETURN TOK_DETAILS
                                       {
                                         $$ = TRUE;
                                       }

/* type pStmtDDL */
drop_sequence_statement : TOK_DROP TOK_SEQUENCE ddl_qualified_name 
		      {
			$$ = new (PARSERHEAP())
			  StmtDDLDropSequence(
					      *$3 /*seq_name_clause*/);
			delete $3 /*seq_name*/;
		      }

/* type pStmtDDL */
drop_schema_statement : TOK_DROP schema_or_database
                        {

                          SqlParser_CurrentParser->hiveDDLInfo_->
                            setValues(TRUE, StmtDDLonHiveObjects::DROP_, StmtDDLonHiveObjects::SCHEMA_);
                        }
                        schema_name_clause optional_cleanup 
                        optional_drop_behavior 
                                {
                                  // cannot use keyword DATABASE if not hive ddl.
                                  if (($2 == 2) &&
                                      (NOT SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_))
                                    {
                                      YYERROR;
                                    }

				  NAString extSchName($4->getSchemaName().getSchemaNameAsAnsiString());
				  if (! validateVolatileSchemaName(extSchName))
				    {
				      YYERROR;
				    }

				  $$ = new (PARSERHEAP())
				    StmtDDLDropSchema(
                                        *$4 /*schema_name_clause*/,
                                         $6 /*optional_drop_behavior*/,
                                         $5 /*optional_cleanup*/,
					FALSE);
                                  delete $4 /*schema_name*/;
                                }

drop_schema_statement : TOK_DROP schema_or_database TOK_IF TOK_EXISTS 
                        {
                          SqlParser_CurrentParser->hiveDDLInfo_->
                            setValues(TRUE, StmtDDLonHiveObjects::DROP_, StmtDDLonHiveObjects::SCHEMA_, TRUE);
                        }
                        schema_name_clause optional_cleanup
                        optional_drop_behavior
                                {
                                  // cannot use keyword DATABASE if not hive ddl.
                                  if (($2 == 2) &&
                                      (NOT SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_))
                                    {
                                      YYERROR;
                                    }

                                  NAString extSchName($6->getSchemaName().getSchemaNameAsAnsiString());
                                  if (! validateVolatileSchemaName(extSchName))
                                    {
                                      YYERROR;
                                    }

                                    StmtDDLDropSchema *pNode =
                                      new (PARSERHEAP())
                                      StmtDDLDropSchema(
                                        *$6 /*schema_name_clause*/,
                                         $8 /*optional_drop_behavior*/,
                                         $7 /*optional_cleanup*/,
                                        FALSE);
                                  pNode->setDropIfExists(TRUE); 
                                  delete $6 /*schema_name*/;
                                  $$ = pNode;
                                }

drop_schema_statement : TOK_DROP TOK_VOLATILE TOK_SCHEMA schema_name optional_cleanup optional_drop_behavior
                                {
				  if (! Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
				    {
				      yyerror(""); YYERROR; /*internal syntax only!*/
				    }

                                  ElemDDLSchemaName edsn(*$4);

				  StmtDDLDropSchema *pNode = 
				    new (PARSERHEAP())
				    StmtDDLDropSchema(
                                         edsn /*schema_name*/,
                                         $6 /*optional_drop_behavior*/,
					 $5,
					FALSE);
                                  delete $4 /*schema_name*/;
				  pNode->setIsVolatile(TRUE);
				  $$ = pNode;
                                }

                        | TOK_DROP TOK_IMPLICIT TOK_VOLATILE TOK_SCHEMA optional_cleanup optional_drop_behavior
                                {
				  if (! Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
				    {
				      yyerror(""); YYERROR; /*internal syntax only!*/
				    }

				  SchemaName schName(CmpCommon::context()->sqlSession()->volatileSchemaName(),
						     CmpCommon::context()->sqlSession()->volatileCatalogName());
                                  ElemDDLSchemaName edsn(schName);
				    
				  StmtDDLDropSchema *pNode = 
				    new (PARSERHEAP())
				    StmtDDLDropSchema(
					 edsn,
                                         $6 /*optional_drop_behavior*/,
					 $5,
					 FALSE);
				  pNode->setIsVolatile(TRUE);
				  pNode->setProcessAsExeUtil(TRUE);
				  $$ = pNode;
                                }

                         | TOK_DROP TOK_IMPLICIT TOK_VOLATILE TOK_SCHEMA TOK_TABLES optional_cleanup optional_drop_behavior
                                {
				  if (! Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
				    {
				      yyerror(""); YYERROR; /*internal syntax only!*/
				    }

				  SchemaName schName(CmpCommon::context()->sqlSession()->volatileSchemaName(),
						     CmpCommon::context()->sqlSession()->volatileCatalogName());
                                  ElemDDLSchemaName edsn(schName);

				  StmtDDLDropSchema *pNode = 
				    new (PARSERHEAP())
				    StmtDDLDropSchema(
					 edsn,
                                         $7 /*optional_drop_behavior*/,
					 $6,
					 TRUE);
				  pNode->setIsVolatile(TRUE);
				  $$ = pNode;
                                }

/* type ComDropBehavior */
extension_drop_behavior : empty
                                {
                                  //
                                  // If drop behavior does not appear
                                  // (a Tandem extension), the default
                                  // is Restrict.
                                  //
                                  $$ = COM_RESTRICT_DROP_BEHAVIOR;
                                }

                      | TOK_CASCADE
                                {
#ifndef NDEBUG
                                  $$ = COM_CASCADE_DROP_BEHAVIOR;
#else
				  yyerror("");
				  YYERROR;
#endif
                                }


/* type ComDropBehavior */
optional_drop_behavior : empty
                                {
                                  //
                                  // If drop behavior does not appear, the default
                                  // is Restrict.
                                  //
                                  $$ = COM_RESTRICT_DROP_BEHAVIOR;
                                }

                      | drop_behavior

/* type ComDropBehavior */
drop_behavior : TOK_CASCADE
                                {
                                  $$ = COM_CASCADE_DROP_BEHAVIOR;
                                }

                      | TOK_RESTRICT
                                {
                                  $$ = COM_RESTRICT_DROP_BEHAVIOR;
                                }
                     | TOK_NO TOK_CHECK
                                {
				  if (NOT Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
				    { 
				      yyerror(""); 
				      YYERROR; /*internal syntax only!*/
				    }

                                  $$ = COM_NO_CHECK_DROP_BEHAVIOR;
                                }

optional_drop_index_behavior : empty
                                {
                                  //
                                  // If drop behavior does not appear, the default
                                  // is Restrict.
                                  //
                                  $$ = COM_RESTRICT_DROP_BEHAVIOR;
                                }
                       | TOK_CASCADE
                                {
                                  $$ = COM_CASCADE_DROP_BEHAVIOR;
                                }

                      | TOK_RESTRICT
                                {
                                  $$ = COM_RESTRICT_DROP_BEHAVIOR;
                                }

                      | TOK_NO TOK_CHECK
                                {
                                  $$ = COM_NO_CHECK_DROP_BEHAVIOR;
                                }

/* type ComDropBehavior */
optional_drop_invalidate_dependent_behavior : empty
                                {
                                  //
                                  // If drop behavior does not appear, the default
                                  // is Restrict.
                                  //
                                  $$ = COM_RESTRICT_DROP_BEHAVIOR;
                                }

                      | TOK_CASCADE TOK_INVALIDATE
				{
 				  $$ = COM_CASCADE_INVALIDATE_DEPENDENT_BEHAVIOR;
				} 
                      | drop_behavior
optional_cleanup : empty
                      {
                        $$ = FALSE;
                      }
                      | TOK_CLEANUP
                      {
                        $$ = TRUE;
                      }
                      | TOK_WITH TOK_CLEANUP
                      {
                        $$ = TRUE;
                      }

optional_validate : empty
                      {
                        $$ = FALSE;
                      }
                      | TOK_VALIDATE
                      {
                        yyerror(""); YYERROR; /*internal syntax only!*/
                      }

optional_logfile : empty
                      {
                         $$ = NULL;
                      }
                      | TOK_LOG log_file_name
                      {
                         $$ = $2;
                      } 

/* type pStmtDDL */
alter_index_statement : TOK_ALTER optional_ghost TOK_INDEX ddl_qualified_name
                                alter_index_action
                                {
                                  $$ = $5 /*alter_index_action*/;
                                  if ($2) /*optional_ghost*/
                                    $$->setIsGhostObject(TRUE);
                                  $$->castToStmtDDLAlterIndex()->
                                    setIndexName(*$4 /*ddl_qualified_name*/);
                                  delete $4 /*ddl_qualified_name*/;
                                }

/* type pStmtDDL */
alter_index_action : file_attribute_clause
                                {
                                  $$ = new (PARSERHEAP())
				    StmtDDLAlterIndexAttribute(
                                       $1 /*file_attribute_clause*/);
                                }
                      | TOK_ALTER hbase_table_options
                        {
                                $$ = new (PARSERHEAP())
				  StmtDDLAlterIndexHBaseOptions($2->castToElemDDLHbaseOptions());
                        }

//----------------------------------------------------------------------------
// MV - RG

/* type pStmtDDL */
alter_mv_refresh_group_statement : TOK_ALTER TOK_MVGROUP mv_group_name_to_alter
			mv_group_alter_action_type mv_name_list
{
  $$ = new (PARSERHEAP())StmtDDLAlterMvRGroup(*$3, // groupQaulName
                                              $4, // action
                                              $5 // ElemDDLList of MVs
                                              );
  delete $3;
}


/* type pQualName */
mv_group_name_to_alter : ddl_qualified_name

/* type MVRGAlterActionType */
mv_group_alter_action_type : TOK_ADD
							 {
								
							 $$ = StmtDDLAlterMvRGroup::ADD_ACTION;

							 }
						 | TOK_REMOVE
							 {

							 $$ = StmtDDLAlterMvRGroup::REMOVE_ACTION;

							 }
						| TOK_OPENBLOWNAWAY
							{
							$$ = StmtDDLAlterMvRGroup::testOpenBlownAway_action; // OZY_TEST
							}
						| TOK_REDEFTIME
							{
							$$ = StmtDDLAlterMvRGroup::testRedefTimeStamp_action; // OZY_TEST

							}

/* type pElemDDL */
mv_name_list : mv_name_node
			| mv_name_list ',' mv_name_node
				   {

				   $$ = 
					new (PARSERHEAP()) ElemDDLList(	$1, // ElemDDLList
													$3	// ElemDDLMVNameNode
																				);
				   }


/* type pElemDDL */
mv_name_node : ddl_qualified_name
					   {
						$$ = new (PARSERHEAP())ElemDDLQualName(*$1);
						delete $1;
					   }



//----------------------------------------------------------------------------
//++ INTERNAL REFRESH PARSING SECTION

// OZ_REFRESH

// relx
internal_refresh_command : TOK_INTERNAL TOK_REFRESH internal_refresh_options
			  {
     	     		    if (Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE) &&
			        Get_SqlParser_Flags(ALLOW_FUNNY_IDENTIFIER)	)
			    {
			      $$ = $3;
		            }
			    else
			    { yyerror(""); YYERROR; /*internal syntax only!*/}
			  }

// relx				
internal_refresh_options : internal_refresh_mv_name recompute_refresh_options
			  {
			    $$ = new (PARSERHEAP())Refresh(*$1,
							    $2->getIsNoDelete());
							    // NEW RECOMPUTE
			    delete $1;
			    delete (RecomputeRefreshOption*)$2;

			  }
			  | internal_refresh_mv_name incremental_refresh_options
			  {
			    $2->synthesize(); // without this nothing will work
			    // $2->trace();

			    if (IncrementalRefreshOption::SINGLEDELTA == $2->getType())
			    {
			      $$ = new (PARSERHEAP())Refresh( *$1, // mvName
							$2->getDeltaDefPtrList(), 
							$2->getNRowsClause(),
							$2->getPipelineClause());
			    } else if (IncrementalRefreshOption::MULTIDELTA == $2->getType())
			      $$ = new (PARSERHEAP())Refresh( *$1, // mvName
							      $2->getDeltaDefPtrList(),
							      $2->getPhaseNum(),
							      $2->getPipelineClause());
			    delete $1;
			    delete $2;

			  }



// pQualName			
internal_refresh_mv_name : qualified_name
			{
			  $$ = qualifiedNameFromStrings($1);
			  // delete $1 done in qualifiedNameFromStrings;
			}



// pRecomputeRefreshOption
recompute_refresh_options: TOK_RECOMPUTE TOK_NODELETE
			 {
			  $$ = new (PARSERHEAP())RecomputeRefreshOption(TRUE);
			 }
			 | TOK_RECOMPUTE
			 {
			  $$ = new (PARSERHEAP())RecomputeRefreshOption(FALSE);
			 }

// pIncrementalRefreshOption	
incremental_refresh_options : TOK_FROM TOK_SINGLEDELTA delta_definition_list optional_nrows_clause optional_pipeline_clause
			    {
			      $$ = new (PARSERHEAP())IncrementalRefreshOption
				      (
				      $3, //pDeltaDefinitionPtrList 
				      $4, // pOptionalNRowsClause
				      $5  // pOptionalPipelineClause
				      );

			    }
			    | TOK_FROM TOK_MULTIDELTA delta_definition_list TOK_PHASE unsigned_integer optional_pipeline_clause
			    {
			      $$ = new (PARSERHEAP())IncrementalRefreshOption
					  (
					  $3, //pDeltaDefinitionPtrList 
					  $5, // uint
					  $6  // pOptionalPipelineClause
					  );

			    }

						   
//pDeltaDefinitionPtrList		
delta_definition_list : delta_definition_node
		      {
			$$ = new (PARSERHEAP())DeltaDefinitionPtrList();
			$$->insert($1);
		      }
		      |
		      delta_definition_list ',' delta_definition_node
		      {
			$1->insert($3);
			//delete $3;
			$$ = $1;
		      }
//pDeltaDefinition		
delta_definition_node: qualified_name TOK_BETWEEN begin_epoch TOK_AND end_epoch delta_options
					   {
					      $$ = new(PARSERHEAP())DeltaDefinition
						  (
							  qualifiedNameFromStrings($1),
							  $3, // begin_epoch
							  $5, // end_epoch
							  $6 // pDeltaOptions
						  );
					      
					      // delete $1 done in qualifiedNameFromStrings;


					   }
					   
//uint						
begin_epoch : unsigned_integer


//uint						
end_epoch : unsigned_integer


//pDeltaOptions
delta_options : TOK_DE TOK_LEVEL unsigned_integer delta_def_logs
		{
		  $$ = new (PARSERHEAP())DeltaOptions($3, $4);
		}

//pDeltaDefLogs
delta_def_logs : delta_def_range_log delta_def_iud_log
		{
		  $$ = new (PARSERHEAP())DeltaDefLogs($1, $2);
		}

//pDeltaDefRangeLog
delta_def_range_log : TOK_USE TOK_NO TOK_RANGELOG 
		      {
		        $$ = new (PARSERHEAP())DeltaDefRangeLog(DeltaDefRangeLog::NO_LOG);
		      }
	  	      | TOK_USE TOK_RANGELOG unsigned_integer TOK_NUM_OF_RANGES
		      {
		        $$ = new (PARSERHEAP())DeltaDefRangeLog(DeltaDefRangeLog::CARDINALITY_ONLY, $3);
		      }
		      | TOK_USE TOK_RANGELOG unsigned_integer TOK_NUM_OF_RANGES unsigned_integer TOK_ROWS_COVERED
		      {
		        $$ = new (PARSERHEAP())DeltaDefRangeLog(DeltaDefRangeLog::ALL, $3, $5);
		      }

//pDeltaDefIUDLog
delta_def_iud_log :  TOK_USE TOK_IUDLOG iud_statistics_rows
		    {
		      $$ = new (PARSERHEAP())DeltaDefIUDLog(DeltaDefIUDLog::STAT, 
							    $3 //pIUDStatistics 
							    );
		    }
		    | TOK_USE TOK_NO TOK_IUDLOG 
		    {
		      $$ = new (PARSERHEAP())DeltaDefIUDLog(DeltaDefIUDLog::NO_LOG);
		    }
		    | TOK_USE TOK_IUDLOG TOK_INSERT TOK_ONLY
		    {
		      $$ = new (PARSERHEAP())DeltaDefIUDLog(DeltaDefIUDLog::INSERT_ONLY);
		    }
		    | TOK_USE TOK_IUDLOG
		    {
		      $$ = new (PARSERHEAP())DeltaDefIUDLog(DeltaDefIUDLog::NO_STAT);
		    }
		    

//pIUDStatistics
iud_statistics_rows : num_inserted num_deleted num_updated optional_update_collumns
		    {
		      $$ = new (PARSERHEAP())IUDStatistics($1,$2,$3,$4);
		    }

//uint						
num_inserted : unsigned_integer TOK_ROWS_INSERTED
	     {
		$$ = $1;
	     }

//uint						
num_deleted : unsigned_integer TOK_ROWS_DELETED
	   {
	      $$ = $1;
	   }

//uint						
num_updated : unsigned_integer TOK_ROWS_UPDATED
	   {
	    $$ = $1;
	   }

			  
// pIntegerList
optional_update_collumns :  TOK_COLUMNS '(' columns_num_list ')'
			{
			  $$ = $3; 
			}
			|empty
			 {
			    $$ = NULL;				   
			 }


// pIntegerList
columns_num_list : unsigned_integer 
		 {
		  $$ = new (PARSERHEAP())IntegerList();
		  $$->insert($1);
		 }
		 | columns_num_list ',' unsigned_integer
		 {
		  $1->insert($3);
		  $$ = $1;
		 }
			  
// pOptionalNRowsClause
optional_nrows_clause: empty
		     {
			$$ = NULL;
		     }
		     | TOK_COMMIT TOK_EACH unsigned_integer TOK_PHASE phase_num optional_catchup
		     {
		      
		       $$ = new (PARSERHEAP())NRowsClause( $3, // commit each
							  $5, // PHASE
							  $6 // pOptionalCatchupClause
							  );
		     }



//uint						
phase_num : unsigned_integer

// item
optional_catchup : empty
		  {
		    $$ = NULL;
		  }
		  | TOK_CATCHUP unsigned_integer
		  {
		    $$ = new (PARSERHEAP())ConstValue($2);
		  }
		  | TOK_CATCHUP dynamic_parameter
		  {
		    $$ = $2;
		  }




//pPipelineClause
optional_pipeline_clause : empty
			 {
			    $$ = NULL;
			 }
			 | pipeline_clause
			 {
			    $$ = $1;
			 }

//pPipelineClause				
pipeline_clause :  TOK_PIPELINE '(' pipeline_mv_name_list ')' pipeline_def_list
		 {
		    $$ = new (PARSERHEAP())PipelineClause($3, $5);
		 }
		 | TOK_PIPELINE '(' pipeline_mv_name_list ')' 
		 {
		    $$ = new (PARSERHEAP())PipelineClause($3);
		 }

					

// pPipelineDefPtrList
pipeline_def_list: pipeline_def
		  {

		    PipelineDefPtrList * pOneNodeDefList = 
						    new (PARSERHEAP())PipelineDefPtrList();

		    pOneNodeDefList->insert($1);
						    
		    $$ = pOneNodeDefList;
		  }
		  
		  | pipeline_def_list ',' pipeline_def
		     {
			$1->insert($3);
			//delete $3;
			$$ = $1;
		     }


// pPipelineDef
pipeline_def: qualified_name TOK_PIPELINE '(' pipeline_mv_name_list ')'
	    {
	      QualifiedName * mvName = qualifiedNameFromStrings($1);
	      // delete $1 done in qualifiedNameFromStrings;
	      
	      $$ = new (PARSERHEAP())PipelineDef( mvName, $4 );
	    }

//pQualName
pipeline_mv_name_list: pipeline_mv_name_node
		     {
			$$ = new (PARSERHEAP())QualNamePtrList();
			$$->insert($1);

		     }
			     | pipeline_mv_name_list ',' pipeline_mv_name_node
		     {
			$1->insert($3);
			//delete $3;
			$$ = $1;	
		     }

// pQualifiedNamePtrList
pipeline_mv_name_node: qualified_name
		       {
			  $$ = qualifiedNameFromStrings($1);
			  // delete $1 done in qualifiedNameFromStrings;
		       }

//-- INTERNAL REFRESH PARSING SECTION
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//++ MVLOG

mvlog_command : mvlog_keywords mvlog_table_name 
				'(' column_list ')' TOK_BETWEEN mvlog_values_list TOK_AND mvlog_values_list
				{
					$$ = new (PARSERHEAP()) MvLog($2, $4, $7, $9);
				}

mvlog_values_list : '(' value_expression ')' 
					{
					  $$ = $2;
					}
					| '(' value_expression_list_comma ')' 
					{
					  $$ = $2;
					}

mvlog_keywords : TOK_MVLOG TOK_INTO TOK_RANGELOG TOK_OF

mvlog_table_name : qualified_name
				   {
				     $$ = qualifiedNameFromStrings($1);
				     // delete $1 done in qualifiedNameFromStrings;
				   }


//-- MVLOG
//----------------------------------------------------------------------------

 no_check_log: empty
		{
		  $$ = 0;
		}
		| TOK_NOMVLOG
		{
		  $$ = 1;
		}
		| TOK_NO TOK_CHECK
		{
		  $$ = 2;
		}
		| TOK_NOMVLOG TOK_NO TOK_CHECK
		{
		  $$ = 3;
		}
		| TOK_NO TOK_CHECK TOK_NOMVLOG
		{
		  $$ = 3;
		}

ignore_triggers: empty
		{
			$$ = FALSE;
		}
		| TOK_IGNORETRIGGERS
		{
			$$ = TRUE;
		}

// type boolean		
                 
no_rollback: empty
        {
            $$ = FALSE;
        }
        | TOK_WITH TOK_NO TOK_ROLLBACK
        {
            $$ = TRUE;
        }

/* type boolean */
enable_status : TOK_DISABLE
                 {
		   $$ = FALSE;
		 }
               | TOK_ENABLE
                 {
		   $$ = TRUE;
		 }
/* type boolean */
optional_all_of : empty
                 {
		   $$ = FALSE;
		 }
               | TOK_ALL TOK_OF
                 {
		   $$ = TRUE;
		 }

/* type pStmtDDL */
alter_trigger_statement : TOK_ALTER TOK_TRIGGER enable_status
                             optional_all_of  ddl_qualified_name
                          {
			    $$ = new (PARSERHEAP())
			      StmtDDLAlterTrigger(
						  $3, /* enable_status */
						  $4, /* optional_all_of */
						  *$5 /*ddl_qualified_name*/);
			    delete $5;
			  }

/* type uint */
alter_view_start_tokens : TOK_ALTER TOK_VIEW
                   {
                     SqlParser_CurrentParser->hiveDDLInfo_->
                       setValues(TRUE, StmtDDLonHiveObjects::ALTER_, StmtDDLonHiveObjects::VIEW_);

                     $$ = 0;
                   }

/* type pStmtDDL */
alter_view_statement : alter_view_start_tokens 
                       ddl_qualified_name
                       TOK_RENAME TOK_TO identifier
                          {
                            $$ = new (PARSERHEAP())StmtDDLAlterView
                                     ( *$2 // ddl_qualified_name (old name)
                                     , *$5 // identifier (new name)
                                     );
                            delete $2;  // ddl_qualified_name
                            delete $5;  // identifier
                          }
                     |  alter_view_start_tokens
                        ddl_qualified_name
                        TOK_COMPILE optional_cascade 
                          {
                            $$ = new (PARSERHEAP())StmtDDLAlterView
                                     ( *$2 // ddl_qualified_name (view name to validate)
                                     ,  $4 // cascade TRUE or FALSE 
                                     );
                            delete $2;  // ddl_qualified_name
                          }

//----------------------------------------------------------------------------
//++ MV

// type pStmtDDL
alter_mv_statement : TOK_ALTER optional_ghost mv_token alter_mv_body
					 {
                                           *SqlParser_Diags << DgSqlCode(-3131);
                                           YYERROR;
                                           
                                           $4->castToStmtDDLAlterMV()->synthesize();
                                           $$ = $4 /*alter_mv_body*/;
                                           if ($2) /*optional_ghost*/
                                             $$->setIsGhostObject(TRUE);
					 }


// type pStmtDDL
alter_mv_body : alter_mv_query_rewrite
				   {
					   $$ = $1;
				   }
				| alter_mv_file_attribs
				{
					$$ = $1;
				}
				| alter_mv_mvfile_attribs
				{
					$$ = $1;
				}
				| alter_mv_rename
				{
					$$ = $1;
				}
                                | alter_mv_attribute_table_lists
                                {
                                        $$ = $1;
                                }



// type pStmtDDL
alter_mv_query_rewrite : ddl_qualified_name enable_status TOK_QUERY TOK_REWRITE 
					 {
						$$ = new (PARSERHEAP())StmtDDLAlterMV( *$1, //ddl_qualified_name
																$2 // enable_status 
																);
						delete $1;
					 }

// type pStmtDDL
alter_mv_file_attribs : ddl_qualified_name file_attribute_clause 
					{
						$$ = new (PARSERHEAP())StmtDDLAlterMV( *$1, //ddl_qualified_name
																$2 // ElemDDLFileAttrClause 
																);
						delete $1;
					}

// type pStmtDDL
alter_mv_mvfile_attribs : ddl_qualified_name mv_file_attribute_clause 
					{
						$$ = new (PARSERHEAP())StmtDDLAlterMV( *$1, //ddl_qualified_name
																$2 // ElemDDLFileAttrClause 
																);
						delete $1;
					}

/* type pStmtDDL */
alter_mv_rename : ddl_qualified_name TOK_RENAME TOK_TO identifier
                                 optional_cascade
                                {
                                  $$ = new (PARSERHEAP())StmtDDLAlterMV
                                           ( *$1 // ddl_qualified_name (old name)
                                           , *$4 // identifier (new name)
                                           ,  $5 // optional_cascade
                                           );
                                  delete $1;  // ddl_qualified_name
                                  delete $4;  // identifier
                                }

/* type pStmtDDL */
alter_mv_attribute_table_lists : ddl_qualified_name TOK_ADD ignore_changes_on_table_list
                                 {
                                   $$ = new (PARSERHEAP()) StmtDDLAlterMV
                                         ( *$1
                                         ,  $3
                                         , StmtDDLAlterMV::ADD_IGNORE_CHANGES_LIST
                                         );

                                  delete $1;
                                 }

                               | ddl_qualified_name TOK_REMOVE ignore_changes_on_table_list
                                 {
                                   $$ = new (PARSERHEAP()) StmtDDLAlterMV
                                         ( *$1
                                         ,  $3
                                         , StmtDDLAlterMV::REMOVE_IGNORE_CHANGES_LIST
                                         );

                                  delete $1;
                                 }


/* type boolean */
optional_cascade : empty
                                {
                                  $$ = FALSE;
                                }

                      | TOK_CASCADE
                                {
                                  $$ = TRUE;
                                }

/* type boolean */
optional_skip_view_check : empty
                                {
                                  $$ = FALSE;
                                }

                      | TOK_SKIP TOK_VIEW TOK_CHECK
                                {
                                  if (! Get_SqlParser_Flags(INTERNAL_QUERY_FROM_EXEUTIL))
                                    {
                                      yyerror("");
                                      YYERROR;     /*internal syntax only!*/
                                    }
                                  $$ = TRUE;
                                }

//-- MV
//----------------------------------------------------------------------------


/* type pStmtDDL */
alter_audit_config_statement: TOK_ALTER TOK_AUDIT TOK_CONFIG 
                                 TOK_LOG QUOTED_STRING QUOTED_STRING QUOTED_STRING
				{
				    $$ = new (PARSERHEAP())
				      StmtDDLAlterAuditConfig 
					(*$5, /*string*/ 
					 *$6, /*string*/ 
					 *$7  /*string*/ 
                                         );
				}

/* type pStmtDDL */
alter_catalog_statement: TOK_ALTER TOK_CATALOG sql_mx_catalog_name enable_status TOK_SCHEMA schema_name
				{
				    $$ = new (PARSERHEAP())
				      StmtDDLAlterCatalog 
					(*$3,	//sql_mx_catalog_name
					  $4,	//enable_status
					 *$6	//schema_name
					 );				      				     
				      delete $6;
				}

			  | TOK_ALTER TOK_CATALOG sql_mx_catalog_name enable_status TOK_ALL TOK_SCHEMA
				{
				    $$ = new (PARSERHEAP())
				      StmtDDLAlterCatalog
				      (*$3,	//sql_mx_catalog_name
				       $4,      //enable_status
                                       FALSE);  //disable_create
				}

                          | TOK_ALTER TOK_CATALOG sql_mx_catalog_name enable_status TOK_CREATE
                                {
                                    if (!Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                                    {
                                      // Internal syntax: not allowed
                                      yyerror("");
                                      YYERROR;
                                    }
                                    $$ = new (PARSERHEAP())
                                      StmtDDLAlterCatalog
                                      (*$3,     //sql_mx_catalog_name
                                       $4,      //enable_status
                                       TRUE);   //disable_create
                                }

                          | TOK_ALTER TOK_ALL TOK_CATALOG enable_status TOK_CREATE
                                {
                                    $$ = new (PARSERHEAP())
                                      StmtDDLAlterCatalog
                                      ($4);     //enable_status
                                }

                          | TOK_ALTER TOK_ALL TOK_CATALOGS enable_status TOK_CREATE
                                {
                                    $$ = new (PARSERHEAP())
                                      StmtDDLAlterCatalog
                                      ($4);     //enable_status
                                }

                          | TOK_ALTER TOK_CATALOG sql_mx_catalog_name enable_status TOK_CREATE TOK_IN TOK_SCHEMA schema_name
                                {
                                    if (!Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                                    {
                                      // Internal syntax: not allowed
                                      yyerror("");
                                      YYERROR;
                                    }
                                    $$ = new (PARSERHEAP())
                                      StmtDDLAlterCatalog
                                      (*$3,     //sql_mx_catalog_name
                                       $4,      //enable_status
                                       TRUE,    //disable/enable_create
				       *$8);
                                }

alter_schema_start_tokens : TOK_ALTER schema_or_database
                            {
                              SqlParser_CurrentParser->hiveDDLInfo_->
                                setValues(TRUE, StmtDDLonHiveObjects::ALTER_, StmtDDLonHiveObjects::SCHEMA_);

                              $$ = $2;
                            }

/* type pStmtDDL */
alter_schema_statement: alter_schema_start_tokens
                        schema_name_clause alter_stored_descriptor_option
			{
                          // cannot use keyword DATABASE if not hive ddl.
                          if (($1 == 2) &&
                              (NOT SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_))
                            {
                              YYERROR;
                            }

                          $$ = new (PARSERHEAP()) 
                            StmtDDLAlterSchema
                            (*$2,
                             (StmtDDLAlterTableStoredDesc::AlterStoredDescType)$3);

                        }
                     |  alter_schema_start_tokens
                        schema_name_clause TOK_DROP TOK_ALL TOK_TABLES
			{
                          // cannot use keyword DATABASE if not hive ddl.
                          if (($1 == 2) &&
                              (NOT SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_))
                            {
                              YYERROR;
                            }

                          NAString extSchName($2->getSchemaName().getSchemaNameAsAnsiString());
                          if (! validateVolatileSchemaName(extSchName))
                            {
                              YYERROR;
                            }
                          
                          $$ = new (PARSERHEAP())
                            StmtDDLDropSchema(
                                 *$2 /*schema_name_clause*/,
                                 COM_CASCADE_DROP_BEHAVIOR,
                                 FALSE /*optional_cleanup*/,
                                 TRUE);
                          delete $2 /*schema_name*/;
                        }
                     |  alter_schema_start_tokens
                        schema_name_clause TOK_RENAME TOK_TO identifier
			{
                          // cannot use keyword DATABASE if not hive ddl.
                          if (($1 == 2) &&
                              (NOT SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_))
                            {
                              YYERROR;
                            }

                          NAString extSchName($2->getSchemaName().getSchemaNameAsAnsiString());
                          if (! validateVolatileSchemaName(extSchName))
                            {
                              YYERROR;
                            }
                          
                          $$ = new (PARSERHEAP())
                            StmtDDLAlterSchema(
                                 *$2 , //schema_name_clause
                                 *$5);
                          delete $2; // schema_name
                          delete $5; // renamed schema
                        }

/* type pStmtDDL */
alter_library_statement : TOK_ALTER TOK_LIBRARY ddl_qualified_name 
                          TOK_FILE std_char_string_literal
                          optional_library_clientname
                          optional_library_clientfilename
                               {
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterLibrary(
                                        *$3 /*ddl_qualified_name*/,
                                        *$5 /*string*/,
                                        $6 /*ElemDDLNode*/,
                                        $7 /*ElemDDLNode*/,
                                        PARSERHEAP());
                                  delete $3 /*ddl_qualified_name*/;
                                 
                               }
/* type pElemDDL */
optional_library_clientname : empty
                         {
                       $$ = NULL;
                         }
                   | TOK_HOST TOK_NAME std_char_string_literal
                         {
                          $$ = new (PARSERHEAP()) ElemDDLLibClientName(*$3); // std_char_string_literal
                         } 

/* type pElemDDL */
optional_library_clientfilename : empty
                         {
                       $$ = NULL;
                         }
                   | TOK_LOCAL TOK_FILE std_char_string_literal
                         {
                          $$ = new (PARSERHEAP()) ElemDDLLibClientFilename(*$3); // std_char_string_literal
                         } 
                               
// Make optional clauses not position dependent                              
//* type pElemDDL LIBRARY
//optional_library_attribute_list : empty
//                         {
//                       $$ = NULL;
//                         }
//                      | library_attribute_list
//
//* type pElemDDL LIBRARY
//library_attribute_list : library_attribute
//                      | library_attribute_list library_attribute
//                                {
//                                  $$ = new (PARSERHEAP())
//				    ElemDDLOptionList(
//                                       $1 ,//*library_attribute_listLIBRARY
//                                       $2 );//*library_attributeLIBRARY
//                                }
//
//* type pElemDDL LIBRARY
//library_attribute :  TOK_LOCAL TOK_FILE std_char_string_literal
//                         {
//                          $$ = new (PARSERHEAP()) ElemDDLLibClientFilename(*$3); // std_char_string_literal
//                      	 }
//                   | TOK_HOST TOK_NAME std_char_string_literal
//                         {
//                          $$ = new (PARSERHEAP()) ElemDDLLibClientName(*$3); // std_char_string_literal
//                         } 
//
                          
/* type pStmtDDL */
create_library_stmt : TOK_CREATE optional_system TOK_LIBRARY ddl_qualified_name 
                          TOK_FILE std_char_string_literal
                          optional_library_clientname
                          optional_library_clientfilename
                          optional_by_auth_identifier
                               {
                                  $$ = new (PARSERHEAP())
                                    StmtDDLCreateLibrary(
                                        $2 /* isSystem */,
                                        *$4 /*ddl_qualified_name*/,
                                        *$6 /*string*/,
                                        $7 /*ElemDDLNode*/,
                                        $8 /*ElemDDLNode*/,
                                        $9 /*by authid*/,
                                        PARSERHEAP());
                                  delete $4 /*ddl_qualified_name*/;
                                 
                               }
                               
/* type pStmtDDL */
optional_system : empty
                  {
                    $$ = FALSE;
                  }
                  | TOK_SYSTEM
                  {
		    $$ = TRUE;
		  }

/* type pStmtDDL */
drop_library_statement : TOK_DROP TOK_LIBRARY ddl_qualified_name optional_drop_behavior
                               {
                                  $$ = new (PARSERHEAP())
                                    StmtDDLDropLibrary(
                                        *$3 /*ddl_qualified_name*/,
                                        $4  /*optional_drop_behavior*/ );
                                  delete $3 /*ddl_qualified_name*/;
                               }

/* type uint */
alter_table_start_tokens : TOK_ALTER optional_ghost TOK_TABLE
                   {
                     if ($2)
                       $$ = 1;
                     else
                       $$ = 0;

                     SqlParser_CurrentParser->hiveDDLInfo_->
                       setValues(TRUE, StmtDDLonHiveObjects::ALTER_, StmtDDLonHiveObjects::TABLE_);
                   }

                          
/* type pStmtDDL */
alter_table_statement :  alter_table_start_tokens
                                ddl_qualified_name
                                alter_table_action 
                                {
                                  $$ = $3 /*alter_table_action*/;
                                  if ($1) /*optional_ghost*/
                                    $$->setIsGhostObject(TRUE);
                                  $$->castToStmtDDLAlterTable()->
                                    setTableName(QualifiedName (*$2 /*ddl_qualified_name*/, 
                                                  PARSERHEAP()));
				  if($$->castToStmtDDLAlterTableAddColumn())
                                    {
				      $$->castToStmtDDLAlterTableAddColumn()->
					synthesize();
                                    }
                                  delete $2 /*ddl_qualified_name*/;
                                }
                       | alter_table_start_tokens ddl_qualified_name
                                is_not_droppable
                                {
                                  StmtDDLAlterTable *pNode = new (PARSERHEAP())
				                             StmtDDLAlterTable(DDL_ALTER_TABLE_DROPPABLE);
                                  pNode->setTableName(QualifiedName
				                      (*$2 /*ddl_qualified_name*/,
						       PARSERHEAP()));

                                  pNode->setIsDroppable(!$3);
                                  $$ = pNode;
                                  delete $2 /*ddl_qualified_name*/;
                                  if ($1) /*optional_ghost*/
                                    $$->setIsGhostObject(TRUE);
                                }
                       | alter_table_start_tokens ddl_qualified_name
                                TOK_INSERT_ONLY
                                {
                                  if (CmpCommon::getDefault(CAT_ALLOW_NEW_FEATUREX) == DF_OFF)
                                  {
                                    // Feature not externalized
                                    yyerror(""); 
                                    YYERROR;
                                  }

                                  StmtDDLAlterTable *pNode = new (PARSERHEAP())
                                                             StmtDDLAlterTable(DDL_ALTER_TABLE_INSERT_ONLY);
                                  pNode->setTableName(QualifiedName
                                                      (*$2 /*ddl_qualified_name*/,
                                                       PARSERHEAP()));
                                  pNode->setInsertOnly(TRUE);
                                  $$ = pNode;
                                  delete $2 /*ddl_qualified_name*/;
                                  if ($1) /*optional_ghost*/
                                    $$->setIsGhostObject(TRUE);
                                }

                     | alter_table_start_tokens ddl_qualified_name TOK_NAMESPACE 
				{
                                  if ( ! Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE)
		                       && ( CmpCommon::getDefault(ALLOW_GHOST_OBJECTS) == DF_OFF )
                                     )
                                  {
                                    // Internal syntax: not allowed
                                    yyerror(""); 
                                    YYERROR; 
                                  }
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableNamespace
                                      (*$2);
                                  $$->castToStmtDDLAlterTable()->
                                    setTableName(QualifiedName
                                                 (*$2 /*ddl_qualified_name*/, 
                                                  PARSERHEAP()));
                                  if($1)
                                    $$->setIsGhostObject(TRUE);
 				  else
                                    $$->setIsGhostObject(FALSE);
                                  delete $2; // identifier
				}

                       | alter_table_start_tokens ddl_qualified_name online_or_offline                      
                        {
                            StmtDDLAlterTable *pNode = new (PARSERHEAP())
			                                    StmtDDLAlterTable(DDL_ALTER_TABLE_TOGGLE_ONLINE);
                            pNode->setTableName(QualifiedName(*$2 , PARSERHEAP())); 
                            pNode->setIsOnline($3);
                            $$ = pNode;
  		            if($1)
                              $$->setIsGhostObject(TRUE);
 			    else
                              $$->setIsGhostObject(FALSE);     
                            delete $2;
                        }
                       | alter_table_start_tokens ddl_qualified_name online_or_offline TOK_FOR TOK_PURGEDATA
                        {
			  if ((NOT Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE)) ||
                              ($2)) // ghost
			    { 
			      yyerror(""); 
			      YYERROR; /*internal syntax only!*/
			    }

			  StmtDDLAlterTable *pNode = new (PARSERHEAP())
			    StmtDDLAlterTable(DDL_ALTER_TABLE_TOGGLE_ONLINE);
			  pNode->setTableName(QualifiedName(*$2 , PARSERHEAP())); 
			  pNode->setIsOnline($3);
			  pNode->setForPurgedata(TRUE);
			  $$ = pNode;
			  $$->setIsGhostObject(FALSE);
			  delete $2;
                        }
                     | TOK_ALTER TOK_VOLATILE TOK_TABLE volatile_ddl_qualified_name
                                alter_table_action
                                {
                                  $$ = $5 /*alter_table_action*/;
				  $$->setIsVolatile(TRUE);
				  
                                  $$->castToStmtDDLAlterTable()->
                                    setTableName(QualifiedName
                                                 (*$4 /*ddl_qualified_name*/, 
                                                  PARSERHEAP()));
                                  delete $4 /*ddl_qualified_name*/;
                                }

                     | TOK_MSCK
                       { 
                         // this is a Hive only syntax
                         SqlParser_CurrentParser->hiveDDLInfo_->
                           setValues(TRUE, StmtDDLonHiveObjects::MSCK_, 
                                     StmtDDLonHiveObjects::TABLE_);
                       }
                       TOK_REPAIR TOK_TABLE ddl_qualified_name
                       {
                         if (NOT SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_)
                           {
                             *SqlParser_Diags << DgSqlCode(-3242)
                                              << DgString0("Specified object must be a Hive object.");
                           }

                         $$ = NULL;
                         YYERROR;
                       }
                     | alter_table_start_tokens ddl_qualified_name TOK_RECOVER TOK_PARTITIONS
                       {
                         // this is a Hive only syntax
                         SqlParser_CurrentParser->hiveDDLInfo_->
                           setValues(TRUE, StmtDDLonHiveObjects::MSCK_, 
                                     StmtDDLonHiveObjects::TABLE_);

                         if (NOT SqlParser_CurrentParser->hiveDDLInfo_->foundDDL_)
                           {
                             *SqlParser_Diags << DgSqlCode(-3242)
                                              << DgString0("Specified object must be a Hive object.");
                           }
 
                         $$ = NULL;
                         YYERROR;
                       }

ghost : TOK_GHOST
                 {
                   // GHOST is allowed only if the flag ALLOW_SPECIALTABLETYPE is set,
                   // or the CQD ALLOW_GHOST_OBJECTS is set to 'ON'.
                   if ( ! Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE)
		        && ( CmpCommon::getDefault(ALLOW_GHOST_OBJECTS) == DF_OFF )
                      )
                   {
                     // Internal syntax: GHOST not allowed
                     yyerror(""); 
                     YYERROR; 
                   }
                 }

/* type boolean */
optional_ghost : empty
                 {
                   $$ = FALSE;
                 }
                 | ghost
                 {
                   $$ = TRUE;
                 }


/* type pStmtDDL */
alter_table_action : add_table_constraint_definition
                                {
                                  switch ($1->getOperatorType())
                                  {
                                  case ELM_CONSTRAINT_CHECK_ELEM :
                                    $$ = new (PARSERHEAP())
				      StmtDDLAddConstraintCheck($1);
                                    break;
                                  case ELM_CONSTRAINT_PRIMARY_KEY_ELEM :
                                    // Assumes that this case is only
                                    // used when the user specifies the
                                    // ALTER TABLE <table-name> ADD
                                    // CONSTRAINT statement to create a
                                    // Primary Key constraint which will
                                    // always be droppable regardless of
                                    // the value in the PRIMARY_KEY_
                                    // CONSTRAINT_DROPPABLE_OPTION in the
                                    // DEFAULTS table.
                                    $$ = new (PARSERHEAP())
				      StmtDDLAddConstraintPK($1,
                                       TRUE /* isAlwaysDroppable */);
                                    break;
                                  case
                                    ELM_CONSTRAINT_REFERENTIAL_INTEGRITY_ELEM :
                                    $$ = new (PARSERHEAP())
				      StmtDDLAddConstraintRI($1);
                                    break;
                                  case ELM_CONSTRAINT_UNIQUE_ELEM :
                                    $$ = new (PARSERHEAP())
				      StmtDDLAddConstraintUnique($1);
                                    break;
                                  default :
                                    ABORT("internal logic error");
                                    break;
                                  }
                                }

                      | drop_table_constraint_definition


                      | file_attribute_clause
                                {
                                  $$ = new (PARSERHEAP())
				    StmtDDLAlterTableAttribute(
                                       $1 /*file_attribute_clause*/);
                                }

                      | alter_table_disable_index_clause
                                {
                                  $$ = $1;
                                }

                      | alter_table_enable_index_clause
                                {
                                  $$ = $1;
                                }

                      | alter_table_column_clause
                                {
                                  // *** Error *** COLUMN clause
                                  // in ALTER TABLE statement
                                  // not yet supported.
                                  *SqlParser_Diags << DgSqlCode(-3032);
                                  $$ = $1;
                                }
								
                      | alter_table_move_clause
                                {
                                  // *** Error *** MOVE clause
                                  // in ALTER TABLE statement
                                  // not yet supported.
                                  *SqlParser_Diags << DgSqlCode(-3033);
                                  $$ = new (PARSERHEAP())
				    StmtDDLAlterTableMove($1);
                                }

                      | partition_definition
                                {
                                  // *** Error *** PARTITION clause
                                  // in ALTER TABLE statement
                                  // not yet supported.
				  *SqlParser_Diags << DgSqlCode(-3034);
                                  $$ = new (PARSERHEAP())
				    StmtDDLAlterTablePartition($1);
                                }

                      | alter_table_rename_clause
                                {
                                  // *** ERROR[3035] message is now obsolete.
                                  // // *** Error *** RENAME clause
                                  // // in ALTER TABLE statement
                                  // // not yet supported.
				  // *SqlParser_Diags << DgSqlCode(-3035);
                                  $$ = $1;
                                }

                      | alter_table_set_constraint_clause
                                {
                                  // *** Error *** SET CONSTRAINT
                                  // clause in ALTER TABLE statement
                                  // not yet supported.
				  *SqlParser_Diags << DgSqlCode(-3036);
                                  $$ = $1;
                                }

		      | alter_table_disable_constraint_clause
				{
				  $$=$1;
				}

		      | alter_table_enable_constraint_clause
				{
				  $$ = $1;
				}

                      | alter_table_add_column_clause
                                {
                                  $$ = $1;
                                }

                     | alter_table_drop_column_clause
                                {
                                  $$ = $1;
                                }

		      | alter_table_alter_column_clause // for LOGGABLE
				{
				  $$ = $1;
				  
				}                               
		      | alter_table_alter_column_datatype
			{
      				$$ = $1;
			}
		      | alter_table_alter_column_rename
			{
      				$$ = $1;
			}
		      | alter_table_alter_column_default_value 
			{
      				$$ = $1;

			}
			
		      | alter_table_alter_column_set_sg_option 
			{
      				$$ = $1;

			}
                      | TOK_ALTER hbase_table_options
                        {
                                $$ = new (PARSERHEAP())
				  StmtDDLAlterTableHBaseOptions($2->castToElemDDLHbaseOptions());
                        }
			
                      | alter_stored_descriptor_option
                        {
                          $$ = new (PARSERHEAP()) StmtDDLAlterTableStoredDesc
                            ((StmtDDLAlterTableStoredDesc::AlterStoredDescType)$1);
                        }


/* type pStmtDDL */
alter_synonym_statement : TOK_ALTER TOK_SYNONYM ddl_qualified_name 
                          TOK_TO ddl_qualified_name
                               {
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterSynonym(
                                        *$3 /*ddl_qualified_name*/,
                                        *$5 /*ddl_qualified_name*/);
                                  delete $3 /*ddl_qualified_name*/;
                                  delete $5 /*ddl_qualified_name*/;
                               }
                               
/* type pStmtDDL */
drop_table_constraint_definition : TOK_DROP TOK_CONSTRAINT constraint_name
                                   optional_drop_index_behavior
                                {
                                  $$ = new (PARSERHEAP())
				    StmtDDLDropConstraint (
                                      *$3, /* constraint name */
                                       $4  /* optional drop behavior */);
                                  delete $3;
                               }

/* type pElemDDL */
add_table_constraint_definition : TOK_ADD table_constraint_definition
                                {
                                  $$ = $2 /*table_constraint_definition*/;
                                }

/* type pStmtDDL */
alter_table_column_clause : TOK_COLUMN identifier heading
                                {
                                  $$ = new (PARSERHEAP())
				    StmtDDLAlterTableColumn(
                                       *$2 /*identifier (column name)*/,
                                        $3 /*heading*/,
                                       PARSERHEAP());
                                  delete $2;
                                }

// type pStmtDDL
alter_table_alter_column_datatype : TOK_ALTER TOK_COLUMN column_definition
				{
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableAlterColumnDatatype(
                                         $3 /* column definition */);
                                  restoreInferCharsetState();
				}


// type pStmtDDL
alter_table_alter_column_default_value : TOK_ALTER TOK_COLUMN column_name TOK_DEFAULT enableCharsetInferenceInColDefaultVal alter_col_default_clause_arg
				{
				  $$ = new (PARSERHEAP())
				       StmtDDLAlterTableAlterColumnDefaultValue(
						*$3, // column name
						 $6 /*alter_col_default_clause_arg*/);
                		       delete $3;
			       	       restoreInferCharsetState();
				}

// type pStmtDDL
alter_table_alter_column_rename : TOK_ALTER TOK_COLUMN column_name TOK_RENAME TOK_TO column_name
				{
				  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableAlterColumnRename(
                                         *$3,  // column name
                                         *$6); // renamed column name
                                  delete $3;
                                  delete $6;
                                  restoreInferCharsetState();
				}
				
// type pStmtDDL
alter_table_alter_column_set_sg_option : TOK_ALTER TOK_COLUMN column_name TOK_SET sequence_generator_options
				{
				  ElemDDLSGOptions *sgOptions = new (PARSERHEAP()) ElemDDLSGOptions(
				     1, /* SG_INTERNAL */
				     $5 /*sequence_generator_option_list*/);
                                       
				  $$ = new (PARSERHEAP())
				    StmtDDLAlterTableAlterColumnSetSGOption(
				      *$3,        // column name
				      sgOptions  /* sequence generator options*/);
				      
				  delete $3;
				}
                             | TOK_ALTER TOK_COLUMN column_name reset_option
				{
				  ElemDDLSGOptions *sgOptions = new (PARSERHEAP()) ElemDDLSGOptions(
				     1, /* SG_INTERNAL */
				     $4 /*sequence_generator_option_list*/);
                                       
				  $$ = new (PARSERHEAP())
				    StmtDDLAlterTableAlterColumnSetSGOption(
				      *$3,        // column name
				      sgOptions  /* sequence generator options*/);
				      
				  delete $3;
				}
				
/* type pElemDDL */
alter_col_default_clause_arg : literal
                               {
                                  $$ = new (PARSERHEAP())
                                    ElemDDLColDefault(
                                       ElemDDLColDefault::COL_DEFAULT,
                                       $1 /*literal*/);
                               }

// type pStmtDDL
alter_table_alter_column_clause : TOK_ALTER TOK_COLUMN column_name alter_column_type
								{
									$$ = new (PARSERHEAP())
										StmtDDLAlterTableAlterColumnLoggable(	
										*$3, // column name
										$4 // loggable
										);
									delete $3;

								}
// type boolean
alter_column_type : TOK_LOGGABLE
					{
						$$ = TRUE;	
					}
					| TOK_NOT TOK_LOGGABLE
					{
						$$ = FALSE;	
					}


/* type pElemDDL */
alter_table_move_clause : TOK_MOVE source_location_list TOK_TO
                                dest_location_list
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLAlterTableMove(
                                       $2 /*source_location_list*/,
                                       $4 /*dest_location_list*/);
                                }

/* type pStmtDDL */
alter_table_set_constraint_clause : TOK_SET constraints_keyword
                                constraint_name_list constraint_setting
                                {
                                  $$ = new (PARSERHEAP())
				    StmtDDLAlterTableSetConstraint(
                                       $3 /*constraint_name_list*/,
                                       $4 /*constraint_setting*/);
                                }

/* type tokval */
constraints_keyword : TOK_CONSTRAINT
                      | TOK_CONSTRAINTS

/* type pElemDDL */
constraint_name_list : constraint_simple_name
                      | constraint_name_list ',' constraint_simple_name
                                {
                                  $$ = new (PARSERHEAP())
				    ElemDDLConstraintNameList(
                                       $1 /*constraint_name_list*/,
                                       $3 /*constraint_simple_name*/);
                                }

/* type pElemDDL */
constraint_simple_name : qualified_name
                                {
				  if ($1->numParts() >
				      ShortStringSequence::MAX_SIMPLENAME_PARTS)
				    {
				      // ~String0 is an invalid simple name 
                                      *SqlParser_Diags << DgSqlCode(-3027) 
 				        << DgWString0(badNameFromStrings($1));
                                      delete $1;
				      YYABORT;
				    }
				  else
				    {
				      //
				      // note that qualifiedNameFromStrings()
				      // contains code that deletes $1
				      //
				      QualifiedName *qualName =
					qualifiedNameFromStrings($1);
				      if (qualName == NULL) YYABORT;
				      $$ = new (PARSERHEAP())
					     ElemDDLConstraintName(*qualName,
                                                                   PARSERHEAP());
				    }
                                }

/* type boolean */
constraint_setting : TOK_OFF
                                {
                                  $$ = FALSE;
                                }

                      | TOK_ON
                                {
                                  $$ = TRUE;
                                }

/* type pElemDDL */
source_location_list : location_list

/* type pElemDDL */
dest_location_list : location_list

/* type pElemDDL */
location_list : location_definition

/* type pStmtDDL */
alter_table_disable_index_clause : TOK_DISABLE TOK_ALL TOK_INDEXES
                                {
                                  NAString *tmp = new 
                                     (PARSERHEAP()) NAString((""),PARSERHEAP());
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableDisableIndex(*tmp, 
                                                                  TRUE, FALSE);
                                  delete tmp;
                                }
                                |
                                TOK_DISABLE TOK_ALL TOK_UNIQUE TOK_INDEXES
                                {
                                  NAString *tmp = new 
                                     (PARSERHEAP()) NAString((""),PARSERHEAP());
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableDisableIndex(*tmp, FALSE,
                                                                  TRUE);
                                  delete tmp;
                                }
                                |
                                TOK_DISABLE TOK_ALL TOK_INDEX
                                {
                                  NAString *tmp = new
                                     (PARSERHEAP()) NAString((""),PARSERHEAP());
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableDisableIndex(*tmp, TRUE, 
                                                                  FALSE);
                                  delete tmp;
                                }
                                |
                                TOK_DISABLE TOK_INDEX index_name 
                                {
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableDisableIndex
                                    ( *$3, FALSE, FALSE);
                                  delete $3;
                                }

alter_table_enable_index_clause : TOK_ENABLE TOK_ALL TOK_INDEXES
                                {
                                  NAString *tmp = new 
                                     (PARSERHEAP()) NAString((""),PARSERHEAP());
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableEnableIndex(*tmp, TRUE, 
                                                                 FALSE);
                                  delete tmp;
                                }
                                |
                                TOK_ENABLE TOK_ALL TOK_UNIQUE TOK_INDEXES
                                {
                                  NAString *tmp = new 
                                     (PARSERHEAP()) NAString((""),PARSERHEAP());
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableEnableIndex(*tmp, FALSE,
                                                                 TRUE);
                                  delete tmp;
                                }
                                |
                                TOK_ENABLE TOK_ALL TOK_INDEX
                                {
                                  NAString *tmp = new
                                     (PARSERHEAP()) NAString((""),PARSERHEAP());
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableEnableIndex(*tmp, TRUE, 
                                                                 FALSE);
                                  delete tmp;
                                }
                                |
                                TOK_ENABLE TOK_INDEX index_name 
                                {
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableEnableIndex
                                    ( *$3, FALSE, FALSE);
                                  delete $3;
                                }

alter_table_rename_clause : TOK_RENAME TOK_TO identifier optional_cascade optional_skip_view_check
                                {
                                  $$ = new (PARSERHEAP())
				    StmtDDLAlterTableRename
                                      ( *$3 // identifier (new name)
                                      ,  $4 // optional_cascade
                                      ,  $5 // optional_skip_view_check
                                      );
                                  delete $3; // identifier
                                }

/* type pStmtDDL */
alter_table_disable_constraint_clause : TOK_DISABLE TOK_ALL TOK_CONSTRAINTS
                                {
                                  YYERROR; // not yet supported.

                                  NAString *tmp = new 
                                     (PARSERHEAP()) NAString((""),PARSERHEAP());
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableToggleConstraint(*tmp, TRUE, TRUE, FALSE);
                                  delete tmp;
                                }
                                |
                                TOK_DISABLE TOK_CONSTRAINT constraint_name
                                {
                                  YYERROR; // not yet supported

                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableToggleConstraint( *$3, FALSE, TRUE, FALSE);
                                  delete $3;
                                }

/* type pStmtDDL */
alter_table_enable_constraint_clause : TOK_ENABLE TOK_ALL TOK_CONSTRAINTS optional_validate_clause
                                {
                                  YYERROR; // not yet supported.

                                  NAString *tmp = new 
                                     (PARSERHEAP()) NAString((""),PARSERHEAP());
                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableToggleConstraint(*tmp, TRUE, FALSE, $4);
                                  delete tmp;
                                }
                                |
                                TOK_ENABLE TOK_CONSTRAINT constraint_name optional_validate_clause
                                {
                                  YYERROR; // not yet supported

                                  $$ = new (PARSERHEAP())
                                    StmtDDLAlterTableToggleConstraint( *$3, FALSE, FALSE, $4);
                                  delete $3;
                                }

optional_validate_clause : empty
                     { $$ = TRUE; }
                   | TOK_VALIDATE
                     { $$ = TRUE; }
                   | TOK_NO TOK_VALIDATE
                     { $$ = FALSE; }

/* type pStmtDDL */
alter_table_add_column_clause : TOK_ADD optional_col_keyword 
                                  column_definition
                                  {
                                   StmtDDLAlterTableAddColumn *pNode = 
                                     new (PARSERHEAP())
                                     StmtDDLAlterTableAddColumn( 
                                      $3 /* column_definition */);
                                   $$ = pNode;
                                }
alter_table_add_column_clause : TOK_ADD TOK_IF TOK_NOT TOK_EXISTS optional_col_keyword
                                  column_definition
                                  {
                                   StmtDDLAlterTableAddColumn *pNode = 
                                     new (PARSERHEAP())
                                     StmtDDLAlterTableAddColumn( 
                                      $6 /* column_definition */);
				   pNode->setAddIfNotExists(TRUE);
                                   $$ = pNode;
                                }

/* type tokval */
optional_col_keyword : empty
                     | TOK_COLUMN

/* type pStmtDDL */
alter_table_drop_column_clause : TOK_DROP optional_col_keyword
                                  column_name
                                  {
                                   StmtDDLAlterTableDropColumn *pNode = 
                                     new (PARSERHEAP())
                                     StmtDDLAlterTableDropColumn( 
                                      *$3 /* column_name */);
                                   $$ = pNode;
                                  }

alter_table_drop_column_clause : TOK_DROP optional_col_keyword TOK_IF TOK_EXISTS column_name
                                  {
                                   StmtDDLAlterTableDropColumn *pNode = 
                                     new (PARSERHEAP())
                                     StmtDDLAlterTableDropColumn( 
                                      *$5 /* column_name */);
				   pNode->setDropIfExists(TRUE);
                                   $$ = pNode;
                                  }

/* type uint */
alter_stored_descriptor_option : TOK_GENERATE TOK_STORED TOK_DESCRIPTOR
              {
                $$ = (Int32)StmtDDLAlterTableStoredDesc::GENERATE;
              }
              | TOK_CHECK TOK_STORED TOK_DESCRIPTOR
              {
                $$ = (Int32)StmtDDLAlterTableStoredDesc::CHECK;
              }
              | TOK_DELETE TOK_STORED TOK_DESCRIPTOR
              {
                $$ = (Int32)StmtDDLAlterTableStoredDesc::DELETE;
              }
              | TOK_ENABLE TOK_STORED TOK_DESCRIPTOR
              {
                $$ = (Int32)StmtDDLAlterTableStoredDesc::ENABLE;
              }
              | TOK_DISABLE TOK_STORED TOK_DESCRIPTOR
              {
                $$ = (Int32)StmtDDLAlterTableStoredDesc::DISABLE;
              }


/* type pStmtDDL */

drop_sql : TOK_DROP TOK_SQL extension_drop_behavior
                               {
                                  $$ = new (PARSERHEAP()) StmtDDLDropSQL($3);
                               }
/* type pStmtDDL */

drop_module : TOK_DROP TOK_MODULE module_name
                              {
                                  QualifiedName *modName = qualifiedNameFromStrings($3);
				  // note that qualifiedNameFromStrings()
				  // contains code that deletes $3
	                          if (!modName) YYERROR;
                                  $$ = new (PARSERHEAP()) StmtDDLDropModule(*modName);
                              }



/* type pStmtDDL */
drop_synonym_stmt : TOK_DROP TOK_SYNONYM ddl_qualified_name
                               {
                                  $$ = new (PARSERHEAP())
                                    StmtDDLDropSynonym(
                                        *$3 /*ddl_qualified_name*/);
                                  delete $3 /*ddl_qualified_name*/;
                               }
                               
/* type pStmtDDL */
drop_exception_stmt : TOK_DROP TOK_EXCEPTION TOK_TABLE ddl_qualified_name TOK_ON
                               ddl_qualified_name optional_cleanup
                               optional_drop_behavior optional_logfile
                               {
                                 /* If LOG option specified, */
                                 /* Either ALLOW_SPECIALTABLETYPE or CQD IS_DB_TRANSPORTER */
                                 /* must also be specified  */
                                 if ($9)
                                 {
                                     CHECK_DBTRANSPORTER ;
                                 }
                                 NAString *pLogFile = NULL;
                                 if ($9)
                                    pLogFile =new (PARSERHEAP()) NAString
                                                   ( $9->data(), PARSERHEAP());

                                 $$ = new (PARSERHEAP())
                                 StmtDDLDropExceptionTable(
                                       *$4 /*ddl_qualified_name*/,
                                       *$6 /*ddl_qualified_name*/,
                                        $8   /*optional_drop_behavior*/,
                                        $7 /*for CLEANUP mode set to TRUE*/,
                                         pLogFile  /*log_file_name*/                                  
                                 );
                                 delete $4 /*ddl_qualified_name*/;
                                 delete $6 /*ddl_qualified_name*/;
                                 delete $9 /*log_file_name*/;
                               }    
                               
/* type pStmtDDL */                             
drop_all_exception_stmt : TOK_DROP TOK_ALL TOK_EXCEPTION TOK_TABLES TOK_ON
                               ddl_qualified_name optional_cleanup
                               optional_drop_behavior optional_logfile
                               {
                                 /* If LOG option specified, */
                                 /* Either ALLOW_SPECIALTABLETYPE or CQD IS_DB_TRANSPORTER */
                                 /* must also be specified  */
                                 if ($9)
                                 {
                                     CHECK_DBTRANSPORTER ;
                                 }
                                 NAString *pLogFile = NULL;
                                 if ($9)
                                    pLogFile =new (PARSERHEAP()) NAString
                                                   ( $9->data(), PARSERHEAP());

                                 $$ = new (PARSERHEAP())
                                 StmtDDLDropExceptionTable(
                                       *$6 /*ddl_qualified_name*/,
                                        $8 /*optional_drop_behavior*/,
                                        $7 /*for CLEANUP mode set to TRUE*/,
                                         pLogFile  /*log_file_name*/                                  
                                 );
                                 delete $6 /*ddl_qualified_name*/;
                                 delete $9 /*log_file_name*/;
                               }                                                                                             
                                                                                        
/* type pStmtDDL */
drop_table_statement : TOK_DROP special_table_name optional_drop_behavior
               {
                 StmtDDLDropTable *pNode =
                   new (PARSERHEAP())
                     StmtDDLDropTable(
                                      $2->getQualifiedNameObj() /*table_name*/,
                                      $3 /*optional_drop_behavior*/ );
                 pNode->setTableType($2->getSpecialType());
                 $$ = pNode;
                 delete $2 /*table_name*/;
               }

               | drop_table_start_tokens  ddl_qualified_name optional_cleanup
                 optional_drop_invalidate_dependent_behavior 
               {
                   $$ = new (PARSERHEAP())
                   StmtDDLDropTable(
                                    *$2  /*ddl_qualified_name*/,
                                    $4   /*optional_drop_invalidate_dependent_behavior*/,
                                    $3   /*for CLEANUP mode set to TRUE*/,
                                    FALSE, /* validate option - to be obsoleted*/
                                    NULL  /*log_file_name - to be obsoleted*/);
                   // $1: 0 - regular table, 1 - ghost table, 2 - regular table IF EXISTS,
                   //     3 - external table, 4 - external table IF EXISTS
                   if ($1 == 1)  /*ghost*/
                   {
                     $$->setIsGhostObject(TRUE);
                     $$->castToStmtDDLDropTable()->setTableType(ExtendedQualName::GHOST_TABLE);
                   }

                  if ($1 == 3 || $1 == 4)
                     $$->castToStmtDDLDropTable()->setIsExternal(TRUE);

                  if ($1 == 5 || $1 == 6)
                     $$->castToStmtDDLDropTable()->setIsExternal(TRUE);

                   if ($1 == 2 || $1 == 4 || $1 == 6)
                     {
                       $$->castToStmtDDLDropTable()->setDropIfExists(TRUE);
                     }

                   delete $2 /*ddl_qualified_name*/;

                 }
                  | TOK_DROP TOK_VOLATILE TOK_TABLE volatile_ddl_qualified_name
                                optional_cleanup optional_drop_behavior
				{
				  StmtDDLDropTable *pNode = 
				    new (PARSERHEAP())
				    StmtDDLDropTable(
					 *$4 /*ddl_qualified_name*/,
					 $6 /*optional_drop_behavior*/,
					 $5 /*optional cleanup*/,
					 FALSE, NULL);
				  pNode->setIsVolatile(TRUE);
				  pNode->setProcessAsExeUtil(TRUE);
				  pNode->synthesize();
				  delete $4 /*ddl_qualified_name*/;
				  $$ = pNode;
				}

                  | TOK_DROP TOK_LOCAL TOK_TEMPORARY TOK_TABLE volatile_ddl_qualified_name
                                optional_cleanup optional_drop_behavior
				{
				  StmtDDLDropTable *pNode = 
				    new (PARSERHEAP())
				    StmtDDLDropTable(
					 *$5 /*ddl_qualified_name*/,
					 $7 /*optional_drop_behavior*/,
					 $6 /*optional cleanup*/,
					 FALSE, NULL);
				  pNode->setIsVolatile(TRUE);
				  pNode->setProcessAsExeUtil(TRUE);
				  pNode->synthesize();
				  delete $5 /*ddl_qualified_name*/;
				  $$ = pNode;
				}
               | TOK_DROP TOK_HBASE TOK_TABLE identifier
                 {
		   QualifiedName qn(*$4);

		   StmtDDLDropHbaseTable *pNode =
		     new (PARSERHEAP())
		     StmtDDLDropHbaseTable(
					   qn /*ddl_qualified_name*/);
		   
		   $$ = pNode;
		 }
               | drop_table_start_tokens identifier TOK_FOR ddl_qualified_name
                 optional_cleanup optional_drop_behavior
                 {
                   // TBD: currently the syntax ignores identifier.  The drop
                   // code assumes the identifier is the same as the third part
                   // of the ddl_qualified_name. We may allow them to be 
                   // different in the future.  
                   $$ = new (PARSERHEAP())
                   StmtDDLDropTable(
                                    *$4  /*ddl_qualified_name*/,
                                    $6   /*optional_drop_invalidate_dependent_behavior*/,
                                    $5   /*for CLEANUP mode set to TRUE*/,
                                    FALSE, /* validate option - to be obsoleted*/
                                    NULL  /*log_file_name - to be obsoleted*/);
                   // $1: 0 - regular table, 1 - ghost table, 2 - regular table IF EXISTS,
                   //     3 - external table, 4 - external table IF EXISTS
                   if ($1 == 3 || $1 == 4)
                     $$->setIsExternal(TRUE);
                   if ($1 == 4)
                     $$->castToStmtDDLDropTable()->setDropIfExists(TRUE);
                      
                   delete $2 /*identifier*/;
                   delete $4 /*ddl_qualified_name*/;
                 }


// It took some care to avoid introducing a shift/reduce conflict for DROP GHOST TABLE.
// See the shift/reduce case study near the beginning of this file.

/* type uint */
drop_table_start_tokens : TOK_DROP TOK_TABLE
                   {
                     $$ = 0;

                     SqlParser_CurrentParser->hiveDDLInfo_->
                       setValues(TRUE, StmtDDLonHiveObjects::DROP_, StmtDDLonHiveObjects::TABLE_);
                   }
                  | TOK_DROP ghost TOK_TABLE
                   {
                     $$ = 1;
                   }
                  | TOK_DROP TOK_TABLE TOK_IF TOK_EXISTS
                   {
                     $$ = 2;

                     SqlParser_CurrentParser->hiveDDLInfo_->
                       setValues(TRUE, StmtDDLonHiveObjects::DROP_, StmtDDLonHiveObjects::TABLE_, TRUE);
                   }
                  | TOK_DROP TOK_EXTERNAL TOK_TABLE 
                   {
                     $$ = 3;
                   }
                  | TOK_DROP TOK_EXTERNAL TOK_TABLE TOK_IF TOK_EXISTS
                  {
                    SqlParser_CurrentParser->hiveDDLInfo_->ifExistsOrNotExists_ = TRUE;
                     $$ = 4;
                   }

/* type pStmtDDL */
// MV - RG
drop_mvrgroup_statement : TOK_DROP TOK_MVGROUP ddl_qualified_name
{
  *SqlParser_Diags << DgSqlCode(-3131);
  YYERROR;

  $$ = new (PARSERHEAP())StmtDDLDropMvRGroup(*$3);
  delete $3;
}

/* type pStmtDDL */
drop_trigger_statement : TOK_DROP TOK_TRIGGER ddl_qualified_name 
                         optional_cleanup optional_validate optional_logfile
                {
                  *SqlParser_Diags << DgSqlCode(-3131);
                  YYERROR;

                  /* If VALIDATE, or LOG option specified, */
                  /* ALLOW_SPECIALTABLETYPE must also be specified  */
                  if (($5 || $6) &&
                     !Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                  {
                    yyerror(""); YYERROR; /*internal syntax only!*/
                  }
                  else
                  {
                    NAString *pLogFile = NULL;
                    if ($6)
                      pLogFile =new (PARSERHEAP()) NAString
                        ( $6->data(), PARSERHEAP());
                    $$ = new (PARSERHEAP())
                      StmtDDLDropTrigger(
                                         *$3  /*ddl_qualified_name*/,
                                          $4 /*for CLEANUP mode set to TRUE*/,
                                          $5 /*for VALIDATE mode set to FALSE*/,
                                          pLogFile  /*log_file_name*/);
                    delete $3 /*ddl_qualified_name*/;
                    delete $6 /*log_file_name*/;
                   }
                 }

/* type pStmtDDL */
drop_mv_statement : TOK_DROP optional_ghost mv_token ddl_qualified_name optional_cleanup
                    optional_drop_behavior optional_validate optional_logfile
                {
                  *SqlParser_Diags << DgSqlCode(-3131);
                  YYERROR;

                  /* If VALIDATE, or LOG option specified, */
                  /* ALLOW_SPECIALTABLETYPE must also be specified  */
                  if (($7 || $8) &&
                     !Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                  {
                     yyerror(""); YYERROR; /*internal syntax only!*/
                  }
                  else
                  {
                    NAString *pLogFile = NULL;
                    if ($8)
                      pLogFile =new (PARSERHEAP()) NAString
                        ( $8->data(), PARSERHEAP());

                    $$ = new (PARSERHEAP())
		    StmtDDLDropMV(
                                  *$4  /*ddl_qualified_name*/,
                                   $6   /*optional_drop_behavior*/,
                                   $5 /*for CLEANUP mode set to TRUE*/,
                                   $7 /*for VALIDATE mode set to FALSE*/,
                                   pLogFile  /*log_file_name*/);
                    if ($2) /*optional_ghost*/
                      $$->setIsGhostObject(TRUE);
                    delete $4 /*ddl_qualified_name*/;
                    delete $8 /*log_file_name*/;
                  }
                }

/* type pStmtDDL */
drop_index_statement : TOK_DROP optional_ghost TOK_INDEX ddl_qualified_name optional_cleanup
                       optional_drop_index_behavior optional_validate optional_logfile
               {
                 /* If VALIDATE, or LOG option specified, */
                 /* ALLOW_SPECIALTABLETYPE must also be specified  */
                 if (($7 || $8) &&
                    !Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                 {
                   yyerror(""); YYERROR; /*internal syntax only!*/
                 }
                 else
                 {
                   NAString *pLogFile = NULL;
                   if ($8)
                     pLogFile = new (PARSERHEAP()) NAString
                       ( $8->data(), PARSERHEAP());
                   $$ = new (PARSERHEAP())
		   StmtDDLDropIndex(
                                    *$4  /*ddl_qualified_name*/,
                                    $6   /*optional_drop_behavior*/,
                                    $5 /*for CLEANUP mode set to TRUE*/,
                                    $7 /*for VALIDATE mode set to FALSE*/,
                                    pLogFile  /*log_file_name*/);
                   if ($2) /*optional_ghost*/
                     $$->setIsGhostObject(TRUE);
                   delete $4 /*ddl_qualified_name*/;
                   delete $8 /*log_file_name*/;
                 }
               }

/* type routineTypeEnum */
drop_routine_type_tokens : TOK_FUNCTION { $$ = COM_UNKNOWN_ROUTINE_TYPE; }
                         | TOK_SCALAR TOK_FUNCTION { $$ = COM_SCALAR_UDF_TYPE; }
                         | table_mapping_function_tokens
                         | universal_function_tokens
                         | TOK_PROCEDURE { $$ = COM_PROCEDURE_TYPE; }

/* type pStmtDDL */
drop_routine_statement : TOK_DROP drop_routine_type_tokens optional_if_exists_clause
                         ddl_qualified_name
                         optional_cleanup  optional_drop_behavior
                         optional_validate optional_logfile
                {
                  $$ = SqlParserAux_buildDropRoutine
                    ( $2  // in - ComRoutineType drop_routine_type_tokens
                    , $4  // in - QualifiedName * ddl_qualified_name of routine - deep copy
                    , $5  // in - NABoolean       optional_cleanup
                    , $6  // in - ComDropBehavior optional_drop_behavior
                    , $7  // in - NABoolean       optional_validate
                    , $8  // in - NAString      * optional_logfile              - deep copy
                    , $3  // in - NABoolean       optional_if_exists_clause
                    );
                  delete $4; // ddl_qualified_name of routine
                  if ($8) delete $8; // optional_logfile
                  if ($$ EQU NULL) { yyerror(""); YYERROR; } // Error: internal syntax only!
                }

/* type pStmtDDL */
drop_view_statement : TOK_DROP TOK_VIEW optional_if_exists_clause 
                        {
                          SqlParser_CurrentParser->hiveDDLInfo_->
                            setValues(TRUE, StmtDDLonHiveObjects::DROP_, StmtDDLonHiveObjects::VIEW_, $3);
                        }
                      ddl_qualified_name optional_cleanup
                      optional_drop_invalidate_dependent_behavior optional_validate optional_logfile
                {
                  /* If VALIDATE, or LOG option specified, */
                  /* ALLOW_SPECIALTABLETYPE must also be specified  */
                  if (($8 || $9) &&
                     !Get_SqlParser_Flags(ALLOW_SPECIALTABLETYPE))
                  {
                    yyerror(""); YYERROR; /*internal syntax only!*/
                  }
                  else
                  {
                    NAString *pLogFile = NULL;
                    if ($9)
                      pLogFile = new (PARSERHEAP()) NAString
                        ( $9->data(), PARSERHEAP());
                    StmtDDLDropView * dropView = new (PARSERHEAP())
                      StmtDDLDropView(
                                    *$5  /*ddl_qualified_name*/,
                                    $7   /*optional_drop_invalidate_dependent_behavior*/,
                                    $6 /*for CLEANUP mode set to TRUE*/,
                                    $8 /*for VALIDATE mode set to FALSE*/,
                                    pLogFile  /*log_file_name*/);

                    if ($3)
                      {
                        dropView->setDropIfExists(TRUE);
                      }

                    delete $5 /*ddl_qualified_name*/;
                    delete $9 /*log_file_name*/;
                    $$ = dropView;
                  }
                }

drop_index_statement : TOK_DROP TOK_VOLATILE TOK_INDEX volatile_ddl_qualified_name
		       optional_drop_behavior
                               {
				  StmtDDLDropIndex *pNode = new (PARSERHEAP())
				    StmtDDLDropIndex(
                                        *$4, /*ddl_qualified_name*/
					 $5  /* optional drop behavior */);
				  pNode->setIsVolatile(TRUE);
				  pNode->synthesize();
				  //pNode->setProcessAsExeUtil(TRUE);

				  $$ = pNode;
                                  delete $4 /*ddl_qualified_name*/;
                                }


/* type pStmtDDL */				
revoke_schema_statement: TOK_REVOKE optional_grant_option_for privileges
				TOK_ON TOK_SCHEMA schema_name TOK_FROM
				grantee_list optional_drop_behavior
                                optional_granted_by
			  {		
				  $$ = new (PARSERHEAP())
				    StmtDDLSchRevoke(
					  $2 /*optional_grant_option_for*/,
					  $3 /*schema_privileges*/,
					 *$6 /*schema_name*/,
					  $8 /*grantee_list*/,
					  $9 /*optional_drop_behavior*/,
                                          $10 /*optional_granted_by*/);
				  delete $6  /*schema_name*/;				    
			  }	                                

/* type pStmtDDL */
revoke_component_privilege_stmt : TOK_REVOKE optional_grant_option_for TOK_COMPONENT privilege_or_privileges_token
                                             component_privilege_name_list TOK_ON component_name
                                             TOK_FROM authorization_identifier_or_public
                                             optional_drop_behavior optional_granted_by
                                {
                                  // revoke_component_privilege_stmt ::=
                                  //   TOK_REVOKE optional_grant_option_for TOK_COMPONENT privilege_or_privileges_token
                                  //              component_privilege_name_list TOK_ON component_name
                                  //              TOK_FROM authorization_identifier
                                  $$ = new(PARSERHEAP())
                                    StmtDDLRevokeComponentPrivilege
                                    ( $5  // component_privilege_name_list - shallow copy
                                    , *$7 // component_name - deep copy
                                    , *$9 // authorization_identifier - a.k.a. user_role_name - deep copy
                                    , $2  // optional_grant_option_for - NABoolean
                                    , $11 // optional granted by
                                    , PARSERHEAP()
                                    );
                                  // cannot delete $5 - component_privilege_name_list - shallow copy
                                  delete $7; // component_name
                                  delete $9; // authorization_identifier - a.k.a. user_role_name
                                }

/* type pStmtDDL */
revoke_statement : TOK_REVOKE optional_grant_option_for privileges
                                TOK_ON ddl_object_name optional_action TOK_FROM
                                grantee_list optional_drop_behavior
                                optional_granted_by
                                {
                                  $$ = new (PARSERHEAP())
				    StmtDDLRevoke(
                                         $2 /*optional_grant_option_for*/,
					 $3 /*privileges*/,
                                        *$5 /*ddl_object_name*/,
                                         $8 /*grantee_list*/,
                                         $9 /*optional_drop_behavior*/,
                                         $10 /*optional_granted_by*/,
                                         $6 /*optional_action*/);
                                  delete $5 /*ddl_object_name*/;
                                }                
/* type boolean */
optional_grant_option_for : empty
                                {
                                  $$ = FALSE;
                                }

                      | grant_option_for

/* type boolean */
grant_option_for : TOK_GRANT TOK_OPTION TOK_FOR
                                {
                                  $$ = TRUE;
                                }


/* type pStmtDDL */
drop_catalog_statement : TOK_DROP TOK_CATALOG catalog_name extension_drop_behavior
                                {
				  $$ = new (PARSERHEAP())
				    StmtDDLDropCatalog(
					*$3 /*identifier (catalog name)*/,
                     $4 /*extension_drop_behavior*/);
				  delete $3 /*identifier*/;
                                }

/*ALTER USER*/
alter_user_statement :  TOK_ALTER TOK_USER authorization_identifier 
                        TOK_SET TOK_EXTERNAL TOK_NAME external_user_identifier
                                {
                                  $$ = new (PARSERHEAP())
                                  StmtDDLAlterUser(
                                        *$3 /*databaseUsername*/, 
                                        StmtDDLAlterUser::SET_EXTERNAL_NAME,
                                        $7 /*externalUsername*/,
                                        TRUE /*isValidUser*/,
                                        PARSERHEAP()); 
                                  delete $3;
                                }
			  |
                          
                        TOK_ALTER TOK_USER authorization_identifier 
                        TOK_SET TOK_ONLINE
                                {
                                  $$ = new (PARSERHEAP())
                                  StmtDDLAlterUser(
                                        *$3 /*databaseUsername*/, 
                                        StmtDDLAlterUser::SET_IS_VALID_USER,
                                        NULL /*externalUsername*/,
                                        TRUE /*isValidUser*/,
                                        PARSERHEAP()); 
                                  delete $3;
                                }
			  |
                          
                        TOK_ALTER TOK_USER authorization_identifier 
                        TOK_SET TOK_OFFLINE
                                {
                                  $$ = new (PARSERHEAP())
                                  StmtDDLAlterUser(
                                        *$3 /*databaseUsername*/, 
                                        StmtDDLAlterUser::SET_IS_VALID_USER,
                                        NULL /*NOT USED: externalUsername*/,
                                        FALSE /*isValidUser*/,
                                        PARSERHEAP()); 
                                  delete $3;
                                }

/* type pStmtDDL */
register_component_statement : TOK_REGISTER TOK_COMPONENT component_name optional_system optional_component_detail_clause
                                {
                                  // register_component_statement ::= TOK_REGISTER TOK_COMPONENT component_name
                                  //                                               optional_component_detail_clause
                                  $$ = new (PARSERHEAP())
                                    StmtDDLRegisterComponent
                                    ( StmtDDLRegisterComponent::REGISTER_COMPONENT
                                    , *$3  // component_name - deep copy
                                    , $4   // optional_system
                                    , *$5  // optional_component_detail_clause - deep copy
                                    , PARSERHEAP()
                                    );
                                  delete $3; // component_name
                                  delete $5; // optional_component_detail_clause
                                }
/* type stringval */
optional_component_detail_clause : empty
                                {
                                  // optional_register_component_detail_clause ::= empty
                                  $$ = new(PARSERHEAP()) NAString(PARSERHEAP()); // an empty string
                                }
                   | TOK_DETAIL component_str_lit
                                {
                                  // optional_register_component_detail_clause ::= TOK_DETAIL std_char_string_literal
                                  if ($2/*component_str_lit*/->length() > ComMAX_COMPONENT_DETAIL_STRING_LEN_IN_BYTES)
                                  {
                                    // $0~string0 is too long (longer than $1~int1 $2~string1).
                                    // Component detail text is too long (longer than 80 bytes).
                                    *SqlParser_Diags << DgSqlCode(-3301)
                                                     << /*subst0*/ DgString0("Component detail text")
                                                     << /*subst1*/ DgInt0(ComMAX_COMPONENT_DETAIL_STRING_LEN_IN_BYTES)
                                                     << /*subst2*/ DgString1("bytes");
                                    YYERROR;
                                  }
                                  $$ = $2; // component_str_lit
                                }
/* type stringval */
component_str_lit : std_char_string_literal
                                {
                                  // component_str_lit ::= std_char_string_literal
                                  NAString *pCStr = NULL;
                                  if (getStringCharSet(&$1) == CharInfo::ISO88591)
                                  {
                                    pCStr = new(PARSERHEAP()) NAString(*$1, PARSERHEAP()); // std_char_string_literal - deep copy
                                  }
                                  else
                                  {
                                    pCStr = charToChar ( (Lng32)CharInfo::ISO88591    // targetCS
                                                       , $1->data()                   // const char *s - std_char_string_literal
                                                       , $1->length()                 // Int32 sLenInBytes
                                                       , (Lng32)getStringCharSet(&$1) // sourceCS
                                                       , PARSERHEAP()                 // heap for allocated target string
                                                       );
                                    if (pCStr == NULL) // conversion failed
                                    {
                                      YYERROR;
                                    }
                                  }
                                  if (NOT NAStringHasOnly7BitAsciiChars(*pCStr))
                                  {
                                    YYERROR;
                                  }
                                  // No length limit checking here please
                                  NAStringUpshiftASCII(*pCStr);
                                  $$ = pCStr;
                                  delete $1; // std_char_string_literal
                                }
/* type pStmtDDL */
/*REGISTER USER*/
register_user_statement : TOK_REGISTER TOK_USER external_user_identifier
                             optional_as_auth_clause optional_schema_clause
                                {
                                  $$ = new (PARSERHEAP())
                                  StmtDDLRegisterUser(
                                        *$3 /*external_user*/, 
                                        $4 /*auth_id*/,
                                        $5 /*schema clause*/,
                                        PARSERHEAP()); 
                                  delete $3;
                                }

/* type pElemDDL */
optional_schema_clause : empty
                         {
                           $$ = NULL;
                         }
                         /*TODO: Increases shift/reduce conflicts
                         | schema_class TOK_SCHEMA schema_name
                         {
	     	           $$ = new (PARSERHEAP()) ElemDDLAuthSchema(*$3, $1, PARSERHEAP());
                             if ($3 != NULL)
                                delete $3;
                         }
                         */
                         | schema_class TOK_SCHEMA 
                         {
	     	           $$ = new (PARSERHEAP()) ElemDDLAuthSchema($1, PARSERHEAP());
                         }
                     
/* type pStmtDDL */
unregister_component_statement : TOK_UNREGISTER TOK_COMPONENT component_name optional_drop_behavior
                                {
                                  // unregister_component_statement ::= TOK_UNREGISTER TOK_COMPONENT component_name
                                  $$ = new (PARSERHEAP())
                                    StmtDDLRegisterComponent
                                    ( StmtDDLRegisterComponent::UNREGISTER_COMPONENT
                                    , *$3 // component_name - deep copy
                                    , $4  // drop behavior
                                    , PARSERHEAP()
                                    );
                                  delete $3; // component_name
                                }
/* type pStmtDDL */
/*UNREGISTER USER*/
unregister_user_statement : TOK_UNREGISTER TOK_USER external_user_identifier
                             optional_drop_behavior
                                {
                                  $$ = new (PARSERHEAP())
                                  StmtDDLRegisterUser(
                                        *$3 /*auth_id*/,
                                        $4 /*drop_behavior*/,
                                        PARSERHEAP());
                                  delete $3;
                                }

/* type stringval */
as_auth_clause : TOK_AS authorization_identifier
                     {
                        $$ = $2;
                     }

/* type stringval */
optional_as_auth_clause : empty
                     {
                        $$ = NULL;
                     }
                     | as_auth_clause

// type stringval - a guardian style system name having the form: "\FIGARO".
nsk_node_name: BACKSLASH_SYSTEM_NAME 
               {
                NAString *nodeName = new (PARSERHEAP())
                                          NAString(($1)->data(), PARSERHEAP() );
                if ((nodeName->index("\\", 0, NAString::ignoreCase)) != 0 ||
                    nodeName->length() > 8 || nodeName->length() < 2 )
                {
                  *SqlParser_Diags << DgSqlCode(-3127)
                                   << DgString0(nodeName->data());
                  YYERROR;
                }
                $$ = nodeName;
                delete $1;
               }

/* type pStmtDDL */
// Syntax: 
// register [internal] hive {table|view|schema} 
//          [if not exists] <obj-name> [cascade]
//
register_hive_statement : TOK_REGISTER optional_internal_clause TOK_HIVE object_identifier optional_if_not_registered_clause ddl_qualified_name optional_cascade
                          {
                            if (NOT ((*$4 == "TABLE") ||
                                     (*$4 == "VIEW") ||
                                     (*$4 == "SCHEMA")))
                              {
                                YYERROR;
                              }
      
                            if ($7 && (*$4 != "VIEW"))
                              {
                                YYERROR;
                              }

                            $$ = new (PARSERHEAP())
                              StmtDDLRegOrUnregObject(
                                   *$6,
                                   StmtDDLRegOrUnregObject::HIVE,
                                   TRUE, // register
                                   (*$4 == "TABLE" ? COM_BASE_TABLE_OBJECT
                                    : (*$4 == "VIEW" ? COM_VIEW_OBJECT
                                       : COM_SHARED_SCHEMA_OBJECT)),
                                   $5, // if not exists?
                                   $2, // is internal registration?
                                   $7, // is cascade?
                                   FALSE,
                                   PARSERHEAP());
                            delete $6;
                          }

// Syntax: 
// unregister [internal] hive {table|view|schema} 
//            [if exists] <obj-name> [cascade]
//
unregister_hive_statement : TOK_UNREGISTER optional_internal_clause TOK_HIVE object_identifier optional_if_registered_clause ddl_qualified_name optional_cascade optional_cleanup
                              {
                                if (NOT ((*$4 == "TABLE") ||
                                         (*$4 == "VIEW") ||
                                         (*$4 == "SCHEMA")))
                                  {
                                    YYERROR;
                                  }
                                
                                if ($7 &&
                                    (*$4 != "VIEW"))
                                  {
                                    YYERROR;
                                  }
                                
                                $$ = new (PARSERHEAP())
                                  StmtDDLRegOrUnregObject(
                                       *$6,
                                       StmtDDLRegOrUnregObject::HIVE,
                                       FALSE, // unregister
                                       (*$4 == "TABLE" ? COM_BASE_TABLE_OBJECT
                                        : (*$4 == "VIEW" ? COM_VIEW_OBJECT
                                           : COM_SHARED_SCHEMA_OBJECT)),
                                       $5, // if exists?
                                       $2, // is internal unregister?
                                       $7, // is cascade?
                                       $8, // is cleanup?
                                       PARSERHEAP());
                                delete $6;
                              }

/* type pStmtDDL */
// Syntax: register [internal] hbase table [if not exists] <table-name> 
register_hbase_statement : TOK_REGISTER optional_internal_clause TOK_HBASE TOK_TABLE optional_if_not_registered_clause ddl_qualified_name
                          {
                            StmtDDLRegOrUnregObject *pNode = new (PARSERHEAP())
                              StmtDDLRegOrUnregObject(
                                   *$6,
                                   StmtDDLRegOrUnregObject::HBASE,
                                   TRUE, // register
                                   COM_BASE_TABLE_OBJECT,
                                   $5, // if not exists?
                                   $2, // is internal registration?
                                   FALSE,
                                   FALSE,
                                   PARSERHEAP());

                            $$ = pNode;
                            delete $6;
                          }

/* type pStmtDDL */
// Syntax: unregister [internal] hbase table [if exists] <table-name>
unregister_hbase_statement : TOK_UNREGISTER optional_internal_clause TOK_HBASE TOK_TABLE optional_if_registered_clause ddl_qualified_name optional_cleanup
                              {
                                $$ = new (PARSERHEAP())
                                  StmtDDLRegOrUnregObject(
                                       *$6,
                                       StmtDDLRegOrUnregObject::HBASE,
                                       FALSE, // unregister
                                       COM_BASE_TABLE_OBJECT,
                                       $5, // if exists?
                                       $2, // is internal unregister?
                                       FALSE,
                                       $7, // is cleanup?
                                       PARSERHEAP());
                                delete $6;
                              }

/* type boolean */
optional_internal_clause : empty
                  {
                    $$ = FALSE;
                  }
                  | TOK_INTERNAL
                  {
		    $$ = TRUE;
		  }

/*CREATE ROLE*/
create_role_statement : TOK_CREATE TOK_ROLE authorization_identifier
                             optional_with_admin_clause
                                {
                                  $$ = new (PARSERHEAP())
                                  StmtDDLCreateRole(
                                        *$3 /* role name */,
                                        $4 /* grantor/owner is null if not specified or CURRENT_USER is specified*/,
                                        PARSERHEAP());
                                  delete $3;
                                }

/* type pElemDDL */
optional_with_admin_clause : empty
                     {
                        $$ = NULL;
                     }
                     | with_admin_clause

/* type pElemDDL */
with_admin_clause : TOK_WITH TOK_ADMIN authorization_identifier
                    {
                        $$ = new (PARSERHEAP())
                              ElemDDLGrantee(
                                   *$3 /*authorization_identifier*/,
                                   PARSERHEAP());
                        delete $3 /*authorization_identifier*/;
                    }
                    | TOK_WITH TOK_ADMIN TOK_CURRENT_USER
                    {
                        $$ = NULL;  // specifying CURRENT_USER is same as not specifying WITH ADMIN option
                    }

/*DROP ROLE*/
drop_role_statement : TOK_DROP TOK_ROLE authorization_identifier
                      {
                         $$ = new (PARSERHEAP())
                               StmtDDLCreateRole(
                                    *$3 /* role name */,
                                    PARSERHEAP());
                         delete $3;
                      }

/* type pStmtDDL */
create_component_privilege_stmt : TOK_CREATE TOK_COMPONENT TOK_PRIVILEGE 
                                             component_privilege_name
                                             TOK_AS priv_abbrev_str_lit
                                             TOK_ON component_name
                                             optional_system
                                             optional_component_detail_clause
               {
                 // create_component_privilege_stmt ::=
                 //   TOK_CREATE TOK_COMPONENT TOK_PRIVILEGE component_privilege_name
                 //              TOK_AS priv_abbrev_str_lit
                 //              TOK_ON component_name
                 //              optional_component_detail_clause

                 $$ = new (PARSERHEAP())
                   StmtDDLCreateComponentPrivilege
                   ( *$4 // component_privilege_name - deep copy
                   , *$6 // priv_abbrev_str_lit - deep copy
                   , *$8 // component_name - deep copy
		   , $9 //optional_system
                   , *$10 // optional_component_detail_clause - deep copy
                   , PARSERHEAP()
                   );
                 delete $4 /*component_privilege_name*/;
                 delete $6 /*priv_abbrev_str_lit*/;
                 delete $8 /*component_name*/;
                 delete $10 /*optional_component_detail_clause*/;
               }

/* type pStmtDDL */
drop_component_privilege_stmt : TOK_DROP TOK_COMPONENT TOK_PRIVILEGE 
                                 component_privilege_name
                                 TOK_ON component_name optional_drop_behavior
               {
                 // drop_component_privilege_stmt ::=
                 //   TOK_DROP TOK_COMPONENT TOK_PRIVILEGE component_privilege_name
                 //                                        TOK_ON component_name

                 $$ = new (PARSERHEAP())
                   StmtDDLDropComponentPrivilege
                   ( *$4 // component_privilege_name - deep copy
                   , *$6 // component_name - deep copy
                   , $7  // drop behavior
                   , PARSERHEAP()
                   );
                 delete $4 /*component_privilege_name*/;
                 delete $6 /*component_name*/;
               }

/* type stringval */
priv_abbrev_str_lit : component_str_lit
               {
                 // priv_abbrev_str_lit ::= component_str_lit

                 if ($$->length()/*in bytes*/ > ComMAX_COMPONENT_PRIV_ABBREV_STRING_LEN_IN_BYTES)
                 {
                   // $0~string0 is too long (longer than $1~int1 $2~string1).
                   // Component privilege abbreviation is too long (longer than 2 bytes).
                   *SqlParser_Diags << DgSqlCode(-3301)
                                    << /*subst0*/ DgString0("Component privilege abbreviation")
                                    << /*subst1*/ DgInt0(ComMAX_COMPONENT_PRIV_ABBREV_STRING_LEN_IN_BYTES)
                                    << /*subst2*/ DgString1("bytes");
                   YYERROR;
                 }
               }

/* type stringval */
component_privilege_name : identifier_with_7_bit_ascii_chars_only
               {
                 // component_privilege_name ::= identifier_with_7_bit_ascii_chars_only
               }

/* type stringval */
component_name : regular_identifier_with_7_bit_ascii_chars_only
               {
                 // component_name ::= regular_identifier_with_7_bit_ascii_chars_only
               }
/* type stringval */
regular_identifier_with_7_bit_ascii_chars_only : regular_identifier
               {
                  // regular_identifier_with_7_bit_ascii_chars_only ::= regular_identifier

                  NAString * pName = charToChar ( (Lng32)CharInfo::ISO88591 // targetCS
                                                , $1->data()                // const char *s - regular_identifier
                                                , $1->length()              // Int32 sLenInBytes
                                                , (Lng32)ComGetNameInterfaceCharSet() // sourceCS - CharInfo::UTF8
                                                , PARSERHEAP()              // heap for allocated target string
                                                );
                  if ( pName == NULL // conversion failed
                       || NOT NAStringHasOnly7BitAsciiChars(*pName) )
                  {
                    YYERROR;
                  }
                  $$ = pName;
                  if (transformIdentifier(*$$, TRUE, TRUE))
                  {
                        YYERROR;
                  }
                  delete $1; // regular_identifier
               }

/* type stringval */
identifier_with_7_bit_ascii_chars_only : identifier
               {
                  // identifier_with_7_bit_ascii_chars_only ::= identifier

                  NAString * pName = charToChar ( (Lng32)CharInfo::ISO88591 // targetCS
                                                , $1->data()                // const char *s - regular_identifier
                                                , $1->length()              // Int32 sLenInBytes
                                                , (Lng32)ComGetNameInterfaceCharSet() // sourceCS - CharInfo::UTF8
                                                , PARSERHEAP()              // heap for allocated target string
                                                );
                  if ( pName == NULL // conversion failed
                       || NOT NAStringHasOnly7BitAsciiChars(*pName) )
                  {
                    YYERROR;
                  }
                  $$ = pName;
                  delete $1; // identifier
               }

/* type pStmtDDL */
create_synonym_stmt : TOK_CREATE TOK_SYNONYM 
                      ddl_qualified_name TOK_FOR ddl_qualified_name
                      optional_by_auth_identifier
                               {
                                  $$ = new (PARSERHEAP())
                                    StmtDDLCreateSynonym(
                                        *$3 /*ddl_qualified_name*/,
                                        *$5 /*ddl_qualified_name*/,
                                         $6 /*optional_by_auth_identifier*/);
                                  delete $3 /*ddl_qualified_name*/;
                                  delete $5 /*ddl_qualified_name*/;
                               }

/* type longint */
showplan_options : optional_options 
           {
             if ($1 == NULL)
               {
                 $$ = 0x0000000E;
               }
             else 
               {
                 // DEFAULT_CHARSET has no effect on QUOTED_STRING in this context
                 Int32 i = 0;
                 char *str = (char *)$1->data();
                 ULng32 flag = 0;
                 while(str[i] != '\0')
                   {
                     switch(str[i])
                       {
                       case ' ' :  break;
                       case 'p' :  if (flag & 0x00000002)
                           YYERROR;
                         else
                           flag = flag | 0x00000002;
                         break;
                       case 'e' :  if (flag & 0x00000004)
                           YYERROR;
                         else
                           flag = flag | 0x00000004;
                         break;
                       case 't' :  if (flag & 0x00000008)
                           YYERROR;
                         else
                           flag = flag | 0x00000008;
                         break;
                       case 'n' :  if (flag & 0x00000010)
                           YYERROR;
                         else
                           flag = flag | 0x00000010;
                         break;
                       default  :  YYERROR;
                       }
                     i++;
                   }
                 // if only 'n' option is specified(no regenerate pcode),
                 // then display everything.
                 if (flag == 0x10)
                   {
                     flag |= 0x0E;
                   }
                 $$ = flag;
               }
           }

cpu_identifier : SYSTEM_CPU_IDENTIFIER
                {
                  $$ = $1;
                }
               | NUMERIC_LITERAL_EXACT_NO_SCALE
                {
                  $$ = $1;
                }
cpu_identifier_with_all : cpu_identifier
                  {
                    $$ = $1;
                  } 
                | TOK_ALL
                  {
                    $$ = new (PARSERHEAP()) NAString("-1", PARSERHEAP());
                  }               
pid_identifier : cpu_identifier ',' NUMERIC_LITERAL_EXACT_NO_SCALE
                {
                    $1->append(",");
                    $1->append(*$3);
                    $$ = $1;
                    delete $3;
                }
               | DOLLAR_IDENTIFIER
                {
                  $$ = $1;
                }  
               | TOK_CURRENT
                {
                  $$ = new (PARSERHEAP()) NAString("CURRENT", PARSERHEAP());
                }

qid_internal_identifier : NUMERIC_LITERAL_EXACT_NO_SCALE  /* cpu */
                      ',' NUMERIC_LITERAL_EXACT_NO_SCALE  /* pid */ 
                      ',' NUMERIC_LITERAL_EXACT_NO_SCALE  /* timestamp */
                      ',' NUMERIC_LITERAL_EXACT_NO_SCALE  /* query number */
               {
                  $1->append(",");
                  $1->append(*$3);
                  $1->append(",");
                  $1->append(*$5);
                  $1->append(",");
                  $1->append(*$7);
                  $$ = $1;
                  delete $3;
                  delete $5;
                  delete $7;
               }

stats_active_clause : /* empty */
                { $$ = 1;}
             |   TOK_ACTIVE NUMERIC_LITERAL_EXACT_NO_SCALE    
                { 
                  $$ = atoi(*$2);
                  delete $2;
                }
reset_clause : /* empty */
                  { $$ = 0; }
             |  TOK_RESET
                  { $$ = 2; } /* same as RMS_INIT_STATS Positive value because we can't return negative */ 


qid_internal_stats_merge_clause : /* empty */
                                 { $$ = 0; } /* use the session default view type */
                                | ',' stats_merge_clause
                                 { $$ = $2; }

stats_merge_clause : /*empty */
               { $$ = 0; } /* use the session default view type */
             |  TOK_ACCUMULATED   
               { $$ = SQLCLI_ACCUMULATED_STATS; }
             |  TOK_PERTABLE   
               { $$ = SQLCLI_PERTABLE_STATS; }
             |  TOK_PROGRESS
               { $$ = SQLCLI_PROGRESS_STATS; }
             | TOK_DEFAULT
               { $$ = SQLCLI_SAME_STATS; }  


/* type pStmtDDL */
comment_on_statement : TOK_COMMENT TOK_ON comment_on_object_types ddl_qualified_name TOK_IS QUOTED_STRING
               {
                 StmtDDLCommentOn *pNode = 
                   new(PARSERHEAP()) StmtDDLCommentOn(
                     $3,
                     *$4,
                     *$6,
                     PARSERHEAP()
                   );

                 $$ = pNode;
               }
             | TOK_COMMENT TOK_ON TOK_SCHEMA schema_name TOK_IS QUOTED_STRING
               {
                   NAString tmpSchema($4->getSchemaNameAsAnsiString());

                   if (! validateVolatileSchemaName(tmpSchema))
                   {
                     YYERROR;
                   }

                   StmtDDLCommentOn *pNode = new(PARSERHEAP()) StmtDDLCommentOn(
                                                 StmtDDLCommentOn::COMMENT_ON_TYPE_SCHEMA,
                                                 QualifiedName(SEABASE_SCHEMA_OBJECTNAME, $4->getSchemaName(), $4->getCatalogName(), PARSERHEAP()),
                                                 *$6,
                                                 PARSERHEAP());

                   $$ = pNode;
               }
             | TOK_COMMENT TOK_ON TOK_COLUMN qualified_name TOK_IS QUOTED_STRING
               {
                 ShortStringSequence *seq = (ShortStringSequence *) $4;
                 UInt32 numParts = seq->numParts();

                 if (numParts < 2)
                   YYABORT;

                 NAString strEmpty("", PARSERHEAP());

                 NAString *columnName = seq->extract(numParts - 1);
                 NAString *tableName  = seq->extract(numParts - 2);
                 NAString *schemaName = numParts > 2 ? seq->extract(numParts - 3) : &strEmpty;
                 NAString *catalogName = numParts > 3 ? seq->extract(numParts - 4) : &strEmpty;

                 QualifiedName tblName(*tableName, *schemaName, *catalogName, PARSERHEAP());
                 ColRefName *colRefName = new(PARSERHEAP()) ColRefName(*columnName, CorrName(tblName, PARSERHEAP()));
                 StmtDDLCommentOn *pNode = 
                           new(PARSERHEAP()) StmtDDLCommentOn(
                                  StmtDDLCommentOn::COMMENT_ON_TYPE_COLUMN,
                                  tblName,
                                  *$6,
                                  new(PARSERHEAP()) ColReference(colRefName),
                                  PARSERHEAP()
                           );

                 $$ = pNode;
               }


comment_on_object_types : TOK_TABLE
               {
                 $$ = StmtDDLCommentOn::COMMENT_ON_TYPE_TABLE;
               }
             | TOK_INDEX
               {
                 $$ = StmtDDLCommentOn::COMMENT_ON_TYPE_INDEX;
               }
             | TOK_VIEW
               {
                 $$ = StmtDDLCommentOn::COMMENT_ON_TYPE_VIEW;
               }
             | TOK_LIBRARY
               {
                 $$ = StmtDDLCommentOn::COMMENT_ON_TYPE_LIBRARY;
               }
             | TOK_PROCEDURE
               {
                 $$ = StmtDDLCommentOn::COMMENT_ON_TYPE_PROCEDURE;
               }
             | TOK_FUNCTION
               {
                 $$ = StmtDDLCommentOn::COMMENT_ON_TYPE_FUNCTION;
               }
             | TOK_SEQUENCE
               {
                 $$ = StmtDDLCommentOn::COMMENT_ON_TYPE_SEQUENCE;
               }
               
               

/* type tokval */
//
//   As many tokens as possible should be ADDED to this list, and REMOVED
//   from common/ReservedWords.h list "TandemReservedWords".
//   Criteria for being non-reserved are:
//
//     1. token is a single word
//
//     2. it is not a <reserved word> or potential <reserved word>
//	  as defined by Ansi 5.2, i.e.,
//	  it is not on either of the ReservedWords.h lists
//	  "AnsiReservedWords" or "PotentialAnsiReservedWords"
//	  (but see exceptions in the latter list, in the .h file!)
//
//     3. SqlParser does not emit a syntax error (error 15001) given the input
//	    TABLE candidateword;	e.g. TABLE ASCENDING;
//
//     4. adding the word to this list does not increase the number of
//	  conflicts/ambiguities in the grammar, as indicated by warning messages
//	  from yacc or bison
//
nonreserved_word :      TOK_ABORT
                      | TOK_ACCESS
                      | TOK_ACCUMULATED
                      | TOK_ACTIVATE
                      | TOK_ACTIVE
                      | TOK_ALIGNED
                      | TOK_ALLOW
                      | TOK_ALLOWED // MV
                      | TOK_APPEND
                      | TOK_AREA
		      | TOK_AUTOABORT
                      | TOK_AUTOMATIC // MV
                      | TOK_REPEATABLE
                      | TOK_SERIALIZABLE
	        //          | TOK_ANSIVARCHAR  //->nonreserved_datatype   
                      | TOK_ALL_DDL
                      | TOK_ALL_DML
                      | TOK_ALL_UTILITY
                      | TOK_ALTER_LIBRARY
                      | TOK_ALTER_MV
                      | TOK_ALTER_MV_GROUP
                      | TOK_ALTER_ROUTINE
                      | TOK_ALTER_ROUTINE_ACTION
                      | TOK_ALTER_SYNONYM
                      | TOK_ALTER_TABLE
                      | TOK_ALTER_TRIGGER
                      | TOK_ALTER_VIEW
                      | TOK_ALWAYS
                      | TOK_AQR
                      | TOK_ARKCMP
                      | TOK_ASCENDING
                      | TOK_ATOMIC
                      | TOK_ATTRIBUTE
                      | TOK_ATTRIBUTES
		      | TOK_AUDITONREFRESH 
                      | TOK_AUDIT
                      | TOK_AUTOBEGIN
                      | TOK_AUTOCOMMIT
                      | TOK_AUDITCOMPRESS
                      | TOK_AUTHENTICATION
		      | TOK_AVERAGE_STREAM_WAIT
		      | TOK_BACKUP
	        //          | TOK_BIGINT      //->nonreserved_datatype         
                      | TOK_BLOCKSIZE
                      | TOK_BT
                      | TOK_BRIEF
                      | TOK_BUFFER
                      | TOK_BUFFERED
                      | TOK_BYTES
                      | TOK_C
		   // | TOK_CALL  // uncomment *IF* remove from ReservedWords.h
                      | TOK_CANCEL
                      | TOK_CARDINALITY
                      | TOK_CATALOGS
                      | TOK_CATALOG_NAME
		      | TOK_CATCHUP // MV
                      | TOK_CENTURY
                      | TOK_CHANGED
		      | TOK_CHANGES // MV
                      | TOK_CHARS
                      | TOK_CHARACTERS
                      | TOK_CHARACTER_SET_CATALOG
                      | TOK_CHARACTER_SET_NAME
                      | TOK_CHARACTER_SET_SCHEMA
                      | TOK_CLASS_ORIGIN
                      | TOK_CLEAN
                      | TOK_CLEANUP
                      | TOK_CLEAR
                      | TOK_CLEARONPURGE
                      | TOK_CLUSTER
                      | TOK_CLUSTERING
                      | TOK_COLLATION_CATALOG
                      | TOK_COLLATION_NAME
                      | TOK_COLLATION_SCHEMA
					  | TOK_COLUMNS // MV OZ_REFRESH
                      | TOK_COLUMN_NAME
                      | TOK_COLUMN_NUMBER
                      | TOK_COMMANDS
                      | TOK_COMMAND_FUNCTION
                      | TOK_COMMENT
                      | TOK_COMMITTED
                      | TOK_COMP
                      | TOK_COMPACT
                      | TOK_COMPARE
                      | TOK_COMPLETE
                      | TOK_COMPONENT
                      | TOK_COMPONENTS
		      | TOK_COMPRESS
                      | TOK_COMPRESSED
                      | TOK_COMPRESSION
                      | TOK_CONCURRENT
                      | TOK_CONCURRENCY
                      | TOK_CONDITION_NUMBER
                      | TOK_CONFIG
                      | TOK_CONNECTION_NAME
                      | TOK_CONSTRAINT_CATALOG
                      | TOK_CONSTRAINT_NAME
                      | TOK_CONSTRAINT_SCHEMA
                      | TOK_CONTAINS
                      | TOK_CONTROL
                      | TOK_COPY
                      | TOK_COST
                      | TOK_CPP
                      | TOK_CPU
                      | TOK_CREATE_LIBRARY
                      | TOK_CREATE_MV
                      | TOK_CREATE_MV_GROUP
                      | TOK_CREATE_PROCEDURE
                      | TOK_CREATE_ROUTINE
                      | TOK_CREATE_ROUTINE_ACTION
                      | TOK_CREATE_TABLE
                      | TOK_CREATE_TRIGGER
                      | TOK_CREATE_SYNONYM
                      | TOK_CREATE_VIEW
                      | TOK_CQD
                      | TOK_CURSOR_NAME
                      | TOK_CACHE
                      | TOK_CYCLE
                      | TOK_D                   /* ODBC extension  */
                      | TOK_DATA
                //    | TOK_DATETIME            /* MP syntax--moved to lexer */
                      | TOK_DATETIME_CODE
                      | TOK_DBA
                      | TOK_DCOMPRESS
                      | TOK_DDL
		      | TOK_DE			// MV OZ_REFRESH
                      | TOK_DECADE
                      | TOK_DEFINER
                      | TOK_DEFINITION
                      | TOK_DEFAULTS
                      | TOK_DELAY
                      | TOK_DELIMITER
		      | TOK_DEPENDENT
                      | TOK_DESCENDING
                      | TOK_DETAIL
                      | TOK_DETAILS
		      | TOK_DIRECTEDBY // MV
                      | TOK_DISABLE     
                      | TOK_DISK
                      | TOK_DISPLAY
                      | TOK_DIVISION
                      | TOK_DO
                      | TOK_DOUBLE_IEEE
                      | TOK_DOW
                      | TOK_DOY
                      | TOK_DROP_LIBRARY
                      | TOK_DROP_MV
                      | TOK_DROP_MV_GROUP
                      | TOK_DROP_PROCEDURE
                      | TOK_DROP_ROUTINE
                      | TOK_DROP_ROUTINE_ACTION
                      | TOK_DROP_SYNONYM
                      | TOK_DROP_TABLE
                      | TOK_DROP_TRIGGER
                      | TOK_DROP_VIEW
                      | TOK_DROPPABLE
                      | TOK_DSLACK
                      | TOK_DUPLICATE
                      | TOK_DYNAMIC_FUNCTION
                      | TOK_EID
                      | TOK_ENABLE         
                      | TOK_ENFORCED
                      | TOK_ENFORCERS
                      | TOK_ERROR
                      | TOK_ENTERPRISE
                      | TOK_ENTRY
                      | TOK_ENTRIES
                      | TOK_EPOCH
                      | TOK_ET
                      | TOK_EUROPEAN
                      | TOK_EXCEPTIONS
                      | TOK_EXCEPTION_TABLE
                      | TOK_EXCHANGE
                      | TOK_EXCHANGE_AND_SORT
                      | TOK_EXCLUSIVE
                      | TOK_EXECUTION
                      | TOK_EXIT
                      | TOK_EXPLAIN
                      | TOK_EXTENT
                      | TOK_EXTRACT_SOURCE
                      | TOK_EXTRACT_TARGET
                      | TOK_FAMILY
                      | TOK_FAST
		      | TOK_FEATURE_VERSION_INFO    // Versioning
                      | TOK_FILE
                      | TOK_FINAL
		      | TOK_FIRST_FSCODE
                      | TOK_FLOAT_IEEE
                      | TOK_FOLLOWING
                      | TOK_FOR_MAXRUNTIME
                      | TOK_FORMAT
                      | TOK_FORCE
               //     | TOK_FRACTION             /* MP syntax -- moved to lexer */
                      | TOK_G
                      | TOK_GENERATE
                      | TOK_GENERATED
                      | TOK_GHOST
                      | TOK_GIVE
                      | TOK_GRANTEES
                      | TOK_GRANTED
                      | TOK_HARDWARE
                      | TOK_HASH
                      | TOK_HASH2
                      | TOK_TRAFODION
                      | TOK_HBASE
                      | TOK_HBASE_OPTIONS
                      | TOK_SERIALIZED
		      | TOK_HEADER
                      | TOK_HEADING
                      | TOK_HEADINGS
                      | TOK_HEXADECIMAL
                      | TOK_HORIZONTAL
                      | TOK_HIGH_VALUE
		      | TOK_HOURS
                        //                      | TOK_KEY
                      | TOK_SHOW
                      | TOK_SHOWSTATS
		      | TOK_SHOWTRANSACTION
                      | TOK_ICOMPRESS
                      | TOK_IGNORETRIGGERS
                      | TOK_IGNORE_TRIGGER
                      | TOK_IMMUTABLE
                      | TOK_IMPLICIT
                      | TOK_INCREMENT
                      | TOK_INDEX_TABLE
                      | TOK_INDICATOR_DATA
                      | TOK_INDICATOR_POINTER
                      | TOK_INDICATOR_TYPE
                      | TOK_INGEST
		      | TOK_INITIALIZATION // MV
                      | TOK_INITIALIZE
                      | TOK_INITIALIZED 
                      | TOK_INPUTS
                      | TOK_INSERT_ONLY
		      | TOK_INSERTLOG // MV
		      | TOK_INTERNAL // MV REFRESH
                      | TOK_INTERNALSP
                      | TOK_INDEX
                      | TOK_INDEXES
                      | TOK_INS
                      | TOK_INTERVALS
                      | TOK_INVOKER
                      | TOK_IO
                      | TOK_ISLACK
                      | TOK_ISOLATE
		      | TOK_INVALID
		      | TOK_INVALIDATE
                      | TOK_JAVA
                      | TOK_K
     //                 | TOK_LARGEINT   //->nonreserved_datatype
                      | TOK_LABEL
                      | TOK_LABEL_CREATE         
                      | TOK_LABEL_DROP
		      | TOK_LABEL_ALTER
                      | TOK_LABEL_PURGEDATA
                      | TOK_LANGUAGE
	              | TOK_LAST_FSCODE
		      | TOK_LAST_SYSKEY
                      | TOK_LASTSYSKEY
                      | TOK_LEADING_PRECISION
                      | TOK_LEVELS
                      | TOK_EOF
                      | TOK_LIBRARY
                      | TOK_LIBRARIES
                      | TOK_LINE_NUMBER
                      | TOK_LOAD
                      | TOK_LOAD_ID
                      | TOK_LOCATION
                      | TOK_LOCK
                      | TOK_LOCK_ROW
                      | TOK_LOCKING
		      | TOK_LOCKONREFRESH // MV
		      | TOK_LOGGABLE //++ MV
                      | TOK_LOGON
                      | TOK_LZO
                      | TOK_GZIP
		      | TOK_IUDLOG     // MV REFRESH
                      | TOK_IUD_LOG_TABLE    
		      | TOK_RANGE_LOG_TABLE
     //                 | TOK_LONG       //->nonreserved_datatype         
                      | TOK_LOW_VALUE
     //                 | TOK_LSDECIMAL  //->nonreserved_datatype         
                      | TOK_M
                      | TOK_MAP
                      | TOK_MASTER
                      | TOK_MATERIALIZED  
		      | TOK_MAXEXTENTS // Extent Changes : Swati Ambulkar
                      | TOK_MAXRUNTIME
     //               | TOK_MAXSIZE
                      | TOK_MAXVALUE
                      | TOK_MEMORY
                      | TOK_MERGE
                      | TOK_MESSAGE
                      | TOK_MESSAGE_LEN
                      | TOK_MESSAGE_OCTET_LEN
                      | TOK_MESSAGE_TEXT
                      | TOK_METADATA
                      | TOK_MINIMAL
		      | TOK_MINUTES
		      | TOK_MINVALUE
                      | TOK_MODE
                      | TOK_MODULES
                      | TOK_MORE
                      | TOK_MOVE
                      | TOK_MOVEMENT
                      | TOK_MTS
                      | TOK_MV  
                      | TOK_MULTI            /* Long Running */
		      | TOK_MULTIDELTA // MV
                      | TOK_MSCK
		      | TOK_MVATTRIBUTE  // MV
		      | TOK_MVATTRIBUTES // MV
                      | TOK_MV_TABLE  
		      | TOK_MVSTATUS	// MV
		      | TOK_MVS_UMD //
		      | TOK_REGEXP  
		      | TOK_REMOVE //
		      | TOK_OPENBLOWNAWAY //
		      | TOK_REDEFTIME	// Y_TEST
  		      | TOK_MVGROUP  //
  		      | TOK_MVGROUPS
		      | TOK_MVLOG // MV
		      | TOK_MVUID // MV
                      | TOK_NAME
                      | TOK_NAMED
		      | TOK_NAMESPACE
                      | TOK_NAMETYPE          /* Tandem extension */
                      | TOK_NATABLE_CACHE_ENTRIES
                      | TOK_NATIVE
                      | TOK_NECESSARY
                      | TOK_NEEDED
                      | TOK_NEXT
		      | TOK_NODELETE // MV
                      | TOK_NODES
		      | TOK_NOMVLOG // MV
                      | TOK_NOLOG
                      | TOK_NORMAL
                      | TOK_NSK_CODE
                      | TOK_NULLABLE
                      | TOK_NULL_STRING
		      | TOK_NUMBER
                      | TOK_OBSOLETE
                      | TOK_OBJECT
                      | TOK_OBJECTS
                      | TOK_OFFLINE
                      | TOK_OJ                /* ODBC extension  */
                      | TOK_ONLINE
		      | TOK_OPCODE            /* alter opcode */
                      | TOK_OPTIONS
                      | TOK_ORDERED
                      | TOK_OVER
                      | TOK_OVERRIDE
                      | TOK_PACKED
                      | TOK_PAGE
                      | TOK_PAGES
                      | TOK_PARALLEL
                      | TOK_PARALLELISM
                      | TOK_PARENT
                      | TOK_PARSERFLAGS
                      | TOK_ENVVAR
                      | TOK_ENVVARS
                        //                      | TOK_PARTIAL
                      | TOK_PARTITION
                      | TOK_PARTITIONING
                      | TOK_PARTITIONS
                      | TOK_PASS
                      | TOK_PATH
                      | TOK_PERTABLE
		      | TOK_PHASE // MV REFRESH
		      | TOK_PID
		      | TOK_PIPELINE // MV REFRESH
                      | TOK_PLACING
                      | TOK_POOL
		      | TOK_POPULATE
                      | TOK_POS
                      | TOK_PRECEDING
		      | TOK_PREFER_FOR_SCAN_KEY
		      | TOK_PRESERVE
                      | TOK_PRIORITY
                      | TOK_PRIORITY_DELTA
                      | TOK_PRIVATE
                      | TOK_PRIVILEGE
                      | TOK_PROCESS
                      | TOK_PROGRESS
                      | TOK_PROMPT
                      | TOK_QID
                      | TOK_QID_INTERNAL
	              | TOK_QUERY
                      | TOK_QUERY_CACHE
                      | TOK_HYBRID_QUERY_CACHE
                      | TOK_HYBRID_QUERY_CACHE_ENTRIES
                      | TOK_QUERY_CACHE_ENTRIES
                      | TOK_CATMAN_CACHE
		      | TOK_NATABLE_CACHE
		      | TOK_NAROUTINE_CACHE
		      | TOK_NAROUTINE_ACTION_CACHE
                      | TOK_RANGE
		      | TOK_RANGE_N
		      | TOK_RANGELOG   // MV 
                      | TOK_RATE 
                      | TOK_REAL_IEEE
                      | TOK_REBUILD
                      | TOK_RECOMPUTE // MV 
                      | TOK_RECORD_SEPARATOR
                      | TOK_RECOVER
                      | TOK_RECOVERY
                      | TOK_REFRESH // MV
                      | TOK_REGION
                      | TOK_REGISTER
                      | TOK_REGISTERED
                      | TOK_REINITIALIZE
                      | TOK_RELATED
                      | TOK_RELATEDNESS     // Versioning
                      | TOK_RELOAD
                      | TOK_REMOTE
                      | TOK_RENAME
                      | TOK_REPAIR
                      | TOK_REPOSITORY
                      | TOK_REQUEST // MV
                      | TOK_REQUIRED
                      | TOK_RESET
                      | TOK_RETURNED_LENGTH
                      | TOK_RETURNED_OCTET_LENGTH
                      | TOK_RETURNED_SQLSTATE
                      | TOK_REWRITE // MV
                      | TOK_ROLE
                      | TOK_ROLES
                      | TOK_ROW_COUNT
		      | TOK_ROWS_INSERTED // MV REFRESH
		      | TOK_ROWS_DELETED  // MV REFRESH
		      | TOK_ROWS_UPDATED  // MV REFRESH
		      | TOK_ROWS_COVERED  // MV AB_REFRESH
		      | TOK_NUM_OF_RANGES // MV AB_REFRESH
                      | TOK_ROWWISE
		      | TOK_ROWSET_IND_LAYOUT_SIZE
		      | TOK_ROWSET_SIZE
		      | TOK_ROWSET_VAR_LAYOUT_SIZE
//                      | TOK_ROW
                      | TOK_RUN
                      | TOK_SAFE
                      | TOK_SALT
                      | TOK_SAS_FORMAT
                      | TOK_SAS_LOCALE
                      | TOK_SAS_MODEL_INPUT_TABLE
                      | TOK_SCALAR
                      | TOK_SCALE
                      | TOK_SCAN
                      | TOK_SCHEMAS
                      | TOK_SCHEMA_NAME
                      | TOK_SECONDS
                      | TOK_SECURITY
//                      | TOK_SEL
                      | TOK_SELECTIVITY
                      | TOK_SEPARATE
                      | TOK_SERVER_NAME
                      | TOK_SESSIONS
                      | TOK_SG_TABLE
                      | TOK_SHAPE
                      | TOK_SHARE
                      | TOK_SHARED
                      | TOK_SIGNED
		      | TOK_SINGLEDELTA // MV
//                      | TOK_SIZE
                      | TOK_SLACK
                      | TOK_SOFTWARE
                      | TOK_SOURCE
                      | TOK_SNAPSHOT
                      | TOK_SUFFIX
                      | TOK_TARGET
                      | TOK_SOURCE_FILE
                      | TOK_SP_RESULT_SET
                      | TOK_SQL_WARNING
                      | TOK_SQLROW
		      | TOK_START  /* used in nist618 for column name */
		      | TOK_STATE  /* used internally? qat tests */
                      | TOK_STATEMENT
                      | TOK_STATIC
                      | TOK_STATISTICS
                      | TOK_STATS
                      | TOK_STATUS
                      | TOK_STORAGE
                      | TOK_STORE
                      | TOK_STORED
                      | TOK_STRING_SEARCH
                      | TOK_STYLE
                      | TOK_SUBCLASS_ORIGIN
                      | TOK_SUBSYSTEM_ID
                      | TOK_HBMAP_TABLE
                      | TOK_SUSPEND
                      | TOK_SYNONYMS
                      | TOK_T                 /* ODBC extension  */
                      | TOK_TABLE_MAPPING
                      | TOK_TABLE_NAME
		      | TOK_TABLES				// MV 
                      | TOK_TABLESPACE
                      | TOK_TAG
                      | TOK_TEMP_TABLE
                      | TOK_TEXT
                      | TOK_THROUGH
                      | TOK_TIMEOUT    
                      | TOK_TITLE
		      | TOK_TRANSFORM
                      | TOK_TRIGGERS
                      | TOK_TRIGGER_CATALOG
                      | TOK_TRIGGER_NAME
                      | TOK_TRIGGER_SCHEMA
                      | TOK_TS                /* ODBC extension  */
                      | TOK_TYPE
                      | TOK_TYPES
                      | TOK_TYPE_ANSI
                      | TOK_TYPE_FS
                      | TOK_UDF
                      | TOK_UNBOUNDED
                      | TOK_UNCOMMITTED
                      | TOK_UNIVERSAL
                      | TOK_UNLOCK
                      | TOK_UNLOAD
                      | TOK_UNNAMED
                      | TOK_UNREGISTER
                      | TOK_UNSIGNED
                      | TOK_UPD
                      | TOK_UPGRADE
		      | TOK_UPDATE_STATS
                      | TOK_UPDATE_LOB
                      | TOK_UPPERCASE
                      | TOK_USA				
		      | TOK_USE				// MV REFRESH
                      | TOK_USERS
                      | TOK_VALUE
                      | TOK_VARIABLE_DATA
                      | TOK_VARIABLE_POINTER
                      | TOK_VOLATILE			
                      | TOK_VERSION
                      | TOK_VERSIONS
                      | TOK_VPROC
                      | TOK_VERSION_INFO		// Versioning
                      | TOK_VIEWS
                      | TOK_VSBB
                      | TOK_WAITED
                      | TOK_WAITEDIO
                      | TOK_WOM

		      	// New words added can be merged into sorted list above
                      | TOK_INVOKE
		      | TOK_SHOWCONTROL
		      | TOK_SHOWDDL
		      | TOK_SHOWPLAN
		      | TOK_SHOWSHAPE
                      | TOK_SHOWSET 		      
                        // New words for Sampling
                      | TOK_SAMPLE
                      | TOK_PERIODIC
                      | TOK_PERCENT
                      | TOK_BALANCE
                      | TOK_EVERY
                      | TOK_EXISTING
                      | TOK_SORT
                      | TOK_CLUSTERS
                      | TOK_BLOCKS
                        // New words for Sequence Functions
                      | TOK_INCLUSIVE
                      | TOK_SEQUENCE
                      | TOK_SEQUENCES
                      | TOK_SINCE
//		      | TOK_MAINTAIN
                      | TOK_MANAGEMENT
		      | TOK_MANUAL
		      | TOK_MIXED
		      | TOK_MVS  // MV
                      | TOK_PURGEDATA
                      | TOK_INCREMENTAL
                      | TOK_PROCEDURES
                      | TOK_SUMMARY
                      | TOK_SYSTEM
		      | TOK_UNAVAILABLE // MV
		      | TOK_UID
// QSTUFF
                      | TOK_STREAM
                      | TOK_SKIP
		      | TOK_CONFLICT
		      |	TOK_HOLD
// QSTUFF
                      | TOK_VALIDATE
                      | TOK_RMS

// This was added for JIRA Trafodion 2367. There are oddities in
// how PREPARE is parsed vs. how EXPLAIN is parsed, along with
// pecularities in the specific syntax of EXPLAIN that prevent
// us from recognizing the same identifiers for both. In sqlci,
// for example, sqlci's own parser picks off the PREPARE <identifier>
// part, and this parser only sees the query text afterwards. So,
// sqlci has its own rules for what <identifier>s are allowed.
// EXPLAIN on the other hand is fully parsed here in this parser.
// Trafci seems to have different processing yet. EXPLAIN itself
// has some confounding syntax: One can say "EXPLAIN <query text>"
// as well as "EXPLAIN <statement identifier>", so the identifier
// can conflict with any token that can start a statement. This
// anomaly is unique to EXPLAIN. That means that we can't simply
// plug in nonreserved_word as an alternative production for
// explain_identifier; we'll get a boatload of additional
// shift/reduce and reduce/reduce conflicts. It is possible in
// principle to create a subset of nonreserved_word for EXPLAIN,
// but in light of the fact that the PREPARE rules are in different
// parsers (and differ between sqlci and trafci), this seems a
// fool's errand.
// 
// So, up until this JIRA, only regular identifiers (that is,
// non-keywords) and delimited identifiers were allowed for EXPLAIN.
// Unfortunately, C is a keyword, since it is a language name on
// CREATE FUNCTION. So, EXPLAIN C; gives a syntax error. Since
// humans are sometimes prone to using one-letter identifiers,
// this can be highly irritating. So, to remove this irritation,
// we've supplied a separate nonreserved_word production just for
// EXPLAIN that contains all the one-letter tokens.

nonreserved_word_for_explain: TOK_C
                      | TOK_D
                      | TOK_G
                      | TOK_K
                      | TOK_M
                      | TOK_T

// Formerly declared as FUNC_ in ulexer.cpp keywordTable.  Now defined
// as nonreserved_func_word.  This works better and does not increase the
// shift reduce conflicts. When they were FUNC_s they were treated as
// IDENTIFIERs unless they were followed by a '('.  However, there are
// some contexts in which they should be treated as IDENTIFIERs even
// though they are followed by a '('.  For instance: "SELECT * from T
// ABS(a)".  In this case, ABS should be treated as an IDENTIFIER not
// a function name.
//
nonreserved_func_word:  TOK_ABS
                      | TOK_ACOS
                      | TOK_ASCII
                      | TOK_ASIN
                      | TOK_ATAN
                      | TOK_ATAN2
                      | TOK_AUTHNAME
                      | TOK_AUTHTYPE
                      | TOK_BITAND
                      | TOK_BITOR
                      | TOK_BITXOR
                      | TOK_BITNOT
                      | TOK_BITEXTRACT
                      | TOK_CONVERTTOBITS
                      | TOK_CEIL
                      | TOK_CEILING
                      | TOK_CHR
                      | TOK_CODE_VALUE
                      | TOK_COLUMN_CREATE
                      | TOK_COLUMN_LOOKUP
                      | TOK_COLUMN_DISPLAY
                      | TOK_CONCAT
                      | TOK_CONVERTFROMHEX
                      | TOK_CONVERTTIMESTAMP
                      | TOK_CONVERTTOHEX
                      | TOK_CONVERTTOHX_INTN
                      | TOK_COS
                      | TOK_COSH
                      | TOK_CRC32
                      | TOK_CURDATE
                      | TOK_CURTIME
                      | TOK_D_RANK 
                      | TOK_DATABASE
                      | TOK_DATEFORMAT
                      | TOK_DAYNAME
                      | TOK_DAYOFMONTH
                      | TOK_DAYOFWEEK
                      | TOK_DAYOFYEAR
                      | TOK_DEBUG
                      | TOK_DEGREES
                      | TOK_DIFF1
                      | TOK_DIFF2
                      | TOK_ENCODE_KEY
                      | TOK_ENCODE_BASE64
                      | TOK_DECODE_BASE64
                      | TOK_EXP
                      | TOK_EXTEND
                      | TOK_FIRSTDAYOFYEAR
                      | TOK_FLOOR
                      | TOK_FN
                      | TOK_FROM_HEX
                      | TOK_GREATEST
                      | TOK_GROUPING_ID
                      | TOK_HASHPARTFUNC
                      | TOK_HASH2PARTFUNC
                      | TOK_HBASE_TIMESTAMP
                      | TOK_HBASE_VERSION
                      | TOK_HEX
                      | TOK_HIVE
                      | TOK_HIVEMD
                      | TOK_INET_ATON
                      | TOK_INET_NTOA
                      | TOK_INITIAL
                      | TOK_INSTR
                      | TOK_ISIPV4
                      | TOK_ISIPV6
                      | TOK_KEY_RANGE_COMPARE
                      | TOK_JSONOBJECTFIELDTEXT
                      | TOK_JULIANTIMESTAMP
                      | TOK_LASTNOTNULL
                      | TOK_LAST_DAY
                      | TOK_LCASE
                      | TOK_LEAST
                      | TOK_LENGTH
                      | TOK_LOCATE
                      | TOK_LOG
                      | TOK_LOG10
                      | TOK_LOG2
                      | TOK_LPAD
                      | TOK_LTRIM
                      | TOK_MAVG
                      | TOK_MCOUNT
                      | TOK_MD5
                      | TOK_MMAX
                      | TOK_MMIN
                      | TOK_MOD
                      | TOK_MONTHNAME
                      | TOK_MONTHS_BETWEEN
                      | TOK_MRANK
                      | TOK_MSTDDEV
                      | TOK_MSUM
                      | TOK_MVARIANCE
                      | TOK_NEXT_DAY
		      | TOK_NOW
                      | TOK_NVL
                      | TOK_NULLIFZERO
                      | TOK_OFFSET
                      | TOK_OS_USERID
                      | TOK_PI
                      | TOK_PIVOT
                      | TOK_PIVOT_GROUP
                      | TOK_POWER
                      | TOK_QUARTER
                      | TOK_QUERYID_EXTRACT
                      | TOK_RADIANS
                      | TOK_RAND
                      | TOK_RANDOM
                      | TOK_RAVG
                      | TOK_RCOUNT
                      | TOK_REPEAT
                      | TOK_RESTORE
                      | TOK_RESUME
                      | TOK_RETRIES
                      | TOK_RETURNS
                      | TOK_RMAX
                      | TOK_RMIN
                      | TOK_ROUND
                      | TOK_ROWNUM
                      | TOK_ROW_NUMBER
                      | TOK_RPAD
                      | TOK_RRANK 
                      | TOK_RRPARTFUNC
                      | TOK_RSTDDEV
                      | TOK_RSUM
                      | TOK_RTRIM
                      | TOK_RVARIANCE
                      | TOK_SEQNUM
                      | TOK_SHA
                      | TOK_SHA1
                      | TOK_SHA2
                      | TOK_SIGN
                      | TOK_SIN
                      | TOK_SINH
                      | TOK_SOUNDEX
                      | TOK_SORT_KEY
                      | TOK_SPACE
                      | TOK_SQRT
                      | TOK_STDDEV
                      | TOK_STOP
			//                      | TOK_SYSDATE
                      | TOK_TAN
                      | TOK_TANH
                      | TOK_THIS
                      | TOK_TOKENSTR
                      | TOK_TO_BINARY
                      | TOK_TO_CHAR
                      | TOK_TO_DATE
                      | TOK_TO_HEX
                      | TOK_TO_NUMBER
                      | TOK_TO_TIME
                      | TOK_TO_TIMESTAMP
                      | TOK_TRUNC
                      | TOK_TRUNCATE
                      | TOK_TYPECAST
                      | TOK_UCASE
			//                      | TOK_UPSERT
                      | TOK_UNIQUE_ID
                      | TOK_UUID
                      | TOK_SYS_GUID
		      | TOK_USERNAMEINTTOEXT
                      | TOK_VARIANCE
                      | TOK_WEEK
                      | TOK_XMLAGG
                      | TOK_XMLELEMENT
                      | TOK_ZEROIFNULL

                      | TOK_PERFORM
                      | TOK_PARAMETER_MODE
                      | TOK_PARAMETER_ORDINAL_POSITION
                      | TOK_PARAMETER_INDEX
                      | TOK_DATA_OFFSET
                      | TOK_NULL_IND_OFFSET
                      | TOK_ALIGNED_LENGTH

// New SQL functions
                      | TOK_ADD_MONTHS
                      | TOK_DATEADD
                      | TOK_DATE_ADD
                      | TOK_DATE_SUB
                      | TOK_DECODE
                      | TOK_DATE_PART
		      | TOK_DATE_TRUNC
		      | TOK_DATEDIFF
		      | TOK_TIMESTAMPADD
		      | TOK_TIMESTAMPDIFF
                      | TOK_ISNULL
//  These are added to ignore options from other vendors
                      | TOK_CHECKSUM
		      | TOK_FALLBACK
		      | TOK_PROTECTION
		      | TOK_FREESPACE
		      | TOK_JOURNAL
		      | TOK_MULTISET
		      | TOK_CASESPECIFIC
                      | TOK_FIXED
                      | TOK_BUFFERTOLOB
                      | TOK_EXTERNALTOLOB
                      | TOK_FILETOLOB
                      | TOK_FILETOEXTERNAL
                      | TOK_LOADTOLOB
		      | TOK_STRINGTOLOB
                      | TOK_STRINGTOEXTERNAL
                      | TOK_LOB
                      | TOK_LOBLENGTH
                      | TOK_LOBTOBUFFER
		      | TOK_LOBTOFILE
		      | TOK_LOBTOSTRING
                      | TOK_EXTERNALTOSTRING
                      | TOK_EMPTY_CLOB
                      | TOK_EMPTY_BLOB
                      | TOK_UNHEX

nonreserved_datatype  : TOK_ANSIVARCHAR
                      | TOK_BIGINT
                      | TOK_BYTE 
                      | TOK_BYTEINT
                      | TOK_LARGEINT
                      | TOK_LONG
                      | TOK_LONGWVARCHAR
                      | TOK_LSDECIMAL
                      | TOK_ROWSET
                      | TOK_TINYINT
                      | TOK_VARBINARY 
                      | TOK_VARWCHAR
                      | TOK_WCHAR

// The following tokens are reserved in SQL/MX, but 'non-reserved' in
// SQL/MP.  Using them as identifiers in SQL/MX will result in an
// ERROR (see transformIdentifier(), but they can be used as
// identifiers in SQL/MP stored text.

MP_nonreserved_word :    
                         TOK_DOUBLE
                       | TOK_ELSE
                       | TOK_END
                       | TOK_FLOAT
                       | TOK_NATIONAL
                       | TOK_NCHAR
                       | TOK_PRECISION
                       | TOK_REAL
//                       | TOK_ROW
                       | TOK_VARCHAR
                       | TOK_VARYING
		       | TOK_NEW
                       | TOK_OLD
		       | TOK_AFTER
		       | TOK_BEFORE
		       | TOK_EACH
		       | TOK_REFERENCING
		       | TOK_SIGNAL
		       | TOK_SQLSTATE
		       | TOK_TRIGGER

MP_nonreserved_func_word : TOK_CAST 
                         | TOK_CHAR_LENGTH
                         | TOK_LOWER
                         | TOK_MIN
                         | TOK_OCTET_LENGTH
                         | TOK_OVERLAY
                         | TOK_STUFF
                         | TOK_POSITION
                         | TOK_REVERSE
                         | TOK_TRIM
                         | TOK_SUBSTRING
                         | TOK_UPPER
                         | TOK_UPSHIFT

// The following tokens are reserved in SQL/MX, but 'non-reserved' in
// SQL/MP.  However, since they would increase the shift/reduce and/or
// reduce/reduce conflicts in added to the nonreserved_word list they
// cannot be used as identifiers in SQL/MP (or SQL/MX).  Using these
// as identifiers will result in a Syntax ERROR.
//
//
//                       | TOK_COLLATE
//                       | TOK_DATE
//                       | TOK_DAY
//                       | TOK_DEFAULT
//                       | TOK_HOUR
//                       | TOK_INTERVAL
//                       | TOK_MINUTE
//                       | TOK_MONTH
//                       | TOK_RIGHT
//                       | TOK_SECOND
//                       | TOK_THEN
//                       | TOK_TIME
//                       | TOK_TIMESTAMP
//                       | TOK_UNION
//                       | TOK_YEAR
 

//
// Adding to this list? See checklist above for additional things to be done.

/* end of file */
