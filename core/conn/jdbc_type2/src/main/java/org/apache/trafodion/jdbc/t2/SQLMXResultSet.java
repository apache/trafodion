// @@@ START COPYRIGHT @@@
//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// @@@ END COPYRIGHT @@@

/* -*-java-*-
 * Filename :		SQLMXResultSet.java
 * Description :	A table of data representing a database result set,
 *			which is usually generated by executing a statement
 *			that queries the database.
 */

package org.apache.trafodion.jdbc.t2;

import java.io.InputStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.DataTruncation;
import java.sql.DatabaseMetaData;
import java.sql.Date;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Calendar;
import java.util.Map;
import java.util.HashMap;

public class SQLMXResultSet extends SQLMXHandle implements java.sql.ResultSet {
	// java.sql.ResultSet interface methods
	public boolean absolute(int row) throws SQLException {
		if(this.getTracer() != null) {
			this.getTracer().println(getTraceId() + "absolute(" + row + ")");
		}
		if (JdbcDebugCfg.entryActive)
			debug[methodId_absolute].methodEntry();
		try {
			boolean flag = false;
			int absRow;

			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getType() == ResultSet.TYPE_FORWARD_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"forward_only_cursor", null);
			if (row == 0)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_row_number", null);
			if (isAnyLob_)
				closeLobObjects();
			if (row > 0) {
				if (row <= numRows_) {
					currentRow_ = row;
					isBeforeFirst_ = false;
					isAfterLast_ = false;
					onInsertRow_ = false;
					flag = true;
				} else {
					do {
						flag = next();
						if (!flag)
							break;
					} while (currentRow_ < row);
				}
			} else {
				absRow = -row;
				afterLast();
				if (absRow <= numRows_) {
					currentRow_ = numRows_ - absRow + 1;
					isAfterLast_ = false;
					isBeforeFirst_ = false;
					onInsertRow_ = false;
					flag = true;
				} else
					beforeFirst();
			}
			return flag;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_absolute].methodExit();
		}
	}

	public void afterLast() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "afterLast()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_afterLast].methodEntry();
		try {
			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getType() == ResultSet.TYPE_FORWARD_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"forward_only_cursor", null);
			last();
			/* Cursor is incremented by one row from the end of the resultset */
			currentRow_ = currentRow_ + 1;
			isAfterLast_ = true;
			isBeforeFirst_ = false;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_afterLast].methodExit();
		}
	}

	public void beforeFirst() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "beforeFirst()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_beforeFirst].methodEntry();
		try {
			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getType() == ResultSet.TYPE_FORWARD_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"forward_only_cursor", null);
			if (isAnyLob_)
				closeLobObjects();
			currentRow_ = 0;
			isBeforeFirst_ = true;
			isAfterLast_ = false;
			onInsertRow_ = false;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_beforeFirst].methodExit();
		}
	}

	public void cancelRowUpdates() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "cancelRowUpdates()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_cancelRowUpdates].methodEntry();
		try {
			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getConcurrency() == ResultSet.CONCUR_READ_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"read_only_concur", null);
			if (onInsertRow_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_position", null);
			DataWrapper row = getCurrentRow();
			if (!row.getUpdated())
				row.clearUpdated();
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_cancelRowUpdates].methodExit();
		}
	}

	public void close() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "close()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_close_V].methodEntry();
		try {
			clearWarnings();
			if (isClosed_ || connection_.isClosed_)
				return;
			if (isAnyLob_)
				closeLobObjects();
			if (stmt_ instanceof PreparedStatement && resultSetIndex_ < 1)
				close(false);
			else
				close(true);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_close_V].methodExit();
		}
	}

	public void deleteRow() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "deleteRow()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_deleteRow].methodEntry();
		try {
			clearWarnings();

			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getConcurrency() == ResultSet.CONCUR_READ_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"read_only_concur", null);
			if (onInsertRow_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_position", null);
			if (isAnyLob_)
				closeLobObjects();
			prepareDeleteStmt();
			// Remove the row from database
			getCurrentRow().deleteRow(connection_.locale_, deleteStmt_,
					paramCols_);
			// Remove the row from the resultSet
			cachedRows_.remove(--currentRow_);
			--numRows_;


			if ((getType() == ResultSet.TYPE_FORWARD_ONLY)
					&& (getConcurrency() == ResultSet.CONCUR_UPDATABLE)) {
				int temp;
				temp = currentRowCount_;

				if (!next()) {
					if (temp == 1) {
						isBeforeFirst_ = true;
					}
					currentRowCount_ = 0;
				} else {
					--currentRowCount_;
				}

			} else {
				if (currentRow_ == 0)
					isBeforeFirst_ = true;
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_deleteRow].methodExit();
		}
	}

	public int findColumn(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "findColumn(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_findColumn].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
 			if (colMap_ == null) {
 				colMap_ = new HashMap<String, Integer>();
				for (int columnIndex = 1; columnIndex <= outputDesc_.length ; columnIndex++) {
					colMap_.put(outputDesc_[columnIndex-1].name_.toUpperCase(), columnIndex);
				}
			}
			Integer colIdx = colMap_.get(columnName.toUpperCase());
			if (colIdx == null)
				throw Messages.createSQLException(connection_.locale_,
					"invalid_column_name", null);
			return colIdx;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_findColumn].methodExit();
		}
	}

	public boolean first() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "first()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_first].methodEntry();
		try {
			boolean flag = true;

			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getType() == ResultSet.TYPE_FORWARD_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"forward_only_cursor", null);
			if (isAnyLob_)
				closeLobObjects();
			if (isBeforeFirst_)
				flag = next();
			if (numRows_ > 0) {
				currentRow_ = 1;
				isAfterLast_ = false;
				isBeforeFirst_ = false;
				onInsertRow_ = false;
			}
			return flag;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_first].methodExit();
		}
	}

	// JDK 1.2
	public Array getArray(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getArray(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getArray_I].methodEntry();
		try {
			validateGetInvocation(columnIndex);
			Messages.throwUnsupportedFeatureException(connection_.locale_,
					"getArray()");
			return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getArray_I].methodExit();
		}
	}

	// JDK 1.2
	public Array getArray(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getArray(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getArray_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getArray(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getArray_L].methodExit();
		}
	}

	public InputStream getAsciiStream(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getAsciiStream(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getAsciiStream_I].methodEntry();
		try {
			String data;
			int dataType;
			Clob clob;
			Blob blob;

			validateGetInvocation(columnIndex);
			dataType = outputDesc_[columnIndex - 1].dataType_;
			switch (dataType) {
			case Types.CLOB:
				clob = getClob(columnIndex);
				if (clob != null)
					return clob.getAsciiStream();
				else
					return null;
			case Types.BLOB:
				blob = getBlob(columnIndex);
				if (blob != null)
					return blob.getBinaryStream();
				else
					return null;
			case Types.CHAR:
			case Types.VARCHAR:
			case Types.LONGVARCHAR:
			case Types.BINARY:
			case Types.VARBINARY:
			case Types.LONGVARBINARY:

				data = getString(columnIndex);

				if (data != null) {
					try {
						return new java.io.DataInputStream(
								new java.io.ByteArrayInputStream(data
										.getBytes("ASCII")));
					} catch (java.io.UnsupportedEncodingException e) {
						Object[] messageArguments = new Object[1];
						messageArguments[0] = e.getMessage();
						throw Messages.createSQLException(connection_.locale_,
								"unsupported_encoding", messageArguments);
					}
				} else
					return null;
			default:
				throw Messages.createSQLException(connection_.locale_,
						"restricted_data_type", null);
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getAsciiStream_I].methodExit();
		}
	}

	public InputStream getAsciiStream(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getAsciiStream(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getAsciiStream_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getAsciiStream(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getAsciiStream_L].methodExit();
		}
	}

	public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBigDecimal(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBigDecimal_I].methodEntry();
		try {
			int dataType;

			String data;
			BigDecimal retValue;
			double d;

			validateGetInvocation(columnIndex);
			outputDesc_[columnIndex - 1]
					.checkValidNumericConversion(connection_.locale_);

			// String returned may not be numeric in case of SQL_CHAR,
			// SQL_VARCHAR and SQL_LONGVARCHAR
			// fields. Hoping that java might throw invalid value exception
			data = getString(columnIndex);
			if (data != null) {
				data = data.trim();
				try {
					retValue = new BigDecimal(data);
				} catch (NumberFormatException e) {
					try {
						d = Double.parseDouble(data);
					} catch (NumberFormatException e1) {
						throw Messages.createSQLException(connection_.locale_,
								"invalid_cast_specification", null);
					}
					retValue = new BigDecimal(d);
				}
				return retValue;
			} else
				return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBigDecimal_I].methodExit();
		}
	}

	@Deprecated
	public BigDecimal getBigDecimal(int columnIndex, int scale)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBigDecimal(" + columnIndex + "," + scale + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBigDecimal_II].methodEntry();
		try {
			BigDecimal retValue;

			retValue = getBigDecimal(columnIndex);
			if (retValue != null)
				return retValue.setScale(scale);
			else
				return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBigDecimal_II].methodExit();
		}
	}

	public BigDecimal getBigDecimal(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBigDecimal(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBigDecimal_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getBigDecimal(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBigDecimal_L].methodExit();
		}
	}

	@Deprecated
	public BigDecimal getBigDecimal(String columnName, int scale)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBigDecimal(" + columnName + "," + scale + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBigDecimal_LI].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getBigDecimal(columnIndex, scale);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBigDecimal_LI].methodExit();
		}
	}

	public InputStream getBinaryStream(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBinaryStream(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBinaryStream_I].methodEntry();
		try {
			byte[] data;
			int dataType;
			Clob clob;
			Blob blob;

			validateGetInvocation(columnIndex);
			dataType = outputDesc_[columnIndex - 1].dataType_;
			switch (dataType) {
			case Types.CLOB:
				clob = getClob(columnIndex);
				if (clob != null)
					return clob.getAsciiStream();
				else
					return null;
			case Types.BLOB:
				blob = getBlob(columnIndex);
				if (blob != null)
					return blob.getBinaryStream();
				else
					return null;
			case Types.CHAR:
			case Types.VARCHAR:
			case Types.LONGVARCHAR:
			case Types.BINARY:
			case Types.VARBINARY:
			case Types.LONGVARBINARY:
				data = getBytes(columnIndex);
				if (data != null)
					return new java.io.ByteArrayInputStream(data);
				else
					return null;
			default:
				throw Messages.createSQLException(connection_.locale_,
						"restricted_data_type", null);
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBinaryStream_I].methodExit();
		}
	}

	public InputStream getBinaryStream(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBinaryStream(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBinaryStream_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getBinaryStream(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBinaryStream_L].methodExit();
		}
	}

	// JDK 1.2
	public Blob getBlob(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBlob(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBlob_I].methodEntry();
		try {
			int dataType;
			Object x;
			String data_locator;
			Blob data;
			String tableName;

			validateGetInvocation(columnIndex);
			dataType = outputDesc_[columnIndex - 1].dataType_;
			if (dataType != Types.BLOB)
				throw Messages.createSQLException(connection_.locale_,
						"restricted_data_type", null);
			DataWrapper row = getCurrentRow();
			x = row.getObject(columnIndex);
			wasNull_ = (x == null);
			if (wasNull_)
				data = null;
			else {
				if (x instanceof Blob)
					data = (Blob) x;
				else if (x instanceof String) {
					data_locator = (String)x; 
					data = new SQLMXBlob(connection_, data_locator);
					row.setObject(columnIndex, data);
					isAnyLob_ = true;
				} else if (x instanceof byte[]) {
					data_locator = new String((byte[])x);
					data = new SQLMXBlob(connection_, data_locator);
					row.setObject(columnIndex, data);
					isAnyLob_ = true;
				} else
					throw Messages.createSQLException(connection_.locale_,
							"restricted_data_type", null);
			}
			return data;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBlob_I].methodExit();
		}
	}

	// JDK 1.2
	public Blob getBlob(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBlob(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBlob_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getBlob(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBlob_L].methodExit();
		}
	}

	public boolean getBoolean(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBoolean(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBoolean_I].methodEntry();
		try {
			validateGetInvocation(columnIndex);
			outputDesc_[columnIndex - 1]
					.checkValidNumericConversion(connection_.locale_);
			DataWrapper row = getCurrentRow();
			wasNull_ = row.isNull(columnIndex);
			if (wasNull_)
				return false;

			return (row.getBoolean(columnIndex, connection_.locale_));
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBoolean_I].methodExit();
		}
	}

	public boolean getBoolean(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBoolean(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBoolean_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getBoolean(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBoolean_L].methodExit();
		}
	}

	public byte getByte(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getByte(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getByte_I].methodEntry();
		try {
			byte byteValue;

			validateGetInvocation(columnIndex);
			outputDesc_[columnIndex - 1]
					.checkValidNumericConversion(connection_.locale_);
			DataWrapper row = getCurrentRow();
			wasNull_ = row.isNull(columnIndex);
			if (wasNull_)
				return 0;

			byteValue = row.getByte(columnIndex, connection_.locale_);
			if (row.isTruncated(columnIndex))
				setSQLWarning(null, "data_truncation", null);
			return byteValue;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getByte_I].methodExit();
		}
	}

	public byte getByte(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getByte(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getByte_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getByte(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getByte_L].methodExit();
		}
	}

	public byte[] getBytes(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBytes(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBytes_I].methodEntry();
		try {
			int dataType;
			Blob blob;
			DataWrapper row;
			validateGetInvocation(columnIndex);
			dataType = outputDesc_[columnIndex - 1].dataType_;

			switch (dataType) {
			case Types.BINARY:
			case Types.VARBINARY:
			case Types.LONGVARBINARY:
			case Types.CHAR: // HP Extensions allows char,
			case Types.VARCHAR: // varchar, and
			case Types.LONGVARCHAR: // longvarchar data types
				row = getCurrentRow();
				wasNull_ = row.isNull(columnIndex);
				if (wasNull_)
					return null;

				// Currently the JNI layer (getObject) will always returns a
				// byte array
				// and therefore any other instance is considered a programming
				// error
				if (row.dataType[columnIndex - 1] == DataWrapper.BYTES)
					return row.getBytes(columnIndex);

				Object[] errMsg = new Object[1];
				errMsg[0] = "Invalid java instance for SQL data type";
				throw Messages.createSQLException(connection_.locale_,
						"programming_error", errMsg);
			case Types.BLOB: // HP Extension allows BLOB;
				blob = getBlob(columnIndex);
				wasNull_ = (blob == null);
				if ((wasNull_) || ((int) blob.length() == 0))
					return null;
				else
					return blob.getBytes(1L, (int) blob.length());
			default:
				throw Messages.createSQLException(connection_.locale_,
						"restricted_data_type", null);
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBytes_I].methodExit();
		}
	}

	public byte[] getBytes(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getBytes(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getBytes_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getBytes(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getBytes_L].methodExit();
		}
	}

	public Reader getCharacterStream(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getCharacterStream(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getCharacterStream_I].methodEntry();
		try {
			String data;
			int dataType;
			Clob clob;

			validateGetInvocation(columnIndex);
			dataType = outputDesc_[columnIndex - 1].dataType_;
			switch (dataType) {
			case Types.CLOB:
				clob = getClob(columnIndex);
				if (clob != null)
					return clob.getCharacterStream();
				else
					return null;
			case Types.CHAR:
			case Types.VARCHAR:
			case Types.LONGVARCHAR:
			case Types.BINARY:
			case Types.VARBINARY:
			case Types.LONGVARBINARY:
				data = getString(columnIndex);
				if (data != null)
					return new java.io.StringReader(data);
				else
					return null;
			default:
				throw Messages.createSQLException(connection_.locale_,
						"restricted_data_type", null);
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getCharacterStream_I].methodExit();
		}
	}

	public Reader getCharacterStream(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getCharacterStream(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getCharacterStream_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getCharacterStream(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getCharacterStream_L].methodExit();
		}
	}

	// JDK 1.2
	public Clob getClob(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getClob(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getClob_I].methodEntry();
		try {
			int dataType;
			String  data_locator;
			Clob data;
			String tableName;

			validateGetInvocation(columnIndex);
			dataType = outputDesc_[columnIndex - 1].dataType_;
			if (dataType != Types.CLOB)
				throw Messages.createSQLException(connection_.locale_,
						"restricted_data_type", null);
			DataWrapper row = getCurrentRow();
			Object x = row.getObject(columnIndex);
			wasNull_ = (x == null);
			if (wasNull_)
				data = null;
			else {
				if (x instanceof Clob)
					data = (Clob) x;
				else if (x instanceof String) {
					data_locator = (String) x;
					data = new SQLMXClob(connection_, data_locator);
					row.setObject(columnIndex, data);
					isAnyLob_ = true;
				} else if (x instanceof byte[]) {
					data_locator = new String((byte[])x);
					data = new SQLMXClob(connection_, data_locator);
					row.setObject(columnIndex, data);
					isAnyLob_ = true;
				} else
					throw Messages.createSQLException(connection_.locale_,
							"restricted_data_type", null);
			}
			return data;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getClob_I].methodExit();
		}
	}

	// JDK 1.2
	public Clob getClob(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getClob(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getClob_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getClob(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getClob_L].methodExit();
		}
	}

	public int getConcurrency() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getConcurrency()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getConcurrency].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (stmt_ != null)
				return stmt_.resultSetConcurrency_;
			else
				return ResultSet.CONCUR_READ_ONLY;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getConcurrency].methodExit();
		}
	}

	public String getCursorName() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getCursorName()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getCursorName].methodEntry();
		try {
			String cursorName;

			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (stmt_ != null) {
				cursorName = stmt_.cursorName_;
				if (cursorName == null)
					cursorName = stmt_.getStmtLabel_();
				return cursorName;
			} else
				return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getCursorName].methodExit();
		}
	}

	public Date getDate(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getDate(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getDate_I].methodEntry();
		try {
			int dataType;
			String dateStr;
			Date retValue;
			int endIndex;

			validateGetInvocation(columnIndex);
			dataType = outputDesc_[columnIndex - 1].dataType_;
			if (dataType != Types.CHAR && dataType != Types.VARCHAR
					&& dataType != Types.LONGVARCHAR && dataType != Types.DATE
					&& dataType != Types.TIMESTAMP)
				throw Messages.createSQLException(connection_.locale_,
						"restricted_data_type", null);
			dateStr = getString(columnIndex);
			if (dateStr != null) {
				try {
					retValue = Date.valueOf(dateStr);
				} catch (IllegalArgumentException e) {
					dateStr = dateStr.trim();
					if ((endIndex = dateStr.indexOf(' ')) != -1)
						dateStr = dateStr.substring(0, endIndex);
					try {
						retValue = Date.valueOf(dateStr);
						setSQLWarning(null, "data_truncation", null);

					} catch (IllegalArgumentException ex) {
						throw Messages.createSQLException(connection_.locale_,
								"invalid_cast_specification", null);
					}
				}
				return retValue;
			} else
				return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getDate_I].methodExit();
		}
	}

	public Date getDate(int columnIndex, Calendar cal) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getDate(" + columnIndex + "," + cal + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getDate_IL].methodEntry();
		try {
			Date sqlDate;
			java.util.Date d;

			sqlDate = getDate(columnIndex);
			if (sqlDate != null) {
				if (cal != null) {
					java.util.Calendar targetCalendar = java.util.Calendar
							.getInstance(cal.getTimeZone());
					targetCalendar.clear();
					targetCalendar.setTime(sqlDate);
					java.util.Calendar defaultCalendar = java.util.Calendar
							.getInstance();
					defaultCalendar.clear();
					defaultCalendar.setTime(sqlDate);
					long timeZoneOffset = targetCalendar
							.get(java.util.Calendar.ZONE_OFFSET)
							- defaultCalendar
									.get(java.util.Calendar.ZONE_OFFSET)
							+ targetCalendar.get(java.util.Calendar.DST_OFFSET)
							- defaultCalendar
									.get(java.util.Calendar.DST_OFFSET);
					sqlDate.setTime(sqlDate.getTime() - timeZoneOffset);
				}
				return sqlDate;
			} else
				return (sqlDate);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getDate_IL].methodExit();
		}
	}

	public Date getDate(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getDate(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getDate_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getDate(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getDate_L].methodExit();
		}
	}

	public Date getDate(String columnName, Calendar cal) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getDate(" + columnName + "," + cal + ")");
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getDate_SL].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getDate(columnIndex, cal);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getDate_SL].methodExit();
		}
	}

	//**************************************************************************
	// **
	// *
	// * METHOD: getDouble
	// *
	// * DESCRIPTION: This routine is called directly or by getDouble(string),
	// * getFloat(columnIndex), and by getFloat(string) to return the
	// * floating point value from the resultset. All of the result set
	// * data values are stored as string, and have to be converted from
	// * a string to a floating point value.
	// *
	// * INPUT: columIndex
	// *
	// * RETURN: double - a double floating point value, which is the result of
	// the
	// * string to floating point conversion.
	// *
	//**************************************************************************
	// **
	public double getDouble(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getDouble(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getDouble_I].methodEntry();
		try {
			validateGetInvocation(columnIndex); // Checks to see if valid column
			// name and row
			outputDesc_[columnIndex - 1]
					.checkValidNumericConversion(connection_.locale_); // This
			// routine
			// checks
			// to
			// see
			// that
			// it is
			// a
			// numeric
			// data
			// type
			DataWrapper row = getCurrentRow();
			wasNull_ = row.isNull(columnIndex);
			if (wasNull_)
				return 0;
			return row.getDouble(columnIndex, connection_.locale_);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getDouble_I].methodExit();
		}
	}

	public double getDouble(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getDouble(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getDouble_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getDouble(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getDouble_L].methodExit();
		}
	}

	public int getFetchDirection() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getFetchDirection()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getFetchDirection].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			return fetchDirection_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getFetchDirection].methodExit();
		}
	}

	public int getFetchSize() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getFetchSize()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getFetchSize].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			return fetchSize_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getFetchSize].methodExit();
		}
	}

	public float getFloat(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getFloat(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getFloat_I].methodEntry();
		try {
			validateGetInvocation(columnIndex);
			outputDesc_[columnIndex - 1]
					.checkValidNumericConversion(connection_.locale_);
			DataWrapper row = getCurrentRow();
			wasNull_ = row.isNull(columnIndex);
			if (wasNull_)
				return 0.0f;
			return row.getFloat(columnIndex, connection_.locale_);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getFloat_I].methodExit();
		}
	}

	public float getFloat(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getFloat(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getFloat_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getFloat(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getFloat_L].methodExit();
		}
	}

	public int getInt(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getInt(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getInt_I].methodEntry();
		if (JdbcDebugCfg.traceActive)
			debug[methodId_getInt_I].methodParameters("columnIndex = "
					+ columnIndex);
		try {
			validateGetInvocation(columnIndex);
			outputDesc_[columnIndex - 1]
					.checkValidNumericConversion(connection_.locale_);
			DataWrapper row = getCurrentRow();
			wasNull_ = row.isNull(columnIndex);
			if (wasNull_)
				return 0;

			int intValue = row.getInt(columnIndex, connection_.locale_);
			if (row.isTruncated(columnIndex))
				setSQLWarning(null, "data_truncation", null);
			return intValue;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getInt_I].methodExit();
		}
	}

	public int getInt(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getInt(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getInt_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getInt(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getInt_L].methodExit();
		}
	}

	public long getLong(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getLong(" + columnIndex + ")");

		if (JdbcDebugCfg.entryActive)
			debug[methodId_getLong_I].methodEntry();
		try {
			long longValue;

			validateGetInvocation(columnIndex);
			outputDesc_[columnIndex - 1]
					.checkValidNumericConversion(connection_.locale_);
			DataWrapper row = getCurrentRow();
			wasNull_ = row.isNull(columnIndex);
			if (wasNull_)
				return 0;
			longValue = row.getLong(columnIndex, connection_.locale_);
			if (row.isTruncated(columnIndex))
				setSQLWarning(null, "data_truncation", null);
			return longValue;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getLong_I].methodExit();
		}
	}

	public long getLong(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getLong(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getLong_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getLong(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getLong_L].methodExit();
		}
	}

	public ResultSetMetaData getMetaData() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getMetaData()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getMetaData].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			return new SQLMXResultSetMetaData(this, outputDesc_);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getMetaData].methodExit();
		}
	}

	public Object getObject(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getObject(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getObject_I].methodEntry();
		try {
			int dataType;
			byte byteValue;
			short shortValue;
			int intValue;
			long longValue;
			float floatValue;
			double doubleValue;
			boolean booleanValue;

			validateGetInvocation(columnIndex);
			dataType = outputDesc_[columnIndex - 1].dataType_;
			switch (dataType) {
			case Types.TINYINT:
				intValue = getByte(columnIndex);
				if (wasNull_)
					return null;
				else
					return new Integer(intValue);
			case Types.SMALLINT:
				intValue = getShort(columnIndex);
				if (wasNull_)
					return null;
				else
					return new Integer(intValue);
			case Types.INTEGER:
				intValue = getInt(columnIndex);
				if (wasNull_)
					return null;
				else
					return new Integer(intValue);
			case Types.BIGINT:
				longValue = getLong(columnIndex);
				if (wasNull_)
					return null;
				else
					return new Long(longValue);
			case Types.REAL:
				floatValue = getFloat(columnIndex);
				if (wasNull_)
					return null;
				else
					return new Float(floatValue);
			case Types.FLOAT:
			case Types.DOUBLE:
				doubleValue = getDouble(columnIndex);
				if (wasNull_)
					return null;
				else
					return new Double(doubleValue);
			case Types.DECIMAL:
			case Types.NUMERIC:
				return getBigDecimal(columnIndex);
			case Types.BIT:
				booleanValue = getBoolean(columnIndex);
				if (wasNull_)
					return null;
				else
					return new Boolean(booleanValue);
			case Types.CHAR:
			case Types.VARCHAR:
			case Types.LONGVARCHAR:
				return getString(columnIndex);
			case Types.BINARY:
			case Types.VARBINARY:
				return getBytes(columnIndex);
			case Types.LONGVARBINARY:
				return getBinaryStream(columnIndex);
			case Types.DATE:
				return getDate(columnIndex);
			case Types.TIME:
				return getTime(columnIndex);
			case Types.TIMESTAMP:
				return getTimestamp(columnIndex);
			case Types.BLOB:
				return getBlob(columnIndex);
			case Types.CLOB:
				return getClob(columnIndex);
			case Types.OTHER:
				return getString(columnIndex);
			default:
				throw Messages.createSQLException(connection_.locale_,
						"restricted_data_type", null);
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getObject_I].methodExit();
		}
	}

	// JDK 1.2
	public Object getObject(int columnIndex, Map map) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getObject(" + columnIndex + "," + map + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getObject_IL].methodEntry();
		try {
			validateGetInvocation(columnIndex);
			Messages.throwUnsupportedFeatureException(connection_.locale_,
					"getObject()");
			return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getObject_IL].methodExit();
		}
	}

	public Object getObject(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getObject(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getObject_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getObject(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getObject_L].methodExit();
		}
	}

	// JDK 1.2
	public Object getObject(String columnName, Map map) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getObject(" + columnName + "," + map + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getObject_LL].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getObject(columnIndex, map);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getObject_LL].methodExit();
		}
	}

	// JDK 1.2
	public Ref getRef(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getRef(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getRef_I].methodEntry();
		try {
			validateGetInvocation(columnIndex);
			Messages.throwUnsupportedFeatureException(connection_.locale_,
					"getRef()");
			return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getRef_I].methodExit();
		}
	}

	// JDK 1.2
	public Ref getRef(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getRef(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getRef_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getRef(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getRef_L].methodExit();
		}
	}

	public int getRow() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getRow()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getRow].methodEntry();
		try {
			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);

			if (isBeforeFirst_ || isAfterLast_ || onInsertRow_)
				return 0;

			if ((getType() == ResultSet.TYPE_FORWARD_ONLY)
					&& (getConcurrency() == ResultSet.CONCUR_UPDATABLE)) {
				return currentRowCount_;
			}

			return currentRow_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getRow].methodExit();
		}
	}

	public short getShort(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getShort(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getShort_I].methodEntry();
		try {
			short shortValue;

			validateGetInvocation(columnIndex);
			outputDesc_[columnIndex - 1]
					.checkValidNumericConversion(connection_.locale_);
			DataWrapper row = getCurrentRow();
			wasNull_ = row.isNull(columnIndex);
			if (wasNull_)
				return 0;
			shortValue = row.getShort(columnIndex, connection_.locale_);
			if (row.isTruncated(columnIndex))
				setSQLWarning(null, "data_truncation", null);
			return shortValue;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getShort_I].methodExit();
		}
	}

	public short getShort(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getShort(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getShort_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getShort(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getShort_L].methodExit();
		}
	}

	public Statement getStatement() throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getStatement].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			return stmt_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getStatement].methodExit();
		}
	}

	public String getString(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getString(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getString_I].methodEntry();
		if (JdbcDebugCfg.traceActive)
			debug[methodId_getString_I].methodParameters("columnIndex = "
					+ columnIndex);
		try {
			validateGetInvocation(columnIndex);
			DataWrapper row = getCurrentRow();
			wasNull_ = row.isNull(columnIndex);
			if (wasNull_)
				return null;

			// For the CLOB datatype the toString() DataWrapper call will return
			// the datalocator data from the base table. getString(col, x)
			// should be called to return the expected LOB table data.
			int dataType = outputDesc_[columnIndex - 1].dataType_;

			if ((dataType != Types.CLOB) && (row.isNumeric(columnIndex)))
				return row.getString(columnIndex);
			return getString(columnIndex, row.getObject(columnIndex));
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getString_I].methodExit();
		}
	}

	private String getString(int columnIndex, Object x) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getString_IL].methodEntry();
		try {
			String data = null;
			int dataType;
			int charsetcode;
			String charsetname;

			dataType = outputDesc_[columnIndex - 1].dataType_;
			switch (dataType) // The getString can not be used to get the
			// following six column types
			{ // Some of these types are not supported by SQL/MX, but here for
			// future
			case Types.BLOB:
			case Types.ARRAY:
			case Types.REF:
			case Types.STRUCT:
			case Types.DATALINK:
			case Types.JAVA_OBJECT:
				Object[] parmIndex = new Object[2];
				parmIndex[0] = new String("ResultSet.getString");
				parmIndex[1] = new Integer(columnIndex);
				throw Messages.createSQLException(connection_.locale_,
						"invalid_getter_for_column", parmIndex);
			case Types.CLOB:
				Clob clob = getClob(columnIndex);
				wasNull_ = (clob == null);
				if ((wasNull_)) { // || ((int) clob.length() == 0))
					return null;
				}
				else
					return clob.getSubString(1L, (int) clob.length());
			default:
				// Get character set code and translate to corresponding char
				// set name
				charsetcode = outputDesc_[columnIndex - 1].sqlCharset_;
				charsetname = SQLMXConnection.getCharsetEncodingCached(
						connection_.server_, connection_.getDialogueId(),
						charsetcode, connection_.iso88591EncodingOverride_);
				wasNull_ = false;
				try {
					if (x instanceof byte[]) {
						if (charsetname != null)
							data = new String((byte[]) x, charsetname);
						else
							data = new String((byte[]) x);
					} else {
						if (charsetname != null)
							data = new String(x.toString().getBytes(),
									charsetname);
						else
							data = x.toString();
					}
					if (stmt_ != null && stmt_.maxFieldSize_ != 0) {
						switch (dataType) {
						case Types.CHAR:
						case Types.VARCHAR:
						case Types.LONGVARCHAR:
						case Types.BINARY:
						case Types.VARBINARY:
						case Types.LONGVARBINARY:
							if (data.length() > stmt_.maxFieldSize_) {
								data = data.substring(0, stmt_.maxFieldSize_);
							}
							break;
						default:
						}
					}
				} catch (java.io.UnsupportedEncodingException e) {
					Object[] messageArguments = new Object[1];
					messageArguments[0] = e.getMessage();
					throw Messages.createSQLException(connection_.locale_,
							"unsupported_encoding", messageArguments);
				}
			}
			return data;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getString_IL].methodExit();
		}
	}

	public String getString(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getString(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getString_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getString(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getString_L].methodExit();
		}
	}

	public Time getTime(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getTime(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getTime_I].methodEntry();
		try {
			int dataType;
			String timeStr;
			Time retValue;
			Timestamp timestamp;

			validateGetInvocation(columnIndex);
			dataType = outputDesc_[columnIndex - 1].dataType_;
			if (dataType != Types.CHAR && dataType != Types.VARCHAR
					&& dataType != Types.LONGVARCHAR && dataType != Types.TIME
					&& dataType != Types.TIMESTAMP)
				throw Messages.createSQLException(connection_.locale_,
						"restricted_data_type", null);
			timeStr = getString(columnIndex);
			if (timeStr != null) {
				switch (dataType) {
				case Types.TIMESTAMP:
					try {
						timestamp = Timestamp.valueOf(timeStr);
						retValue = new Time(timestamp.getTime());
					} catch (IllegalArgumentException e) {
						throw Messages.createSQLException(connection_.locale_,
								"invalid_cast_specification", null);
					}
					break;
				case Types.CHAR:
				case Types.VARCHAR:
				case Types.LONGVARCHAR:
				case Types.TIME:
					switch (dataType) {
					case Types.CHAR:
					case Types.VARCHAR:
					case Types.LONGVARCHAR:
						timeStr = timeStr.trim();
						break;
					}
					try {
						retValue = Time.valueOf(timeStr);
					} catch (IllegalArgumentException e) {
						try {
							timestamp = Timestamp.valueOf(timeStr);
							retValue = new Time(timestamp.getTime());
						} catch (IllegalArgumentException ex) {
							throw Messages.createSQLException(
									connection_.locale_,
									"invalid_cast_specification", null);
						}
					}
					break;
				default:
					throw Messages.createSQLException(connection_.locale_,
							"restricted_data_type", null);
				}
				return retValue;
			} else
				return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getTime_I].methodExit();
		}
	}

	public Time getTime(int columnIndex, Calendar cal) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getTime(" + columnIndex + "," + cal + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getTime_IL].methodEntry();
		try {
			Time sqlTime;
			java.util.Date d;

			sqlTime = getTime(columnIndex);
			if (sqlTime != null) {
				if (cal != null) {
					java.util.Calendar targetCalendar = java.util.Calendar
							.getInstance(cal.getTimeZone());
					targetCalendar.clear();
					targetCalendar.setTime(sqlTime);
					java.util.Calendar defaultCalendar = java.util.Calendar
							.getInstance();
					defaultCalendar.clear();
					defaultCalendar.setTime(sqlTime);
					long timeZoneOffset = targetCalendar
							.get(java.util.Calendar.ZONE_OFFSET)
							- defaultCalendar
									.get(java.util.Calendar.ZONE_OFFSET)
							+ targetCalendar.get(java.util.Calendar.DST_OFFSET)
							- defaultCalendar
									.get(java.util.Calendar.DST_OFFSET);
					sqlTime.setTime(sqlTime.getTime() - timeZoneOffset);
				}
				return sqlTime;
			} else
				return (sqlTime);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getTime_IL].methodExit();
		}
	}

	/*
	 * 
	 * 
	 * METHOD: getResultSetInfo
	 * 
	 * DESCRIPTION: This method returns information about a ResultSet Object. It
	 * is only called from the SPJRS environment. In order for the MXUDR Server
	 * to return resultSet rows to the calling application it will need
	 * information about each underlying SQL/MX statement. If the result set is
	 * already closed or the (SPJ resultSet) stmId_ is zero, JDBC/MX assigns a
	 * value of 0 or null to all data elements. If the JNI method fails to load
	 * ctxHandle or the statement_id, JDBC/MX will also assign a value of 0 or
	 * null to all data elements.
	 * 
	 * INPUT: none
	 * 
	 * OUTPUT: LOBDataDetected - LOB column data was detected in the Result Set
	 * (equals a setting of True). connection - Connection object reference
	 * ctxHandle - The handle of the SQL/MX context that contains the underlying
	 * result set cursor. stmtID - The C++ pointer address of a SQLSTMT_ID
	 * has fetched from SQL/MX and that is still buffered in the JDBC/MX driver.
	 * forward-only cursor. TYPE_FORWARD_ONLY or TYPE_SCROLL_INSENSITIVE
	 * RSCounter - The value is a long and is incremented for each result set
	 * created. RSClosed - Set to true if RS is closed.
	 */
	public ResultSetInfo getResultSetInfo() throws SQLException {
		int dataType = 0; // dataType
		int colCount = 0; // Current Column index

		if (JdbcDebugCfg.entryActive)
			debug[methodId_getResultSetInfo].methodEntry();
		try {
			ResultSetInfo retValue; // Define ResultSetInfo return value
			retValue = new ResultSetInfo(); // Allocate ResultSetInfo

			clearWarnings();

			// Initialize variables
			retValue.LOBDataDetected = false;
			retValue.connection = null;
			retValue.ctxHandle = 0;
			retValue.stmtID = 0;
			retValue.firstBufferedRow = 0;
			retValue.lastBufferedRow = 0;
			retValue.currentRowPosition = 0;
			retValue.cursorType = 0;
			retValue.RSCounter = 0;

			retValue.RSClosed = false;
			retValue.stmtClosed = false; 

			/*
			 * The following two values need not be real. The real values are
			 * got after JNI Call
			 */
			retValue.RSClosed = this.isClosed_;
			if(this.stmt_!= null){
			retValue.stmtClosed = this.stmt_.isClosed_;
			}
			// Context Handle and Statement ID
			// Call to the C++ or JNI layer to retrieve ctxHandle and stmtID
			getResultSetInfo(connection_.getDialogueId(), stmtId_, retValue);
			if (retValue.stmtClosed) {
				retValue.RSClosed = retValue.stmtClosed;
			}

			if ((retValue.ctxHandle == 0) || (retValue.stmtID == 0)) {
				retValue.ctxHandle = 0; // Clear both variables on a failure
				retValue.stmtID = 0;
				return retValue; // return
			}


			// Information passed back to SQL for SPJRS
			// Connection Reference
			retValue.connection = connection_;

			// Last Row of Buffered Data
			retValue.lastBufferedRow = totalRowsFetched_; // Last index of
			// cached data =
			// total rows
			// fetched

			// First Row of Buffered Data
			// last index ptr - last rows cached + 1 (to offset -1 in rows
			// cached)
			// except if no rows fetched = 0
			if (totalRowsFetched_ != 0) {
				// first index of cached data = total rows fetched - rows cached
				// + 1
				retValue.firstBufferedRow = totalRowsFetched_ - numRows_ + 1;
			}

			// Current Row Position
			retValue.currentRowPosition = currentRowCount_;

			// Result set Type
			retValue.cursorType = resultSetType_;

			// ResultSet Counter
			retValue.RSCounter = resultSetCounter_;

			// Determine LOBDataDetected flag for a ResultSet
			// If LOB data is detected set LOBDataDetected flag to TRUE
			if (outputDesc_ != null) {
				// outputDesc_.length = # of columns in RS
				for (colCount = 0; colCount < outputDesc_.length; colCount++) {
					dataType = outputDesc_[colCount].dataType_;
					if ((dataType == Types.BLOB) || (dataType == Types.CLOB)) {
						retValue.LOBDataDetected = true;
						break;
					}
				}
			}
			return retValue;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getResultSetInfo].methodExit();
		}
	}

	public Time getTime(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getTime(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getTime_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getTime(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getTime_L].methodExit();
		}
	}

	public Time getTime(String columnName, Calendar cal) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getTime(" + columnName + "," + cal + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getTime_LL].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getTime(columnIndex, cal);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getTime_LL].methodExit();
		}
	}

	public Timestamp getTimestamp(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getTimestamp(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getTimestamp_I].methodEntry();
		try {
			int dataType;
			String timestampStr;
			Timestamp retValue;
			Date dateValue;
			Time timeValue;

			validateGetInvocation(columnIndex);
			dataType = outputDesc_[columnIndex - 1].dataType_;
			if (dataType != Types.CHAR && dataType != Types.VARCHAR
					&& dataType != Types.LONGVARCHAR && dataType != Types.DATE
					&& dataType != Types.TIMESTAMP)
				throw Messages.createSQLException(connection_.locale_,
						"restricted_data_type", null);
			timestampStr = getString(columnIndex);
			if (timestampStr != null) {
				switch (dataType) {
				case Types.DATE:
					try {
						dateValue = Date.valueOf(timestampStr);
						retValue = new Timestamp(dateValue.getTime());
					} catch (IllegalArgumentException e) {
						throw Messages.createSQLException(connection_.locale_,
								"invalid_cast_specification", null);
					}
					break;
				case Types.CHAR:
				case Types.VARCHAR:
				case Types.LONGVARCHAR:
				case Types.TIMESTAMP:
					switch (dataType) {
					case Types.CHAR:
					case Types.VARCHAR:
					case Types.LONGVARCHAR:
						timestampStr = timestampStr.trim();
						break;
					}
					try {
						retValue = Timestamp.valueOf(timestampStr);
					} catch (IllegalArgumentException e) {
						try {
							dateValue = Date.valueOf(timestampStr);
							retValue = new Timestamp(dateValue.getTime());
						} catch (IllegalArgumentException ex) {
							throw Messages.createSQLException(
									connection_.locale_,
									"invalid_cast_specification", null);
						}
					}
					break;
				default:
					throw Messages.createSQLException(connection_.locale_,
							"restricted_data_type", null);
				}
				return retValue;
			} else
				return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getTimestamp_I].methodExit();
		}
	}

	public Timestamp getTimestamp(int columnIndex, Calendar cal)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getTimestamp(" + columnIndex + "," + cal + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getTimestamp_IL].methodEntry();
		try {
			Timestamp sqlTimestamp;
			java.util.Date d;
			int nanos;

			sqlTimestamp = getTimestamp(columnIndex);
			if (sqlTimestamp != null) {
				if (cal != null) {
					int nano = sqlTimestamp.getNanos();
					java.util.Calendar targetCalendar = java.util.Calendar
							.getInstance(cal.getTimeZone());
					targetCalendar.clear();
					targetCalendar.setTime(sqlTimestamp);
					java.util.Calendar defaultCalendar = java.util.Calendar
							.getInstance();
					defaultCalendar.clear();
					defaultCalendar.setTime(sqlTimestamp);
					long timeZoneOffset = targetCalendar
							.get(java.util.Calendar.ZONE_OFFSET)
							- defaultCalendar
									.get(java.util.Calendar.ZONE_OFFSET)
							+ targetCalendar.get(java.util.Calendar.DST_OFFSET)
							- defaultCalendar
									.get(java.util.Calendar.DST_OFFSET);
					sqlTimestamp.setTime(sqlTimestamp.getTime()
							- timeZoneOffset);
					sqlTimestamp.setNanos(nano);
				}
				return sqlTimestamp;
			} else
				return (sqlTimestamp);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getTimestamp_IL].methodExit();
		}
	}

	public Timestamp getTimestamp(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getTimestamp(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getTimestamp_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getTimestamp(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getTimestamp_L].methodExit();
		}
	}

	public Timestamp getTimestamp(String columnName, Calendar cal)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getTimestamp(" + columnName + "," + cal + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getTimestamp_LL].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getTimestamp(columnIndex, cal);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getTimestamp_LL].methodExit();
		}
	}

	public int getType() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getType()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getType].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (stmt_ != null)
				return stmt_.resultSetType_;
			else
				return ResultSet.TYPE_FORWARD_ONLY;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getType].methodExit();
		}
	}

	@Deprecated
	public InputStream getUnicodeStream(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getUnicodeStream(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getUnicodeStream_I].methodEntry();
		try {
			String data;

			validateGetInvocation(columnIndex);
			data = getString(columnIndex);
			if (data != null) {
				try {
					return new java.io.ByteArrayInputStream(data
							.getBytes("UnicodeBigUnmarked"));
				} catch (java.io.UnsupportedEncodingException e) {
					Object[] messageArguments = new Object[1];
					messageArguments[0] = e.getMessage();
					throw Messages.createSQLException(connection_.locale_,
							"unsupported_encoding", messageArguments);
				}
			} else
				return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getUnicodeStream_I].methodExit();
		}
	}

	@Deprecated
	public InputStream getUnicodeStream(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getUnicodeStream(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getUnicodeStream_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getUnicodeStream(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getUnicodeStream_L].methodExit();
		}
	}

	public URL getURL(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getURL(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getURL_I].methodEntry();
		try {
			validateGetInvocation(columnIndex);
			Messages.throwUnsupportedFeatureException(connection_.locale_,
					"getURL()");
			return null;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getURL_I].methodExit();
		}
	}

	public URL getURL(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "getURL(\"" + columnName + "\")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getURL_L].methodEntry();
		try {
			int columnIndex = validateGetInvocation(columnName);
			return getURL(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getURL_L].methodExit();
		}
	}

	public void insertRow() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "insertRow()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_insertRow].methodEntry();
		try {
			int i;

			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getConcurrency() == ResultSet.CONCUR_READ_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"read_only_concur", null);
			if (!onInsertRow_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_position", null);
			prepareInsertStmt();
			DataWrapper insertRow = getCurrentRow();
			// Insert the row into database
			insertRow.insertRow(insertStmt_, paramCols_);
			// Add the row to the resultSet
			DataWrapper row = new DataWrapper(outputDesc_.length);
			row.copyRows(insertRow);
			row.setInserted();
			if (isBeforeFirst_ || isAfterLast_)
				i = currentRow_;
			else
				i = currentRow_ - 1;
			cachedRows_.add(i, row);
			numRows_++;
			if (isAnyLob_)
				closeLobObjects();
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_insertRow].methodExit();
		}
	}

	public boolean isAfterLast() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "isAfterLast()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_isAfterLast].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			return isAfterLast_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_isAfterLast].methodExit();
		}
	}

	public boolean isBeforeFirst() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "isBeforeFirst()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_isBeforeFirst].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			return isBeforeFirst_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_isBeforeFirst].methodExit();
		}
	}

	public boolean isFirst() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "isFirst()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_isFirst].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);

			if ((getType() == ResultSet.TYPE_FORWARD_ONLY)
					&& (getConcurrency() == ResultSet.CONCUR_UPDATABLE)) {
				if (!onInsertRow_ && currentRowCount_ == 1)
					return true;
				else
					return false;
			} else {
				if (!onInsertRow_ && currentRow_ == 1)
					return true;
				else
					return false;
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_isFirst].methodExit();
		}
	}

	public boolean isLast() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "isLast()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_isLast].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (!onInsertRow_ && endOfData_) {
				if (currentRow_ == numRows_)
					return true;
			}
			return false;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_isLast].methodExit();
		}
	}

	public boolean last() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "last()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_last].methodEntry();
		try {
			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getType() == ResultSet.TYPE_FORWARD_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"forward_only_cursor", null);
			if (isAnyLob_)
				closeLobObjects();
			onInsertRow_ = false;
			if (endOfData_) {
				currentRow_ = numRows_;
				isBeforeFirst_ = false;
				isAfterLast_ = false;
			} else
				while (next())
					;
			if (currentRow_ != 0) {
				isAfterLast_ = false;
				return true;
			} else
				return false;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_last].methodExit();
		}
	}

	public void moveToCurrentRow() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "moveToCurrentRow()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_moveToCurrentRow].methodEntry();
		try {
			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (!onInsertRow_)
				return;
			else {
				if (isAnyLob_)
					closeLobObjects();
				currentRow_ = savedCurrentRow_;
				onInsertRow_ = false;
				return;
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_moveToCurrentRow].methodExit();
		}
	}

	public void moveToInsertRow() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "moveToInsertRow()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_moveToInsertRow].methodEntry();
		try {
			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getConcurrency() == ResultSet.CONCUR_READ_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"read_only_concur", null);
			if (isAnyLob_)
				closeLobObjects();

			if (insertRow_ == null) {
				if (outputDesc_.length > 0) {
					insertRow_ = new DataWrapper(outputDesc_.length);
					insertRow_.setInsertRow();
				}
			}
			onInsertRow_ = true;
			savedCurrentRow_ = currentRow_;
			insertRow_.initDataWrapper();
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_moveToInsertRow].methodExit();
		}
	}

	public boolean next() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "next()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_next].methodEntry();
		try {
			boolean validRow = false;
			;
			int maxRowCnt;
			int maxRows;
			int queryTimeout;

			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (isAnyLob_)
				closeLobObjects();

			onInsertRow_ = false;
			if (currentRow_ < numRows_) {
				validRow = true;
				currentRow_++;
				isBeforeFirst_ = false;
			} else {
				if (endOfData_) {
					isAfterLast_ = true;
					isBeforeFirst_ = false;
				} else {
					if (stmt_ != null) {
					    if ((stmt_.maxRows_) > 0 && (stmt_.fetchSize_ > stmt_.maxRows_) )
							stmt_.setFetchSize(stmt_.maxRows_);
						maxRows = stmt_.maxRows_;
						queryTimeout = stmt_.queryTimeout_;
					} else {
						maxRows = 0;
						queryTimeout = 0;
					}

					// Calculate the MaxRowCnt here
					if (maxRows == 0
							|| maxRows > totalRowsFetched_ + fetchSize_)
						maxRowCnt = fetchSize_;
					else
						maxRowCnt = maxRows - totalRowsFetched_;
					if (maxRowCnt == 0)
						validRow = false;
					else {
						synchronized (connection_) {
							// Prevent a sig 11 due to an rs.next() after a
							// connection.close()
							// Note: Change is isolated to only prior to calling
							// the fetch to
							// prevent potential customer regression due to
							// behavior change.
							if (connection_.isClosed_) {
								if (stmt_ instanceof org.apache.trafodion.jdbc.t2.SQLMXPreparedStatement)
									close(false);
								else
									close(true);
								throw Messages.createSQLException(
										connection_.locale_,
										"invalid_cursor_state", null);
							}
							validRow = fetchN(connection_.server_, connection_
									.getDialogueId(), connection_.getTxid(),
									connection_.transactionMode_, stmtId_,
									maxRowCnt, queryTimeout, holdability_);
						}// End sync
					}
					if (validRow) {
						currentRow_++;
						isAfterLast_ = false;
						isBeforeFirst_ = false;
					} else {
						// In some cases endOfData_ is reached when fetchN
						// returns false;
						endOfData_ = true;
						isAfterLast_ = true;
						isBeforeFirst_ = false;
					}
				}
			}

			if (validRow) {
				currentRowCount_++;
			} else {
				currentRowCount_ = 0;
			}
			return validRow;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_next].methodExit();
		}
	}

	public boolean previous() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "previous()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_previous].methodEntry();
		try {
			boolean validRow = false;
			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getType() == ResultSet.TYPE_FORWARD_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"forward_only_cursor", null);
			if (isAnyLob_)
				closeLobObjects();
			onInsertRow_ = false;
			if (currentRow_ > 1) {
				currentRow_--;
				validRow = true;
				isBeforeFirst_ = false;
				isAfterLast_ = false;
			} else {
				currentRow_ = 0;
				isBeforeFirst_ = true;
				isAfterLast_ = false;
			}
			return validRow;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_previous].methodExit();
		}
	}

	public void refreshRow() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "refreshRow()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_refreshRow].methodEntry();
		try {
			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (onInsertRow_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_operation", null);
			if (getType() == ResultSet.TYPE_FORWARD_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"forward_only_cursor", null);
			if (getType() == ResultSet.TYPE_SCROLL_INSENSITIVE)
				return;
			if (getConcurrency() == ResultSet.CONCUR_READ_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"read_only_concur", null);

			prepareSelectStmt();
			getCurrentRow().refreshRow(connection_.locale_, selectStmt_,
					paramCols_, keyCols_);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_refreshRow].methodExit();
		}

	}

	public boolean relative(int row) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "relative(" + row + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_relative].methodEntry();
		try {
			int absRow;
			int rowInc;
			boolean flag = false;

			clearWarnings();
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (getType() == ResultSet.TYPE_FORWARD_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"forward_only_cursor", null);
			if (isAnyLob_)
				closeLobObjects();
			onInsertRow_ = false;
			if (row > 0) {
				rowInc = 0;
				do {
					flag = next();
					if (!flag)
						break;
				} while (++rowInc < row);
			} else {
				absRow = -row;
				if (absRow < currentRow_) {
					currentRow_ -= absRow;
					isAfterLast_ = false;
					isBeforeFirst_ = false;
					flag = true;
				} else
					beforeFirst();
			}
			return flag;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_relative].methodExit();
		}
	}

	public boolean rowDeleted() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "rowDeleted()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_rowDeleted].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (onInsertRow_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_operation", null);
			return getCurrentRow().getDeleted();
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_rowDeleted].methodExit();
		}
	}

	public boolean rowInserted() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "rowInserted()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_rowInserted].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (onInsertRow_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_operation", null);
			return getCurrentRow().getInserted();
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_rowInserted].methodExit();
		}
	}

	public boolean rowUpdated() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "rowUpdated()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_rowUpdated].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (onInsertRow_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_operation", null);
			return getCurrentRow().getUpdated();
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_rowUpdated].methodExit();
		}
	}

	public void setFetchDirection(int direction) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "setFetchDirection(" + direction + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_setFetchDirection].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			switch (direction) {
			case ResultSet.FETCH_FORWARD:
				fetchDirection_ = direction;
				break;
			case ResultSet.FETCH_REVERSE:
			case ResultSet.FETCH_UNKNOWN:
				fetchDirection_ = ResultSet.FETCH_FORWARD;
				break;
			default:
				throw Messages.createSQLException(connection_.locale_,
						"invalid_fetch_direction", null);
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_setFetchDirection].methodExit();
		}
	}

	public void setFetchSize(int rows) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "setFetchSize(" + rows + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_setFetchSize].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if (rows < 0)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_fetch_size", null);
			// Fetch size of zero means to take best guess.
			// Since we have no statistics, just leave as is.
			if (rows != 0)
				fetchSize_ = rows;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_setFetchSize].methodExit();
		}
	}

	public void updateArray(int columnIndex, Array x) throws SQLException {
		if (this.getTracer() != null)
		{
			this.getTracer().println(getTraceId() + "updateArray(" + columnIndex + "," + x + ")");
		}
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateArray_IL].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			Messages.throwUnsupportedFeatureException(connection_.locale_,
					"updateArray()");
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateArray_IL].methodExit();
		}
	}

	public void updateArray(String columnName, Array x) throws SQLException {
		if (this.getTracer() != null)
		{
			this.getTracer().println(getTraceId() + "updateArray(" + columnName + "," + x + ")");
		}

		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateArray_LL].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateArray(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateArray_LL].methodExit();
		}
	}

	public void updateAsciiStream(int columnIndex, InputStream x, int length)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateAsciiStream(" + columnIndex + "," + x + "," + length + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateAsciiStream_ILI].methodEntry();
		try {
			byte value[];

			validateUpdInvocation(columnIndex);
			value = new byte[length];
			try {
				x.read(value, 0, length);
			} catch (java.io.IOException e) {
				Object[] messageArguments = new Object[1];
				messageArguments[0] = e.getMessage();
				throw Messages.createSQLException(connection_.locale_,
						"io_exception", messageArguments);
			}
			try {
				getCurrentRow().setString(columnIndex,
						new String(value, "ASCII"));
			} catch (java.io.UnsupportedEncodingException e) {
				Object[] messageArguments = new Object[1];
				messageArguments[0] = e.getMessage();
				throw Messages.createSQLException(connection_.locale_,
						"unsupported_encoding", messageArguments);
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateAsciiStream_ILI].methodExit();
		}
	}

	public void updateAsciiStream(String columnName, InputStream x, int length)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateAsciiStream(" + columnName + "," + x + "," + length + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateAsciiStream_LLI].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateAsciiStream(columnIndex, x, length);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateAsciiStream_LLI].methodExit();
		}
	}

	public void updateBigDecimal(int columnIndex, BigDecimal x)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateBigDecimal(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateBigDecimal_IL].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setObject(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateBigDecimal_IL].methodExit();
		}
	}

	public void updateBigDecimal(String columnName, BigDecimal x)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateBigDecimal(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateBigDecimal_LL].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateBigDecimal(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateBigDecimal_LL].methodExit();
		}
	}

	public void updateBinaryStream(int columnIndex, InputStream x, int length)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateBinaryStream(" + columnIndex + "," + x +
			"," + length + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateBinaryStream_ILI].methodEntry();
		try {
			byte value[];

			validateUpdInvocation(columnIndex);
			value = new byte[length];
			try {
				x.read(value, 0, length);
			} catch (java.io.IOException e) {
				Object[] messageArguments = new Object[1];
				messageArguments[0] = e.getMessage();
				throw Messages.createSQLException(connection_.locale_,
						"io_exception", messageArguments);
			}
			getCurrentRow().setObject(columnIndex, value);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateBinaryStream_ILI].methodExit();
		}
	}

	public void updateBinaryStream(String columnName, InputStream x, int length)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateBinaryStream(" + columnName + "," + x +
			"," + length + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateBinaryStream_LLI].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateBinaryStream(columnIndex, x, length);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateBinaryStream_LLI].methodExit();
		}
	}

	public void updateBlob(int columnIndex, Blob x) throws SQLException {
		if (this.getTracer() != null)
		{
			this.getTracer().println(getTraceId() + "updateBlob(" + columnIndex + "," + x + ")");
		}

		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateBlob_IL].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setObject(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateBlob_IL].methodExit();
		}
	}

	public void updateBlob(String columnName, Blob x) throws SQLException {
		if (this.getTracer() != null)
		{
			this.getTracer().println(getTraceId() + "updateBlob(" + columnName + "," + x + ")");
		}

		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateBlob_LL].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateBlob(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateBlob_LL].methodExit();
		}
	}

	public void updateBoolean(int columnIndex, boolean x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateBoolean(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateBoolean_IZ].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setObject(columnIndex, new Boolean(x));
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateBoolean_IZ].methodExit();
		}
	}

	public void updateBoolean(String columnName, boolean x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateBoolean(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateBoolean_LZ].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateBoolean(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateBoolean_LZ].methodExit();
		}
	}

	public void updateByte(int columnIndex, byte x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateByte(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateByte_IZ].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setObject(columnIndex, new Byte(x));
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateByte_IZ].methodExit();
		}
	}

	public void updateByte(String columnName, byte x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateByte(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateByte_LZ].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateByte(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateByte_LZ].methodExit();
		}
	}

	public void updateBytes(int columnIndex, byte[] x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateBytes(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateBytes_IZ].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setBytes(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateBytes_IZ].methodExit();
		}
	}

	public void updateBytes(String columnName, byte[] x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateBytes(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateBytes_LZ].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateBytes(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateBytes_LZ].methodExit();
		}
	}

	public void updateCharacterStream(int columnIndex, Reader x, int length)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateCharacterStream(" + columnIndex + "," + x +
			"," + length + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateCharacterStream_ILI].methodEntry();
		try {
			char value[];

			validateUpdInvocation(columnIndex);
			value = new char[length];
			try {
				x.read(value, 0, length);
			} catch (java.io.IOException e) {
				Object[] messageArguments = new Object[1];
				messageArguments[0] = e.getMessage();
				throw Messages.createSQLException(connection_.locale_,
						"io_exception", messageArguments);
			}
			getCurrentRow().setString(columnIndex, new String(value));
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateCharacterStream_ILI].methodExit();
		}
	}

	public void updateCharacterStream(String columnName, Reader x, int length)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateCharacterStream(" + columnName + "," + x +
			"," + length + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateCharacterStream_LLI].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateCharacterStream(columnIndex, x, length);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateCharacterStream_LLI].methodExit();
		}
	}

	public void updateClob(int columnIndex, Clob x) throws SQLException {
		if (this.getTracer() != null)
		{
			this.getTracer().println(getTraceId() + "updateClob(" + columnIndex + "," + x + ")");
		}
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateClob_IL].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setClob(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateClob_IL].methodExit();
		}
	}

	public void updateClob(String columnName, Clob x) throws SQLException {
		if (this.getTracer() != null)
		{
			this.getTracer().println(getTraceId() + "updateClob(" + columnName + "," + x + ")");
		}

		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateClob_LL].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateClob(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateClob_LL].methodExit();
		}
	}

	public void updateDate(int columnIndex, Date x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateDate(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateDate_IL].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setObject(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateDate_IL].methodExit();
		}
	}

	public void updateDate(String columnName, Date x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateDate(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateDate_LL].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateDate(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateDate_LL].methodExit();
		}
	}

	public void updateDouble(int columnIndex, double x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateDouble(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateDouble_ID].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setDouble(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateDouble_ID].methodExit();
		}
	}

	public void updateDouble(String columnName, double x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateDouble(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateDouble_LD].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateDouble(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateDouble_LD].methodExit();
		}
	}

	public void updateFloat(int columnIndex, float x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateFloat(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateFloat_IF].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setFloat(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateFloat_IF].methodExit();
		}
	}

	public void updateFloat(String columnName, float x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateFloat(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateFloat_LF].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateDouble(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateFloat_LF].methodExit();
		}
	}

	public void updateInt(int columnIndex, int x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateInt(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateInt_II].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setInt(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateInt_II].methodExit();
		}
	}

	public void updateInt(String columnName, int x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateInt(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateInt_LI].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateDouble(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateInt_LI].methodExit();
		}
	}

	public void updateLong(int columnIndex, long x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateLong(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateLong_IJ].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setLong(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateLong_IJ].methodExit();
		}
	}

	public void updateLong(String columnName, long x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateLong(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateLong_LJ].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateLong(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateLong_LJ].methodExit();
		}
	}

	public void updateNull(int columnIndex) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateNull(" + columnIndex + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateNull_I].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setNull(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateNull_I].methodExit();
		}
	}

	public void updateNull(String columnName) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateNull(" + columnName + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateNull_L].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateNull(columnIndex);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateNull_L].methodExit();
		}
	}

	public void updateObject(int columnIndex, Object x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateObject(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateObject_IL].methodEntry();
		try {
			updateObject(columnIndex, x, 0);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateObject_IL].methodExit();
		}
	}

	public void updateObject(int columnIndex, Object x, int scale)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateObject(" + columnIndex + "," + x +
			"," + scale + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateObject_ILI].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setObject(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateObject_ILI].methodExit();
		}
	}

	public void updateObject(String columnName, Object x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateObject(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateObject_LL].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateObject(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateObject_LL].methodExit();
		}
	}

	public void updateObject(String columnName, Object x, int scale)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateObject(" + columnName + "," + x +
			"," + scale + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateObject_LLI].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateObject(columnIndex, x, scale);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateObject_LLI].methodExit();
		}
	}

	public void updateRef(int columnIndex, Ref x) throws SQLException {
		if (this.getTracer() != null)
		{
			this.getTracer().println(getTraceId() + "updateRef(" + columnIndex + "," + x + ")");
		}

		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateRef_IL].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			Messages.throwUnsupportedFeatureException(connection_.locale_,
					"updateRef()");
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateRef_IL].methodExit();
		}
	}

	public void updateRef(String columnName, Ref x) throws SQLException {
		if (this.getTracer() != null)
		{
			this.getTracer().println(getTraceId() + "updateRef(" + columnName + "," + x + ")");
		}

		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateRef_LL].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateRef(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateRef_LL].methodExit();
		}
	}

	public void updateRow() throws SQLException {

		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateRow()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateRow].methodEntry();
		try {
			clearWarnings();
			if (getConcurrency() == ResultSet.CONCUR_READ_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"read_only_concur", null);
			if (onInsertRow_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_position", null);
			prepareUpdateStmt();
			// Update the row in database
			getCurrentRow().updateRow(connection_.locale_, updateStmt_,
					paramCols_, keyCols_);
			if (isAnyLob_)
				closeLobObjects();
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateRow].methodExit();
		}
	}

	public void updateShort(int columnIndex, short x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateShort(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateShort_IS].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setShort(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateShort_IS].methodExit();
		}
	}

	public void updateShort(String columnName, short x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateShort(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateShort_LS].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateShort(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateShort_LS].methodExit();
		}
	}

	public void updateString(int columnIndex, String x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateString(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateString_IL].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setString(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateString_IL].methodExit();
		}
	}

	public void updateString(String columnName, String x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateString(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateString_LL].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateString(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateString_LL].methodExit();
		}
	}

	public void updateTime(int columnIndex, Time x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateTime(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateTime_IL].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setObject(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateTime_IL].methodExit();
		}
	}

	public void updateTime(String columnName, Time x) throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateTime(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateTime_LL].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateTime(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateTime_LL].methodExit();
		}
	}

	public void updateTimestamp(int columnIndex, Timestamp x)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateTimestamp(" + columnIndex + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateTimestamp_IL].methodEntry();
		try {
			validateUpdInvocation(columnIndex);
			getCurrentRow().setObject(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateTimestamp_IL].methodExit();
		}
	}

	public void updateTimestamp(String columnName, Timestamp x)
			throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "updateTimestamp(" + columnName + "," + x + ")");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_updateTimestamp_LL].methodEntry();
		try {
			int columnIndex = validateUpdInvocation(columnName);
			updateTimestamp(columnIndex, x);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_updateTimestamp_LL].methodExit();
		}
	}

	public boolean wasNull() throws SQLException {
		if (this.getTracer() != null)
			this.getTracer().println(getTraceId() + "wasNull()");
		
		if (JdbcDebugCfg.entryActive)
			debug[methodId_wasNull].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			return wasNull_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_wasNull].methodExit();
		}
	}

	void setColumnName(int columnIndex, String columnName) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_setColumnName].methodEntry();
		try {
			if (columnIndex < 1 || columnIndex > outputDesc_.length)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_column_index", null);
			outputDesc_[columnIndex - 1].name_ = columnName;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_setColumnName].methodExit();
		}
	}

	// Other methods
	void close(boolean dropStmt) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_close_Z].methodEntry();
		if (JdbcDebugCfg.traceActive)
			debug[methodId_close_Z].methodParameters(" dropStmt = " + dropStmt
					+ " for stmtId = " + stmtId_ + " = 0x"
					+ Long.toHexString(stmtId_) + " and resultSetIndex = "
					+ resultSetIndex_);
		try {
			int txid;

			if (!isClosed_) {
				clearWarnings();
				try {
					synchronized (connection_) {
						// Send the txid only when the transaction is started by
						// this resultSet
						// else don't send the transaction
						// This will ensure that ResultSet that started the
						// transaction will only
						// end the transaction
						txid = 0;
						if (txnStarted_) {
							if ((stmt_ != null) && (stmt_.isSPJResultSet_)) 
							{
								if ((stmt_.currentResultSetIndex_ == stmt_.resultSetIndex_)
										&& (stmt_.spjRSCommitCount_ == 1)) {
									txid = connection_.getTxid();
									stmt_.spjRSCommitCount_--;
								}
							} else
								txid = connection_.getTxid();
						}
						
						close(connection_.server_,
								connection_.getDialogueId(), txid,
								connection_.autoCommit_,
								connection_.transactionMode_, stmtId_, dropStmt);

						//Do not reuse a statement for a new query.
						//In SQL we do not support reusing the statement id for a new statement.
						if(dropStmt && (stmt_ != null)){
							this.stmt_.stmtId_ = 0;
						}
					}// End sync
				} finally {
					isClosed_ = true;
					if (stmt_ != null) {
						if (!(stmt_ instanceof org.apache.trafodion.jdbc.t2.SQLMXPreparedStatement)) {
							connection_.removeElement(stmt_);
							stmt_.resultSet_ = null;
						}
					}

				}
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_close_Z].methodExit();
		}
	}

	private int validateGetInvocation(String columnName) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_validateGetInvocation_L].methodEntry();
		try {
			int i;
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			for (i = 0; i < outputDesc_.length; i++) {
				if (columnName.equalsIgnoreCase(outputDesc_[i].name_))
					return i + 1;
			}
			throw Messages.createSQLException(connection_.locale_,
					"invalid_column_name", null);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_validateGetInvocation_L].methodExit();
		}
	}

	private void validateGetInvocation(int columnIndex) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_validateGetInvocation_I].methodEntry();
		try {
			if (isClosed_)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_cursor_state", null);
			if ((columnIndex < 1) || (columnIndex > outputDesc_.length))
				throw Messages.createSQLException(connection_.locale_,
						"invalid_column_index", null);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_validateGetInvocation_I].methodExit();
		}
	}

	private int validateUpdInvocation(String columnName) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_validateUpdInvocation_L].methodEntry();
		try {
			int i;
			if (getConcurrency() == ResultSet.CONCUR_READ_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"read_only_concur", null);
			for (i = 0; i < outputDesc_.length; i++) {
				if (columnName.equalsIgnoreCase(outputDesc_[i].name_))
					return i + 1;
			}
			throw Messages.createSQLException(connection_.locale_,
					"invalid_column_name", null);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_validateUpdInvocation_L].methodExit();
		}
	}

	private void validateUpdInvocation(int columnIndex) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_validateUpdInvocation_I].methodEntry();
		try {
			if (getConcurrency() == ResultSet.CONCUR_READ_ONLY)
				throw Messages.createSQLException(connection_.locale_,
						"read_only_concur", null);
			if (columnIndex < 1 || columnIndex > outputDesc_.length)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_column_index", null);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_validateUpdInvocation_I].methodExit();
		}
	}

	private DataWrapper getCurrentRow() throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getCurrentRow].methodEntry();
		try {
			if (onInsertRow_)
				return insertRow_;
			if (isBeforeFirst_)
				throw Messages.createSQLException(connection_.locale_,
						"cursor_is_before_first_row", null);
			if (isAfterLast_)
				throw Messages.createSQLException(connection_.locale_,
						"cursor_after_last_row", null);
			return (DataWrapper) cachedRows_.get(currentRow_ - 1);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getCurrentRow].methodExit();
		}
	}

	private int getRowCount() {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getRowCount].methodEntry();
		try {
			return numRows_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getRowCount].methodExit();
		}
	}

	void getKeyColumns() throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getKeyColumns].methodEntry();
		try {
			String colName;
			int index = 0;
			int rowCount;
			int colNo;
			int columnCount;
			StringBuffer insertColsStr;
			StringBuffer insertValueStr;
			StringBuffer updateStr;
			StringBuffer whereClause;
			StringBuffer selectWhereClause;
			StringBuffer selectClause;
			StringBuffer deleteWhereClause; 
			String keyCatalogNm;
			String keySchemaNm;
			String keyTableNm;
			String[] keyColumns;
			String columnName;

			if (noKeyFound_)
				throw Messages.createSQLException(connection_.locale_,
						"no_primary_key", null);
			DatabaseMetaData dbmd = connection_.getMetaData();
			ResultSetMetaData rsmd = getMetaData();
			// The table of the first column in the select list is being treated
			// as the table to be updated. Columns from the other tables are
			// ignored
			columnCount = rsmd.getColumnCount();
			keyCatalogNm = rsmd.getCatalogName(1);
			keySchemaNm = rsmd.getSchemaName(1);
			keyTableNm = rsmd.getTableName(1);
			ResultSet rs = dbmd.getPrimaryKeys(keyCatalogNm, keySchemaNm,
					keyTableNm);
			rowCount = ((SQLMXResultSet) rs).getRowCount();
			if (rowCount == 0) {
				noKeyFound_ = true;
				stmt_.resultSetConcurrency_ = ResultSet.CONCUR_READ_ONLY;
				// JDBC allows update stmts on tables w/out a primary key
				// defined if the stmt
				// is issued by the application. For updateable ResultSets, a
				// primary key
				// restriction is required to avoid updating more rows than
				// desired.
				throw Messages.createSQLException(connection_.locale_,
						"no_primary_key", null);
			}

			keyColumns = new String[rowCount];
			while (rs.next()) {
				colName = rs.getString(4);
				keyColumns[index++] = colName;
			}
			// Commented out since rs.close() will end the transaction and hence
			// the application
			// may not be able to fetch its next row. It is ok not to close,
			// since it is an internal
			// stmt
			// rs.close();
			// Check if Key columns are there in the result Set
			keyCols_ = new BitSet(columnCount);
			for (index = 0; index < keyColumns.length; index++) {
				for (colNo = 1; colNo <= columnCount; colNo++) {
					if (rsmd.getColumnName(colNo).equals(keyColumns[index])
							&& rsmd.getTableName(colNo).equals(keyTableNm)
							&& rsmd.getSchemaName(colNo).equals(keySchemaNm)
							&& rsmd.getCatalogName(colNo).equals(keyCatalogNm)) {
						keyCols_.set(colNo - 1);
						break;
					}
				}
				if (colNo > columnCount) {
					noKeyFound_ = true;
					stmt_.resultSetConcurrency_ = ResultSet.CONCUR_READ_ONLY;
					throw Messages.createSQLException(connection_.locale_,
							"primary_key_not_selected", null);
				}
			}
			// Create a Update, Insert, Delete and Select statements
			// Select statement where clause has only primary keys
			// Update and Delete statments where clause has all columns of the
			// table being modified
			// Update statement set clause doesn't contain the primary keys,
			// since it can't be updated
			// Insert statement has all the columns of the table in the value
			// list
			paramCols_ = new BitSet(columnCount);
			whereClause = new StringBuffer(2048).append(" where ");
			insertColsStr = new StringBuffer(2048).append("(");
			insertValueStr = new StringBuffer(2048).append(" values (");
			updateStr = new StringBuffer(2048).append(" set ");
			selectWhereClause = new StringBuffer(2048).append(" where ");
			selectClause = new StringBuffer(2048).append("select ");
			deleteWhereClause = new StringBuffer(2048).append(" where "); 
			for (colNo = 1; colNo < columnCount; colNo++) {
				if (rsmd.getTableName(colNo).equals(keyTableNm)
						&& rsmd.getSchemaName(colNo).equals(keySchemaNm)
						&& rsmd.getCatalogName(colNo).equals(keyCatalogNm)) {
					paramCols_.set(colNo - 1);
					columnName = rsmd.getColumnName(colNo);
					insertColsStr = insertColsStr.append(columnName).append(
							", ");
					insertValueStr = insertValueStr.append("?, ");

					if (!keyCols_.get(colNo - 1)) {
						updateStr = updateStr.append(columnName).append(
								" = ? , "); 
					} else {
						whereClause = whereClause.append(columnName).append(
								" = ? and "); 
						selectWhereClause = selectWhereClause
								.append(columnName).append(" = ?, ");
						// selectWhereClause =
						// selectWhereClause.append(columnName
						// ).append(" = ? and "); 
					}
					selectClause = selectClause.append(columnName).append(", ");
					deleteWhereClause = deleteWhereClause.append(columnName)
							.append(" = ? and "); 
				}
			}

			int length = 0; 
			length = updateStr.length() - 1; 
			paramCols_.set(colNo - 1);
			columnName = rsmd.getColumnName(columnCount);
			insertColsStr = insertColsStr.append(columnName).append(")");
			insertValueStr = insertValueStr.append("?)");

			if (keyCols_.get(columnCount - 1)) 
			{
				if ((columnCount == 1) && (columnName.equals(keyColumns[0]))) {
					// Only one column in the table, and it is the primary key,
					// append the "?" wildcard
					// for the update string set portion (ex.
					// "...set col1 = ?...").
					updateStr = updateStr.append(columnName).append(" = ? ");
				} else {
					// If updating more than one column, remove the trailing
					// ", " from the end
					// of the update string set portion (ex. will become
					// "...set col1 = ?, col2 = ?...").
					updateStr.delete(length - 2, length);
				}
				whereClause = whereClause.append(columnName).append(" = ?");
				selectWhereClause = selectWhereClause.append(columnName)
						.append(" = ?");
			} else {
				// The update is to be performed w/out a where clause (ex.
				// "update tbl set col1 =?")
				updateStr = updateStr.append(columnName).append(" = ? ");
				whereClause = whereClause.delete(whereClause.length() - 5,
						whereClause.length());
				selectWhereClause.delete(selectWhereClause.length() - 2,
						selectWhereClause.length());
				// selectWhereClause.delete(selectWhereClause.length()-5,
				// selectWhereClause.length());
			}
			deleteWhereClause = deleteWhereClause.append(columnName).append(
					" = ? "); 

			selectClause = selectClause.append(columnName).append(" from ");
			selectCmd_ = new StringBuffer(2048).append(selectClause).append(
					keyCatalogNm).append(".").append(keySchemaNm).append(".")
					.append(keyTableNm).append(selectWhereClause);
			deleteCmd_ = new StringBuffer(2048).append("delete from ").append(
					keyCatalogNm).append(".").append(keySchemaNm).append(".")
					.append(keyTableNm).append(deleteWhereClause); 
			insertCmd_ = new StringBuffer(2048).append("insert into ").append(
					keyCatalogNm).append(".").append(keySchemaNm).append(".")
					.append(keyTableNm).append(insertColsStr).append(
							insertValueStr);
			updateCmd_ = new StringBuffer(2048).append("update ").append(
					keyCatalogNm).append(".").append(keySchemaNm).append(".")
					.append(keyTableNm).append(updateStr).append(whereClause);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getKeyColumns].methodExit();
		}
	}

	void prepareDeleteStmt() throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_prepareDeleteStmt].methodEntry();
		try {
			if (deleteStmt_ == null) {
				if (deleteCmd_ == null)
					getKeyColumns();
				deleteStmt_ = (SQLMXPreparedStatement) connection_
						.prepareStatement(deleteCmd_.toString());
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_prepareDeleteStmt].methodExit();
		}
	}

	void prepareInsertStmt() throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_prepareInsertStmt].methodEntry();
		try {
			if (insertStmt_ == null) {
				if (insertCmd_ == null)
					getKeyColumns();
				insertStmt_ = (SQLMXPreparedStatement) connection_
						.prepareStatement(insertCmd_.toString());
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_prepareInsertStmt].methodExit();
		}
	}

	void prepareUpdateStmt() throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_prepareUpdateStmt].methodEntry();
		try {
			if (updateStmt_ == null) {
				if (updateCmd_ == null)
					getKeyColumns();
				updateStmt_ = (SQLMXPreparedStatement) connection_
						.prepareStatement(updateCmd_.toString());
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_prepareUpdateStmt].methodExit();
		}
	}

	void prepareSelectStmt() throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_prepareSelectStmt].methodEntry();
		try {
			if (selectStmt_ == null) {
				if (selectCmd_ == null)
					getKeyColumns();
				selectStmt_ = (SQLMXPreparedStatement) connection_
						.prepareStatement(selectCmd_.toString());
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_prepareSelectStmt].methodExit();
		}
	}

	void closeLobObjects() throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_closeLobObjects].methodEntry();
		try {
			try {
				((DataWrapper) getCurrentRow()).closeLobObjects();
				isAnyLob_ = false;
			} catch (SQLException se) {
			}
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_closeLobObjects].methodExit();
		}
	}

	// This method is called from the native method FetchN for user given SQL
	// statements. For
	// DatabaseMetaData catalog APIs also call this method to update the rows
	// fetched
	//
	void setFetchOutputs(DataWrapper[] row, int rowsFetched, boolean endOfData,
			int txid) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_setFetchOutputs].methodEntry();
		try {
			// numRows_ contain the number of rows in the ArrayList. In case of
			// TYPE_FORWARD_ONLY,
			// the numRows_ is reset to 0 whenever this method is called.
			// totalRowsFetched_ contain the total number of rows fetched
			if (getType() == ResultSet.TYPE_FORWARD_ONLY) {
				cachedRows_.clear();
				numRows_ = 0;
				currentRow_ = 0;
			}
			for (int i = 0; i < row.length; i++)
				cachedRows_.add(row[i]);
			// add to the totalRowsFetched
			totalRowsFetched_ += rowsFetched;
			numRows_ += rowsFetched;
			connection_.setTxid_(txid);
			endOfData_ = endOfData;
			isBeforeFirst_ = false;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_setFetchOutputs].methodExit();
		}
	}

	// Method used by JNI layer to set the Data Truncation warning
	void setDataTruncation(int index, boolean parameter, boolean read,
			int dataSize, int transferSize) {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_setDataTruncation].methodEntry();
		try {
			DataTruncation dtLeaf = new DataTruncation(index, parameter, read,
					dataSize, transferSize);
			if (sqlWarning_ == null)
				sqlWarning_ = dtLeaf;
			else
				sqlWarning_.setNextWarning(dtLeaf);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_setDataTruncation].methodExit();
		}
	}

	void setCurrentTxid(int txid) {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_setCurrentTxid].methodEntry();
		try {
			connection_.setTxid_(txid);
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_setCurrentTxid].methodExit();
		}
	}

	int getFSDataType(int ColumnCount) throws SQLException // 0 -based
	{
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getFSDataType].methodEntry();
		try {
			if (ColumnCount >= outputDesc_.length)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_column_index", null);
			else
				return outputDesc_[ColumnCount].fsDataType_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getFSDataType].methodExit();
		}
	}

	int getSQLDataType(int ColumnCount) throws SQLException // 0 -based
	{
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getSQLDataType].methodEntry();
		try {
			if (ColumnCount >= outputDesc_.length)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_column_index", null);
			else
				return outputDesc_[ColumnCount].sqlDataType_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getSQLDataType].methodExit();
		}
	}

	int getPrecision(int ColumnCount) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getPrecision].methodEntry();
		try {
			if (ColumnCount >= outputDesc_.length)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_column_index", null);
			else
				return outputDesc_[ColumnCount].precision_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getPrecision].methodExit();
		}
	}

	int getScale(int ColumnCount) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getScale].methodEntry();
		try {
			if (ColumnCount >= outputDesc_.length)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_column_index", null);
			else
				return outputDesc_[ColumnCount].scale_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getScale].methodExit();
		}
	}

	int getSqlDatetimeCode(int ColumnCount) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getSqlDatetimeCode].methodEntry();
		try {
			if (ColumnCount >= outputDesc_.length)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_column_index", null);
			else
				return outputDesc_[ColumnCount].sqlDatetimeCode_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getSqlDatetimeCode].methodExit();
		}
	}

	boolean getSigned(int ColumnCount) throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getSigned].methodEntry();
		try {
			if (ColumnCount >= outputDesc_.length)
				throw Messages.createSQLException(connection_.locale_,
						"invalid_column_index", null);
			else
				return outputDesc_[ColumnCount].isSigned_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getSigned].methodExit();
		}
	}
//Venu changed stmtId from int to long for 64 bit
	void setupResultSet(SQLMXDesc[] outputDesc, long stmtId) {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_setupResultSet].methodEntry();
		try {
			if (JdbcDebugCfg.traceActive)
				debug[methodId_setupResultSet]
						.methodParameters("  outputDesc = " + outputDesc
								+ "  stmdId = " + stmtId);
			// Add additional information to the result set that was
			// not avalible when the result set was created.
			outputDesc_ = outputDesc;
			stmtId_ = stmtId;
			resultSetCounter_ = connection_.getNextRSCount();
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_setupResultSet].methodExit();
		}
	}

	SQLMXDesc[] getOutputDesc() {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_getOutputDesc].methodEntry();
		try {
			return outputDesc_;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_getOutputDesc].methodExit();
		}
	}

	// Constructors - used in SQLMXStatement
	SQLMXResultSet(SQLMXStatement stmt, SQLMXDesc[] outputDesc)
			throws SQLException {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_SQLMXResultSet_LL].methodEntry();
		try {
			stmt_ = stmt;
			outputDesc_ = outputDesc;
			// update all the resultSet fields from stmt
			connection_ = stmt.connection_;
			concurrency_ = stmt.resultSetConcurrency_;
			fetchSize_ = stmt.fetchSize_;
			fetchDirection_ = stmt.fetchDirection_;
			stmtId_ = stmt.stmtId_;
			cachedRows_ = new ArrayList<DataWrapper>();
			isBeforeFirst_ = true;
			holdability_ = stmt.resultSetHoldability_;
			resultSetType_ = stmt.resultSetType_;
			resultSetIndex_ = stmt.resultSetIndex_;
			stmtId_ = stmt.stmtId_;

			if (JdbcDebugCfg.traceActive)
				debug[methodId_SQLMXResultSet_LL]
						.methodParameters("ResultSet created with resultSetIndex = "
								+ resultSetIndex_
								+ " and stmtId = "
								+ stmtId_
								+ " = 0x" + Long.toHexString(stmtId_));
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_SQLMXResultSet_LL].methodExit();
		}
	}

	// Constructor - used in SQLMXDatabaseMetaData
	// Venu changed stmtId from int to long for 64 bit
	SQLMXResultSet(SQLMXDatabaseMetaData dbMetaData, SQLMXDesc[] outputDesc,
			int txid, long stmtId) {
		if (JdbcDebugCfg.entryActive)
			debug[methodId_SQLMXResultSet_LLII].methodEntry();
		try {
			connection_ = dbMetaData.connection_;
			outputDesc_ = outputDesc;
			stmtId_ = stmtId;
			fetchSize_ = DEFAULT_FETCH_SIZE;
			stmt_ = null;

			// update all the resultSet stmt fields w/o stmt
			connection_ = dbMetaData.connection_;
			concurrency_ = ResultSet.CONCUR_READ_ONLY;
			fetchDirection_ = ResultSet.FETCH_FORWARD;
			cachedRows_ = new ArrayList<DataWrapper>();
			isBeforeFirst_ = true;
			holdability_ = CLOSE_CURSORS_AT_COMMIT;
			resultSetType_ = ResultSet.TYPE_FORWARD_ONLY;
			resultSetIndex_ = 0;
			stmtId_ = stmtId;

			// Check if the transaction is started by this Select statement
			if (connection_.getTxid() == 0 && txid != 0)
				txnStarted_ = true;
			connection_.setTxid_(txid);
			holdability_ = CLOSE_CURSORS_AT_COMMIT;
		} finally {
			if (JdbcDebugCfg.entryActive)
				debug[methodId_SQLMXResultSet_LLII].methodExit();
		}
	}

	// Native methods
	// venu changed dialogueId and stmtId from int to long for 64 bit
	private native boolean fetchN(String server, long dialogueId, int txid,
			int txnMode, long stmtId, int maxRowCnt, int queryTimeout,
			int holdability);
	// venu changed dialogueId and stmtId from int to long for 64 bit
	private native void close(String server, long dialogueId, int txid,
			boolean autocommit, int txnMode, long stmtId, boolean dropStmt);

	// SPJRS Native Method
	// venu changed dialogueId and stmtId from int to long for 64 bit
	private native void getResultSetInfo(long dialogueId, long stmtId,
			ResultSetInfo RSInfo);

	/**
	 * @param tracer
	 *            the tracer to set
	 */
	public void setTracer(PrintWriter tracer) {
	
		this.tracer = tracer;
	}

	/**
	 * @return the tracer
	 */
	public PrintWriter getTracer() {
		return tracer;
	}
	public void setTraceId(String traceId_) {
		this.traceId_ = traceId_;
	}

	public String getTraceId() {
		setTraceId(org.apache.trafodion.jdbc.t2.T2Driver.traceText
				+ org.apache.trafodion.jdbc.t2.T2Driver.dateFormat.format(new java.util.Date()) 
				+ "]:[" + Thread.currentThread() + "]:["
				+ System.identityHashCode(this) +  "]:"
				+ this.getClass().getName().substring(org.apache.trafodion.jdbc.t2.T2Driver.REMOVE_PKG_NAME,this.getClass().getName().length()) 
				+ ".");
		return traceId_;
	}
	

	// public static final int HOLD_CURSORS_OVER_COMMIT=1;
	// public static final int CLOSE_CURSORS_AT_COMMIT=2;
	// Fields
	SQLMXDesc[] outputDesc_;
	SQLMXStatement stmt_;
	int resultSetType_;
	long resultSetIndex_;
	long resultSetCounter_; // returned in getResultSetInfo
	int concurrency_;
	SQLMXConnection connection_;
	boolean isClosed_;
	int currentRow_;
	boolean endOfData_;
	HashMap<String, Integer> colMap_;
	// Fetch outputs updated by JNI Layer
	boolean wasNull_;
	int totalRowsFetched_;
	int fetchSize_;
	int fetchDirection_;
	//Venu changed stmtId_ from int to long for 64 bit
	long stmtId_;
	private PrintWriter tracer;
	private String traceId_ = null;

	ArrayList<DataWrapper> cachedRows_;
	boolean onInsertRow_;
	DataWrapper insertRow_;
	int savedCurrentRow_;
	boolean showInserted_;
	int numRows_;
	boolean isAfterLast_;
	boolean isBeforeFirst_;

	boolean noKeyFound_;
	StringBuffer deleteCmd_;
	StringBuffer insertCmd_;
	StringBuffer updateCmd_;
	StringBuffer selectCmd_;
	SQLMXPreparedStatement deleteStmt_;
	SQLMXPreparedStatement insertStmt_;
	SQLMXPreparedStatement updateStmt_;
	SQLMXPreparedStatement selectStmt_;
	BitSet paramCols_;
	BitSet keyCols_;

	int holdability_;

	int currentRowCount_ = 0;

	boolean txnStarted_;
	boolean isAnyLob_;
	protected static final int DEFAULT_FETCH_SIZE = 100;
	
	private static int methodId_absolute = 0;
	private static int methodId_afterLast = 1;
	private static int methodId_beforeFirst = 2;
	private static int methodId_cancelRowUpdates = 3;
	private static int methodId_close_V = 4;
	private static int methodId_deleteRow = 5;
	private static int methodId_findColumn = 6;
	private static int methodId_first = 7;
	private static int methodId_getArray_I = 8;
	private static int methodId_getArray_L = 9;
	private static int methodId_getAsciiStream_I = 10;
	private static int methodId_getAsciiStream_L = 11;
	private static int methodId_getBigDecimal_I = 12;
	private static int methodId_getBigDecimal_II = 13;
	private static int methodId_getBigDecimal_L = 14;
	private static int methodId_getBigDecimal_LI = 15;
	private static int methodId_getBinaryStream_I = 16;
	private static int methodId_getBinaryStream_L = 17;
	private static int methodId_getBlob_I = 18;
	private static int methodId_getBlob_L = 19;
	private static int methodId_getBoolean_I = 20;
	private static int methodId_getBoolean_L = 21;
	private static int methodId_getByte_I = 22;
	private static int methodId_getByte_L = 23;
	private static int methodId_getBytes_I = 24;
	private static int methodId_getBytes_L = 25;
	private static int methodId_getCharacterStream_I = 26;
	private static int methodId_getCharacterStream_L = 27;
	private static int methodId_getClob_I = 28;
	private static int methodId_getClob_L = 29;
	private static int methodId_getConcurrency = 30;
	private static int methodId_getCursorName = 31;
	private static int methodId_getDate_I = 32;
	private static int methodId_getDate_IL = 33;
	private static int methodId_getDate_L = 34;
	private static int methodId_getDate_SL = 35;
	private static int methodId_getDouble_I = 36;
	private static int methodId_getDouble_L = 37;
	private static int methodId_getFetchDirection = 38;
	private static int methodId_getFetchSize = 39;
	private static int methodId_getFloat_I = 40;
	private static int methodId_getFloat_L = 41;
	private static int methodId_getInt_I = 42;
	private static int methodId_getInt_L = 43;
	private static int methodId_getLong_I = 44;
	private static int methodId_getLong_L = 45;
	private static int methodId_getMetaData = 46;
	private static int methodId_getObject_I = 47;
	private static int methodId_getObject_IL = 48;
	private static int methodId_getObject_L = 49;
	private static int methodId_getObject_LL = 50;
	private static int methodId_getRef_I = 51;
	private static int methodId_getRef_L = 52;
	private static int methodId_getRow = 53;
	private static int methodId_getShort_I = 54;
	private static int methodId_getShort_L = 55;
	private static int methodId_getStatement = 56;
	private static int methodId_getString_I = 57;
	private static int methodId_getString_L = 58;
	private static int methodId_getTime_I = 59;
	private static int methodId_getTime_IL = 60;
	private static int methodId_getTime_L = 61;
	private static int methodId_getTime_LL = 62;
	private static int methodId_getTimestamp_I = 63;
	private static int methodId_getTimestamp_IL = 64;
	private static int methodId_getTimestamp_L = 65;
	private static int methodId_getTimestamp_LL = 66;
	private static int methodId_getType = 67;
	private static int methodId_getUnicodeStream_I = 68;
	private static int methodId_getUnicodeStream_L = 69;
	private static int methodId_getURL_I = 70;
	private static int methodId_getURL_L = 71;
	private static int methodId_insertRow = 72;
	private static int methodId_isAfterLast = 73;
	private static int methodId_isBeforeFirst = 74;
	private static int methodId_isFirst = 75;
	private static int methodId_isLast = 76;
	private static int methodId_last = 77;
	private static int methodId_moveToCurrentRow = 78;
	private static int methodId_moveToInsertRow = 79;
	private static int methodId_next = 80;
	private static int methodId_previous = 81;
	private static int methodId_refreshRow = 82;
	private static int methodId_relative = 83;
	private static int methodId_rowDeleted = 84;
	private static int methodId_rowInserted = 85;
	private static int methodId_rowUpdated = 86;
	private static int methodId_setFetchDirection = 87;
	private static int methodId_setFetchSize = 88;
	private static int methodId_updateArray_IL = 89;
	private static int methodId_updateArray_LL = 90;
	private static int methodId_updateAsciiStream_ILI = 91;
	private static int methodId_updateAsciiStream_LLI = 92;
	private static int methodId_updateBigDecimal_IL = 93;
	private static int methodId_updateBigDecimal_LL = 94;
	private static int methodId_updateBinaryStream_ILI = 95;
	private static int methodId_updateBinaryStream_LLI = 96;
	private static int methodId_updateBlob_IL = 97;
	private static int methodId_updateBlob_LL = 98;
	private static int methodId_updateBoolean_IZ = 99;
	private static int methodId_updateBoolean_LZ = 100;
	private static int methodId_updateByte_IZ = 101;
	private static int methodId_updateByte_LZ = 102;
	private static int methodId_updateBytes_IZ = 103;
	private static int methodId_updateBytes_LZ = 104;
	private static int methodId_updateCharacterStream_ILI = 105;
	private static int methodId_updateCharacterStream_LLI = 106;
	private static int methodId_updateClob_IL = 107;
	private static int methodId_updateClob_LL = 108;
	private static int methodId_updateDate_IL = 109;
	private static int methodId_updateDate_LL = 110;
	private static int methodId_updateDouble_ID = 111;
	private static int methodId_updateDouble_LD = 112;
	private static int methodId_updateFloat_IF = 113;
	private static int methodId_updateFloat_LF = 114;
	private static int methodId_updateInt_II = 115;
	private static int methodId_updateInt_LI = 116;
	private static int methodId_updateLong_IJ = 117;
	private static int methodId_updateLong_LJ = 118;
	private static int methodId_updateNull_I = 119;
	private static int methodId_updateNull_L = 120;
	private static int methodId_updateObject_IL = 121;
	private static int methodId_updateObject_ILI = 122;
	private static int methodId_updateObject_LL = 123;
	private static int methodId_updateObject_LLI = 124;
	private static int methodId_updateRef_IL = 125;
	private static int methodId_updateRef_LL = 126;
	private static int methodId_updateRow = 127;
	private static int methodId_updateShort_IS = 128;
	private static int methodId_updateShort_LS = 139;
	private static int methodId_updateString_IL = 130;
	private static int methodId_updateString_LL = 131;
	private static int methodId_updateTime_IL = 132;
	private static int methodId_updateTime_LL = 133;
	private static int methodId_updateTimestamp_IL = 134;
	private static int methodId_updateTimestamp_LL = 135;
	private static int methodId_wasNull = 136;
	private static int methodId_setColumnName = 137;
	private static int methodId_close_Z = 138;
	private static int methodId_validateGetInvocation_L = 139;
	private static int methodId_validateGetInvocation_I = 140;
	private static int methodId_validateUpdInvocation_L = 141;
	private static int methodId_validateUpdInvocation_I = 142;
	private static int methodId_getCurrentRow = 143;
	private static int methodId_getRowCount = 144;
	private static int methodId_getCharSetEncodingName = 145;
	private static int methodId_getKeyColumns = 146;
	private static int methodId_prepareDeleteStmt = 147;
	private static int methodId_prepareInsertStmt = 148;
	private static int methodId_prepareUpdateStmt = 149;
	private static int methodId_prepareSelectStmt = 150;
	private static int methodId_closeLobObjects = 151;
	private static int methodId_setFetchOutputs = 152;
	private static int methodId_setDataTruncation = 153;
	private static int methodId_setCurrentTxid = 154;
	private static int methodId_getFSDataType = 155;
	private static int methodId_getSQLDataType = 156;
	private static int methodId_getPrecision = 157;
	private static int methodId_getScale = 158;
	private static int methodId_getSqlDatetimeCode = 159;
	private static int methodId_getSigned = 160;
	private static int methodId_getString_IL = 162;
	private static int methodId_setupResultSet = 163;
	private static int methodId_getOutputDesc = 164;
	private static int methodId_SQLMXResultSet_LL = 165;
	private static int methodId_SQLMXResultSet_LLII = 166;
	private static int methodId_getResultSetInfo = 167;
	private static int totalMethodIds = 168;

	private static JdbcDebug[] debug;

	static {
		String className = "SQLMXResultSet";
		if (JdbcDebugCfg.entryActive) {
			debug = new JdbcDebug[totalMethodIds];
			debug[methodId_absolute] = new JdbcDebug(className, "absolute");
			debug[methodId_afterLast] = new JdbcDebug(className, "afterLast");
			debug[methodId_beforeFirst] = new JdbcDebug(className,
					"beforeFirst");
			debug[methodId_cancelRowUpdates] = new JdbcDebug(className,
					"cancelRowUpdates");
			debug[methodId_close_V] = new JdbcDebug(className, "close_V");
			debug[methodId_deleteRow] = new JdbcDebug(className, "deleteRow");
			debug[methodId_findColumn] = new JdbcDebug(className, "findColumn");
			debug[methodId_first] = new JdbcDebug(className, "first");
			debug[methodId_getArray_I] = new JdbcDebug(className, "getArray_I");
			debug[methodId_getArray_L] = new JdbcDebug(className, "getArray_L");
			debug[methodId_getAsciiStream_I] = new JdbcDebug(className,
					"getAsciiStream[I]");
			debug[methodId_getAsciiStream_L] = new JdbcDebug(className,
					"getAsciiStream[L]");
			debug[methodId_getBigDecimal_I] = new JdbcDebug(className,
					"getBigDecimal[I]");
			debug[methodId_getBigDecimal_II] = new JdbcDebug(className,
					"getBigDecimal[II]");
			debug[methodId_getBigDecimal_L] = new JdbcDebug(className,
					"getBigDecimal[L]");
			debug[methodId_getBigDecimal_LI] = new JdbcDebug(className,
					"getBigDecimal[LI]");
			debug[methodId_getBinaryStream_I] = new JdbcDebug(className,
					"getBinaryStream[I]");
			debug[methodId_getBinaryStream_L] = new JdbcDebug(className,
					"getBinaryStream[L]");
			debug[methodId_getBlob_I] = new JdbcDebug(className, "getBlob[I]");
			debug[methodId_getBlob_L] = new JdbcDebug(className, "getBlob[L]");
			debug[methodId_getBoolean_I] = new JdbcDebug(className,
					"getBoolean[I]");
			debug[methodId_getBoolean_L] = new JdbcDebug(className,
					"getBoolean[L]");
			debug[methodId_getByte_I] = new JdbcDebug(className, "getByte[I]");
			debug[methodId_getByte_L] = new JdbcDebug(className, "getByte[L]");
			debug[methodId_getBytes_I] = new JdbcDebug(className, "getBytes[I]");
			debug[methodId_getBytes_L] = new JdbcDebug(className, "getBytes[L]");
			debug[methodId_getCharacterStream_I] = new JdbcDebug(className,
					"getCharacterStream[I]");
			debug[methodId_getCharacterStream_L] = new JdbcDebug(className,
					"getCharacterStream[L]");
			debug[methodId_getClob_I] = new JdbcDebug(className, "getClob[I]");
			debug[methodId_getClob_L] = new JdbcDebug(className, "getClob[L]");
			debug[methodId_getConcurrency] = new JdbcDebug(className,
					"getConcurrency");
			debug[methodId_getCursorName] = new JdbcDebug(className,
					"getCursorName");
			debug[methodId_getDate_I] = new JdbcDebug(className, "getDate[I]");
			debug[methodId_getDate_IL] = new JdbcDebug(className, "getDate[IL]");
			debug[methodId_getDate_L] = new JdbcDebug(className, "getDate[L]");
			debug[methodId_getDate_SL] = new JdbcDebug(className, "getDate[SL]");
			debug[methodId_getDouble_I] = new JdbcDebug(className,
					"getDouble[I]");
			debug[methodId_getDouble_L] = new JdbcDebug(className,
					"getDouble[L]");
			debug[methodId_getFetchDirection] = new JdbcDebug(className,
					"getFetchDirection");
			debug[methodId_getFetchSize] = new JdbcDebug(className,
					"getFetchSize");
			debug[methodId_getFloat_I] = new JdbcDebug(className, "getFloat[I]");
			debug[methodId_getFloat_L] = new JdbcDebug(className, "getFloat[L]");
			debug[methodId_getInt_I] = new JdbcDebug(className, "getInt[I]");
			debug[methodId_getInt_L] = new JdbcDebug(className, "getInt[L]");
			debug[methodId_getLong_I] = new JdbcDebug(className, "getLong[I]");
			debug[methodId_getLong_L] = new JdbcDebug(className, "getLong[L]");
			debug[methodId_getMetaData] = new JdbcDebug(className,
					"getMetaData");
			debug[methodId_getObject_I] = new JdbcDebug(className,
					"getObject[I]");
			debug[methodId_getObject_IL] = new JdbcDebug(className,
					"getObject[IL]");
			debug[methodId_getObject_L] = new JdbcDebug(className,
					"getObject[L]");
			debug[methodId_getObject_LL] = new JdbcDebug(className,
					"getObject[LL]");
			debug[methodId_getRef_I] = new JdbcDebug(className, "getRef[I]");
			debug[methodId_getRef_L] = new JdbcDebug(className, "getRef[L]");
			debug[methodId_getRow] = new JdbcDebug(className, "getRow");
			debug[methodId_getShort_I] = new JdbcDebug(className, "getShort[I]");
			debug[methodId_getShort_L] = new JdbcDebug(className, "getShort[L]");
			debug[methodId_getStatement] = new JdbcDebug(className,
					"getStatement");
			debug[methodId_getString_I] = new JdbcDebug(className,
					"getString[I]");
			debug[methodId_getString_L] = new JdbcDebug(className,
					"getString[L]");
			debug[methodId_getTime_I] = new JdbcDebug(className, "getTime[I]");
			debug[methodId_getTime_IL] = new JdbcDebug(className, "getTime[IL]");
			debug[methodId_getTime_L] = new JdbcDebug(className, "getTime[L]");
			debug[methodId_getTime_LL] = new JdbcDebug(className, "getTime[LL]");
			debug[methodId_getTimestamp_I] = new JdbcDebug(className,
					"getTimestamp[I]");
			debug[methodId_getTimestamp_IL] = new JdbcDebug(className,
					"getTimestamp[IL]");
			debug[methodId_getTimestamp_L] = new JdbcDebug(className,
					"getTimestamp[L]");
			debug[methodId_getTimestamp_LL] = new JdbcDebug(className,
					"getTimestamp[LL]");
			debug[methodId_getType] = new JdbcDebug(className, "getType");
			debug[methodId_getUnicodeStream_I] = new JdbcDebug(className,
					"getUnicodeStream[I]");
			debug[methodId_getUnicodeStream_L] = new JdbcDebug(className,
					"getUnicodeStream[L]");
			debug[methodId_getURL_I] = new JdbcDebug(className, "getURL[I]");
			debug[methodId_getURL_L] = new JdbcDebug(className, "getURL[L]");
			debug[methodId_insertRow] = new JdbcDebug(className, "insertRow");
			debug[methodId_isAfterLast] = new JdbcDebug(className,
					"isAfterLast");
			debug[methodId_isBeforeFirst] = new JdbcDebug(className,
					"isBeforeFirst");
			debug[methodId_isFirst] = new JdbcDebug(className, "isFirst");
			debug[methodId_isLast] = new JdbcDebug(className, "isLast");
			debug[methodId_last] = new JdbcDebug(className, "last");
			debug[methodId_moveToCurrentRow] = new JdbcDebug(className,
					"moveToCurrentRow");
			debug[methodId_moveToInsertRow] = new JdbcDebug(className,
					"moveToInsertRow");
			debug[methodId_next] = new JdbcDebug(className, "next");
			debug[methodId_previous] = new JdbcDebug(className, "previous");
			debug[methodId_refreshRow] = new JdbcDebug(className, "refreshRow");
			debug[methodId_relative] = new JdbcDebug(className, "relative");
			debug[methodId_rowDeleted] = new JdbcDebug(className, "rowDeleted");
			debug[methodId_rowInserted] = new JdbcDebug(className,
					"rowInserted");
			debug[methodId_rowUpdated] = new JdbcDebug(className, "rowUpdated");
			debug[methodId_setFetchDirection] = new JdbcDebug(className,
					"setFetchDirection");
			debug[methodId_setFetchSize] = new JdbcDebug(className,
					"setFetchSize");
			debug[methodId_updateArray_IL] = new JdbcDebug(className,
					"updateArray[IL]");
			debug[methodId_updateArray_LL] = new JdbcDebug(className,
					"updateArray[LL]");
			debug[methodId_updateAsciiStream_ILI] = new JdbcDebug(className,
					"updateAsciiStream[ILI]");
			debug[methodId_updateAsciiStream_LLI] = new JdbcDebug(className,
					"updateAsciiStream[LLI]");
			debug[methodId_updateBigDecimal_IL] = new JdbcDebug(className,
					"updateBigDecimal[IL]");
			debug[methodId_updateBigDecimal_LL] = new JdbcDebug(className,
					"updateBigDecimal[LL]");
			debug[methodId_updateBinaryStream_ILI] = new JdbcDebug(className,
					"updateBinaryStream[ILI]");
			debug[methodId_updateBinaryStream_LLI] = new JdbcDebug(className,
					"updateBinaryStream[LLI]");
			debug[methodId_updateBlob_IL] = new JdbcDebug(className,
					"updateBlob[IL]");
			debug[methodId_updateBlob_LL] = new JdbcDebug(className,
					"updateBlob[LL]");
			debug[methodId_updateBoolean_IZ] = new JdbcDebug(className,
					"updateBoolean[IZ]");
			debug[methodId_updateBoolean_LZ] = new JdbcDebug(className,
					"updateBoolean[LZ]");
			debug[methodId_updateByte_IZ] = new JdbcDebug(className,
					"updateByte[IZ]");
			debug[methodId_updateByte_LZ] = new JdbcDebug(className,
					"updateByte[LZ]");
			debug[methodId_updateBytes_IZ] = new JdbcDebug(className,
					"updateBytes[IZ]");
			debug[methodId_updateBytes_LZ] = new JdbcDebug(className,
					"updateBytes[LZ]");
			debug[methodId_updateCharacterStream_ILI] = new JdbcDebug(
					className, "updateCharacterStream[ILI]");
			debug[methodId_updateCharacterStream_LLI] = new JdbcDebug(
					className, "updateCharacterStream[LLI]");
			debug[methodId_updateClob_IL] = new JdbcDebug(className,
					"updateClob[IL]");
			debug[methodId_updateClob_LL] = new JdbcDebug(className,
					"updateClob[LL]");
			debug[methodId_updateDate_IL] = new JdbcDebug(className,
					"updateDate[IL]");
			debug[methodId_updateDate_LL] = new JdbcDebug(className,
					"updateDate[LL]");
			debug[methodId_updateDouble_ID] = new JdbcDebug(className,
					"updateDouble[ID]");
			debug[methodId_updateDouble_LD] = new JdbcDebug(className,
					"updateDouble[LD]");
			debug[methodId_updateFloat_IF] = new JdbcDebug(className,
					"updateFloat[IF]");
			debug[methodId_updateFloat_LF] = new JdbcDebug(className,
					"updateFloat[LF]");
			debug[methodId_updateInt_II] = new JdbcDebug(className,
					"updateInt[II]");
			debug[methodId_updateInt_LI] = new JdbcDebug(className,
					"updateInt[LI]");
			debug[methodId_updateLong_IJ] = new JdbcDebug(className,
					"updateLong[IJ]");
			debug[methodId_updateLong_LJ] = new JdbcDebug(className,
					"updateLong[LJ]");
			debug[methodId_updateNull_I] = new JdbcDebug(className,
					"updateNull[I]");
			debug[methodId_updateNull_L] = new JdbcDebug(className,
					"updateNull[L]");
			debug[methodId_updateObject_IL] = new JdbcDebug(className,
					"updateObject[IL]");
			debug[methodId_updateObject_ILI] = new JdbcDebug(className,
					"updateObject[ILI]");
			debug[methodId_updateObject_LL] = new JdbcDebug(className,
					"updateObject[LL]");
			debug[methodId_updateObject_LLI] = new JdbcDebug(className,
					"updateObject[LLI]");
			debug[methodId_updateRef_IL] = new JdbcDebug(className,
					"updateRef[IL]");
			debug[methodId_updateRef_LL] = new JdbcDebug(className,
					"updateRef[LL]");
			debug[methodId_updateRow] = new JdbcDebug(className, "updateRow");
			debug[methodId_updateShort_IS] = new JdbcDebug(className,
					"updateShort[IS]");
			debug[methodId_updateShort_LS] = new JdbcDebug(className,
					"updateShort[LS]");
			debug[methodId_updateString_IL] = new JdbcDebug(className,
					"updateString[IL]");
			debug[methodId_updateString_LL] = new JdbcDebug(className,
					"updateString[LL]");
			debug[methodId_updateTime_IL] = new JdbcDebug(className,
					"updateTime[IL]");
			debug[methodId_updateTime_LL] = new JdbcDebug(className,
					"updateTime[LL]");
			debug[methodId_updateTimestamp_IL] = new JdbcDebug(className,
					"updateTimestamp[IL]");
			debug[methodId_updateTimestamp_LL] = new JdbcDebug(className,
					"updateTimestamp[LL]");
			debug[methodId_wasNull] = new JdbcDebug(className, "wasNull");
			debug[methodId_setColumnName] = new JdbcDebug(className,
					"setColumnName");
			debug[methodId_close_Z] = new JdbcDebug(className, "close[Z]");
			debug[methodId_validateGetInvocation_L] = new JdbcDebug(className,
					"validateGetInvocation[L]");
			debug[methodId_validateGetInvocation_I] = new JdbcDebug(className,
					"validateGetInvocation[I]");
			debug[methodId_validateUpdInvocation_L] = new JdbcDebug(className,
					"validateUpdInvocation[L]");
			debug[methodId_validateUpdInvocation_I] = new JdbcDebug(className,
					"validateUpdInvocation[I]");
			debug[methodId_getCurrentRow] = new JdbcDebug(className,
					"getCurrentRow");
			debug[methodId_getRowCount] = new JdbcDebug(className,
					"getRowCount");
			debug[methodId_getCharSetEncodingName] = new JdbcDebug(className,
					"getCharSetEncodingName");
			debug[methodId_getKeyColumns] = new JdbcDebug(className,
					"getKeyColumns");
			debug[methodId_prepareDeleteStmt] = new JdbcDebug(className,
					"prepareDeleteStmt");
			debug[methodId_prepareInsertStmt] = new JdbcDebug(className,
					"prepareInsertStmt");
			debug[methodId_prepareUpdateStmt] = new JdbcDebug(className,
					"prepareUpdateStmt");
			debug[methodId_prepareSelectStmt] = new JdbcDebug(className,
					"prepareSelectStmt");
			debug[methodId_closeLobObjects] = new JdbcDebug(className,
					"closeLobObjects");
			debug[methodId_setFetchOutputs] = new JdbcDebug(className,
					"setFetchOutputs");
			debug[methodId_setDataTruncation] = new JdbcDebug(className,
					"setDataTruncation");
			debug[methodId_setCurrentTxid] = new JdbcDebug(className,
					"setCurrentTxid");
			debug[methodId_getFSDataType] = new JdbcDebug(className,
					"getFSDataType");
			debug[methodId_getSQLDataType] = new JdbcDebug(className,
					"getSQLDataType");
			debug[methodId_getPrecision] = new JdbcDebug(className,
					"getPrecision");
			debug[methodId_getScale] = new JdbcDebug(className, "getScale");
			debug[methodId_getSqlDatetimeCode] = new JdbcDebug(className,
					"getSqlDatetimeCode");
			debug[methodId_getSigned] = new JdbcDebug(className, "getSigned");
			debug[methodId_getString_IL] = new JdbcDebug(className,
					"getString[IL]");
			debug[methodId_setupResultSet] = new JdbcDebug(className,
					"setupResultSet");
			debug[methodId_getOutputDesc] = new JdbcDebug(className,
					"getOutputDesc");
			debug[methodId_SQLMXResultSet_LL] = new JdbcDebug(className,
					"SQLMXResultSet[LL]");
			debug[methodId_SQLMXResultSet_LLII] = new JdbcDebug(className,
					"SQLMXResultSet[LLII]");
			debug[methodId_getResultSetInfo] = new JdbcDebug(className,
					"getResultSetInfo");
		}
	}

	public Object unwrap(Class iface) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public boolean isWrapperFor(Class iface) throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	public RowId getRowId(int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public RowId getRowId(String columnLabel) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public void updateRowId(int columnIndex, RowId x) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateRowId(String columnLabel, RowId x) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public int getHoldability() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	public void updateNString(int columnIndex, String nString)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateNString(String columnLabel, String nString)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateNClob(String columnLabel, NClob nClob)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public NClob getNClob(int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public NClob getNClob(String columnLabel) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public SQLXML getSQLXML(int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public SQLXML getSQLXML(String columnLabel) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public void updateSQLXML(int columnIndex, SQLXML xmlObject)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateSQLXML(String columnLabel, SQLXML xmlObject)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public String getNString(int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public String getNString(String columnLabel) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public Reader getNCharacterStream(int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public Reader getNCharacterStream(String columnLabel) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public void updateNCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateNCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateAsciiStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateBinaryStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateAsciiStream(String columnLabel, InputStream x, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateBinaryStream(String columnLabel, InputStream x,
			long length) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateBlob(int columnIndex, InputStream inputStream, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateBlob(String columnLabel, InputStream inputStream,
			long length) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateNClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateNClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateNCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateNCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateAsciiStream(int columnIndex, InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateBinaryStream(int columnIndex, InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateAsciiStream(String columnLabel, InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateBinaryStream(String columnLabel, InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateBlob(int columnIndex, InputStream inputStream)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateBlob(String columnLabel, InputStream inputStream)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateClob(int columnIndex, Reader reader) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateClob(String columnLabel, Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateNClob(int columnIndex, Reader reader) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void updateNClob(String columnLabel, Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public Object getObject(int columnIndex, Class type) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public Object getObject(String columnLabel, Class type)
			throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

        public boolean isClosed() throws SQLException {
               return false;
        }
    public SQLMXDesc[] getResultSetDesc(){
        return outputDesc_;
    }
    public int getTotalRowsFetched(){
        return totalRowsFetched_;
    }
    public int getCurrentRowNumber(){
        return currentRow_;
    }
    public ArrayList<DataWrapper> getCachedRows(){
        ArrayList<DataWrapper> lcachedRows_ = cachedRows_;
        return lcachedRows_;
    }
    public byte[] getSQLBytes(int columnIndex)  throws SQLException {
        DataWrapper row;
        row = (DataWrapper)cachedRows_.get(currentRow_ - 1);
        return row.getSQLBytes(columnIndex);
    }
  
    String getLobLocator(int columnIndex) throws SQLException 
    {
        Object x;
        String data = null;

        validateGetInvocation(columnIndex);
        int dataType = outputDesc_[columnIndex - 1].dataType_;
        if (dataType != Types.CLOB && dataType != Types.BLOB)
           throw Messages.createSQLException(connection_.locale_, "restricted_data_type", null);
        DataWrapper row = getCurrentRow();
        wasNull_ = row.isNull(columnIndex);
        if (wasNull_)
           return null;
        x = row.getObject(columnIndex);
        wasNull_ = (x == null);
        if (wasNull_)
           data = null;
        else {
           if (x instanceof String) {
               data = (String)x;
           } else if (x instanceof byte[]) {
               data = new String((byte[])x);
           } 
        }
        return data;
    }

//--------------------------
}
