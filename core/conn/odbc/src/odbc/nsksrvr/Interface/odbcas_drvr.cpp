/**********************************************************************
// @@@ START COPYRIGHT @@@
//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// @@@ END COPYRIGHT @@@
********************************************************************/
/*
 * Translation unit: ODBCAS
 * Generated by CNPGEN(TANTAU CNPGEN TANTAU_AG_PC8 20001120.103031) on Tue Jan 21 13:12:34 2003
 * Code file for use with the CEE
 * Client functionality included
 */
#include <platform_ndcs.h>
#include <stdarg.h>
#include <cee.h>
#if CEE_H_VERSION != 19991123
#error Version mismatch CEE_H_VERSION != 19991123
#endif
#include <idltype.h>
#if IDL_TYPE_H_VERSION != 19971225
#error Version mismatch IDL_TYPE_H_VERSION != 19971225
#endif
#include "odbcCommon.h"
#include "odbcsrvrcommon.h"
#include "odbcas_cl.h"
#include "Transport.h"
#include "FileSystemDrvr.h"
#include "marshaling.h"
#include "marshalingsrvr_drvr.h"
#include "Global.h"

extern SRVR_GLOBAL_Def *srvrGlobal;

namespace SRVR {
extern void exitServerProcess(void);
}

extern void logError( short Code, short Severity, short Operation );
extern char errStrBuf1[], errStrBuf2[], errStrBuf3[], errStrBuf4[], errStrBuf5[];

/*******************
 * Module 'odbcas' *
 *******************/

/****************************
 * Interface 'odbcas_ASSvc' *
 ****************************/

/***************************************
 * Operation 'odbcas_ASSvc_RegProcess' *
 ***************************************/

typedef void (*odbcas_ASSvc_RegProcess_cct_) (
    /* In    */ CEE_tag_def cmptag_
  , /* In    */ const struct odbcas_ASSvc_RegProcess_exc_ *exception_
  , /* In    */ const SRVR_CONTEXT_def *srvrContext
  );
/*
 * Call completion wrapper for
 * operation 'odbcas_ASSvc_RegProcess'
 */
static void
odbcas_ASSvc_RegProcess_ccw_(
    /* In    */ CEE_tag_def tag1_
  , /* In    */ CEE_tag_def tag2_
  , /* In    */ const void *const *pv_)
{
  odbcas_ASSvc_RegProcess_cct_ f_;
  *((CEE_tag_def *) &f_) = tag1_;
  (*f_) (
      tag2_
    , (struct odbcas_ASSvc_RegProcess_exc_ *) pv_[1]
    , (SRVR_CONTEXT_def *) pv_[2]
    );
}
/*
 * Asynchronous object call for
 * operation 'odbcas_ASSvc_RegProcess'
 */
extern CEE_status
odbcas_ASSvc_RegProcess_pst_(
    /* In    */ const CEE_handle_def *ph_
  , /* In    */ CEE_tag_def tag_
  , /* In    */ odbcas_ASSvc_RegProcess_cct_ rtn_
  , /* In    */ const VERSION_def *intfVersion
  , /* In    */ IDL_long srvrType
  , /* In    */ const IDL_char *srvrObjRef
  , /* In    */ const PROCESS_ID_def *nskProcessInfo
  )
{
	CEE_status retcode = CEE_SUCCESS;
	bool sts;
	long wlength,rlength;
	char* wbuffer, *rbuffer;

//#ifdef JAVA_AS
	void *pv_[3] = {0};
	odbcas_ASSvc_RegProcess_ccw_(
	    /* In    */ (void *) rtn_
	  , /* In    */ tag_
	  , /* In    */ pv_);
	return retcode;
}
/********************************************
 * Operation 'odbcas_ASSvc_UpdateSrvrState' *
 ********************************************/
/*
 * Call Completion function pointer type for
 * operation 'odbcas_ASSvc_UpdateSrvrState'
 */
typedef void (*odbcas_ASSvc_UpdateSrvrState_cct_) (
    /* In    */ CEE_tag_def cmptag_
  , /* In    */ const struct odbcas_ASSvc_UpdateSrvrState_exc_ *exception_
  , /* In    */ IDL_long TraceType
  , /* In    */ IDL_long StatisticsType
  , /* In    */ IDL_long ContextType
  , /* In    */ const SRVR_CONTEXT_def *srvrContext
  );
/*
 * Call completion wrapper for
 * operation 'odbcas_ASSvc_UpdateSrvrState'
 */
static void
odbcas_ASSvc_UpdateSrvrState_ccw_(
    /* In    */ CEE_tag_def tag1_
  , /* In    */ CEE_tag_def tag2_
  , /* In    */ const void *const *pv_)
{
  odbcas_ASSvc_UpdateSrvrState_cct_ f_;
  *((CEE_tag_def *) &f_) = tag1_;
  (*f_) (
      tag2_
    , (struct odbcas_ASSvc_UpdateSrvrState_exc_ *) pv_[1]
    , *(IDL_long *) pv_[2]
    , *(IDL_long *) pv_[3]
    , *(IDL_long *) pv_[4]
    , (SRVR_CONTEXT_def *) pv_[5]
    );
}
/*
 * Asynchronous object call for
 * operation 'odbcas_ASSvc_UpdateSrvrState'
 */
extern CEE_status
odbcas_ASSvc_UpdateSrvrState_pst_(
    /* In    */ const CEE_handle_def *ph_
  , /* In    */ CEE_tag_def tag_
  , /* In    */ odbcas_ASSvc_UpdateSrvrState_cct_ rtn_
  , /* In    */ IDL_long srvrType
  , /* In    */ const IDL_char *srvrObjRef
  , /* In    */ IDL_long srvrState
  , /* In    */ IDL_long userID
  , /* In    */ const IDL_char *userSID
  )
{
	CEE_status retcode = CEE_SUCCESS;
	bool sts;
	long wlength,rlength;
	char* wbuffer, *rbuffer;

	CFSystemDrvr* FileSystem = GTransport.m_FSystemDrvr_list->ins_node();
	if (FileSystem == NULL)
		return CEE_ALLOCFAIL;

	FileSystem->odbcAPI = AS_API_UPDATESRVRSTATE;
	FileSystem->dialogueId = 0;
	FileSystem->dwTimeout = 0;
//
// do marshaling of input parameters
//
	retcode = odbcas_ASSvc_UpdateSrvrState_param_pst_(
		  FileSystem
		, wbuffer
		, wlength
		, srvrType
		, srvrObjRef
		, srvrState
		, userID
		, userSID);

	if (retcode != CEE_SUCCESS)
		goto bailout;

	sts = OpenIO (FileSystem,srvrGlobal->ASProcessName);
	if (sts == false)
	{
		retcode = GET_ERROR((long)FileSystem);
		goto bailout;
	}

	sts = DoIO (FileSystem, wbuffer, wlength, rbuffer, rlength);
	if (sts == false)
	{
		retcode = GET_ERROR((long)FileSystem);
		goto bailout;
	}

	CloseIO (FileSystem);
//
// process output parameters
//
	long* param[5];
	retcode = decodeParameters(5, param, rbuffer, rlength);
	if (retcode != CEE_SUCCESS)
	{
//LCOV_EXCL_START
		strcpy( errStrBuf2, "odbcas_drvr.cpp");
		strcpy( errStrBuf3, "SRVR-odbcas_ASSvc_UpdateSrvrState_pst_");
		strcpy( errStrBuf4, "buffer overflow");
		sprintf( errStrBuf5, "retcode <%d>", retcode);
		logError( PROGRAM_ERROR, SEVERITY_MAJOR, CAPTURE_ALL + PROCESS_STOP );
		SRVR::exitServerProcess();
//LCOV_EXCL_STOP
	}

    {
	void *pv_[6] = {0};
	pv_[1] = (void *)param[0];
	pv_[2] = (void *)param[1];
	pv_[3] = (void *)param[2];
	pv_[4] = (void *)param[3];
	pv_[5] = (void *)param[4];
	odbcas_ASSvc_UpdateSrvrState_ccw_(
	    /* In    */ (void *) rtn_
	  , /* In    */ tag_
	  , /* In    */ pv_);
    }

bailout:
	GTransport.m_FSystemDrvr_list->del_node(FileSystem);

	return CEE_SUCCESS;
}
/********************************************
 * Operation 'odbcas_ASSvc_WouldLikeToLive' *
 ********************************************/
/*
 * Call Completion function pointer type for
 * operation 'odbcas_ASSvc_WouldLikeToLive'
 */
typedef void (*odbcas_ASSvc_WouldLikeToLive_cct_) (
    /* In    */ CEE_tag_def cmptag_
  , /* In    */ const struct odbcas_ASSvc_WouldLikeToLive_exc_ *exception_
  , /* In    */ IDL_long lifePermit
  );
/*
 * Call completion wrapper for
 * operation 'odbcas_ASSvc_WouldLikeToLive'
 */
static void
odbcas_ASSvc_WouldLikeToLive_ccw_(
    /* In    */ CEE_tag_def tag1_
  , /* In    */ CEE_tag_def tag2_
  , /* In    */ const void *const *pv_)
{
  odbcas_ASSvc_WouldLikeToLive_cct_ f_;
  *((CEE_tag_def *) &f_) = tag1_;
  (*f_) (
      tag2_
    , (struct odbcas_ASSvc_WouldLikeToLive_exc_ *) pv_[1]
    , *(IDL_long *) pv_[2]
    );
}
/*
 * Asynchronous object call for
 * operation 'odbcas_ASSvc_WouldLikeToLive'
 */
extern CEE_status
odbcas_ASSvc_WouldLikeToLive_pst_(
    /* In    */ const CEE_handle_def *ph_
  , /* In    */ CEE_tag_def tag_
  , /* In    */ odbcas_ASSvc_WouldLikeToLive_cct_ rtn_
  , /* In    */ IDL_long srvrType
  , /* In    */ const IDL_char *srvrObjRef
  )
{
	CEE_status retcode = CEE_SUCCESS;
	bool sts;
	long wlength,rlength;
	char* wbuffer, *rbuffer;

	CFSystemDrvr* FileSystem = GTransport.m_FSystemDrvr_list->ins_node();
	if (FileSystem == NULL)
		return CEE_ALLOCFAIL;

	FileSystem->odbcAPI = AS_API_WOULDLIKETOLIVE;
	FileSystem->dialogueId = 0;
	FileSystem->dwTimeout = 0;
//
// do marshaling of input parameters
//
	retcode = odbcas_ASSvc_WouldLikeToLive_param_pst_(
		  FileSystem
		, wbuffer
		, wlength
		, srvrType
		, srvrObjRef);

	if (retcode != CEE_SUCCESS)
		goto bailout;

	sts = OpenIO (FileSystem,srvrGlobal->ASProcessName);
	if (sts == false)
	{
		retcode = GET_ERROR((long)FileSystem);
		goto bailout;
	}

	sts = DoIO (FileSystem, wbuffer, wlength, rbuffer, rlength);
	if (sts == false)
	{
		retcode = GET_ERROR((long)FileSystem);
		goto bailout;
	}

	CloseIO (FileSystem);
//
// process output parameters
//
	long* param[2];
	retcode = decodeParameters(2, param, rbuffer, rlength);
	if (retcode != CEE_SUCCESS)
	{
//LCOV_EXCL_START
		strcpy( errStrBuf2, "odbcas_drvr.cpp");
		strcpy( errStrBuf3, "SRVR-odbcas_ASSvc_WouldLikeToLive_pst_");
		strcpy( errStrBuf4, "buffer overflow");
		sprintf( errStrBuf5, "retcode <%d>", retcode);
		logError( PROGRAM_ERROR, SEVERITY_MAJOR, CAPTURE_ALL + PROCESS_STOP );
		SRVR::exitServerProcess();
//LCOV_EXCL_STOP
	}

    {
	void *pv_[3] = {0};
	pv_[1] = (void *)param[0];
	pv_[2] = (void *)param[1];
	odbcas_ASSvc_WouldLikeToLive_ccw_(
	    /* In    */ (void *) rtn_
	  , /* In    */ tag_
	  , /* In    */ pv_);
    }
bailout:
	GTransport.m_FSystemDrvr_list->del_node(FileSystem);

	return retcode;
}
