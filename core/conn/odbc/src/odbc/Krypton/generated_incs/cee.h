// @@@ START COPYRIGHT @@@
//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// @@@ END COPYRIGHT @@@
#ifndef CEE_H
#define CEE_H
#define CEE_H_VERSION 19991123
/*
 * !CEE API
 *
 * $RCSfile: cee_head.h $$Revision: 1.39 $$Date: 1999/11/24 19:25:24 $
 *
 * This header file contains definitions for users of the
 * TANTAU Common Execution Environment (including generated code).
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#include <glu.h>
#ifndef CEE_H_
#define CEE_H_
/*
 * Translation unit: CEE
 * Generated by CNPGEN(TANTAU CNPGEN TANTAU_AG_PC1 19991203.133909) on Tue Nov 21 10:05:14 2000
 */
#include <idltype.h>
#if IDL_TYPE_H_VERSION != 19971225
#error Version mismatch IDL_TYPE_H_VERSION != 19971225
#endif

/****************
 * Module 'CEE' *
 ****************/
typedef IDL_enum CEE_synch_def;
#define CEE_INVALID_METHOD ((IDL_enum) 0)
#define CEE_SYNCH_METHOD ((IDL_enum) 1)
#define CEE_ASYNCH_METHOD ((IDL_enum) 2)
#define CEE_SYNCH_MULTITHREADED_METHOD ((IDL_enum) 3)
#define CEE_TRANSPORT_INVALID ((IDL_long) 0)
#define CEE_TRANSPORT_NULL ((IDL_long) 1)
#define CEE_TRANSPORT_FSP ((IDL_long) 2)
#define CEE_TRANSPORT_TCP ((IDL_long) 3)
#define CEE_TRANSPORT_TI ((IDL_long) 4)
#define CEE_TRANSPORT_SRT ((IDL_long) 5)
#define CEE_MAX_SRT_RESOURCE_TYPES ((IDL_long) 2)
#define CEE_SRT_RESOURCE_TYPE_UNKNOWN ((IDL_long) -1)
#define CEE_SRT_RESOURCE_TYPE_IMPLEMENTER ((IDL_long) 0)
#define CEE_SRT_RESOURCE_TYPE_PROVIDER ((IDL_long) 1)
#define CEE_SRT_ResourceTypeImplementer ((IDL_string) "IMPLE" \
    "MENTER")
#define CEE_SRT_ResourceTypeProvider ((IDL_string) "PROVIDER")
#define CEE_MAX_SRT_POLICIES ((IDL_long) 3)
#define CEE_SRT_POLICY_UNKNOWN ((IDL_long) -1)
#define CEE_SRT_POLICY_ROUNDROBIN ((IDL_long) 0)
#define CEE_SRT_POLICY_FALLBACK ((IDL_long) 1)
#define CEE_SRT_POLICY_STICKY ((IDL_long) 2)
#define CEE_SRT_PolicyRoundrobin ((IDL_string) "ROUNDROBIN")
#define CEE_SRT_PolicyFallback ((IDL_string) "FALLBACK")
#define CEE_SRT_PolicySticky ((IDL_string) "STICKY")
#define CEE_UNIX_NOTIFY_READ ((IDL_long) 1)
#define CEE_UNIX_NOTIFY_WRITE ((IDL_long) 2)
#define CEE_UNIX_NOTIFY_EXCEPTION ((IDL_long) 3)
struct CEE_handle_tag {
  IDL_long contents[4];
};
typedef struct CEE_handle_tag CEE_handle_def;
#define CEE_handle_def_cin_ ((char *) "b1+a1+4+F")
#define CEE_handle_def_csz_ ((IDL_unsigned_long) 9)
#define CEE_INVALID_IO_ID ((IDL_long) 0)
#define CEE_SVC_CTX_UNUSED ((IDL_unsigned_long) 0)
#define CEE_SVC_CTX_KTF ((IDL_unsigned_long) 1)
#define CEE_SVC_CTX_RESERVED_MAX ((IDL_unsigned_long) 2147483647)
/* End module: CEE */
typedef IDL_long CEE_status;
#define CEE_status_cin_ ((char *) "F")
#define CEE_status_csz_ ((IDL_unsigned_long) 1)
#define CEE_SUCCESS ((IDL_long) 0)
#define CEE_UNKNOWN ((IDL_long) 1)
#define CEE_ALLOCFAIL ((IDL_long) 2)
#define CEE_ALREADYEXISTS ((IDL_long) 3)
#define CEE_BADHANDLE ((IDL_long) 4)
#define CEE_PROXYSTALE ((IDL_long) 5)
#define CEE_BADCIN ((IDL_long) 6)
#define CEE_INUSE ((IDL_long) 7)
#define CEE_BADMETHIDX ((IDL_long) 8)
#define CEE_NOTSYNCHRONOUS ((IDL_long) 9)
#define CEE_INTERNALFAIL ((IDL_long) 10)
#define CEE_OCERROR ((IDL_long) 11)
#define CEE_PROXYINITFAIL ((IDL_long) 12)
#define CEE_BADENTRYPOINT ((IDL_long) 13)
#define CEE_BADLIBNAME ((IDL_long) 14)
#define CEE_LIBUNLOAD ((IDL_long) 15)
#define CEE_NOTALLINIT ((IDL_long) 16)
#define CEE_PROXYINUSE ((IDL_long) 17)
#define CEE_BADMETHMIX ((IDL_long) 18)
#define CEE_ALREADYDESTR ((IDL_long) 19)
#define CEE_CLIENTFAIL ((IDL_long) 20)
#define CEE_SERVERFAIL ((IDL_long) 21)
#define CEE_BADREQHEADER ((IDL_long) 22)
#define CEE_BADRSPHEADER ((IDL_long) 23)
#define CEE_BADREQVERSION ((IDL_long) 24)
#define CEE_BADRSPVERSION ((IDL_long) 25)
#define CEE_LONGREQUEST ((IDL_long) 26)
#define CEE_LONGRESPONSE ((IDL_long) 27)
#define CEE_SHORTREQUEST ((IDL_long) 28)
#define CEE_SHORTRESPONSE ((IDL_long) 29)
#define CEE_BADREQSEQSIZE ((IDL_long) 30)
#define CEE_BADRSPSEQSIZE ((IDL_long) 31)
#define CEE_BADREQSTRSIZE ((IDL_long) 32)
#define CEE_BADRSPSTRSIZE ((IDL_long) 33)
#define CEE_NOSUCHOP ((IDL_long) 34)
#define CEE_OPNOTIMPL ((IDL_long) 35)
#define CEE_BADTIME ((IDL_long) 36)
#define CEE_BADPV ((IDL_long) 37)
#define CEE_NOSUCHOBJ ((IDL_long) 38)
#define CEE_BADOBJREF ((IDL_long) 39)
#define CEE_BADTRANSPORT ((IDL_long) 40)
#define CEE_DOESNOTEXIST ((IDL_long) 41)
#define CEE_LONGOID ((IDL_long) 42)
#define CEE_OBJNOTACT ((IDL_long) 43)
#define CEE_BADOBJID ((IDL_long) 44)
#define CEE_TOOMANYIOS ((IDL_long) 45)
#define CEE_NOTINIT ((IDL_long) 46)
#define CEE_ALREADYINIT ((IDL_long) 47)
#define CEE_BADMEMORYADDR ((IDL_long) 48)
#define CEE_TRANSPORTFAILURE ((IDL_long) 49)
#define CEE_BADCAPSULEID ((IDL_long) 50)
#define CEE_SESSIONCLOSED ((IDL_long) 51)
#define CEE_EXECUTEFINISHED ((IDL_long) 52)
#define CEE_PROCESSUNNAMED ((IDL_long) 53)
#define CEE_LOGFAILURE ((IDL_long) 54)
#define CEE_BADEVENT ((IDL_long) 55)
#define CEE_BADFD ((IDL_long) 56)
#define CEE_SKIERROR ((IDL_long) 57)
#define CEE_SKINOTFOUND ((IDL_long) 58)
#define CEE_BIGCAPSULENAME ((IDL_long) 59)
#define CEE_BADCAPSULENAME ((IDL_long) 60)
#define CEE_UNUSEDENTRYPOINT ((IDL_long) 61)
#define CEE_OBJECTINITFAILED ((IDL_long) 62)
#define CEE_TABLEFULL ((IDL_long) 63)
#define CEE_NOTDYNAMICOBJ ((IDL_long) 64)
#define CEE_CANCELED ((IDL_long) 65)
#define CEE_BADSIGNALNUMBER ((IDL_long) 66)
#define CEE_TOOMANYTIST ((IDL_long) 67)
#define CEE_REQTOOBIG ((IDL_long) 68)
#define CEE_RSPTOOBIG ((IDL_long) 69)
#define CEE_UNIMPLCONV ((IDL_long) 70)
#define CEE_BADTFILEOPEN ((IDL_long) 71)
#define CEE_SHORTOUTBUF ((IDL_long) 72)
#define CEE_NOTGWYOID ((IDL_long) 73)
#define CEE_NOTCONFIGOID ((IDL_long) 74)
#define CEE_SHORTOID ((IDL_long) 75)
#define CEE_TRANSACTIONREQUIRED ((IDL_long) 76)
#define CEE_TRANSACTIONROLLEDBACK ((IDL_long) 77)
#define CEE_INVALIDTRANSACTION ((IDL_long) 78)
#define CEE_WRONGTRANSACTION ((IDL_long) 79)
#define CEE_IMPLIMIT ((IDL_long) 80)
#define CEE_LONGOBJREF ((IDL_long) 81)
#define CEE_LONGCAPSULEID ((IDL_long) 82)
#define CEE_TRACE_ERROR ((IDL_long) 83)
#define CEE_INVALIDCONFIGURATION ((IDL_long) 84)
#define CEE_NOSUCHOBJRETRYPOSSIBLE ((IDL_long) 85)
#define CEE_BADFILNUM ((IDL_long) 86)
#define CEE_TOOMANYSVCCTX ((IDL_long) 87)
#define CEE_NOTOBJGROUPID ((IDL_long) 88)
#define CEE_BADTHREAD ((IDL_long) 89)
#define CEE_RETRYPOSSIBLE ((IDL_long) 90)
#define CEE_BADPGRMROLE ((IDL_long) 91)
/*
 * End translation unit: CEE
 */
#endif /* CEE_H_ */
/*
 * $RCSfile: cee_tail.h $$Revision: 1.81 $$Date: 1999/08/27 12:44:25 $
 */

/*
 * !CEE_tag_def
 *
 * "CEE_tag_def" is the type for tag arguments in the CEE routines that
 * register up-calls.
 *
 * You set the tag argument to an arbitrary value and the CEE passes this
 * value to the up-called routine. This provides a mechanism to pass
 * context information to the up-called routnies.
 *
 */

typedef void *CEE_tag_def;

/*
 * !CEE_call_monitor_ptr
 *
 * The CEE calls functions of type "CEE_call_monitor_ptr" when asynchronous
 * operations from clients are no longer valid.
 *
 * An asynchronous call can become invalid when the client destroys the proxy used
 * for the call or when the client that made the call exits.
 *
 * You register a routine to handle invalid asynchronous operations with
 * "CEE_CALL_MONITOR".
 *
 * <monitor_tag>  The arbitrary value you pass to CEE_CALL_MONITOR.
 *
 */

typedef void (*CEE_call_monitor_ptr) (
  /* In  */ CEE_tag_def     monitor_tag
  );

/*
 * !CEE_cfg_update_ptr
 *
 * "CEE_cfg_update_ptr" is the type used to
 * specify upcall function pointers for configuration 
 * updates (see also "CEE_CFG_UPDATE_REGISTER"). 
 *
 * <cfg_tag>      is the tag that was supplied to 
 *                "CEE_CFG_UPDATE_REGISTER".
 *
 * <qualifier>    same value as was supplied to
 *                "CEE_CFG_GET_RECORD".
 *
 * <entry_name>   same value as was supplied to
 *                "CEE_CFG_GET_RECORD".
 *
 * <old_value>    is the old value of the configuration 
 *                parameter.
 *
 * <new_value>    is the new value of the configuration 
 *                parameter.
 *
 * <return-value> zero indicates success, the new 
 *                configuration has been applied. Any
 *                other value indicates failure and
 *                the reconfiguration request will be
 *                rejected.
 *
 */

typedef IDL_long (*CEE_cfg_update_ptr) (
  /* In  */ CEE_tag_def     cfg_tag,
  /* In  */ const char     *qualifier,
  /* In  */ const char     *entry_name,
  /* In  */ const void     *old_value,
  /* In  */ const void     *new_value
  );

/*
 * !CEE_object_shutdown_ptr
 *
 * "CEE_object_shutdown_ptr" is the type used to
 * specify upcall function pointers for capsule
 * shutdown (see also "CEE_OBJECT_SET_SHUTDOWN"). 
 *
 * <obj_tag>      is the tag that was supplied to 
 *                "CEE_OBJECT_CREATE" (dynamic
 *                objects) or that was returned
 *                by the object initialization
 *                function (configured objects).
 *
 *
 */

typedef void (*CEE_object_shutdown_ptr) (
  /* In  */ CEE_tag_def     obj_tag
  );

/*
 * !CEE_signal_handler_ptr
 *
 * The CEE calls functions of type "CEE_signal_handler_ptr" when signals
 * are generated.
 *
 * You register a routine to handle a signal with "CEE_SIGNAL_HANDLER_CREATE".
 *
 * <signal_number>     The signal number being monitored. Signal numbers are
 *                     defined in the standard C header file "signal.h".
 *
 * <signal_tag>        The arbitrary value you pass to "CEE_SIGNAL_HANDLER_CREATE".
 *
 */

typedef void (*CEE_signal_handler_ptr) (
  /* In  */ int             signal_number,
  /* In  */ CEE_tag_def     signal_tag
  );

/*
 * !CEE_NSK_io_completion_detail_def
 *
 * "CEE_NSK_io_completion_detail_def" is the type returned in the bytes_or_detail
 * parameter of "CEE_NSK_io_completion_ptr" in certain cases.
 *
 * "CEE_NSK_io_completion_detail_def" is a union that contains either
 * the number of byte transferred or error information.
 *
 * The caller must cast the long for backwards compatibility reasons.
 *
 * <sc_send_info>               The CEE calls SERVERCLASS_SEND_INFO_ and puts
 *                              the results in this structure if status is
 *                              FESCERROR (233).
 *
 * <bytes_transferred>          The number of bytes transferred if
 *                              SERVERCLASS_SEND_INFO_ succeeds.
 *
 */
typedef union CEE_NSK_io_completion_detail_tag {

  struct CEE_NSK_sc_send_info_tag {    /* if status FESCERROR (233) */
    short       path_send_error;                
    short       file_system_error;
  } sc_send_info;

  long          bytes_transferred;     /* In all other cases */

} CEE_NSK_io_completion_detail_def;

/*
 * !CEE_NSK_io_completion_ptr
 *
 * CEE calls functions of type "CEE_NSK_io_completion_ptr" when asynchronous
 * (nowaited) I/O operations are posted.
 *
 * You register a completion routine for an asynchronous I/O operation with
 * "CEE_NSK_ASYNC_IO_PREPARE".
 *
 * <status>             The status of the completed operation as returned by
 *                      FILE_GETINFO_.
 *
 * <io_tag>             The arbitrary value you pass to "CEE_NSK_ASYNCH_IO_PREPARE".
 *
 * <bytes_or_detail>    The number of bytes transferred during the
 *                      I/O operation (AWAITIOX param #3) or an error detail.
 *                      You must cast "bytes_or_detail" to
 *                      "CEE_NSK_io_completion_detail_def" in certain cases.
 *                      See "CEE_NSK_io_completion_detail_def" for details.
 *
 */

typedef void (*CEE_NSK_io_completion_ptr) (
  /* In  */ short           status,
  /* In  */ CEE_tag_def     io_tag,
  /* In  */ long            bytes_or_detail
  );

/*
 * !CEE_NSK_end_tx_completion_ptr
 *
 * The CEE calls functions of type "CEE_NSK_end_tx_completion_ptr" when
 * nowait ENDTRANSACTIONs complete.
 *
 * You register a completion routine for a nowait ENDTRANSACTION with
 * "CEE_NSK_ENDTRANSACTION_COMPLETION".
 *
 * <status>             The status of completed ENDTRANSACTION as returned by
 *                      FILE_GETINFO_.
 *
 * <tx_tag>             The arbitrary value you pass to
 *                      "CEE_NSK_ENDTRANSACTION_COMPLETION".
 *
 */

typedef void (*CEE_NSK_end_tx_completion_ptr) (
  /* In  */ short           status,
  /* In  */ CEE_tag_def     tx_tag
  );


/*
 * !CEE_NSK_open_completion_ptr
 *
 * The CEE calls functions of type "CEE_NSK_open_completion_ptr" when nowait
 * FILE_OPEN_ calls are completed.
 *
 * You register a completion routine for a nowait FILE_OPEN_ with
 * "CEE_NSK_FILE_OPEN_COMPLETION".
 *
 * <status>             The status of completed operation as returned by
 *                      FILE_GETINFO_.
 *
 * <open_tag>           The arbitrary value you pass to "CEE_NSK_FILE_OPEN_COMPLETION".
 *
 */

typedef void (*CEE_NSK_open_completion_ptr) (
  /* In  */ short           status,
  /* In  */ CEE_tag_def     open_tag
  );

/*
 * !CEE_NT_io_completion_ptr
 *
 * The CEE calls functions of type "CEE_NT_io_completion_ptr" when asynchronous
 * (overlapped) I/O operations are posted.
 *
 * You register a completion routine for an asynchronous I/O operation with
 * "CEE_NT_ASYNC_IO_PREPARE".
 *
 * <io_tag>         The arbitrary value you pass to "CEE_ASYNCH_IO_PREPARE".
 * 
 */

typedef void (*CEE_NT_io_completion_ptr) (
  /* In  */ CEE_tag_def     io_tag
  );


/*
 * !CEE_UNIX_io_notification_ptr
 *
 * The CEE calls functions of type "CEE_UNIX_io_notification_ptr" when file
 * descriptors become ready for I/O.
 *
 * You register a notification routine for a file descriptors availability
 * with "CEE_UNIX_IO_NOTIFICATION".
 *
 * <io_tag>             The arbitrary value you pass to "CEE_UNIX_IO_NOTIFICATION".
 *
 */

typedef void (*CEE_UNIX_io_notification_ptr) (
  /* In  */ CEE_tag_def     io_tag
  );


/*
 * !CEE_VMS_asynch_upcall_ptr
 *
 * Functions of the type "CEE_VMS_ASYNCH_UPCALL" enable callers to
 * associate the execution of CEE sends and receives with the
 * asynchronous completion of some other activity in the caller's
 * program.
 *
 * "CEE_VMS_ASYNCH_UPCALL" functions are registered using
 * "CEE_VMS_ASYNCH_UPCALL_REGISTER" and are dispatched by calling
 * "CEE_VMS_ASYNCH_UPCALL_DISPATCH".
 *
 * "CEE_VMS_ASYNCH_UPCALL_DISTACH" is intended to be called at AST
 * level.
 *
 * <io_tag>                 The arbitrary value passed to
 *                          "CEE_VMS_ASYNCH_UPCALL_REGISTER".
 *
 */

typedef void (*CEE_VMS_asynch_upcall_ptr) (
  /* In  */ CEE_tag_def     tag
  );


/*
 * !CEE_method_ptr
 *
 * The CEE calls functions of type "CEE_method_ptr" when implementations
 * call methods. The registered methods can be either synchronous or asynchronous.
 *
 * You register a method with "CEE_SET_METHOD".
 *
 * <method_tag>     The arbitrary value you pass to "CEE_SET_METHOD".
 *
 *
 * <object_tag>     For dynamic objects, the tag passed to "CEE_OBJECT_CREATE".
 *                  For configured objects, the tag returned by the object
 *                  initialization up-call.
 *
 * <call_id>        The unique ID of the call. You can use the "call_id" to find out
 *                  more information about the call or caller. Pass the "call_id" to
 *                  "CEE_RESPOND" from asynchronous methods to respond to a call.
 *                  Pass the "call_id" to "CEE_TMP_ALLOCATE" to allocate memory that
 *                  the CEE automatically frees when the call completes.
 *
 * <param_vector>   An array of pointers to the output parameters. The first element
 *                  is not used. The second element points to an exception structure.
 *                  The third though "n" elements point to "Out" parameters.
 *
 */

typedef void (*CEE_method_ptr) (
  /* In  */ CEE_tag_def              method_tag,
  /* In  */ CEE_tag_def              object_tag,
  /* In  */ const CEE_handle_def    *call_id,
  /* In  */ void *const             *param_vector
  );

/*
 * !CEE_object_call_completion_ptr
 *
 * The CEE calls an Asynchronous Object Call Completion Up-call function when
 * an asynchronous object call is posted.
 *
 * You register a completion routine for an asynchronous object call with
 * "CEE_OBJECT_CALL_POST".
 *
 * <call_tag1>      The first arbitrary value you pass to
 *                  "CEE_OBJECT_CALL_POST".
 *
 * <call_tag2>      The second arbitrary value you pass to
 *                  "CEE_OBJECT_CALL_POST".
 *
 * <param_vector>   An array of pointers to the output parameters. The first
 *                  element is not used. The second element points to an exception
 *                  structure. The third though "n" elements point to "Out" parameters.
 *
 */

typedef void (*CEE_object_call_completion_ptr) (
  /* In  */ CEE_tag_def          call_tag1,
  /* In  */ CEE_tag_def          call_tag2,
  /* In  */ const void *const   *param_vector
  );

/*
 * !CEE_object_initialize_ptr
 *
 * CEE calls a Configured Object Initialization Up-call when a configured
 * object is activated.
 *
 * The initialization function name is specified in the object's configuration.
 * An object can be configured in a SAM file or by a call to "CEE_OBJECT_CONFIGURE".
 *
 * At a minimum, the initialization routine must create an implementation for the
 * object being initialized (see "CEE_IMPLEMENTATION_CREATE") and return its handle
 * in the "impl_handle" parameter.
 *
 * Set the "sts" to a non-zero value to indicate that the initialization has failed,
 * and to prevent the CEE from activating the configured object.
 *
 * <object_handle>  The handle of the newly-created object if initialization is
 *                  successful. This parameter is comparable to the "object_handle"
 *                  parameter in "CEE_OBJECT_CREATE".
 *
 * <param>          An arbitrary value you pass to "CEE_OBJECT_CONFIGURE". This value
 *                  does not have to be a string.
 *
 * <param_len>      The number of bytes in "param".
 *
 * <sts>            The object initialization status. Set this to zero to indicate
 *                  that initialization succeeded.
 *
 * <obj_tag>        An arbitrary value that will be passed to this objects methods
 *                  when they are invoked. This provides a convenient way of matching
 *                  the method invocation with the relevant object. This parameter is
 *                  comparable to the "obj_tag" parameter in "CEE_OBJECT_CREATE".
 *
 * <impl_handle>    The implementation handle. Use "CEE_IMPLEMENTATION_CREATE" to
 *                  obtain this value. This handle indicates the interface that the
 *                  object is to implement and the method functions that are to be called.
 *
 */

typedef void (*CEE_object_initialize_ptr) (
  /* In  */ const CEE_handle_def    *object_handle,
  /* In  */ const char              *param,
  /* In  */ long                     param_len,
  /* Out */ CEE_status              *sts,
  /* Out */ CEE_tag_def             *obj_tag,
  /* Out */ CEE_handle_def          *implementation_handle
  );

/*
 * !CEE_timer_expiration_ptr
 *
 * CEE calls a Timer Expiration Up-call function when a timer expires.
 * When you create a timer, you spcify an amount of time.
 * The timer expires when this amount of time has elapsed.
 *
 * You register an expiration routine for a timer with "CEE_TIMER_CREATE".
 *
 * <tag>        An arbitrary value you pass to "CEE_TIMER_CREATE".
 *
 */

typedef void (*CEE_timer_expiration_ptr) (
  /* In  */ CEE_tag_def              tag
  );

/*
 * !CEE_ti_resource_signal_ptr
 *
 * The CEE calls functions of type "CEE_ti_resource_signal_ptr" when a Titanium
 * resource is signaled.
 *
 * You register a signal routine for a Titanium resource with "CEE_TI_SIGNAL_TAG_CREATE".
 *
 * <cee_tag>  an arbitrary value you pass to "CEE_TI_SIGNAL_TAG_CREATE".
 *
 */
typedef void (*CEE_ti_resource_signal_ptr) (
  /* In  */ CEE_tag_def              cee_tag
  );
/*
 * !CEE_CALL_GET_OID
 *
 * "CEE_CALL_GET_OID" allows servers to retrieve the object identifier of
 * a call.
 *
 * <call_id>                       specifies call whose object identifier is
 *                                 to be obtained
 *
 * <oid>                           object identifier
 *
 * <oid_len>                       object identifier length
 *
 * <=return-value>                 "CEE_SUCCESS" if the operation succeeded,
 *                                 otherwise the appropriate CEE status constant. 
 */
extern CEE_status
CEE_CALL_GET_OID(
  /* In    */ const CEE_handle_def                        *call_id,
  /* Out   */ const char                                 **oid,
  /* Out   */ IDL_unsigned_long                           *oid_len
  );


/*
 * !CEE_CALL_OID_DECOMPOSE
 *
 * "CEE_CALL_OID_DECOMPOSE" allows servers to retrieve the object group
 * prefix and remainder (object identifier without prefix) of a call.
 * The prefix pointer is set to NULL if the object identifier of the call
 * does not have a prefix (oid is not a object group).
 *
 * <call_id>                     specifies call whose object identifier
 *                               prefix and remainder is to be obtained
 * <prefix>                      object identifier prefix pointer
 * 
 * <prefix_len>                  prefix length
 *
 * <remainder>                   pointer to object identifier remainder
 *                               (object identifier without prefix)
 *
 * <remainder_len>               remainder length
 *
 * <=return-value>               "CEE_SUCCESS" if the operation succeeded,
 *                                otherwise the appropriate CEE status constant.
 */
extern CEE_status
CEE_CALL_OID_DECOMPOSE(
  /* In    */ const CEE_handle_def                        *call_id,
  /* Out   */ const char                                 **prefix,
  /* Out   */ IDL_unsigned_long                           *prefix_len,
  /* Out   */ const char                                 **remainder,
  /* Out   */ IDL_unsigned_long                           *remainder_len
  );


/*
 * "CEE_CALL_GET_REQUEST_SVC_CTX" allows serverss to retrieve a service
 * context value that was sent by a client that called
 * "CEE_PROXY_SET_REQUEST_SVC_CTX". 
 *
 * See the description of "CEE_PROXY_SET_REQUEST_SVC_CTX" for a discussion
 * of service context ID's and values.
 *
 *
 * <call_id>          specifies call whose service context is to be
 *                    obtained
 *
 * <svc_ctx_type>     specifies which service context is to be
 *                    obtained.
 *
 * <svc_ctx_size_max>  maximum number of bytes that should be written
 *                     to "svc_ctx_value". If the service
 *                     context to be retrived is too large then the
 *                     return status will be CEE_SHORTOUTBUF 
 *                     and the minimum required size is returned in
 *                     "svc_ctx_size"
 *
 * <svc_ctx_value>     pointer a buffer that is to receive the
 *                     service context value.
 *
 * <svc_ctx_size>      number of bytes of data written to 
 *                     "svc_ctx_value"
 */
extern CEE_status
CEE_CALL_GET_REQUEST_SVC_CTX(
  /* In    */ const CEE_handle_def   *call_id,
  /* In    */ IDL_unsigned_long       svc_ctx_type,     
  /* In    */ IDL_unsigned_long       svc_ctx_size_max,  
  /* Out   */ void                   *svc_ctx_value,
  /* Out   */ IDL_unsigned_long      *svc_ctx_size  
  );

/*
 * !CEE_CALL_MONITOR
 * 
 * "CEE_CALL_MONITOR" registers a routine that the CEE calls when an asynchronous
 * method becomes invalid.
 *
 * An asynchronous call can become invalid when the client destroys the proxy used
 * for the call or when the client that made the call exits.
 *
 * You must provide a response to all calls, even when they become invalid.
 *
 * <call_id>          A value that uniquely identifies the monitored call. The CEE
 *                    this value to the "monitor_routine".
 *
 * <monitor_tag>      An arbitrary value. This value is passed to "monitor_routine".
 *                    This provides a mechanism to pass context information to
 *                    "monitor_routine".
 *
 * <monitor_routine>  The routnie up-called when "call_id" becomes invalid.
 *
 */
extern CEE_status
CEE_CALL_MONITOR(
  /* In  */ const CEE_handle_def    *call_id,
  /* In  */ CEE_tag_def              monitor_tag,
  /* In  */ CEE_call_monitor_ptr     monitor_routine
  );


/*
 * "CEE_CALL_SET_RESPONSE_SVC_CTX" associates a service context value 
 * with an active call. This service context value will be transmitted, 
 * in addition to the parameters, back to the client who can obtain the 
 * value using "CEE_PROXY_GET_RESPONSE_SVC_CTX".
 *
 * See the description of "CEE_PROXY_SET_REQUEST_SVC_CTX" for a discussion
 * of service context ID's and values.
 *
 * A server can set any number of service contexts on a call.
 *
 * Synchronous servers must call "CEE_CALL_SET_RESPONSE_SVC_CTX" before
 * returning from the method upcall.
 *
 * Synchronous servers must call "CEE_CALL_SET_RESPONSE_SVC_CTX" before
 * responding to the call with CEE_RESPOND (or the generated xxx_res_
 * function that calls CEE_RESPOND).
 *
 * If "service_context" is a null-pointer, the service context specified
 * by "svc_ctx_type" (if any) is cleared.
 *
 * <call_id>         specifies call whose service context is to be
 *                   set.
 *
 * <svc_ctx_type>    specifies which service context is to be set
 *
 * <svc_ctx_value>   pointer to service context value that is to
 *                   be set on the call. NULL means clear service
 *                   context.
 *
 * <svc_ctx_size>    number of bytes of data pointed to by 
 *                   "svc_ctx_value".
 */

extern CEE_status
CEE_CALL_SET_RESPONSE_SVC_CTX(
  /* In    */ const CEE_handle_def   *call_id,
  /* In    */ IDL_unsigned_long       svc_ctx_type,     
  /* In    */ const void             *svc_ctx_value,
  /* In    */ IDL_unsigned_long       svc_ctx_size
  );

/*
 * "CEE_CAPSULE_SHUTDOWN" is called to shutdown the capsule.
 * Any upcalls registered with CEE_OBJECT_SET_SHUTDOWN will be
 * invoked and the execution loop within CEE_EXECUTE will then be 
 * terminated. The CEE main program exits when this happens.
 * If the CEE main program is not used and the application has called 
 * CEE_EXECUTE itself then the application regains control and has the 
 * opportunity to perform further clean-up before exiting.
 */
extern CEE_status
CEE_CAPSULE_SHUTDOWN(void);

/*
 * !CEE_CFG_DEALLOCATE
 * 
 * "CEE_CFG_DEALLOCATE" frees memory allocated for configuration data.
 *
 * "CEE_CFG_GET", "CEE_CFG_QUALIFIED_GET", and "CEE_CFG_GET_RECORD" allocate memory
 * for configuration data.
 *
 * <entry_value>     A pointer to the configuration data to be freed.
 *
 * <return-value>    "CEE_SUCCESS" if the operation succeeded, otherwise
 *                   the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_CFG_DEALLOCATE(
  /* In */ void     *entry_value
  );


/*
 * !CEE_CFG_GET define
 *
 * "CEE_CFG_GET" gets configuration information from an object.
 *
 * "CEE_CFG_GET_RECORD" and "CEE_CFG_QUALIFIED_GET" also get configuration
 * information from an object. "CEE_CFG_GET" is a convenient macro that
 * you can use when the type and name of the configured name are identical.
 *
 * Use "CEE_CFG_DEALLOCATE" to free the allocated memory when it is no longer
 * needed.
 *
 * Usage example:
 *
 *   myrec *rec;
 *
 *   CEE_CFG_GET(myrec, &rec);
 *
 * <name>  The name of the record containing the requested configuration data. 
 *         Do not use quotes when specifying the entry name.
 *
 * <value> A pointer to the configuration data.
 *
  * <=CEE_SUCCESS>       The call succeeded.
 *
 * <=CEE_SKINOTFOUND>   The specified entry was not found. "value" is left
 *                      unchanged. This allows you to point "value" to defaults
 *                      before calling "CEE_CFG_GET".
 *
 * <=CEE_SKIERROR>      Some other SKI error occurred. The error was logged by the CEE.
 *
 */

#define CEE_CFG_GET(name, value)                     \
  CEE_CFG_GET_RECORD("", -1,                         \
                     #name, -1,                      \
                     name ## _cin_, name ## _csz_ ,  \
                     (void **) (value))

/*
 * !CEE_CFG_QUALIFIED_GET define
 *
 * "CEE_CFG_QUALIFIED_GET" gets configuration information from an object.
 *
 * "CEE_CFG_GET" and "CEE_CFG_GET_RECORD" also get configuration
 * information from an object. "CEE_CFG_QUALIFIED_GET" is a convenient
 * macro that you can use when the type and name of the configured name are identical
 * and you want to specify the "qualifier" parameter.
 *
 * Use "CEE_CFG_DEALLOCATE" to free the allocated memory when it is no longer needed.
 *
 * Usage example:
 *
 *   myrec *rec;
 *
 *   CEE_CFG_QUALIFIED_GET(param, paramLen, myrec, &rec);
 *
 * <qualifier>        The value prefixed to "entry_name" to create the SKI record name.
 *                    This is usually the "param" value passed to a configured object
 *                    initialization function.
 *
 * <qualifier_len>    The size of "qualifier" in bytes. This is usually the "paramLen"
 *                    value passed to a configured object initialization function.
 *
 * <name>             The name of the record containing the requested configuration data.
 *                    Do not use quotes when specifying the entry name.
 *
 * <value>            A pointer to the configuration data.
 *
 * <=CEE_SUCCESS>       The call succeeded.
 *
 * <=CEE_SKINOTFOUND>   The specified entry was not found. "value" is left
 *                      unchanged. This allows you to point "value" to defaults
 *                      before calling "CEE_CFG_QUALIFIED_GET".
 *
 * <=CEE_SKIERROR>      Some other SKI error occurred. The error was logged by the CEE.
 *
 */

#define CEE_CFG_QUALIFIED_GET(qualifier, qualifier_len, name, value)    \
  CEE_CFG_GET_RECORD(qualifier, qualifier_len,                          \
                     #name, -1,                                         \
                     name ## _cin_, name ## _csz_ ,                     \
                     (void **) (value))

/*
 * !CEE_CFG_GET_RECORD
 * 
 * "CEE_CFG_GET_RECORD" gets configuration information from an object.
 *
 * Implementation libraries should use this function, rather than calling the SKI
 * functions directly, so that they will get the correct object-specific configuration.
 *
 * The name of the SKI record is the concatenation of "qualifier", a separator, and
 * "entry_name".
 *
 * Use "CEE_CFG_DEALLOCATE" to free the allocated memory when it is no longer needed.
 *
 * <qualifier>        The value prefixed to "entry_name" to create the SKI record name.
 *                    This is usually the "param" value passed to a configured object
 *                    initialization function.
 *
 * <qualifier_len>    The size of "qualifier" in bytes. This is usually the "paramLen"
 *                    value passed to a configured object initialization function.
 *
 * <entry_name>       The name of the record containing the requested configuration data.
 *                    Do not use quotes when specifying the entry name.
 * 
 * <entry_name_len>   The size of "entry_name" in bytes.
 *
 * <entry_cin>        The "CIN" description of the entry's data type. You can use the 
 *                    IDL-generated constant for this parameter ("xxx_cin_", where
 *                    "xxx" is the IDL typedef name).
 *
 * <entry_cin_len>    The size of "entry_cin" in bytes. You can use the IDL-generated
 *                    constant for this parameter ("xxx_csz_", where "xxx" is the IDL
 *                    typedef name).
 *
 * <entry_value>      A pointer to the configuration data.
 *
 * <=CEE_SUCCESS>       The call succeeded.
 *
 * <=CEE_SKINOTFOUND>   The specified entry was not found. "entry_value" is left
 *                      unchanged. This allows you to point "entry_value" to defaults
 *                      before calling "CEE_CFG_GET_RECORD".
 *
 * <=CEE_SKIERROR>      Some other SKI error occurred. The error was logged by the CEE.
 *
 */
extern CEE_status
CEE_CFG_GET_RECORD(
  /* In  */ const char       *qualifier,
  /* In  */ long              qualifier_len,
  /* In  */ const char       *entry_name,
  /* In  */ long              entry_name_len,
  /* In  */ const char       *entry_cin,
  /* In  */ long              entry_cin_len,
  /* Out */ void            **entry_value
  );

/*
 * !CEE_CFG_SET define
 *
 * This define allows CEE_CFG_SET_RECORD to be
 * called more conveniently from 'C' for the
 * most common case where the type and name of
 * the configured name are identical (see 
 * "CEE_CFG_SET_RECORD" for more details).
 *
 * Usage example:
 *
 *   myrec defval;
 *
 *   CEE_CFG_SET(myrec, &defval, IDL_FALSE);
 *
 * <name>          is the unquoted entry name.
 *
 * <value>         is a pointer to the configuration
 *                 data.
 *
 * <return-value> same as "CEE_CFG_SET_RECORD".
 *
 */

#define CEE_CFG_SET(name, value)                     \
  CEE_CFG_SET_RECORD("", -1,                         \
                     #name, -1,                      \
                     name ## _cin_, name ## _csz_ ,  \
                     (void *) (value))

/*
 * !CEE_CFG_QUALIFIED_SET define
 *
 * This define is the same as CEE_CFG_SET except that
 * it allows the caller to specify the "qualifier"
 * parameter.  See CEE_CFG_SET_RECORD for more 
 * details.
 *
 * Usage example:
 *
 *   myrec defval;
 *
 *   CEE_CFG_QUALIFIED_SET(param, paramLen, 
                           myrec, &defval);
 *
 * <qualifier>     is the qualifier to be used. 
 *                 This is often the "param" passed to
 *                 a configured object initialization
 *                 function.
 *
 * <qualifier_len> is the size of "qualifier" in bytes.
 *                 Usually, the value "paramLen" as
 *                 passed to the configured object
 *                 initialization function.
 *
 * <name>          is the unquoted entry name.
 *
 * <value>         is a pointer to the configuration
 *                 data.
 *
 * <return-value>  same as "CEE_CFG_SET_RECORD".
 *
 */

#define CEE_CFG_QUALIFIED_SET(qualifier, qualifier_len,  \
                              name, value)               \
  CEE_CFG_SET_RECORD(qualifier, qualifier_len,           \
                     #name, -1,                          \
                     name ## _cin_, name ## _csz_ ,      \
                     (void *) (value))

/*
 * !CEE_CFG_SET_RECORD
 * 
 * "CEE_CFG_SET_RECORD" is used to set configuration 
 * data. Note that using this call are not persistent, 
 * they are not written to capsule's SKI file but are 
 * maintained in the capsule's memory. 
 *
 * This call has two primary uses:
 *
 * - to set configuration parameters in applications 
 *   that do not want to use SKI files. This function 
 *   can be called before CEE_INITIALIZE.
 *
 * - to supply defaults for parameters that may not
 *   exist in the capsule's SKI file. This technique
 *   is preferable to simply ignoring the error from
 *   CEE_CFG_GET since the capsule infrastructure will
 *   be aware of the default value for management
 *   purposes.
 *
 * The name of the SKI record to be read is the
 * concatenation of "qualifier", a separator and 
 * "entry_name".
 *
 *
 * <qualifier>       is prepended to "entry_name"
 *                   to create the SKI record name.
 *
 * <qualifier_len>   is the size of "qualifier" in
 *                   bytes.
 *
 * <entry_name>      is the name of the record 
 *                   containing the required
 *                   configuration data.
 *
 * <entry_name_len>  is the size of "entry_name" in
 *                   bytes.
 *
 * <entry_cin>       is the "CIN" description of the
 *                   entry's data type. You can use
 *                   the xxx_cin_ generated constant
 *                   for this parameter where "xxx" is
 *                   the IDL typedef name.
 *
 * <entry_cin_len>   is the size of "entry_cin" in 
 *                   bytes. You can use the xxx_csz_
 *                   generated constant for this 
 *                   parameter.
 *
 * <entry_value>     is a pointer to the config data to
 *                   be set. Passing NULL causes any 
 *                   previous value to be deleted.
 *                   That is, a subsequent 
 *                   CEE_CFG_GET for this parameter 
 *                   will only retrieve the value from
 *                   the SKI file.
 *
 *
 * <return-value>    is CEE_SUCCESS if the operation
 *                   succeeded otherwise it indicates
 *                   the reason for failure.
 *
 */
extern CEE_status
CEE_CFG_SET_RECORD(
  /* In  */ const char   *qualifier,
  /* In  */ long          qualifier_len,
  /* In  */ const char   *entry_name,
  /* In  */ long          entry_name_len,
  /* In  */ const char   *entry_cin,
  /* In  */ long          entry_cin_len,
  /* In  */ const void   *entry_value
  );

/*
 * !CEE_CFG_UPDATE_REGISTER
 * 
 * "CEE_CFG_UPDATE_REGISTER" is used to register an
 * application function that will be upcalled
 * whenever the specified configuration changes.
 * The value of a configuration parameter can
 * change as a result of a management operation
 * or a call to "CEE_CFG_SET_RECORD".
 * the configuration data obtained with "CEE_CFG_GET" 
 * or "CEE_CFG_GET_RECORD".
 *
 * <entry_value>    is pointer to the configuration data
 *                  that was returned "CEE_CFG_GET_RECORD"
 *                  (or the "CEE_CFG_GET" define).
 *
 * <update_routine> will be upcalled by the CEE whenever
 *                  the value of this configuration 
 *                  parameter changes. Passing a NULL
 *                  pointer deregisters a previously
 *                  registered update routine.
 *
 * <cfg_tag>        is an application supplied value
 *                  that can be used to pass context
 *                  to 'update_routine>.
 *
 * <return-value>   is CEE_SUCCESS if the operation 
 *                  succeeded otherwise it indicates the 
 *                  reason for failure.
 *
 */
extern CEE_status
CEE_CFG_UPDATE_REGISTER(
  /* In */ const void           *entry_value,
  /* In */ CEE_cfg_update_ptr    update_routine,
  /* In */ CEE_tag_def           cfg_tag
  );

/*
 * !CEE_EXECUTE
 * 
 * "CEE_EXECUTE" executes the CEE main loop.
 * The standard CEE "main" function calls "CEE_EXECUTE" on
 * your behalf.
 *
 * <return-value> is CEE_SUCCESS if the operation succeeded otherwise
 *                it indicates the reason for failure.
 *
 */
extern CEE_status
CEE_EXECUTE(void);


/*
 * "CEE_EXECUTE_FINISH" causes the main loop to terminate on the next
 * I/O or timer event.  This is useful for applications that wish to call
 * the CEE_EXECUTE but then regain control later on. 
 */
extern CEE_status
CEE_EXECUTE_FINISH(void);


/*
 * !CEE_HANDLE_IS_NIL
 * 
 * "CEE_HANDLE_IS_NIL" returns true if the handle is nil (null), false if it does not.
 *  A handle is nil if it does not point to any object.
 *
 * <handle>             The handle to be tested. The handle must be a valid pointer.
 *
 * <=IDL_TRUE>          "handle" is nil.
 *
 * <=IDL_FALSE>         "handle" is not nil, but not necessarily valid.
 *
 */
extern IDL_boolean
CEE_HANDLE_IS_NIL(
  /* In   */ const CEE_handle_def   *handle
  );


/*
 * !CEE_HANDLE_SET_NIL
 * 
 * "CEE_HANDLE_SET_NIL" sets the handle to nil (null).
 *
 * <handle>             The handle to be set. The handle must be a valid pointer.
 *
 */
extern void
CEE_HANDLE_SET_NIL(
  /* Out   */ CEE_handle_def    *handle
  );


/*
 * !CEE_IMPLEMENTATION_CREATE
 * 
 * "CEE_IMPLEMENTATION_CREATE" creates an implementation.
 * 
 * You can then use the implementation for more than one object.
 *
 * Use "CEE_IMPLEMENTATION_DESTROY" to delete an implementation.
 *
 * <intf_handle>  The interface handle returned by "CEE_INTERFACE_CREATE".
 *
 * <impl_handle>  The handle of the newly-created implementation.
 *
 * <return-value> CEE_SUCCESS if the operation succeeded, otherwise
 *                the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_IMPLEMENTATION_CREATE(
  /* In  */ const CEE_handle_def    *intf_handle,
  /* Out */ CEE_handle_def          *impl_handle
  );

/*
 * !CEE_IMPLEMENTATION_DESTROY
 * 
 * "CEE_IMPLEMENTATION_DESTROY" destroys an implementation.
 *
 * Create an implementation with "CEE_IMPLEMENTATION_CREATE".
 *
 * <impl_handle>  The handle of the implementation to be deleted.
 *
 * <return-value> CEE_SUCCESS if the operation succeeds, otherwise
 *                the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_IMPLEMENTATION_DESTROY(
  /* In  */ const CEE_handle_def    *impl_handle
  );


/*
 * !CEE_INITIALIZE
 * 
 * "CEE_INITIALIZE" initializes the CEE.
 *
 * Use "CEE_INITIALIZE" to initialize the CEE within an executable. The CEE is
 * initialized for you if you run the CEE from the command line:
 *
 * cee -n capsule_name
 *
 * <capsule_name>       The name of the capsule. This is the name of the SKI file
 *                      without the extension. This name identifies the capsule in
 *                      error messages, and you use this name to obtain configuration
 *                      data.
 *
 * <capsule_name_len>   The size of "capsule_name" in bytes.
 *
 * <return-value>       CEE_SUCCESS if the operation succeed, otherwise
 *                      the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_INITIALIZE(
  /* In  */ const char  *capsule_name,
  /* In  */ long         capsule_name_len
  );

/*
 * !CEE_INTERFACE_CREATE
 * 
 * "CEE_INTERFACE_CREATE" creates an interface.
 *
 * You can use the interface for more than one object or proxy object.
 *
 * The operations (including their parameters and exceptions) for the interface are
 * described in Compact IDL Notation (CIN). You usually use the CIN description generated
 * by IDL.
 *
 * Use "CEE_INTERFACE_DESTROY" to delete an interface.
 *
 * <intf_cin>     The interface in Compact IDL Notation (CIN). This is usually obtained
 *                from an IDL-generated constant ("xxx_ici_", where "xxx" is the IDL
 *                typedef name).
 *
 * <intf_cin_length> The length of "intf_cin" in bytes. This is usually obtained from an
 *                   IDL-generated constant ("xxx_ics_", where "xxx" is the IDL typedef
 *                   name).
 *
 * <intf_handle>  The handle of the newly-created interface.
 *
 * <return-value> CEE_SUCCESS if the operation succeeds, otherwise
 *                the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_INTERFACE_CREATE(
  /* In  */ const char      *intf_cin,
  /* In  */ long             intf_cin_length,
  /* Out */ CEE_handle_def  *intf_handle
  );

/*
 * !CEE_INTERFACE_DESTROY
 * 
 * "CEE_INTERFACE_DESTROY" deletes the interface.
 * Create interfaces with "CEE_INTERFACE_CREATE".
 *
 * <intf_handle>  is the handle of the interface to be destroyed.
 *
 * <return-value> CEE_SUCCESS if the operation succeeds, otherwise
 *                the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_INTERFACE_DESTROY(
  /* In  */ const CEE_handle_def    *intf_handle
  );


/*
 * !CEE_NSK_ASYNCH_IO_PREPARE
 * 
 * "CEE_NSK_ASYNCH_IO_PREPARE" registers a routine that the CEE calls when an
 * asynchronous (nowaited) I/O operation completes.
 *
 * You must call "CEE_NSK_ASYNCH_IO_PREPARE" before you post an asynchronous (nowaited)
 * I/O operation. The CEE waits for the I/O operation to complete and then calls the
 * registered routine.
 *
 * The asynchronous I/O operation is subsequently posted using the tag obtained with the
 * "io_id" parameter.
 *
 * This function is NSK-specific.
 *
 * <completion_routine>   The routine up-called when the I/O completes.
 *
 * <io_tag>               An arbitrary value. This value is passed to "completion_routine".
 *                        This provides a mechanism to pass context information to
 *                        "completion_routine".
 *
 * <filnum>               The file number of the open file on which the asynchronous I/O is to be
 *                        posted. If you require a tag for an anowaited SEVERCLASS_SEND_
 *                        then use "-1" for "filnum".
 *
 * <io_id>                A value that uniquely identifies the prepared I/O. 
 *                        Use this value when posting the asynchronous I/O operation 
 *                        or to abandon the prepared I/O with CEE_NSK_ASYNCH_IO_ABANDON.
 *
 * <return-value>         CEE_SUCCESS if the operation succeeds, otherwise
 *                        the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_NSK_ASYNCH_IO_PREPARE(
  /* In  */ CEE_NSK_io_completion_ptr    completion_routine,
  /* In  */ CEE_tag_def                  io_tag,
  /* In  */ short                        filnum,
  /* Out */ long                        *io_id
  );

/*
 * !CEE_NSK_ASYNCH_IO_ABANDON
 * 
 * "CEE_NSK_ASYNCH_IO_ABANDON" frees the resources allocated for the prepared asynchronous
 * I/O operation.
 *
 * Call "CEE_NSK_ASYNCH_IO_ABANDON" if "CEE_NSK_ASYNCH_IO_PREPARE" was successfully
 * called, but the asynchronous I/O operation cannot be posted due to an error.
 *
 * Calling "CEE_NSK_ASYNCH_IO_ABANDON" when an asynchronous I/O operation cannot be
 * posted enables the CEE to de-allocate resources and correctly track the number of
 * outstanding I/O operations.
 *
 * This function is NSK-specific.
 *
 * <io_id>                The ID of the prepared I/O that is to be abandoned.
 *
 */
extern CEE_status
CEE_NSK_ASYNCH_IO_ABANDON(
  /* In  */ long    io_id
  );

/*
 * !CEE_NSK_ENDTRANSACTION_COMPLETION
 * 
 * "CEE_NSK_ENDTRANSACTION_COMPLETION" registers a routine that the CEE calls when a
 * nowait ENDTRANSACTION completes.
 *
 * This function is only needed if a component called "CEE_NSK_TFILE_OPEN" with a
 * non-zero "nowait" parameter. Otherwise "CEE_NSK_ENDTRANSACTION_COMPLETION" must be
 * called before calling ENDTRANSACTION. The same "trans-begin-tag" that was obtained
 * from BEGINTRANSACTION must be supplied. This is necessary so that the CEE can inform
 * the application when the transaction has really ended and so that the application
 * can determine the final outcome of the transaction.
 *
 * To abort the transaction after calling "CEE_NSK_ENDTRANSACTION_COMPLETION" but before
 * calling ENDTRANSACTION, call "CEE_NSK_ENDTRANSACTION_COMPLETION" again with the
 * completion_routine parameter set to NULL. This frees the CEE resources allocated by
 * the initial call to "CEE_NSK_ENDTRANSACTION_COMPLETION".
 *
 * This function is NSK-specific.
 *
 * <trans_begin_tag>      A value that uniquely identifies the transaction. This value
 *                        is returned by the Guardian BEGINTRANSACTION call.
 *
 * <completion_routine>   The routine up-called when the ENDTRANSACTION completes.
 *
 * <tx_tag>               An arbitrary value. This value is passed to "completion_routine".
 *                        This provides a mechanism to pass context information to
 *                        "completion_routine".
 *
 */
extern CEE_status
CEE_NSK_ENDTRANSACTION_COMPLETION(
  /* In  */ long                            trans_begin_tag,
  /* In  */ CEE_NSK_end_tx_completion_ptr   completion_routine,
  /* In  */ CEE_tag_def                     tx_tag
  );

/*
 * !CEE_NSK_FILE_OPEN_COMPLETION
 * 
 * "CEE_NSK_FILE_OPEN_COMPLETION" registers a routine that the CEE calls when a nowait
 * FILE_OPEN_ completes.
 *
 * Call "CEE_NSK_FILE_OPEN_COMPLETION" after every successful call to FILE_OPEN_ that
 * has the "options.<1>" flag set. This enables the CEE to inform the application when
 * the nowait open completes.
 *
 * To close the file before the nowait FILE_OPEN_ completes, call
 * "CEE_NSK_FILE_OPEN_COMPLETION" again with the "completion_routine" parameter set to
 * NULL. This frees the CEE resources allocated by the initial call to
 * "CEE_NSK_FILE_OPEN_COMPLETION".
 *
 * This function is NSK-specific.
 *
 * <filnum>               The file number as returned by the nowait FILE_OPEN_.
 *
 * <completion_routine>   The routine up-called when the FILE_OPEN_ completes.
 *
 * <open_tag>             An arbitrary value. This value is passed to
 *                        "completion_routine". This provides a mechanism to pass
 *                        context information to "completion_routine".
 *
 */
extern CEE_status
CEE_NSK_FILE_OPEN_COMPLETION(
  /* In  */ short                       filnum,
  /* In  */ CEE_NSK_open_completion_ptr completion_routine,
  /* In  */ CEE_tag_def                 open_tag
  );

/*
 * !CEE_NSK_RECEIVE_REGISTER
 * 
 * "CEE_NSK_RECEIVE_REGISTER" registers an object that handles messages on $RECEIVE
 * that are not required by the CEE.
 *
 * The interface to this object (CEERCV) is defined in "ceercv.idl". The object can
 * be either configured or dynamically created and can be either internal or external
 * to the capsule.
 *
 * You can register more than one $RECEIVE handler object. If more than one $RECEIVE
 * handler objects is registered, the objects are called in turn for each message
 * until one of them accepts it. An object accepts a message by not raising the
 * "decline" exception.
 *
 * Re-register a $RECEIVE handler object by calling "CEE_NSK_RECEIVE_DEREGISTER".
 *
 * This function is NSK-specific.
 *
 * <objref>   The object reference of the object that handles $RECEIVE messages.
 *
 */
extern CEE_status
CEE_NSK_RECEIVE_REGISTER(
  /* In  */ const IDL_Object    objref
  );

/*
 * !CEE_NSK_RECEIVE_DEREGISTER
 * 
 * "CEE_NSK_RECEIVE_DEREGISTER" de-registers a $RECEIVE handler object.
 *
 * Use "CEE_NSK_RECEIVE_REGISTER" to register a $RECEIVE handler object.
 *
 * This function is NSK-specific.
 *
 * <objref>   The object reference to be de-registered.
 *
 */
extern CEE_status
CEE_NSK_RECEIVE_DEREGISTER(
  /* In  */ const IDL_Object    objref
  );

/*
 * !CEE_NSK_TFILE_OPEN
 * 
 * "CEE_NSK_TFILE_OPEN" opens the Transaction Monitoring Facilitys (TMF) TFILE, which
 * is known as $TMP.
 *
 * Call "CEE_NSK_TFILE_OPEN" during initialization of components that use the Guardian
 * BEGINTRANSATCION, ABORTTRANSACTION, and ENDTRANSACTION routines.
 *
 * All components must share the capsule's single open, so you should never open $TMP
 * directly with FILE_OPEN_.
 *
 * The nowait parameter allows the component to specify the behavior of ENDTRANSACTION.
 * If nowait is zero, then ENDTRANSACTION will be a waited operation. If nowait is
 * non-zero, then ENDTRANSACTION will be a nowaited operation.
 *
 * If ENDTRANSACTION is a nowaited operation, call "CEE_NSK_ENDTRANSACTION_COMPLETION"
 * before each call to ENDTRANSACTION. This allows the component to register a routine
 * to be called by the CEE when the transaction has ended.
 *
 * If a component uses ENDTRANSACTION as a waited transaction, it should still call
 * "CEE_NSK_TFILE_OPEN" with nowait set to zero. This ensures that Gaurdian disallows
 * any attempt to mix waited and nowaited components in the same capsule.
 *
 * This function is NSK-specific.
 *
 * <nowait>   The behavior of ENDTRANSACTION. Set this value to zero if you want
 *            ENDTRANSACTION to be a waited operation. Set this value to non-zero
 *            if you want ENDTRANSACTION to be a nowaited operation.
 *
 */
extern CEE_status
CEE_NSK_TFILE_OPEN(
  /* In  */ short   nowait
  );

/*
 * !CEE_NT_ASYNCH_IO_PREPARE
 * 
 * "CEE_NT_ASYNCH_IO_PREPARE" registers a routine that the CEE calls when an
 * asynchronous (overlapped) I/O operation completes.
 *
 * You must call "CEE_NT_ASYNCH_IO_PREPARE" before you post an asynchronous (overlapped)
 * I/O operation. The CEE waits for the I/O operation to complete and then calls the
 * registered routine.
 *
 * The asynchronous I/O operation is subsequently posted after placing the event handle
 * obtained from the io_id parameter in the OVERLAPPED structure.
 *
 * Call "CEE_NT_ASYNCH_IO_ABANDON" to cancel up-calls on the I/O handle.
 *
 * This function is Windows NT-specific.
 *
 * <completion_routine>   The routine up-called when the I/O completes.
 *
 * <io_tag>               An arbitrary value. This value is passed to "completion_routine".
 *                        This provides a mechanism to pass context information to
 *                        completion_routine.
 *
 * <io_id>                An event handle. Place this value in the OVERLAPPED structure
 *                        passed to the I/O operation (ReadFile or WriteFile).
 *
 * <return-value>         CEE_SUCCESS if the operation succeeds, otherwise
 *                        the appropriate CEE status constant.
 *
 */

extern CEE_status
CEE_NT_ASYNCH_IO_PREPARE(
  /* In  */ CEE_NT_io_completion_ptr  completion_routine,
  /* In  */ CEE_tag_def               io_tag,
  /* Out */ long                     *io_id
  );

/*
 * !CEE_NT_ASYNCH_IO_REGISTER
 * 
 * "CEE_NT_ASYNCH_IO_REGISTER" registers a routine that the CEE calls when an
 * asynchronous (overlapped) I/O operation completes.
 *
 * "CEE_NT_ASYNCH_IO_REGISTER" is similar to "CEE_NT_ASYNCH_IO_PREPARE" except the
 * caller supplies the NT event handle and the registration is persistent.
 *
 * Call "CEE_NT_ASYNCH_IO_ABANDON" to cancel up-calls on the I/O handle.
 *
 * This function is Windows NT-specific.
 *
 * <hEvent>                The Windows event HANDLE.
 *
 * <completion_routine>    The routine up-called when the I/O completes.
 *
 * <io_tag>                An arbitrary value. This value is passed to
 *                         "completion_routine". This provides a mechanism to pass
 *                         context information to "completion_routine".
 *
 */

extern CEE_status
CEE_NT_ASYNCH_IO_REGISTER(
  /* In  */ void                     *hEvent,
  /* In  */ CEE_NT_io_completion_ptr  completion_routine,
  /* In  */ CEE_tag_def               io_tag
  );

/*
 * !CEE_NT_ASYNCH_IO_ABANDON
 * 
 * "CEE_NT_ASYNCH_IO_ABANDON" frees the resources allocated by either
 * "CEE_NT_ASYNCH_IO_PREPARE" or "CEE_NT_ASYNCH_IO_REGISTER".
 *
 * Call "CEE_NT_ASYNCH_IO_ABANDON" if "CEE_NT_ASYNCH_IO_PREPARE" or
 * "CEE_NT_ASYNCH_IO_REGISTER" was successfully called, but the asynchronous I/O
 * operation cannot be posted due to an error.
 *
 * Calling "CEE_NT_ASYNCH_IO_ABANDON" when an asynchronous I/O operation cannot be
 * posted enables the CEE to de-allocate resources and correctly track the number
 * of outstanding I/O operations.
 *
 * This function is Windows NT-specific.
 *
 * <io_id>                The I/O that is to be abandoned. If the I/O was prepared
 *                        by "CEE_NT_ASYNCH_IO_PREPARE", this is the event handle.
 *                        If the I/O was registered with "CEE_NT_ASYNCH_IO_REGISTER",
 *                        this is the "hEvent".
 *
 */
extern CEE_status
CEE_NT_ASYNCH_IO_ABANDON(
  /* In  */ long  io_id
  );

/*
 * !CEE_OBJECT_CALL
 * 
 * "CEE_OBJECT_CALL" makes a synchronous call to an object.
 *
 * <proxy_handle>  The proxy handle. This value is returned by "CEE_PROXY_CREATE".
 *                 This specifies the Native-mode Object Reference (NOR) to be called.
 *
 * <operation_idx> The operation to be called. This is an index to the operation in
 *                 the interface description that was supplied when the proxy was
 *                 created. This is usually specified using a IDL-generated constant
 *                 ("xxx_ldx_", where "xxx" is the IDL typedef name).
 *
 * <param_vector>  An array of pointers to the exception structure, output parameters,
 *                 and input parameters. The first element points to the exception
 *                 structure. If the operation is not of type "void", then the second
 *                 element points to the variable that receives the operation's result.
 *                 The third through "n" elements point to the operation's input and
 *                 output parameters. The input and output parameters are in the same
 *                 order as they were defined in IDL.
 *
 * <return-value> CEE_SUCCESS if the operation succeeds, otherwise
 *                the appropriate CEE status constant.
 *
 */
extern void
CEE_OBJECT_CALL(
  /* In  */ const CEE_handle_def   *proxy_handle,
  /* In  */ long                    operation_idx,
  /* In  */ void                  **param_vector
  );


/*
 * !CEE_OBJECT_CALL_POST
 * 
 * "CEE_OBJECT_CALL_POST" an asynchronous call to an object.
 *
 *
 * <proxy_handle>  The proxy handle. This value is returned by "CEE_PROXY_CREATE".
 *                 This specifies the Native-mode Object Reference (NOR) to be called.
 *
 * <operation_idx> The operation to be called. This is an index to the operation in
 *                 the interface description that was supplied when the proxy was
 *                 created. This is usually specified using a IDL-generated constant
 *                 ("xxx_ldx_", where "xxx" is the IDL typedef name).
 *
 * <param_vector>  An array of pointers to the object call's input parameters. The
 *                 input parameters are in the same order as they were defined in IDL.
 *
 * <completion_routine> The routine up-called when either a response from the object is
 *                 received or an error occurred that would prevent a response.
 *
 * <completion_tag_1> An arbitrary value. This value is passed to "completion_routine".
 *                 This provides a mechanism to pass context information to
 *                 "completion_routine".
 *
 * <completion_tag_2> An arbitrary value. This value is passed to "completion_routine".
 *                 This provides a mechanism to pass context information to
 *                 "completion_routine".
 *
 * <return-value>  CEE_SUCCESS if the operation succeeds, otherwise
 *                 the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_OBJECT_CALL_POST(
  /* In  */ const CEE_handle_def           *proxy_handle,
  /* In  */ long                            operation_idx,
  /* In  */ const void *const              *param_vector,
  /* In  */ CEE_object_call_completion_ptr  completion_routine,
  /* In  */ CEE_tag_def                     call_tag1,
  /* In  */ CEE_tag_def                     call_tag2
  );

/*
 * !CEE_OBJECT_CONFIGURE
 * 
 * "CEE_OBJECT_CONFIGURE" sets the configuration parameters for an object.
 *
 * <oid>              The object's ID. This has the same syntax as an IDL identifier.
 *
 * <oid_len>          The number of bytes in "oid".
 *
 * <implib_name>        The name of the implementation library. This parameter is
 *                    currently ignored on the NSK platform.
 *
 * <implib_name_len>    The number of bytes in "impl_name".
 *
 * <entry_name>       The name of the object initialization function in the library
 *                    specified by "impl_name". The CEE calls this function when the
 *                    object is activated.
 *
 * <entry_name_len>   The number of bytes in "entry_name".
 *
 * <param>            Arbitrary configuration data that is passed to the object
 *                    initialization function. This value does not have to be a string.
 *
 * <param_len>        The number of bytes in "param".
 *
 * <return-value>     CEE_SUCCESS if the operation succeeds, otherwise
 *                    the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_OBJECT_CONFIGURE(
  /* In  */ const char  *oid,
  /* In  */ long         oid_len,
  /* In  */ const char  *implib_name,
  /* In  */ long         implib_name_len,
  /* In  */ const char  *entry_name,
  /* In  */ long         entry_name_len,
  /* In  */ const char  *param,
  /* In  */ long         param_len
  );

/*
 * !CEE_OBJECT_CREATE
 * 
 * "CEE_OBJECT_CREATE" dynamically creates an object.
 *
 * Use "CEE_OBJECT_DESTROY" to delete dynamically-created objects.
 *
 * <obj_tag>                    An arbitrary value. This value is passed to this objects
 *                              methods. This provides a mechanism to pass context
 *                              information to an objects methods. 
 *                              
 * <impl_handle>                The implementation handle. Use "CEE_IMPLEMENTATION_CREATE"
 *                              to obtain this value. This handle defines the objects
 *                              interface and operations. 
 *
 * <object_handle>              The handle of the newly-created object.
 *
 */
extern CEE_status
CEE_OBJECT_CREATE(
  /* In  */ CEE_tag_def              obj_tag,
  /* In  */ const CEE_handle_def    *impl_handle,
  /* Out */ CEE_handle_def          *object_handle
  );

/*
 * !CEE_OBJECT_DESTROY
 * 
 * "CEE_OBJECT_DESTROY" deletes a dynamic object.
 *
 * Dynamically create an object with "CEE_OBJECT_CREATE".
 *
 * <object_handle> The handle of the object to be destroyed.
 *
 * <return-value> CEE_SUCCESS if the operation succeeds, otherwise
 *                the appropriate CEE status constant.
 *
 */

extern CEE_status
CEE_OBJECT_DESTROY(
  /* In  */ const CEE_handle_def    *object_handle
  );

/*
 * !CEE_OBJECT_GET_OBJREF
 * 
 * "CEE_OBJECT_GET_OBJREF" retrieves an object's reference.
 *
 * <object_handle>              The handle of the object whose object reference is
 *                              requested.
 *
 * <objref_size_max>            The maximum length of "objref", including a terminating
 *                              NULL character. This value is usually determined by
 *                              calling "CEE_OBJREF_GET_SIZE_MAX".
 *
 * <objref>                     The object's reference.
 *
 * <objref_size>                The size of "objref" in bytes, including a terminating
 *                              NULL character. This value is not set if the pointer
 *                              is NULL.
 *
 */
extern CEE_status
CEE_OBJECT_GET_OBJREF(
  /* In  */ const CEE_handle_def    *Object_handle,
  /* In   */ IDL_unsigned_long       objref_size_max,
  /* Out  */ IDL_Object              objref,
  /* Out  */ IDL_unsigned_long      *objref_size
  );


/*
 * !CEE_OBJECT_GET_PREFIX
 *
 * "CEE_OBJECT_GET_PREFIX" retrieves the object group prefix for
 * a object that has been configured to be an object group.
 */
extern CEE_status
CEE_OBJECT_GET_PREFIX(
  /* In */ const CEE_handle_def *object_handle,
  /* Out */ char               **prefix,
  /* Out */ IDL_unsigned_long   *prefix_len
  );


/*
 * !CEE_OBJECT_SET_IDENTITY
 * 
 * "CEE_OBJECT_SET_IDENTITY" is used to associate
 * an application defined string with an object
 * to improve diagnostics and manageability.
 * This function can be used for configured or
 * dynamic objects. Objects initially have the
 * null string as their identity. The identity
 * string typically contains the name of the 
 * component, its version and instance data.
 * The identity string can be accessed by Capsule
 * Management Object clients.
 *
 * <object_handle>   is the handle of the object
 *                   whose identity is to be set.
 *
 * <identity>        application defined string to
 *                   be attached to the object.
 *
 */
extern CEE_status
CEE_OBJECT_SET_IDENTITY(
  /* In  */ const CEE_handle_def    *object_handle,
  /* In  */ const char              *identity
  );

/*
 * !CEE_OBJECT_SET_SHUTDOWN
 * 
 * "CEE_OBJECT_SET_SHUTDOWN" is used to declare
 * an shutdown function for this object.
 *
 * The specified function will be invoked by the
 * CEE if the capsule is shutdown for one of the
 * following reasons:
 *
 * - Management request (e.g. from cmu)
 *
 * - Application called CEE_CAPSULE_SHUTDOWN
 *
 * - (NSK only) Pathway "STOP SERVER" command.
 *
 *
 * <object_handle>    is the handle of the object
 *                    whose shutdown handler is
 *                    be set/cleared.
 *
 * <shutdown_routine> is the function to be called
 *                    when the object is shut down.
 *                    Passing NULL clears any
 *                    previously set value.
 *
 */
extern CEE_status
CEE_OBJECT_SET_SHUTDOWN(
  /* In  */ const CEE_handle_def    *object_handle,
  /* In  */ CEE_object_shutdown_ptr  shutdown_routine
  );

/*
 * !CEE_OBJECT_SET_STATS_PTR
 * 
 * "CEE_OBJECT_SET_STATS_PTR" is used to register
 * a pointer to the object's statisics that are
 * to be accessed by management clients. The 
 * statistics are contained in an IDL defined 
 * data-type. 
 * 
 *
 * <object_handle>   is the handle of the object
 *                   whose statistics are to be
 *                   registered.
 *
 * <stats_cin>       is the "CIN" description of the
 *                   statistics data type. You can use
 *                   the xxx_cin_ generated constant
 *                   for this parameter where "xxx" is
 *                   the IDL typedef name.
 *
 * <stats>           pointer to the statistics.
 *                   Passing NULL clears any
 *                   previously set value.
 *
 */
extern CEE_status
CEE_OBJECT_SET_STATS_PTR(
  /* In  */ const CEE_handle_def    *object_handle,
  /* In  */ const char              *stats_cin,
  /* In  */ const void              *stats
  );

/*
 * !CEE_OBJREF_GET_SIZE_MAX
 * 
 * "CEE_OBJREF_GET_SIZE_MAX" returns the maximum length of an object reference. This 
 * length includes the terminating NULL character.
 *
 * You can configure this value by calling "CEE_OBJECT_CONFIGURE" with
 * CEECFG::MaxObjrefSize.
 *
 * <objref_size_max>            maximum size of an object reference buffer
 *
 */
extern CEE_status
CEE_OBJREF_GET_SIZE_MAX(
  /* Out */ IDL_unsigned_long       *objref_size_max
  );

/*
 * !CEE_OBJREF_IS_NIL
 * 
 * "CEE_OBJREF_IS_NIL" returns true if the object reference is nil (null), false if
 * it is not. An object reference is nil if it does not point to any object reference.
 *
 * "CEE_OBJREF_IS_NIL" does not determine whether or not the object reference is valid.
 *
 * <objref>             The object reference to be tested.
 *
 * <=IDL_TRUE>          "objref" is nil.
 *
 * <=IDL_FALSE>         "objref" is not nil, but not necessarily valid.
 *
 */
extern IDL_boolean
CEE_OBJREF_IS_NIL(
  /* In   */ const IDL_Object       objref
  );


/*
 * !CEE_OBJREF_SET_NIL
 * 
 * "CEE_OBJREF_SET_NIL" sets an object reference to nil (null).
 *
 * <objref_size_max>            The maximum length of objref, including a terminating
 *                              NULL character. This value is usually determined by
 *                              calling "CEE_OBJREF_GET_SIZE_MAX".
 *
 * <objref>                     The object reference to be set. The object reference
 *                              must be a valid pointer.
 *
 * <objref_size>                The size of "objref" in bytes, including a terminating
 *                              NULL character. This value is not set if the pointer
 *                              is NULL.
 *
 */
extern CEE_status
CEE_OBJREF_SET_NIL(
  /* In   */ IDL_unsigned_long   objref_size_max,
  /* Out  */ IDL_Object          objref,
  /* Out  */ IDL_unsigned_long  *objref_size
  );

/*
 * !CEE_PROXY_CREATE
 * 
 * "CEE_PROXY_CREATE" dynamically creates a proxy object.
 *
 * Use a proxy object to make object calls.
 *
 * Delete dynamically-created proxy objects with "CEE_PROXY_DESTROY".
 *
 * <objref>       The object reference of the object that you will call.
 *
 * <intf_handle>  The interface handle. This value is returned by "CEE_INTERFACE_CREATE".
 *                The interface handle defines the input and output parameters and the
 *                exceptions for the operations.
 *
 * <proxy_handle> The handle of the newly-created proxy object.
 *
 * <return-value> CEE_SUCCESS if the operation succeeds, otherwise
 *                the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_PROXY_CREATE(
  /* In  */ const IDL_Object         objref,
  /* In  */ const CEE_handle_def    *intf_handle,
  /* Out */ CEE_handle_def          *proxy_handle
  );


/*
 * !CEE_PROXY_DESTROY
 * 
 * "CEE_PROXY_DESTROY" deletes a proxy object.
 *
 * Dynamically create proxies with "CEE_PROXY_CREATE".
 *
 * <proxy_handle> The handle of the proxy object to be destroyed.
 *

 * <return-value> CEE_SUCCESS if the operation succeeds, otherwise
 *                the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_PROXY_DESTROY(
  /* In  */ const CEE_handle_def    *proxy_handle
  );

/*
 * !CEE_PROXY_GET_OBJREF
 * 
 * "CEE_PROXY_GET_OBJREF" returns the object reference of a proxy object.
 *
 * The object reference is not necessarily identical to the "objref" parameter passed
 * to "CEE_OBJREF_CREATE".
 *
 * <proxy_handle>               The handle of the proxy object.
 *
 * <objref_size_max>            The maximum length of "objref", including a terminating
 *                              NULL character. This value is usually determined by
 *                              calling "CEE_OBJREF_GET_SIZE_MAX".
 *
 * <objref>                     The object reference of the proxy object. The object
 *                              reference must be a valid pointer.
 *
 * <objref_size>                The size of "objref" in bytes, including a terminating
 *                              NULL character. This value is not set if the pointer
 *                              is NULL.
 *
 */
extern CEE_status
CEE_PROXY_GET_OBJREF(
  /* In  */ const CEE_handle_def    *proxy_handle,
  /* In   */ IDL_unsigned_long       objref_size_max,
  /* Out  */ IDL_Object              objref,
  /* Out  */ IDL_unsigned_long      *objref_size
  );

/*
 * "CEE_PROXY_GET_RESPONSE_SVC_CTX" allows clients to retrieve a service
 * context value that was returned by a server that called
 * "CEE_CALL_SET_RESPONSE_SVC_CTX". The client calls 
 * "CEE_PROXY_GET_RESPONSE_SVC_CTX" after an object call on the proxy
 * has completed successfully.
 *
 * See the description of "CEE_PROXY_SET_REQUEST_SVC_CTX" for a discussion
 * of service context ID's and values.
 *
 *
 * <proxy_handle>        proxy whose service context is to be obtained
 *
 * <svc_ctx_type>        specifies which service context is to be
 *                       obtained.
 *
 * <svc_ctx_size_max>    maximum number of bytes that should be written
 *                       to "svc_ctx_value". If the service
 *                       context to be retrived is too large then the
 *                       return status will be CEE_SHORTOUTBUF 
 *                       and the minimum required size is returned in
 *                       "svc_ctx_size"
 *
 * <svc_ctx_value>       pointer a buffer that is to receive the
 *                       service context value.
 *
 * <svc_ctx_size>        number of bytes of data written to 
 *                       "svc_ctx_value"
 */
extern CEE_status
CEE_PROXY_GET_RESPONSE_SVC_CTX(
  /* In    */ const CEE_handle_def   *proxy_handle,
  /* In    */ IDL_unsigned_long       svc_ctx_type,     
  /* In    */ IDL_unsigned_long       svc_ctx_size_max,  
  /* Out   */ void                   *svc_ctx_value,
  /* Out   */ IDL_unsigned_long      *svc_ctx_size  
  );

/*
 * "CEE_PROXY_SET_REQUEST_SVC_CTX" associates a service context value 
 * with the proxy. This service context value will be transmitted in addition
 * to the parameters on every object call that is subsequently made using 
 * this proxy. The service context value can be accessed by the transport
 * that is used to communicate the object call and may affect the behavior
 * of that transport.
 *
 * The service context can also be accessed by the server, see
 * "CEE_CALL_SET_REQUEST_SVC_CTX. The service context thus also provides a 
 * mechanism for clients and server to communicate unstructured information 
 * that is not specified in the IDL interface definition.
 *
 * Service context values are not marshaled during transmission. This
 * means that the sender and recipient are repsonible for any presentation
 * conversion such as big/little-endian conversion.
 *
 * A client can set any number of service contexts on a proxy. Each service
 * context is identified by a numeric "service context ID". The intended
 * recipient of the service context must use the same ID to retrieve the
 * value. Applications should us service context ID's greater/equal to
 * CEE_USER_SERVICE_CONTEXT_ID_MIN to ensure no conflicts with internal
 * mechanisms that use service context.
 * 
 * If "service_context" is a null-pointer, the service context specified
 * by "svc_ctx_type" (if any) is cleared.
 *
 * <proxy_handle>                proxy whose service context is to be set
 *
 * <svc_ctx_type>      specifies which service context is to be set
 *
 * <svc_ctx_value>   pointer to service context value that is to
 *                           be set on the proxy. NULL means clear service
 *                           context.
 *
 * <svc_ctx_size>    number of bytes of data pointed to by 
 *                           "svc_ctx_value".
 */

extern CEE_status
CEE_PROXY_SET_REQUEST_SVC_CTX(
  /* In    */ const CEE_handle_def       *proxy_handle,
  /* In    */ IDL_unsigned_long       svc_ctx_type,     
  /* In    */ const void             *svc_ctx_value,
  /* In    */ IDL_unsigned_long       svc_ctx_size
  );

/*
 * !CEE_RESPOND
 * 
 * "CEE_RESPOND" sends the results of an asynchronous call to the caller.
 *
 * In the asynchronous model, methods are called with input parameters and a "call_id".
 * "CEE_RESPOND" sends the output parameters to the corresponding "call_id".
 *
 * You can call "CEE_RESPOND" when the method exits, or at a later time (when some
 * other operation posted by the method completes, for example).
 *
 * To raise a standard exception, see "CEE_RESPOND_WITH_STDEXC".
 *
 * <call_id>       The ID of the call to which to respond. This value was passed to
 *                 the asynchronous method up-call.
 *
 * <param_vector>  An array of pointers to the exception structure and output parameters.
 *                 The first element points to the exception structure. If the operation
 *                 is not of type void, then the second element points to the variable
 *                 that receives the operation's result. The third through "n" elements
 *                 point to the operation's output parameters. The output parameters are
 *                 in the same order as they were defined in IDL. If the contents of the
 *                 exception structure imply that the operation failed, only the first
 *                 element in the array is relevant.
 *
 * <return-value>  CEE_SUCCESS if the operation succeeds, otherwise
 *                 the appropriate CEE status constant.
 *
 */
extern CEE_status
CEE_RESPOND(
  /* In  */ const CEE_handle_def    *call_id,
  /* In  */ const void *const       *param_vector
  );

/*
 * !CEE_SET_METHOD
 * 
 * "CEE_SET_METHOD" specifies the method that CEE calls for an operation.
 *
 * You can set or change methods before or after object creation. If no method is set
 * for a given operation, or if an operations method is set to NULL, CEE generates a
 * standard exception when a capsule calls the operation.
 *
 * <impl_handle>   The handle of the implementation. This value is assigned by
 *                 "CEE_IMPLEMENTATION_CREATE".
 *
 * <operation_idx> The operation to which to assign the method. This is an index
 *                 to the method in the interface description. This is usually
 *                 specified using a IDL-generated constant ("xxx_ldx_", where "xxx"
 *                 is the IDL typedef name).
 *
 * <method_tag>    An arbitrary value. This value is passed to "method". This provides
 *                 a mechanism to pass context information to method. This tag saves
 *                 generated method wrappers from having to allocate memory to store
 *                 the address of the real method.
 *
 * <synch>         The behavior of the method. Use "CEE_SYNCH" if the method is
 *                 synchronous. Synchronous methods are called with both the
 *                 operation's input and output parameters. Use "CEE_ASYNCH" if the
 *                 method is asynchronous. Asynchronous methods are called with input
 *                 parameters only, then respond with "CEE_RESPOND".
 *
 * <method>       The function that implements the specified operation.
 *
 * <return-value> CEE_SUCCESS if the operation succeeds, otherwise
 *                the appropriate CEE status constant.
 *
 */

extern CEE_status
CEE_SET_METHOD(
  /* In  */ const CEE_handle_def    *impl_handle,
  /* In  */ long                     operation_idx,
  /* In  */ CEE_tag_def              method_tag,
  /* In  */ CEE_synch_def            synch,
  /* In  */ CEE_method_ptr           method
  );


/*
 * !CEE_SIGNAL_HANDLER_CREATE
 * 
 * "CEE_SIGNAL_HANDLER_CREATE" registers functions that the CEE calls when a specified
 * signal is generated.
 *
 * Remove signal handlers with "CEE_SIGNAL_HANDLER_DESTROY".
 *
 * <signal_number>             The monitored signal number. Signal numbers are defined
 *                             in the standard C header file "signal.h".
 *
 * <signal_handler>            The routine up-called when the signal is generated.
 *
 * <signal_tag>                An arbitrary value. This value is passed to
 *                             "signal_handler". This provides a mechanism to pass
 *                             context information to "signal_handler".
 *
 * <signal_handler_handler>    The handle of the newly-created signal handler.
 *
 */
extern CEE_status
CEE_SIGNAL_HANDLER_CREATE(
  /* In  */ int                      signal_number,
  /* In  */ CEE_signal_handler_ptr   signal_handler,
  /* In  */ CEE_tag_def              signal_tag,
  /* Out */ CEE_handle_def          *signal_handler_handle
  );

/*
 * !CEE_SIGNAL_HANDLER_DESTROY
 * 
 * "CEE_SIGNAL_HANDLER_DESTROY" removes signal handlers.
 *
 * Register signal handlers with "CEE_SIGNAL_HANDLER_CREATE".
 *
 * <signal_handler_handler>    The handle of the signal to be removed.
 *
 */
extern CEE_status
CEE_SIGNAL_HANDLER_DESTROY(
  /* In  */ const CEE_handle_def    *signal_handler_handle
  );


/*
 *  !CEE_SRT_ADD_RESOURCES
 *
 *  
 *  <blockname>         The name of the Service Resource Block
 *                      int which the resource is to be added
 *
 *  <serviceType>       The type of service resources to be added.
 *                      Either CEE_SRT_RESOURCE_TYPE_IMPLEMENTER
 *                      or CEE_SRT_RESOURCE_TYPE_PROVIDER
 *  
 *  <buffer>            A buffer containing a string array of resources
 *                      to be added to the specified block.
 *
 *  <bufferEntryCount>  The number of resources in "buffer".
 *  
 *  Returns:
 *
 *  <=CEE_ALLOCFAIL>    Failed to allocate memory for the new resource.
 *
 *  <=CEE_INTERNALFAIL> A internal failure occured on creating a new
 *                      resource block for the resource. Please report
 *                      to Tantau suppport.
 *
 *  <=CEE_SUCCESS>      Resources were successfully added.
 *
 */

extern CEE_status
CEE_SRT_ADD_RESOURCES(
   /* in     */ char                *blockName,
   /* in     */ IDL_unsigned_long   serviceType,
   /* in     */ IDL_string          *buffer,
   /* in     */ IDL_unsigned_long   *bufferEntryCount
   );


/*
 *  !CEE_SRT_GET_RESOURCES
 *
 *  Returns a list of resources currently resident in
 *  the Service Resource Table.
 *
 *  The Service Resource Table is a configured entity which
 *  is used in associating a pseudo-object reference with
 *  a series of real object references. This enables
 *  object reference switching according to some policy.
 *  
 *  <blockname>         The name of the Service Resource Block
 *                      to be referenced
 *
 *
 *  <serviceType>       The type of service resources to be recovered.
 *                      Either CEE_SRT_RESOURCE_TYPE_IMPLEMENTER
 *                      or CEE_SRT_RESOURCE_TYPE_PROVIDER
 *  
 *  <policy>            The name of the policy associated with the
 *                      block of resources.
 *
 *  <buffer>            A buffer to receive a string array of resource
 *                      names. If the buffer is specified as NULL,
 *                      then only "bufferLength" and "entryCount" are
 *                      returned. This mechanism enables the caller to
 *                      determine how much memory to allocate before
 *                      recovering the resources.
 *
 *  <bufferLength>      On input, specifies the size of "buffer". On
 *                      output, specifies the space used or required.
 *  
 *  <bufferEntryCount>  Receives a count of the resource entries
 *                      that were found in the Service Resource
 *                      Table for the specified block.
 *  
 *  Returns:
 *
 *  <=CEE_DOESNOTEXIST> The specified block does not exist or is
 *                      empty.
 *
 *  <=CEE_SHORTOUTBUF>  The output buffer could not accommodate
 *                      all the resources that were found. If
 *                      "buffer" was specified as NULL or a zero
 *                      "bufferLength" was specified, then
 *                      "bufferLength" and "bufferEntryCount" will
 *                      contain the required buffer length and number
 *                      of resources respectively. Otherwise, the
 *                      buffer will contain some, but not all, of the
 *                      resources. in this case "bufferLength" will
 *                      indicate the buffer space used, and
 *                      "bufferEntryCount" will indicate the number
 *                      of resources returned.
 *
 *  <=CEE_SUCCESS>      All resources could be returned.
 *
 */

extern CEE_status
CEE_SRT_GET_RESOURCES(
   /* in     */ char                *blockName,
   /* in     */ IDL_unsigned_long   serviceType,
   /*    out */ IDL_string          policy,
   /* in out */ IDL_string          *buffer,
   /* in out */ IDL_unsigned_long   *bufferLength,
   /*    out */ IDL_unsigned_long   *bufferEntryCount
   );



/*
 * !CEE_STATUS_TO_TEXT
 * 
 * "CEE_STATUS_TO_TEXT" returns a string that describes the specified CEE status constant.
 *
 * <sts>             The CEE status constant whose description is requested.
 *
 * <=descr>          The null-terminated string containing the description of "sts".
 *
 */
extern char *
CEE_STATUS_TO_TEXT(
  /* In  */ CEE_status  sts
  );

/*
 * !CEE_TI_SIGNAL_TAG_CREATE
 * 
 * "CEE_TI_SIGNAL_TAG_CREATE" registers a routine that the CEE calls when the
 * specified Titanium signal tag is generated. This provides a mechanism to
 * integrate asynchronous Titanium operations into the CEE's up-call model.
 *
 * "CEE_TI_SIGNAL_TAG_CREATE" returns a Titanium tag that you can pass to
 * "OC_PortAttributeSet".
 *
 * There is a limit to the number of signal tags. You can configure this value
 * by calling "CEE_OBJECT_CONFIGURE" with CEECFG::MaxTitaniumSignalTags.
 *
 * Remove Titanium signal handlers with "CEE_TI_SIGNAL_TAG_DESTROY".
 *
 * <signal_routine>       The routine up-called when the Titanium resource tag is signaled.
 *
 * <cee_tag>              An arbitrary value. This value is passed to "signal_routine".
 *                        This provides a mechanism to pass context information to
 *                        "signal_routine".
 *
 * <signal_tag>           The newly-created Titanium resource signal tag. You can pass
 *                        this value to "OC_PortAttributeSet".
 *
 */
extern CEE_status
CEE_TI_SIGNAL_TAG_CREATE(
  /* In  */ CEE_ti_resource_signal_ptr  signal_routine,
  /* In  */ CEE_tag_def                 cee_tag,
  /* Out */ unsigned long              *signal_tag
  );

/*
 * !CEE_TI_SIGNAL_TAG_DESTROY
 * 
 * "CEE_TI_SIGNAL_TAG_DESTROY" removes a Titanium resource signal tag.
 *
 * Create Titanium resource signal tags with "CEE_TI_SIGNAL_TAG_CREATE".
 *
 * <signal_tag>           The Titanium signal tag to be removed.
 *

 */
extern CEE_status
CEE_TI_SIGNAL_TAG_DESTROY(
  /* In */ unsigned long                signal_tag
  );

/*
 * !CEE_TIMER_CREATE
 * 
 * "CEE_TIMER_CREATE" registers a routine that the CEE calls after the specified
 *  time elapses.
 *
 * Remove the timer using "CEE_TIMER_DESTROY".
 *
 * <seconds>             The number of seconds (in addition to microseconds) before
 *                       "expiration_routine" is called.
 *
 * <microseconds>        The number of microseconds (in addition to seconds) before
 *                       "expiration_routine" is called. This value must be less
 *                       than 1000000.
 *
 * <expiration_routine>  The routine up-called after "seconds" plus "microseconds"
 *                       have elapsed.
 *
 * <timer_tag>           An arbitrary value. This value is passed to
 *                       "expiration_routine". This provides a mechanism to pass
 *                       context information to "expiration_routine".
 *
 * <timer_handle>        The handle of the newly-created timer.
 *
 * <return-value>        CEE_SUCCESS if the operation succeeds, otherwise
 *                       the appropriate CE status constant.
 *
 */
extern CEE_status
CEE_TIMER_CREATE(
  /* In  */ long                         seconds,
  /* In  */ long                         microseconds,
  /* In  */ CEE_timer_expiration_ptr     expiration_routine,
  /* In  */ CEE_tag_def                  timer_tag,
  /* Out */ CEE_handle_def              *timer_handle
  );

/*
 * !CEE_TIMER_DESTROY
 * 
 * "CEE_TIMER_DESTROY" removes the timer.
 *
 * Create timers with "CEE_TIMER_CREATE".
 *
 * <timer-handle> The handle of the timer to be removed.
 *
 * <return-value> CEE_SUCCESS if the operation succeeds, otherwise
 *                the appropriate CEE status constant.
 *
 */

extern CEE_status
CEE_TIMER_DESTROY(
  /* In  */ const CEE_handle_def     *timer_handle
  );

/*
 * !CEE_TIMER_SET_IDENTITY
 * 
 * "CEE_TIMER_SET_IDENTITY" is used to associate
 * an application defined string with a timer
 * to improve diagnostics and manageability.
 * Timers initially have the null string as their
 * identity. The identity string can be accessed 
 * by CEE_MGMT clients.
 *
 * <object_handle>   is the handle of the timer
 *                   whose identity is to be set.
 *
 * <identity>        application defined string to
 *                   be attached to the timer.
 *
 */
extern CEE_status
CEE_TIMER_SET_IDENTITY(
  /* In  */ const CEE_handle_def    *timer_handle,
  /* In  */ const char              *identity
  );

/*
 * !CEE_TMP_ALLOCATE
 * 
 * "CEE_TMP_ALLOCATE" temporarily allocates memory. The CEE automatically de-allocates
 * this memory when it is no longer needed.

 *
 * You usually use "CEE_TMP_ALLOCATE" to allocate memory for output parameters with
 * unbounded types in operation implementations.
 *
 * Although intended for unbounded parameters, "CEE_TMP_ALLOCATE" can be used to
 * allocate memory for any purpose that requires automatic de-allocation.
 *
 * Use "CEE_TMP_DEALLOCATE" to free allocated memory before it is automatically
 * deallocated.
 *
 * <handle>       The call to which the CEE associates the allocated memory.
 *
 * <len>          The number of bytes to allocate.
 *
 * <ptr>          The address of the allocated memory.
 *
 * <return-value> CEE_SUCCESS if the operation succeeds, otherwise
 *                the appropriate CEE status constant.
 *
 */

extern CEE_status
CEE_TMP_ALLOCATE(
  /* In  */ const CEE_handle_def    *call_id,
  /* In  */ long                     len,
  /* Out */ void                   **ptr
  );


/*
 * !CEE_TMP_DEALLOCATE
 * 
 * "CEE_TMP_DEALLOCATE" de-allocates temporary memory.
 *
 * CEE automatically de-allocates memory allocated with "CEE_TMP_ALLOCATE" when it is
 * no longer needed. Use "CEE_TMP_DEALLOCATE" when you want to prematurely de-allocate
 * this memory.
 * 
 * Allocate temporary memory using "CEE_TMP_ALLOCATE".
 *
 * <ptr>          The address of the memory to be de-allocated.
 *
 */

extern CEE_status
CEE_TMP_DEALLOCATE(
  /* In  */ void    *ptr
  );

/*
 * !CEE_TMP_RESIZE
 * 
 * "CEE_TMP_RESIZE" changes the size of temporarily-allocated memory.
 *
 * Allocate temporary memory using "CEE_TMP_ALLOCATE".
 *
 * <newlen>       The number of bytes to which to resize the memory.
 *
 * <ptr>          The address of the reallocated memory. The address may change during
 *                the resize operation.
 *
 */
extern CEE_status
CEE_TMP_RESIZE(
  /* In    */ long    newlen,
  /* InOut */ void  **ptr
  );



/*
 * !CEE_UNIX_IO_NOTIFY
 * 
 * "CEE_UNIX_IO_NOTIFY" registers a function that the CEE calls when the specified file
 * descriptor becomes ready for I/O.
 *
 * The notification routine is not persistent; it is only up-called once. If you want
 * to be notified when the same event happens again on the same file descriptor, you
 * must call "CEE_UNIX_IO_NOTIFY" again. Alternatively, you can use
 * "CEE_UNIX_IO_REGISTER" for persistent notification.
 *
 * To cancel a call to "CEE_UNIX_IO_NOTIFY", use "CEE_UNIX_IO_DEREGISTER", or call
 * "CEE_UNIX_IO_NOTIFY" with the same filedes and event and with "notification_routine"
 * set to NULL.
 *
 * This function is UNIX-specific.
 *
 * <fildes>               The monitored file descriptor.
 *
 * <event>                The event that triggers the call to "notification_routine".
 *                        "event" must be set to one of the following constants:
 * CEE_UNIX_NOTIFY_READ - "fildes" is ready for reading.
 * CEE_UNIX_NOTIFY_WRITE - "fildes" is ready for writing.
 * CEE_UNIX_NOTIFY_EXCEPTION - an exception is pending on "fildes".
 *
 * <notification_routine>  The routine called by the CEE calls when "fildes" enters the
 *                         state specified by "event".
 *
 * <io_tag>               An arbitrary value. This value is passed to
 *                        "notification_routine". This provides a mechanism to pass
 *                        context information to "notification_routine".
 *
 */
extern CEE_status
CEE_UNIX_IO_NOTIFY(
  /* In  */ int                             fildes,
  /* In  */ long                            event,
  /* In  */ CEE_UNIX_io_notification_ptr    notification_routine,
  /* In  */ CEE_tag_def                     io_tag
  );

/*
 * !CEE_UNIX_IO_REGISTER
 * 
 * "CEE_UNIX_IO_REGISTER" registers a function that is up-called when a specified
 * file descriptor becomes ready for I/O.
 *
 * The notification routine is persistent; it is up-called whenever the specified
 * event occurs to filedes.
 *
 * To cancel a call to "CEE_UNIX_IO_REGISTER", call "CEE_UNIX_IO_DEREGISTER", or call
 * "CEE_UNIX_IO_NOTIFY" with the same filedes and event and with
 * "notification_routine" set to NULL.
 *
 * This function is UNIX-specific.
 *
 * <fildes>               The monitored file descriptor.
 *
 * <event>                The event that triggers the call to "notification_routine".
 *                        "event" must be set to one of the following constants:
 * CEE_UNIX_NOTIFY_READ - "fildes" is ready for reading.
 * CEE_UNIX_NOTIFY_WRITE - "fildes" is ready for writing.
 * CEE_UNIX_NOTIFY_EXCEPTION - an exception is pending on "fildes".
 *
 * <notification_routine> The routine called when "fildes" enters the condition
 *                        specified by event.
 *
 * <io_tag>               An arbitrary value. This value is passed to
 *                        "notification_routine". This provides a mechanism to pass
 *                        context information to "notification_routine".
 *
 */
extern CEE_status
CEE_UNIX_IO_REGISTER(
  /* In  */ int                             fildes,
  /* In  */ long                            event,
  /* In  */ CEE_UNIX_io_notification_ptr    notification_routine,
  /* In  */ CEE_tag_def                     io_tag
  );

/*
 * !CEE_UNIX_IO_DEREGISTER
 *
 * "CEE_UNIX_IO_DEREGISTER" de-registers the notification routine for events occurring
 * on a file descriptor.
 *
 * Notification routines for events on file descriptors are registered with
 * "CEE_UNIX_IO_REGISTER" or "CEE_UNIX_IO_NOTIFY".
 *
 * This function is UNIX-specific.
 *
 * <fildes>               The monitored file descriptor.
 *
 * <event>                The event that triggers the call to "notification_routine".
 *                        "event" must be set to one of the following constants:
 * CEE_UNIX_NOTIFY_READ - "fildes" is ready for reading.
 * CEE_UNIX_NOTIFY_WRITE - "fildes" is ready for writing.
 * CEE_UNIX_NOTIFY_EXCEPTION - an exception is pending on "fildes".
 *
 */
extern CEE_status
CEE_UNIX_IO_DEREGISTER(
  /* In  */ int     fildes,
  /* In  */ long    event
  );

/*
 * !CEE_VMS_ASYNCH_UPCALL_DISPATCH
 * 
 * This function is VMS-specific.
 * 
 * "CEE_VMS_ASYNCH_UPCALL_DISPATCH" upcalls a function previously specified in
 * "CEE_VMS_ASYNCH_UPCALL_REGISTER". The dispatch function may be called 
 * asynchronously and is the only safe way to execute CEE sends and receives
 * from AST level. Note that CEE sends and receives executed within the
 * registered function should be asynchronous.
 *
 * <handle>                           A handle previously returned by 
 *                                    "CEE_VMS_ASYNCH_UPCALL_REGISTER"
 *
 */

extern CEE_status
CEE_VMS_ASYNCH_UPCALL_DISPATCH(
  /* In */ const CEE_handle_def       *handle
  );


/*
 * !CEE_VMS_ASYNCH_UPCALL_DEREGISTER
 *
 * This function is VMS-specific.
 *
 * "CEE_VMS_ASYNCH_UPCALL_DEREGISTER" cancels the registration of an
 *  asynchrounous upcall routine.
 *
 * <handle>                           A handle previously returned by 
 *                                    "CEE_VMS_ASYNCH_UPCALL_REGISTER"
 *
 */
extern CEE_status
CEE_VMS_ASYNCH_UPCALL_DEREGISTER(
  /* In Out */ CEE_handle_def         *handle
  );


/*
 * !CEE_VMS_ASYNCH_UPCALL_REGISTER
 * 
 * This function is VMS-specific.
 *
 * "CEE_VMS_ASYNCH_UPCALL_REGISTER" registers a function to be up-called by
 * "CEE_VMS_ASYNCH_UPCALL_DISPATCH".
 *
 * To registration may be canceled by calling "CEE_VMS_ASYNCH_UPCALL_DEREGISTER".
 *
 *
 * <upcall>                           The routine to be queued for upcall in
 *                                    the CEE following a call to
 *                                    "CEE_VMS_ASYNCH_UPCALL_DISPATCH".
 *
 * <tag>                              Value to be supplied to the upcall routine.
 *
 * <handle>                           Handle by which the registration may
 *                                    be referenced.
 *
 */

extern CEE_status
CEE_VMS_ASYNCH_UPCALL_REGISTER(
  /* In  */ CEE_VMS_asynch_upcall_ptr upcall,
  /* In  */ CEE_tag_def               tag,
  /* Out */ CEE_handle_def            *handle
  );


/*
 * !CEE_TCP_SITE_ID_GET
 *
 * "CEE_TCP_SITE_ID_GET" returns the IP address that this capsule would use as its
 * local address if it were to use the TCP transport (as client and/or server).
 * If a TCP stack is not available to this capsule, an empty string is returned.
 *
 */
extern char *
CEE_TCP_SITE_ID_GET(void);


/*
 * !CEE_TI_SITE_ID_GET
 *
 * "CEE_TI_SITE_ID_GET" returns the Titanium site ID that this capsule would use
 * as its own site ID if it were to use the Titanium transport (as client
 * and/or server). If the capsule is not configured to use Titanium, an empty
 * string is returned.
 *
 */
extern char *
CEE_TI_SITE_ID_GET(void);


/*
 * !CEE_VERSION
 * 
 * "CEE_VERSION" returns the current version of the CEE.
 *
 * Version strings are ordered. You can use "strcmp" to determine whether one CEE
 * version is newer than another.
 *
 * <=version>                   The current version of CEE.
 *
 */
extern
char *
CEE_VERSION(void);

#ifdef __cplusplus
}
#endif
#endif
